[{"title":"LNMP环境（支持LUA）","url":"/2023/07/11/LNMP环境安装/","content":"\n#### 1、安装Mysql5.7\n\n-  配置Mysql 的yum 源 CentOS 的yum源中没有mysql，需要到mysql的官网下载yum repo配置文件\n\n```\n# 下载安装\nwget http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm\nrpm -ivh mysql57-community-release-el7-11.noarch.rpm \nrpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022\nyum -y install mysql-server\n\n# 查看mysqld 服务是否存在并启动\nsystemctl start mysql\nsystemctl status mysqld\n\n# 获取临时密码（mysql5.7才有，5.6默认密码为空）\ncat /var/log/mysqld.log |grep password\n2023-07-06T14:49:50.366809Z 1 [Note] A temporary password is generated for root@localhost: wF4t6oiiju)o\n# 更改密码\nALTER USER 'root'@'localhost' IDENTIFIED BY 'Qwer1234@';\n\n```\n\n- 查看默认密码策略\n\n![image-20230706225840203](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230706225840203.png)\n\n如需关闭密码策略，在/etc/my.cnf 中添加\n\nvalidate_password= off\n\n- 创建数据库和账号\n\n  ```\n  # 创建数据库\n  mysql> create database web_site character set utf8 collate utf8_general_ci;\n  Query OK, 1 row affected (0.00 sec)\n  # 创建用户\n  mysql> create user john@'%' identified by 'Asdf1234@';\n  Query OK, 0 rows affected (0.00 sec)\n  # 授权用户用于该数据库的所有表的权限\n  mysql> grant all privileges on web_site.* to john@'%';\n  Query OK, 0 rows affected (0.00 sec)\n  # 查看用户是否添加成功\n  mysql> use mysql;\n  Reading table information for completion of table and column names\n  You can turn off this feature to get a quicker startup with -A\n  \n  Database changed\n  mysql> select User,Host,authentication_string from user;\n  +---------------+-----------+-------------------------------------------+\n  | User          | Host      | authentication_string                     |\n  +---------------+-----------+-------------------------------------------+\n  | root          | localhost | *F393111FF4D128DBA783646EDBD577DC15DEBE40 |\n  | mysql.session | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |\n  | mysql.sys     | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |\n  | john          | %         | *C244E5730489A669785440CA0861C36379D08029 |\n  +---------------+-----------+-------------------------------------------+\n  4 rows in set (0.00 sec)\n  ```\n\n  \n\n#### 2、php7.3 源码安装\n\n- 安装依赖库\n\n  ```shell\n  yum install -y gcc gcc-c++ make sudo autoconf libtool-ltdl-devel gd-devel freetype-devel libxml2-devel libjpeg-devel libpng-devel curl-devel patch ncurses-devel bzip2 libcap-devel ntp diffutils sendmail iptables unzip cmake pcre-devel zlib-devel openssl openssl-devel libmcrypt-devel libmhash-devel sysklogd\n  \n  # 其中libmcrypt-devel libmhash-devel 安装失败\n  解决办法\n  1、安装第三方yum源\n  wget http://www.atomicorp.com/installers/atomic\n  sh ./atomic\n  2、使用yum命令安装\n  yum  install  libmcrypt-devel libmhash-devel\n  \n  # sysklogd 安装失败，说是在较新的 Linux 发行版中，rsyslog 已经取代了 sysklogd，就没管了\n  ```\n\n- 创建用户和组\n\n  ```\n  [root@192 ~]# groupadd www\n  [root@192 ~]# useradd -r www -g www\n  ```\n\n- 安装\n\n```\n./configure --prefix=/usr/local/php --enable-fpm --with-fpm-user=www --with-fpm-group=www --with-openssl --with-libxml-dir --with-zlib --enable-mbstring --with-mysqli=mysqlnd --enable-mysqlnd --with-pdo-mysql=mysqlnd --with-gd --with-jpeg-dir --with-png-dir --with-zlib-dir --with-freetype-dir --enable-sockets --with-curl --enable-maintainer-zts \n\nmake \nmake install\n```\n\n- 配置PHP环境\n\n  ```\n  cd /usr/local/php/\n  cp etc/php-fpm.conf.default etc/php-fpm.conf\n  cp etc/php-fpm.d/www.conf.default etc/php-fpm.d/www.conf\n  cp /root/php-7.3.32/php.ini-production lib/php.ini\n  /usr/local/php/sbin/php-fpm \n  \n  \n  [root@192 php]# netstat -anplt\n  Active Internet connections (servers and established)\n  Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    \n  tcp        0      0 127.0.0.1:9000          0.0.0.0:*               LISTEN      110017/php-fpm: mas \n  ```\n\n  开启php-fp, 启动9000进行监听，获取从Nignx发送过来的处理请求。\n\n#### 3、安装Nginx（支持LUA）\n\n（注意各个版本，所使用的版本不同可能最后编译失败）\n\n- 安装LuaJIT\n\n  ```shell\n  cd /opt/\n  wget http://luajit.org/download/LuaJIT-2.0.5.tar.gz\n  tar -zxf LuaJIT-2.0.5.tar.gz \n  cd LuaJIT-2.0.5/\n  make && make install\n  ```\n\n- 安装ngx_devel_kit\n\n  ```shell\n  #下载链接\n  https://github.com/vision5/ngx_devel_kit/archive/refs/tags/v0.3.2.tar.gz\n  拷贝到/opt 目录\n  cd /opt\n  tar -zxvf ngx_devel_kit-0.3.2.tar.gz\n  ```\n\n- 安装nginx_lua_module\n\n  ```\n  # 下载链接\n  https://github.com/openresty/lua-nginx-module/archive/refs/tags/v0.10.13.tar.gz\n  拷贝到/opt目录\n  cd /opt\n  tar -zxf lua-nginx-module-0.10.13.tar.gz\n  ```\n\n- 导入环境变量\n\n  ```shell\n  vim /etc/profile\n  # 添加到末尾\n  export LUAJIT_LIB=/usr/local/lib\n  export LUAJIT_INC=/usr/local/include/luajit-2.0\n  ```\n\n- 安装nginx\n\n  ```\n  tar -zxf nginx-1.22.1.tar.gz \n  cd nginx-1.22.1/\n  ./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --pid-path=/usr/local/nginx/nginx.pid --with-http_realip_module --add-module=/opt/ngx_devel_kit-0.3.2 --add-module=/opt/lua-nginx-module-0.10.13 --with-ld-opt=\"-Wl,-rpath,$LUAJIT_LIB\"\n  make -j2 && make install\n  firewall-cmd --add-port=80/tcp --permanent\n  /usr/local/nginx/sbin/nginx\n  ```\n\n  环境安装基本结束\n\n#### 4、配置站点\n\n- 1、创建文件夹存放站点\n\n- 2、递归修改所有的目录所有者,文件所有者为www\n\n- 3、修改数据库连接信息\n\n- 4、修改nginx.conf ，配置网站根目录，取消location 注释等，根据实际情况修改。\n\n![image-20230710215441928](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230710215441928.png)\n\n- 5、配置thinkphp的URL地址重写，修改nginx.conf 。\n\n","tags":["web"],"categories":["web"]},{"title":"dns污染的解决","url":"/2017/11/15/dns污染的解决/","content":"\ndnsmasq+chinadns+hev-dns-forwarder\n\n1.安装dnsmasq\n\n\t sudo apt-get install dnsmasq\n\t 编辑/etc/dnsmasq.conf \n\t 取消no-resolv前面的注释\n\t server=127.0.0.1#5354\n\n2.安装chindns\n    https://github.com/shadowsocks/ChinaDNS/releases/download/1.3.2/chinadns-1.3.2.tar.gz\n\t解压\n\ttar -zxf chinadns-1.3.2.tar.gz \n\tcd chinadns-1.3.2\n\t./configure\n\tmake\n\tmake install\n\t安装结束后在复制到/usr/local/bin 目录中去（可能已经自动复制到了，确认一下）\n\t运行命令为\n\tchinadns -c /home/pi/Desktop/chinadns-1.3.2/chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m  & > /dev/null 2>&1\n\n3.安装\n\n\tgit clone https://github.com/aa65535/hev-dns-forwarder\n\tcd hev-dns-forwarder\n\tmake\n\t编译完会在src目录下生成二进制文件，复制到/usr/local/bin目录下\n\t运行命令\n\thev-dns-forwarder\n\n4.加入开机启动项\n\n\t在/etc/rc.local中加入\n\tsudo  hev-dns-forwarder  & > /dev/null 2>&1\n\tsudo chinadns -c /home/pi/Desktop/chinadns-1.3.2/chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m  & > /dev/null 2>&1\n\n参考链接：\nhttps://blog.bluerain.io/p/SS-Redir-For-Router.html\n\n​\t","tags":["杂学"],"categories":["杂学"]},{"title":"重装系统后hexo 博客恢复","url":"/2017/11/05/hexo 博客恢复/","content":"\n### 1.安装node.js和git\n\n 这个不用多说，直接下载安装就行了。\n\n### 2.配置 git 个人信息，生成新的 ssh 密钥：\n\ngit config --global user.name \"xxxxxx\"\ngit config --global user.email \"xxxxxx\"\nssh-keygen -t rsa -C \"xxxxxxxx(邮箱)\"\n\n### 3.添加公钥\n\n在用户文件夹.ssh 文件里面把公钥复制出来粘贴到github个人设置的ssh位置。\n\n### 4.安装hexo\n\n建议先\nnpm install cnpm -g --registry=[https://registry.npm.taobao.org](https://registry.npm.taobao.org)\n安装的时候 用cpm 代替npm\n这样的话npm 安装比较快而且不容易失败\ncnpm install hexo-cli -g\n\n### 5.删除博客文件夹文件，保留部分\n\n打开原来的博客文件夹,只需保留_config.yml，theme/，source/，scaffolds/，package.json，.gitignore 这些项目，删除其他的文件。\n\n### 6.git bush\n\n在本文件夹下git bush,运行cnpm install\n\n### 7.安装部署插件\n\nnpm install hexo-deployer-git --save\n\n### 8.测试\n\n此时就可以hexo g &amp;&amp; hexo d 测试是否成功了。","tags":["杂学"],"categories":["杂学"]},{"title":"dll注入之APC注入","url":"/2017/09/16/dll之APC注入/","content":"\nAPC注入的原理是利用当线程被唤醒时APC中的注册函数会被执行的机制，并以此去执行我们的DLL加载代码，进而完成DLL注入的目的，其具体流程如下：\n\n    1）当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()时，系统就会产生一个软中断（或者是Messagebox弹窗的时候不点OK的时候也能注入）。\n\n    2）当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数。\n\n    3）利用QueueUserAPC()这个API可以在软中断时向线程的APC队列插入一个函数指针，如果我们插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的。\n程序如下:\n\n\t// TESTAPC2.cpp : 定义控制台应用程序的入口点。\n\t//\n\t\n\t#include \"stdafx.h\"\n\t#include <string>\n\t#include<windows.h>\n\t#include<shlwapi.h>\n\t#include<tlhelp32.h>\n\t#include<winternl.h>\n\t#pragma comment(lib,\"shlwapi.lib\")\n\t#pragma comment(lib,\"ntdll.lib\")\n\tusing namespace std;\n\t//根据进程名获取PID\n\tDWORD GetPidFormName(wstring wsProcessname)\n\t{\n\t\tHANDLE hSnaoshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\t\tif (hSnaoshot == INVALID_HANDLE_VALUE)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tPROCESSENTRY32W pe = { sizeof(pe) };\n\t\tBOOL bok;\n\t\tfor (bok = Process32FirstW(hSnaoshot, &pe); bok; bok = Process32NextW(hSnaoshot,&pe))\n\t\t{\n\t\t\twstring wsNowProcName = pe.szExeFile;\n\t\t\tif (StrStrI(wsNowProcName.c_str(), wsProcessname.c_str()) != NULL)\n\t\t\t{\n\t\t\t\tCloseHandle(hSnaoshot);\n\t\t\t\treturn pe.th32ProcessID;\n\t\t\t}\n\t\t}\n\t\tCloseHandle(hSnaoshot);\n\t\treturn 0;\n\t}\n\t//dll 文件注入到进程wsProcessname\n\tBOOL Injection_APC(const wstring &wsProcessname, const WCHAR wcCacheInDllPath[])\n\t{\n\t\tDWORD dwProcessId = GetPidFormName(wsProcessname);\n\t\tHANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);\n\t\tif (!hProcess)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t\tPVOID lpData = VirtualAllocEx(hProcess, NULL, 1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\t\tDWORD dwRet;\n\t\tif (lpData)\n\t\t{\n\t\t\t//在远程进程申请空间写入待注入dll 的路径\n\t\t\tWriteProcessMemory(hProcess, lpData, (LPVOID)wcCacheInDllPath,MAX_PATH, &dwRet);\n\t\t\tCloseHandle(hProcess);\n\t\t}\n\t\t//开始注入\n\t\tTHREADENTRY32 te = { sizeof(te) };\n\t\tHANDLE handleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);//遍历系统中所有线程\n\t\tif (handleSnap == INVALID_HANDLE_VALUE)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tbool bstat = false;\n\t\tif (Thread32First(handleSnap, &te))\n\t\t{\n\t\t\tdo {\n\t\t\t\tif (te.th32OwnerProcessID == dwProcessId)\n\t\t\t\t{\n\t\t\t\t\tHANDLE handleThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);\n\t\t\t\t\tif (handleThread)\n\t\t\t\t\t{\n\t\t\t\t\t\tDWORD dwRet = QueueUserAPC((PAPCFUNC)LoadLibraryW, handleThread, (ULONG_PTR)lpData);\n\t\t\t\t\t}\n\t\t\t\t\tif (dwRet > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbstat = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tCloseHandle(handleThread);\n\t\t\t\t}\n\t\t\t} while (Thread32Next(handleSnap, &te));\n\t\t\tCloseHandle(handleSnap);\n\t\t\treturn bstat;\n\t\t}\n\t\n\t\t}\n\t\tint main()\n\t\t{\n\t\t\tInjection_APC(L\"testapc.exe\", L\"testapcdll.dll\");\n\t\t\treturn 0;\n\t\t}\n\n测试exe程序：\n\n\t\t#include<windows.h>\n\t\tint main()\n\t\t{\n\t\t\tMessageBox(NULL, L\"start\", L\"tit\", MB_OK);\n\t\t\tSleepEx(1000 * 60 * 5, true);\n\t\t\tMessageBox(NULL, L\"end\", L\"tit\", MB_OK);\n\t\t\tSleep(-1);\n\t\t}\n\n\n测试dll 程序：\u000b\n\n\t#include<windows.h>\n\t#include\"dll.h\"\n\tBOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, void* lpReserved)\n\t{\n\t\tswitch (dwReason)\n\t\t{\n\t\t\t// 动态链接库映射到某个进程的地址空间\n\t\tcase DLL_PROCESS_ATTACH:\n\t\t\tMessageBox(NULL, L\"in apc ok~\", L\"tit\", MB_OK);\n\t\t\t/**\n\t\t\t* 当DLL刚被加载时触发（LoadLibrary），此处专门用来做初始化工作，\n\t\t\t* 如果初始化失败可以返回 false 这样DLL就不会被继续加载了\n\t\t\t**/\n\t\t\tbreak;\n\t\n\t\t\t// 应用程序创建新的线程\n\t\tcase DLL_THREAD_ATTACH:\n\t\n\t\t\tbreak;\n\t\n\t\t\t// 应用程序某个线程正常终止\n\t\tcase DLL_THREAD_DETACH:\n\t\n\t\t\tbreak;\n\t\n\t\t\t// 动态链接库将被卸载\n\t\tcase DLL_PROCESS_DETACH:\n\t\t\t/**\n\t\t\t* 当DLL将要被卸载时触发（FreeLibrary）,此处专门用来做清理工作\n\t\t\t* 如关闭文件，释放内存空间等\n\t\t\t**/\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\t/*\n\tvoid helloDLL(void)\n\t{\n\t//MessageBox(NULL, TEXT(\"Hello DLL~\"), TEXT(\"Title\"), MB_OK);\n\t}*/","tags":["逆向"],"categories":["逆向"]},{"title":"dll加载和劫持","url":"/2017/08/03/dll加载和劫持/","content":"\n一.dll加载顺序\n\n1. DLL查找路径基础\n\n&emsp;&emsp;应用程序可以通过以下方式控制一个DLL的加载路径：使用全路径加载、使用DLL重定向、使用manifest文件。如果上述三种方式均未指定，系统查找DLL的顺序将按照本部分描述的顺序进行。\n\n&emsp;&emsp;对于以下两种情况的DLL，系统将不会查找，而是直接加载：\n\n&emsp;&emsp;a. 对于已经加载到内存中的同名DLL，系统使用已经加载的DLL，并且忽略待加载DLL的路径。（注意对某个进程而言，系统已经加载的DLL一定是唯一的存在于某个目录下。）\n\n&emsp;&emsp;b. 如果该DLL存在于某个Windows版本的已知DLL列表（unkown DLL）中，系统使用已知DLL的拷贝（包括已知DLL的依赖项）。已知DLL列表可以从如下注册表项看到：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs。\n\n&emsp;&emsp;这里有个比较坑的地方，对于有依赖项的DLL（即使使用全路径指定DLL位置），系统查找其所依赖DLL的方法是按照实际的模块名称来的，因此如果加载的DLL不在系统查找顺序目录下，那么动态加载该DLL（LoadLibrary）会返回一个\"找不到模块\"的错误。\n \n\n2.系统标准DLL查找顺序\n\n&emsp;&emsp;系统使用的标准DLL查找顺序依赖于是否设置了\"安全DLL查找模式\"（safe DLL search mode）。\"安全DLL查找模式\"会将用户当前目录置于查找顺序的后边。\n\"安全DLL查找模式\"默认是启用的，禁用的话，可以将注册表项HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\SafeDllSearchMode设为0。调用SetDllDirectory函数可以禁用\"安全DLL查找模式\"，并修改DLL查找顺序。\nWindows XP下，\"安全DLL查找模式\"默认是禁用的，需要启用该项的话，在注册表中新建一个SafeDllSearchMode子项，并赋值为1即可。\"安全DLL查找模式\"从Windows XP SP2开始，默认是启用的。\n \n\n&emsp;&emsp;启用\"安全DLL查找模式\"时，查找顺序如下：\n\n* a . 应用程序所在目录；\n*\nb. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\\Windows\\System32；\nc. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；\nd. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\\Windows；\ne. 当前目录。GetCurrentDirectory返回的目录；\nf. 环境变量PATH中所有目录。\n \n如果\"安全DLL查找模式\"被禁用，查找顺序如下：\na. 应用程序所在目录；\nb. 当前目录。GetCurrentDirectory返回的目录；\nc. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\\Windows\\System32；\nd. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；\ne. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\\Windows；\nf. 环境变量PATH中所有目录。\n \n3. 修改系统DLL查找顺序\n系统使用的标准DLL查找顺序可以通过以下两种方式调整：\n3.1 使用LOAD_WITH_ALTERED_SEARCH_PATH标志调用LoadLibraryEx函数；\n这种方式调用LoadLibraryEx函数，需要设置lpFileName参数（绝对路径）。与标准查找策略不同的是，使用LOAD_WITH_ALTERED_SEARCH_PATH标志调用LoadLibraryEx函数的DLL查找顺序将\"查找应用程序所在目录\"修改为lpFileName指定的目录。\n3.2 调用SetDllDirectory函数。\n注意：SetDllDirectory函数在Windows XP SP1开始支持的。\n函数SetDllDirectory在调用参数lpPathName是一个路径时，可支持修改DLL搜索路径。修改之后的搜索顺序如下：\na. 应用程序所在目录；\nb. 函数SetDllDirectory参数lpPathName给定的目录；\nc. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\\Windows\\System32；\nd. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；\ne. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\\Windows；\nf. 环境变量PATH中所有目录。\n如果lpPathName参数为空字符串，这样就会把当前目录从DLL搜索路径中去掉。\n如果用NULL参数调用SetDllDirectory函数，可以恢复按照系统注册表的\"安全DLL查找模式\"来查找DLL。\n \n当然win8或者windows server 2012提供更多的可定制方法，这个可以参考MSDN上介绍。比如：SetDefaultDllDirectories、 AddDllDirectory、RemoveDllDirectory。\n\n4.为了测试计算机系统的dll 加载顺序可以通过一个程序加载一个不存在的dll,然后用process monitor 来监控加载的行为。\n\t\n\t#include <windows.h>\n\t#include <iostream>\n\t\n\tint main(int argc, char ** argv)\n\t{\n\t    using std::cout;\n\t    using std::endl;\n\t    \n\t    // 随便设置一个不存在的dll名\n\t    HMODULE hMod = LoadLibrary(\"123.dll\");\n\t\n\t    if (NULL != hMod)\n\t        FreeLibrary(hMod);\n\t        \n\t    cout << \"LoadLibrary Test\" << endl;\n\t    \n\t    return 0;\n\t}\n5.通过process monitor 实际测试win10 64位发现加载顺序是\n\t•  应用程序所在目录\n\t• 系统目录（首先是c:\\Windows\\SysWOW64；然后是c:\\Windows\\System）\n\t• windows目录\n\t• 当前目录\n\t• 环境变量path目录\n\n二  dll 劫持\n\n&emsp;&emsp;由于输入表中只包含DLL名而没有它的路径名，因此加载程序必须在磁盘上搜索DLL文件。首先会尝试从当前程序所在的目录加载DLL，如果没找到，则在Windows系统目录中查找，最后是在环境变量中列出的各个目录下查找。利用这个特点，先伪造一个系统同名的DLL，提供同样的输出表，每个输出函数转向真正的系统DLL。程序调用系统DLL时会先调用当前目录下伪造的DLL，完成相关功能后，再跳到系统DLL同名函数里执行。这个过程用个形象的词来描述就是系统DLL被劫持（hijack）了。\n\n&emsp;&emsp;●DLL劫持的实现●\n这一步我们的工作就是通过编程来实现一个LPK.DLL文件，它与系统目录下的LPK.DLL导出表相同，并能加载系统目录下的LPK.DLL，并且能将导出表转发到真实的LPK.DLL。可以看出我们要实现的这个DLL需求如下：\n\n* 1 、构造一个与系统目录下LPK.DLL一样的导出表；\n\n* 2、加载系统目录下的LPK.DLL；\n\n* 3、将导出函数转发到系统目录下的LPK.DLL上；\n\n* 4、在初始化函数中加入我们要执行的代码。\n\n我们使用VC++来进行开发，首先是定义导出函数。核心代码如下：\n\n\n\t#pragma comment(linker, \"/EXPORT:LpkInitialize=_gamehacker_LpkInitialize,@1\")\n\t#pragma comment(linker, \"/EXPORT:LpkTabbedTextOut=_gamehacker_LpkTabbedTextOut,@2\")\n\t#pragma comment(linker, \"/EXPORT:LpkDllInitialize=_gamehacker_LpkDllInitialize,@3\")\n\t#pragma comment(linker, \"/EXPORT:LpkDrawTextEx=_gamehacker_LpkDrawTextEx,@4\")\n\t#pragma comment(linker, \"/EXPORT:LpkExtTextOut=_gamehacker_LpkExtTextOut,@6\")\n\t#pragma comment(linker, \"/EXPORT:LpkGetCharacterPlacement=\n\t_gamehacker_LpkGetCharacterPlacement,@7\")\n\t#pragma comment(linker, \"/EXPORT:LpkGetTextExtentExPoint=_gamehacker_LpkGetTextExtentExPoint,@8\")\n\t#pragma comment(linker, \"/EXPORT:LpkPSMTextOut=_gamehacker_LpkPSMTextOut,@9\")\n\t#pragma comment(linker, \"/EXPORT:LpkUseGDIWidthCache=_gamehacker_LpkUseGDIWidthCache,@10\")\n\t#pragma comment(linker, \"/EXPORT:ftsWordBreak=_gamehacker_ftsWordBreak,@11\")\n\n以上是导出表中的函数，LPK.DLL比较特殊，在导入表中有一项不是函数是数据，因此数据这部分要单独处理。核心代码如下：\n\n\t★\n\tEXTERNC void __cdecl gamehacker_LpkEditControl(void);   \n\tEXTERNC __declspec(dllexport) void (*LpkEditControl[14])() = {gamehacker_LpkEditControl};  \n\t★\nLpkEditControl这个数组有14个成员，如上定义即可，后面我们还需要将真正的数据复制过来。\n加载系统目录下的LPK.DLL。核心代码如下：\n\t★\n\t inline BOOL WINAPI Load()\n\t {\n\t  TCHAR tzPath[MAX_PATH];\n\t  TCHAR tzTemp[MAX_PATH * 2];\n\t  \n\t  GetSystemDirectory(tzPath, MAX_PATH);\n\t  lstrcat(tzPath, TEXT(\"\\\\lpk\"));\n\t  m_hModule=LoadLibrary(tzPath);  \n\t  return (m_hModule != NULL); \n\t }\n\t★\n在代码中可以看到，使用LoadLibrary方式加载系统目录下的LPK.DLL。加载完成后就要实现导出函数的转发了，这步是很关键的。\n首先要获得原函数地址。核心代码如下：\n\n\t★\n\t FARPROC WINAPI GetAddress(PCSTR pszProcName)\n\t {\n\t  FARPROC fpAddress;\n\t  CHAR szProcName[16];\n\t  TCHAR tzTemp[MAX_PATH];\n\t  \n\t  fpAddress = GetProcAddress(m_hModule, pszProcName);  \n\t  return fpAddress;\n\t }\n\t★\n\n然后将我们构造的导出函数一一转发。核心代码如下：\n\n\t★\n\tALCDECL gamehacker_LpkInitialize(void)\n\t{\n\t GetAddress(\"LpkInitialize\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkTabbedTextOut(void)\n\t{\n\t GetAddress(\"LpkTabbedTextOut\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkDllInitialize(void)\n\t{\n\t GetAddress(\"LpkDllInitialize\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkDrawTextEx(void)\n\t{\n\t GetAddress(\"LpkDrawTextEx\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkEditControl(void)\n\t{\n\t GetAddress(\"LpkEditControl\");\n\t __asm jmp DWORD ptr [EAX];\n\t}\n\tALCDECL gamehacker_LpkExtTextOut(void)\n\t{\n\t GetAddress(\"LpkExtTextOut\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkGetCharacterPlacement(void)\n\t{\n\t GetAddress(\"LpkGetCharacterPlacement\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkGetTextExtentExPoint(void)\n\t{\n\t GetAddress(\"LpkGetTextExtentExPoint\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkPSMTextOut(void)\n\t{\n\t GetAddress(\"LpkPSMTextOut\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkUseGDIWidthCache(void)\n\t{\n\t GetAddress(\"LpkUseGDIWidthCache\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_ftsWordBreak(void)\n\t{\n\t GetAddress(\"ftsWordBreak\");\n\t __asm JMP EAX;\n\t}\n\t★\n转发完之后不要忘记LpkEditControl哦，要将真实数据复制过来。核心代码如下：\n★\n memcpy((LPVOID)(LpkEditControl+1), (LPVOID)((int*)GetAddress(\"LpkEditControl\") + 1),52);  \n★\n好了，到这里整个DLL劫持基本就算完成了，也许你要问，那我们要执行的代码写在哪里？我的方法是将其写到初始化函数中。这样当DLL被加载的时候就会执行。下面看一下DLL的入口函数吧。\n\n\t★\n\tBOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)\n\t{\n\t if (dwReason == DLL_PROCESS_ATTACH)\n\t {\n\t  DisableThreadLibraryCalls(hModule);\n\t  if(Load())\n\t  {  \n\t   memcpy((LPVOID)(LpkEditControl+1), (LPVOID)((int*)GetAddress(\"LpkEditControl\") + 1),52);  \n\t   _beginthread(Init,NULL,NULL);\n\t  }\n\t  else\n\t   return FALSE;\n\t }\n\t else if (dwReason == DLL_PROCESS_DETACH)\n\t {\n\t  Free();\n\t }\n\t return TRUE;\n\t}\n\t★\n\n在这个函数中我们看到，当加载系统目录下的LPK.DLL成功后，进行了LpkEditControl数组的复制，并通过_beginthread(Init,NULL,NULL);定义了初始化函数Init，而这个初始化函数是由我们控制的。\n下面在初始化函数Init中写入测试代码如下：\n\n\t★\n\tvoid WINAPIV Init(LPVOID pParam);\n\tvoid WINAPIV Init(LPVOID pParam)\n\t{\n\t TCHAR tzPath[MAX_PATH];\n\t TCHAR tzTemp[MAX_PATH * 2];\n\t  wsprintf(tzTemp, TEXT(\"劫持函数运行了.......\"), tzPath);\n\t   MessageBox(NULL, tzTemp, TEXT(\"gamehacker\"), MB_ICONSTOP);\n\t return; \n\t} \n\t★\n","tags":["网络"],"categories":["网络"]},{"title":"esp脱壳+文件大小自校验","url":"/2017/07/15/esp脱壳+文件大小自校验/","content":"###步骤如下\n\n1.查壳\n由图可见，显然有壳\n\n![](http://i.imgur.com/56OEUZ6.png)\n\n2.找oep(ESP定律)\n\n程序加载进OD，F8单步运行，右边寄存器窗口发现只有esp的值在变，符合ESP定律。\n在寄存器位置右键，点击HW-break下硬件断点。然后F9运行到断点处，到达跳转到oep 的前一步，单步运行，遇到如下图：右键分析点击在模块中删除分析，即得到OEP.在oep处右键用ollydump脱壳当前进程。复制当前oep.\n\n![](http://i.imgur.com/7VfQh3T.png)\n![](http://i.imgur.com/CaYz7wj.png)\n\n3.脱壳(LordPE)\n\n在lordPE中打开样本程序，选中右键纠正镜像大小，再右键完全脱壳。\n![](http://i.imgur.com/o84YxcW.png)\n\n4.修复导入表(ImportREC)\n\n 在ImportREC中打开目标进程即样本进程，然后右边选项中输入之前在OD中选中的OEP，点击IAT自动搜索，然后点击获取导入表。\n\n![](http://i.imgur.com/Ah6wEjD.png)\n\n5.文件大小自检\n\n脱壳以后双击没得反应，可能是有文件大小自检校验，脱壳后的程序载入OD，在GetFileSize函数下断点，在插件中选API断点设置工具->常用API断点。选中文件类的GetFileSize.然后F9运行程序，到断点处停下，在堆栈中右键反汇编跟随，找到调用这个函数的位置，然后下断点，把刚刚的那个断点删除。在断点后发现是几个cmp ,很明显是比较文件大小，故而把这两个ｃｍｐ右键二进制－＞用ｎｏｐ填充。然后复制到可执行文件，保存文件。再次点击程序，发现正常运行。\n![](http://i.imgur.com/3X4dGg6.png)\n\n![](http://i.imgur.com/nIXhd5Y.png)\n\n![](http://i.imgur.com/UEFRdvd.png)\n\n**\n注：esp 定律**\n\n\nESP定律算是我们在脱壳当中最常使用的方法之一，也特别适合像我一样的新手！而今天文章说的是ESP脱壳的原理和分析！只有知道原理了，我们的技术才能走得列远！\n\n\n一.准备知识\n在我们开始讨论ESP定律之前，我先给你讲解一下一些简单的汇编知识。\n\n\n1.call\n\n这个命令是访问子程序的一个汇编基本指令。也许你说，这个我早就知道了！别急请继续看完。call真正的意义是什么呢？我们可以这样来理解：\n\n1.向堆栈中压入下一行程序的地址；\n2.JMP到call的子程序地址处。\n\n例如：\n\n代码:\n\n00401029.E8 DA240A00 call 004A3508\n0040102E.5A pop edx\n\n在执行了00401029以后，程序会将0040102E压入堆栈，然后JMP到004A3508地址处！\n\n\n\n2.RETN\n\n与call对应的就是RETN了。对于RETN我们可以这样来理解：\n\n1.将当前的ESP中指向的地址出栈；\n\n2.JMP到这个地址。\n\n这个就完成了一次调用子程序的过程。在这里关键的地方是：如果我们要返回父程序，则当我们在堆栈中进行堆栈的操作的时候，一定要保证在RETN这条指令之前，ESP指向的是我们压入栈中的地址。这也就是著名的“堆栈平衡”原理！\n\n\n3.狭义ESP定律\n\nESP定律的原理就是“堆栈平衡”原理。\n\n让我们来到程序的入口处看看吧！\n\n1.这个是加了ASPACK壳的入口时各个寄存器的值！\n\n代码:\n\nEAX 00000000\n\nECX 0012FFB0\n\nEDX 7FFE0304 //堆栈值\n\nEBX 7FFDF000 //堆栈值\n\nESP 0012FFC4\n\nEBP 0012FFF0\n\nESI 77F57D70 ntdll.77F57D70\n\nEDI 77F944A8 ntdll.77F944A8\n\nEIP 0040D000 ASPACK.<ModuleEntryPoint>\n\n2.这个是ASPACK壳JMP到OEP后的寄存器的值！\n\n代码:\n\nEAX 004010CC ASPACK.004010CC\n\nECX 0012FFB0\n\nEDX 7FFE0304 //堆栈值\n\nEBX 7FFDF000 //堆栈值\n\nESP 0012FFC4\n\nEBP 0012FFF0\n\nESI 77F57D70 ntdll.77F57D70\n\nEDI 77F944A8 ntdll.77F944A8\n\nEIP 004010CC ASPACK.004010CC\n\n呵呵~是不是除了EIP不同以外，eax保存当前OEP值，其他都一模一样啊！\n\n为什么会这样呢？我们来看看\n\n\n0040D000 A> 60 pushad //注意这里ESP=0012FFC4\n\n0040D001 E8 00000000 call ASPACK.0040D006 //ESP=0012FFA4\n\nPUSHAD就是把所有寄存器压栈！我们在到壳的最后看看：\n\n代码:\n\n0040D558 61 popad //ESP=0012FFA4\n\n0040D559 75 08 jnz short ASPACK.0040D563 //注意这里ESP=0012FFC4\n\n也就是说当我们对ESP的0012FFA4下硬件访问断点之后。当程序要通过堆栈访问这些值，从而恢复原来寄存器的值，准备跳向苦苦寻觅的OEP的时候，OD帮助我们中断下来。\n\n\n\n小结：我们可以把壳假设为一个子程序，当壳把代码解压前和解压后，他必须要做的是遵循堆栈平衡的原理。\n\n因为大家对ESP理解各有异同，但是，大同小异！一般理解可以为：\n\n1、在命令行下断hr esp-4（此时的ESP就是OD载入后当前显示的值）\n\n2、hr ESP(关键标志下一行代码所指示的ESP值(单步通过)) \n\n","tags":["逆向"],"categories":["逆向"]},{"title":"cuckoo真机分析环境(clonezilla)","url":"/2017/07/11/cuckoo真机分析环境/","content":"序言介绍：为了应对层出不穷的反虚拟机技术，本文实现一种真机搭建cuckoo的方式，结合国家网路中心的clonezila来实现分析机器的还原。\n# 1.硬件准备\n\t*ubuntu16.04服务器一台(可在虚拟机中实现）\n\t*win7或者winxp一台\n\t*交换机一台\n# 2.服务器搭建\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我选择的目前最新的ubuntu16.04，内置python2.7比较方便,当然也可以选择其他版本的系统，或者centos应该也可以，不过最好用ubuntu,因为资料较多，cuckoo官方资料也是用cuckoo搭建的。\n\n\n**1.安装python2.7**\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是cuckoo所需要的，如果你的系统内置了python2.7那就不用安装了，安装步骤网上教程一大堆，不再赘述。查看python版本 python -V，一般内置pip安装工具，没有的话另外安装一下。\n\n**2.安装依赖库**\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.安装相关的依赖库\n\n\t\tsudo apt-get install python python-pip python-dev libffi-dev libssl-dev libxml2-dev libxslt1-dev libjpeg-dev\n\n然后去[cuckoog官网](https://cuckoosandbox.org/)或者[github](https://github.com/cuckoosandbox/cuckoo)下载cuckoo最新版本,然后解压打开cuckoo文件夹，有个requiremens.txt的文件夹，这需要全部下载，可以用python的pip进行安装，其中其中的 pefile 需要从 Google Code 上下载，由于大陆网络限制，需要自备梯子，登上梯子后执行以下批量安装命令：\n\n\tpip install -r requirements.txt\n\n或者先把pefile安装源码下载，手动安装，然后把它从requirements.txt里删除，然后用pip命令安装，个人建议用第二种方法。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.Host 机需要可以嗅探网络数据包，需要安装 tcpdump ，如果本机没有，则执行以下命令安装 tcpdump：\n\n\t\t**apt-get install tcpdump**\n\n如果系统没启用 root 账户，由于 tcpdump 的执行需要 root 权限，则需要以下配置：\n\n\t\t**$ sudo setcap cap_net_raw,cap_net_admin=eip /usr/sbin/tcpdump**\n\n如果系统里没有setcap命令，则需要安装 libpcap包：\n\n\t\t**$ sudo apt-get install libcap2-bin**\n\n如果需要启用内存镜像分析，需要安装 volatility：\n\n\t\t**apt-get install volatility**\n**3.cuckoo配置文件的修改**\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主要修改的文件有：cuckoo.conf,physical.conf,auliary.conf.重点修改前两个。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.修改cuckoo.conf\n\n\tversion_check = on 这个其实可以关掉，不然一直检查，如果你版本稍微低了一下就报错。\n\tmachinery = physical 这个地方改成physical\n\tip = 192.168.56.1 根据你的实际情况填写\n\tvm_state = 60  根据你的电脑实际还原时间填写\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.修改physical.conf\n\tuser = username\n\tpassword = password 根据你的分析机填写\n\tinterface = eth0根据你的网卡填写\n\tip = 192.168.56.101根据你的分析机填写\n\n**4.安装drbl**\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 设置静态ip地址，直接在桌面设置及可以了。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.安装drbl金钥\n\n    wget -q http://drbl.nchc.org.tw/GPG-KEY-DRBL -O- | sudo apt-key add -\n\n &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.添加drbl源(根据自己的系统版本修改一下）\n\n    vi /etc/apt/sources.list\n    deb http://free.nchc.org.tw/ubuntu xenial main restricted universe multiverse\n    deb http://free.nchc.org.tw/drbl-core drbl stable\n\n\n​    \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.安装drbl\n\n\tsudo apt-get update\n\tsudo apt-get install drbl \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.设置drblserver\n\n\tsudo drblsrv -i\n提示!当有yes/no选项的时候，预设的值是大写的字母。例如 (y/N), 预设值是 \"N\", 当你按 \"Enter\"的时候，程式使用的值就是 \"N\"。如果你不确认选用那个好的时候，直接按\"Enter\"键是一个保险的方式.感觉不保险的话，去搜一下，很多介绍的，在这不赘述。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.设置环境\n\n\tsudo drblpush -i\n提示!当有yes/no选项的时候，预设的值是大写的字母。例如 (y/N), 预设值是 \"N\", 当你按 \"Enter\"的时候，程式使用的值就是 \"N\"。如果你不确认选用那个好的时候，直接按\"Enter\"键是一个保险的方式.感觉不保险的话，去搜一下，很多介绍的，一般都差不多。**注意有一点，搜集网卡的时候尽量选择实时收集，然后收集完，注意查看是否有文件在相应目录，还有注意系统读取网卡文件的名字的命名方式，比如我的网卡为ens33,所以网卡文件为macadr-ens33.txt,但是系统读取文件的时候可能会去查找以macadr-eth开头的文件，所以遇到这种情况的话，去手动创建一个这样的文件就可以了。还有就是配置的时候尽量切到/etc/drbl目录下进行操作。**\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.现在基本上drbl就设置好了。\n\n**5。网路设置**\n\t\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于我在虚拟机上搭建的服务器，所以我选择桥接模式，桥接到物理机有线网卡上，然后外接到交换机，然后分析机器也接到交换机，构成一个物理的局域网环境。\n\n# 3.分析机设置\n\n1.首先安装python2.7，去python官网下载就好了。\n\n2.关闭防火墙，自动更新，uac。\n\n3.设置python运行权限为管理员。\n\n4.设置固定ip.(注意此时的ip不要和clonezila给他分配的ip一致，否则在还原的时候，网络捕捉模块会抓取太多还原时候的无用包，从而导致分析报告异常庞大。）\n\n\n**到此整个环境搭建就已经差不多了。注意需要熟悉drbl的使用方法才能使用此环境。此外还需要把drbl还原分析机的指令加入到cuckoo的源代码里去。文件具体为：scheduler库文件，添加到让分析机关机指令的前面位置。\n","tags":["恶意代码"],"categories":["恶意代码"]},{"title":"栈基础知识","url":"/2017/07/10/栈基础知识/","content":"\n\n### 1.C语言变量的分布 ：\nC 语言有全局变量(Global)、本地变量(Local)，静态变量(Static)、寄存器变量(Regeister)。每种变量都有不同的分配方式。先来看下面这段代码： \n\n\t#include <stdio.h> \n\tint g1=0, g2=0, g3=0; \n\tint main() \n\t{ \n\tstatic int s1=0, s2=0, s3=0; \n\tint v1=0, v2=0, v3=0; \n\t\n\t//打印出各个变量的内存地址 \n\t\n\tprintf(\"0x%08x\\n\",&v1); //打印各本地变量的内存地址 \n\tprintf(\"0x%08x\\n\",&v2); \n\tprintf(\"0x%08x\\n\\n\",&v3); \n\tprintf(\"0x%08x\\n\",&g1); //打印各全局变量的内存地址 \n\tprintf(\"0x%08x\\n\",&g2); \n\tprintf(\"0x%08x\\n\\n\",&g3); \n\tprintf(\"0x%08x\\n\",&s1); //打印各静态变量的内存地址 \n\tprintf(\"0x%08x\\n\",&s2); \n\tprintf(\"0x%08x\\n\\n\",&s3); \n\tsystem(\"pause\");\n\treturn 0; \n\t} \n\n可以看出本地变量和全局/静态变量的分布完全不同，相差甚远，这是因为他们分布在不同类型的区域。\n进程的内存空间分为：代码区，静态数据区和动态数据区。全局和静态变量分配在静态数据区，本地变量分配在动态数据区，即”堆栈“，\n![](http://i.imgur.com/Pbbtyit.png)\n\n\n\n### 2. 栈的存储\n\n\n\t\t#include <stdio.h> \n\t\tvoid __stdcall func(int param1,int param2,int param3) \n\t\t{ \n\t\tint var1=param1; \n\t\tint var2=param2; \n\t\tint var3=param3; \n\t\tprintf(\"0x%08x\\n\",&parameter1); //打印出各个变量的内存地址 \n\t\tprintf(\"0x%08x\\n\",&parameter2); \n\t\tprintf(\"0x%08x\\n\\n\",&parameter3); \n\t\tprintf(\"0x%08x\\n\",&var1); \n\t\tprintf(\"0x%08x\\n\",&var2); \n\t\tprintf(\"0x%08x\\n\\n\",&var3); \n\t\treturn; \n\t\t} \n\t\tint main() \n\t\t{ \n\t\tfunc(1,2,3); \n\t\treturn 0; \n\t\t} \n\n![](http://i.imgur.com/kFjeO8n.png)\n\n函数的参数是从右向左传递，即先压栈parameter 3，然后parameter 2，最后才是parameter 1，然后是函数的返回地址，然后就是本地变量var1，var2,var3\n\n\n### 3.程序进入main()函数 ，栈帧的保存和关闭\n\n\n例如：\n\n\tint main（）\n\t{\n\treturn0；\n\t}\n\t汇编代码为：\n\tpush ebp;   保存进入main()函数时其他初始化函数的栈底\n\tmove ebp,esp; 把当前esp的值作为栈底\n\tsub esp ,40h 开辟栈空间，作为局部变量的存储空间\n\tpush ebx\n\tpush  esi\n\tpush  edi  保存寄存器的值\n\tLEA edi ,[ebp-40h]  取出此函数可用栈空间首地址  \n\tmov ecx,10h            设置ecx寄存器的值\n\tmov eax ,occcccccch  把局部变量初始化为0xcccccccch\n\trep stos  dword ptr [edi]   根据ecx的值，把eax的内容，以四字节为单位写到edi指向的内存\n\txor eax,eax    设置返回值为0\n\tpop  edi  \n\tpop esi\n\tpop ebx   弹出压入寄存器的值\n\tadd esp,40h  降低esp,局部空间释放\n\tcmp ebp,esp 检查栈平衡\n\tcall _chkesp()  进入栈错误检查函数\n\tmov esp.ebp  还原esp\n\tpop ebp         还原ebp\n\tret\n\n\n### 4.  简单的分配栈帧及溢出修改相邻变量\n\n\n例如：\n\n\t\t#include <windows.h>\n\t\t \n\t\t#define PASSWORD \"1234567\"\n\t\t \n\t\tint verify_password(char *password){\n\t\t\tint authenticated;\n\t\t\tchar buffer[8];\n\t\t\tauthenticated = strcmp(password,PASSWORD);\n\t\t\tstrcpy(buffer,password);\n\t\t\treturn authenticated;\n\t\t}\n\t\t \n\t\tint main(int argc, char* argv[])\n\t\t{\n\t\t\tint valid_flag = 0;\n\t\t\tchar password[1024];\n\t\t\tFILE *fp;\n\t\t\tif (!(fp=fopen(\"password.txt\",\"rw+\"))){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfscanf(fp,\"%s\",password);\n\t\t\tvalid_flag = verify_password(password);\n\t\t\tif(valid_flag){\n\t\t\t\tprintf(\"incorrect password!\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"Congratulation! You have passed the verification !\\n\");\n\t\t\t}\n\t\t\tSleep(-1);\n\t\t\treturn 1;\n\t\t}\n\n用OD调试：\n进入main()主函数，找到验证密码的函数调用位置，进入到函数具体代码处：\n![](http://i.imgur.com/jNcKasB.png)\n![](http://i.imgur.com/pQm0oAL.png)\n![](http://i.imgur.com/qBPQTjK.png)\n\n前面部分就是栈分配局部变量空间和初始化的过程，然后就是字符串的计较，最后是字符串的复制，分析可得栈溢出在这一部分，在指令008D1409处把函数的返回值（EAX储存的是返回值）存在了EBP-0XC处，下面就是strocpy的操作，char buffer[8]分配了八个字节的存储空间，但是password.txt的密码如图为24个字节，知错执行strcpy的时候，把buffer 附近的变量空间也给覆盖了，比如返回值的。以上过程如图所示\n![](http://i.imgur.com/9CBEnex.png)\n![](http://i.imgur.com/S0M3SMC.png)\n![](http://i.imgur.com/S0ptRZH.png)","tags":["逆向"],"categories":["逆向"]}]